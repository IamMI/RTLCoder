{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\n    // Use the conditional operator to select between a and b based on sel\n    assign out = sel ? b : a;\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000: Y2 = (w == 1'b1) ? 1'b0 : 1'b0; // A to A or B (no change for y[2])\n\t\t\t3'b001: Y2 = 1'b1; // B to C or D (always y[2] = 1)\n\t\t\t3'b010: Y2 = (w == 1'b0) ? 1'b0 : 1'b1; // C to E (y[2] = 0) or D (y[2] = 1)\n\t\t\t3'b011: Y2 = (w == 1'b0) ? 1'b1 : 1'b0; // D to F (y[2] = 1) or A (y[2] = 0)\n\t\t\t3'b100: Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // E to E (y[2] = 0) or D (y[2] = 1)\n\t\t\t3'b101: Y2 = (w == 1'b0) ? 1'b1 : 1'b1; // F to C (y[2] = 1) or D (y[2] = 1)\n\t\t\tdefault: Y2 = 1'b0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 6 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n    assign ringer = ring & ~vibrate_mode;  // ringer is on if it's ringing and not in vibrate mode\n    assign motor = ring & vibrate_mode;    // motor is on if it's ringing and in vibrate mode\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n    // Method 1: Using assign statement\n    assign out_assign = a & b;\n\n    // Method 2: Using a combinational always block\n    always @* begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\n\tassign zero = 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (a) begin\n\t\t\tq <= ~q;\n\t\tend\n\tend\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    typedef enum {IDLE, INVERT} state_t;\n    state_t current_state, next_state;\n    \n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Determine next state\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (x == 1) // Transition to INVERT on first '1'\n                    next_state = INVERT;\n                else\n                    next_state = IDLE;\n            end\n            INVERT: begin\n                next_state = INVERT; // Stay in INVERT state\n            end\n        endcase\n    end\n    \n    // Output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            z <= 0;\n        end else begin\n            case (current_state)\n                IDLE: z <= x; // Idle state just outputs input value\n                INVERT: z <= ~x; // Invert state outputs inverted input value\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    reg [1:0] state, next_state;\n\n    // State Encoding\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default to A for safety\n        endcase\n    end\n\n    // State Register\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default to 0 for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out[7:0] = in[31:24];  // Last input byte becomes first output byte\n    assign out[15:8] = in[23:16]; // Second to last input byte becomes second output byte\n    assign out[23:16] = in[15:8]; // Third to last input byte becomes third output byte\n    assign out[31:24] = in[7:0];  // First input byte becomes last output byte\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n// Process triggered on the rising edge of the clock\nalways_ff @(posedge clk) begin\n\tif (r) begin\n\t\t// If reset is high, output is forced to 0\n\t\tq <= 0;\n\tend else begin\n\t\t// Normal behavior: output follows input d\n\t\tq <= d;\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    assign z = (x ^ y) & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= q << 1;\n\t\t\t\t2'b01: q <= q << 8;\n\t\t\t\t2'b10: q <= {q[63], q[63:1]}; // Arithmetic right shift by 1\n\t\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic right shift by 8\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    typedef enum reg [1:0] {S0, S1, S2} state_t;\n    state_t state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = x ? 1 : 0;\n            default: z = 0;\n        endcase\n    end\n\n    // State register update\n    always @(negedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// Define states using local parameters for better readability\n\tlocalparam STATE_A = 0;\n\tlocalparam STATE_B = 1;\n\tlocalparam STATE_C = 2;\n\tlocalparam STATE_D = 3;\n\tlocalparam STATE_E = 4;\n\tlocalparam STATE_F = 5;\n\n\treg [2:0] current_state, next_state;\n\n\t// State Transition Logic\n\talways @(*) begin\n\t\t// Default to current state; it helps in setting next_state\n\t\tnext_state = current_state;\n\t\tcase (current_state)\n\t\t\tSTATE_A: next_state = (w == 0) ? STATE_B : STATE_A;\n\t\t\tSTATE_B: next_state = (w == 0) ? STATE_C : STATE_D;\n\t\t\tSTATE_C: next_state = (w == 0) ? STATE_E : STATE_D;\n\t\t\tSTATE_D: next_state = (w == 0) ? STATE_F : STATE_A;\n\t\t\tSTATE_E: next_state = (w == 0) ? STATE_E : STATE_D;\n\t\t\tSTATE_F: next_state = (w == 0) ? STATE_C : STATE_D;\n\t\tendcase\n\tend\n\n\t// State Register Update\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= STATE_A;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Output Logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tSTATE_E, STATE_F: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\t// Define the states\n\ttypedef enum reg [1:0] {\n\t\tIDLE = 2'b00,\n\t\tBYTE1 = 2'b01,\n\t\tBYTE2 = 2'b10,\n\t\tBYTE3 = 2'b11\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\treg [7:0] byte1, byte2, byte3;\n\n\t// State register\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1)\n\t\t\t\t\tnext_state = BYTE1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\t\n\t\t\tBYTE1: next_state = BYTE2;\n\t\t\t\n\t\t\tBYTE2: next_state = BYTE3;\n\t\t\t\n\t\t\tBYTE3: next_state = IDLE;\n\t\t\t\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\t// Output and byte storage logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout_bytes <= 24'b0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tdone <= 1'b0;\n\t\t\tcase (current_state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\t// Wait for first byte with in[3] == 1\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tBYTE1: begin\n\t\t\t\t\tbyte1 <= in;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tBYTE2: begin\n\t\t\t\t\tbyte2 <= in;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tBYTE3: begin\n\t\t\t\t\tbyte3 <= in;\n\t\t\t\t\tout_bytes <= {byte1, byte2, in}; // Combine the bytes once the packet is received\n\t\t\t\t\tdone <= 1'b1; // Signal that the packet is received\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    // Logic for Y1: transition to B\n    assign Y1 = y[0] & w;\n    \n    // Logic for Y3: transition to D\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[3] & ~w);\n\nendmodule\n", "result": "failed: 95 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\t// Connecting the input vector directly to the output vector\n\tassign outv = vec;\n\t\n\t// Connecting each bit of the input vector to respective outputs\n\tassign o0 = vec[0];\n\tassign o1 = vec[1];\n\tassign o2 = vec[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        // Assign out based on analyzed conditions\n        out = (c ^ d) ^ (a ^ b);\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n    assign out_hi = in[15:8]; // Assign higher byte\n    assign out_lo = in[7:0];  // Assign lower byte\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n\t// Implementation using assign statement\n\tassign out_assign = a ^ b;\n\n\t// Implementation using combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// Implementation using clocked always block\n\talways @(posedge clk) begin\n\t\tout_always_ff = a ^ b;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\t// Logic for Y2\n\t\tY2 = y[2] & ~w;\n\t\t\n\t\t// Logic for Y4\n\t\tY4 = (y[2] & w) | (y[3] & w) | (y[6] & w);\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\n    // Select the bit indexed by sel from the input vector 'in' and assign it to 'out'\n    assign out = in[sel];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (L) begin\n        // Load R into Q when L is asserted.\n        Q <= R;\n    end\n    else if (E) begin\n        // Shift w into Q when E is asserted.\n        Q <= w;\n    end\n    // If neither L nor E are asserted, Q retains its value.\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// Intermediate signals\n\treg q1, q2, q3;\n\twire d1, d2, d3;\n\n\t// D flip-flop logic\n\talways @(posedge clk) begin\n\t\tq1 <= d1;\n\t\tq2 <= d2;\n\t\tq3 <= d3;\n\tend\n\n\t// Gate operations\n\tassign d1 = x ^ q1;\n\tassign d2 = x & ~q2;\n\tassign d3 = x | ~q3;\n\n\t// XNOR operation for output z\n\tassign z = ~(q1 ^ q2 ^ q3);\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n\t// Implementing the logic for q\n\tassign q = ~((a & d) | (~c & ~d));\n\nendmodule\n", "result": "failed: 45 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    integer i;\n    reg [511:0] q_next;\n\n    always @(*) begin\n        // Compute next state for each cell\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({ (i == 0 ? 0 : q[i-1]), q[i], (i == 511 ? 0 : q[i+1]) })\n                3'b111: q_next[i] = 0;\n                3'b110: q_next[i] = 1;\n                3'b101: q_next[i] = 1;\n                3'b100: q_next[i] = 0;\n                3'b011: q_next[i] = 1;\n                3'b010: q_next[i] = 1;\n                3'b001: q_next[i] = 1;\n                3'b000: q_next[i] = 0;\n                default: q_next[i] = 0; // Default case (shouldn't happen)\n            endcase\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load new state from input data if load is high\n        end else begin\n            q <= q_next; // Else, update q with q_next\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// Define states as parameters\n\ttypedef enum logic [1:0] {\n\t\tA = 2'b00,\n\t\tB = 2'b01,\n\t\tC = 2'b10,\n\t\tD = 2'b11\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State transition and output logic\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tA: begin\n\t\t\t\tout = 1'b0;\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tout = 1'b0;\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tout = 1'b0;\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tout = 1'b1;\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 1'b0;\n\t\t\t\tnext_state = A;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// State registers and synchronous reset\n\talways_ff @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @(*) begin\n    case (c)\n        4'b0000: q = b;\n        4'b0001: q = e;\n        4'b0010: q = a;\n        4'b0011: q = d;\n        default: q = 4'b1111;  // f is represented as 4'b1111\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n    always @(*) begin\n        if (sel) \n            out = b; // Select input `b` when sel is 1\n        else \n            out = a; // Select input `a` when sel is 0\n    end\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    wire mux_out;\n\n    // 2-1 MUX Logic\n    assign mux_out = L ? r_in : q_in;\n\n    // Flip-flop to store the result on clock edge\n    always @(posedge clk) begin\n        Q <= mux_out;\n    end\n\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    reg [31:0] prev_in;  // Register to hold the previous state of the input\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;  // Synchronous reset of output\n        end else begin\n            // Detect 1-to-0 transition for each bit\n            out <= out | (prev_in & ~in);\n        end\n        // Update previous state\n        prev_in <= in;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n    assign s = a + b; // Calculate the sum of a and b\n    \n    // Check for overflow\n    // Overflow occurs if the sign of a and b is the same, but the sign of the result is different\n    assign overflow = (~a[7] & ~b[7] & s[7]) | (a[7] & b[7] & ~s[7]); \n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\nassign S_next = state[0] & ~d | state[2] & ~d | state[9] & ack;\nassign S1_next = state[0] & d | state[1] & d;\nassign S11_next = state[1] & ~d | state[2] & d | state[3] & ~d;\nassign S110_next = state[3] & ~d;\nassign B0_next = state[3] & d;\nassign B1_next = state[4];\nassign B2_next = state[5];\nassign B3_next = state[6];\nassign Count_next = state[7] | state[8] & ~done_counting;\nassign Wait_next = state[8] & done_counting | state[9] & ~ack;\n\nassign shift_ena = state[4] | state[5] | state[6] | state[7];\nassign counting = state[8] & ~done_counting;\nassign done = state[9] & ack;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1;\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\nalways @(*) begin\n    // Default value for pos is 0, in case no bits are high\n    pos = 3'd0;\n    for (integer i = 0; i < 8; i = i + 1) begin\n        if (in[i]) begin\n            pos = i; // Set pos to the current index if the bit is high\n            break;   // Exit the loop after finding the first high bit\n        end\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n    \n    always @(*) begin\n        // Default all outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check the scancode and set corresponding output\n        case (scancode)\n            16'he06b: left = 1;  // left arrow scancode\n            16'he072: down = 1;  // down arrow scancode\n            16'he074: right = 1; // right arrow scancode\n            16'he075: up = 1;    // up arrow scancode\n            default: begin\n                // All outputs should stay 0\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n\twire [3:0] carry;\n\n\t// Full Adder for bit 0\n\tassign {carry[0], sum[0]} = x[0] + y[0] + 1'b0;\n\n\t// Full Adder for bit 1\n\tassign {carry[1], sum[1]} = x[1] + y[1] + carry[0];\n\n\t// Full Adder for bit 2\n\tassign {carry[2], sum[2]} = x[2] + y[2] + carry[1];\n\n\t// Full Adder for bit 3\n\tassign {carry[3], sum[3]} = x[3] + y[3] + carry[2];\n\n\t// Carry out represents overflow\n\tassign sum[4] = carry[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset to clear the history register.\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            // Misprediction correction takes precedence.\n            // Load the history before the mispredicted branch and append train_taken.\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            // If valid prediction, shift predict_taken into the history register.\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n        // If neither areset, train_mispredicted, nor predict_valid, retain the current state.\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n    // Intermediate wires\n    wire ab_and;\n    wire cd_and;\n\n    // First layer: AND gates\n    assign ab_and = a & b; // output of first AND gate\n    assign cd_and = c & d; // output of second AND gate\n\n    // Second layer: OR gate\n    assign out = ab_and | cd_and;\n\n    // NOT gate for inverted output\n    assign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    \n    // Internal 8-bit register\n    reg [7:0] Q;\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift operation\n            Q <= {Q[6:0], S};\n        end\n    end\n    \n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case (although not absolutely necessary as all cases are covered)\n        endcase\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    // Heater control: active in heating mode if too cold\n    assign heater = mode & too_cold;\n    \n    // Air conditioner control: active in cooling mode if too hot\n    assign aircon = (~mode) & too_hot;\n    \n    // Fan control: active if heater, aircon are on or if fan_on is requested\n    assign fan = heater | aircon | fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n\t// Sum of Products (SOP) for (2, 7, 15)\n\tassign out_sop = (!a & !b & c & !d) | (!a & b & c & d) | (a & b & c & d);\n\n\t// Product of Sums (POS) for (0, 1, 4, 5, 6, 9, 10, 13, 14)\n\tassign out_pos = (a | b | c | d) & \n\t                 (a | b | c | !d) & \n\t                 (a | !b | c | d) & \n\t                 (a | !b | c | !d) & \n\t                 (a | !b | !c | d) & \n\t                 (!a | b | c | !d) & \n\t                 (!a | b | !c | d) & \n\t                 (!a | !b | c | !d) & \n\t                 (!a | !b | !c | d);\n\nendmodule\n", "result": "failed: 17 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 32'h1; // Reset the register to the initial value\n\t\tend else begin\n\t\t\t// Compute next state using XOR with taps positions\n\t\t\tq[31] <= q[0];\n\t\t\tq[30] <= q[31];\n\t\t\tq[29] <= q[30];\n\t\t\tq[28] <= q[29];\n\t\t\tq[27] <= q[28];\n\t\t\tq[26] <= q[27];\n\t\t\tq[25] <= q[26];\n\t\t\tq[24] <= q[25];\n\t\t\tq[23] <= q[24];\n\t\t\tq[22] <= q[23] ^ q[0]; // Tap position 22\n\t\t\tq[21] <= q[22];\n\t\t\tq[20] <= q[21];\n\t\t\tq[19] <= q[20];\n\t\t\tq[18] <= q[19];\n\t\t\tq[17] <= q[18];\n\t\t\tq[16] <= q[17];\n\t\t\tq[15] <= q[16];\n\t\t\tq[14] <= q[15];\n\t\t\tq[13] <= q[14];\n\t\t\tq[12] <= q[13];\n\t\t\tq[11] <= q[12];\n\t\t\tq[10] <= q[11];\n\t\t\tq[9]  <= q[10];\n\t\t\tq[8]  <= q[9];\n\t\t\tq[7]  <= q[8];\n\t\t\tq[6]  <= q[7];\n\t\t\tq[5]  <= q[6];\n\t\t\tq[4]  <= q[5];\n\t\t\tq[3]  <= q[4];\n\t\t\tq[2]  <= q[3] ^ q[0]; // Tap position 2\n\t\t\tq[1]  <= q[2] ^ q[0]; // Tap position 1\n\t\t\tq[0]  <= q[1] ^ q[0]; // Tap position 32 (16'h0 shifted in)\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n    assign q = (a & b) | (a & c) | (b & c) | (b & d);\n\nendmodule\n", "result": "failed: 16 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // First 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\t\n    // Second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n\tinteger i;\n\talways @(*) begin\n\t\tout = 8'd0; // Initialize the output to zero\n\t\tfor (i = 0; i < 255; i = i + 1) begin\n\t\t\tout = out + in[i]; // Add each bit in the input vector to the output\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\n    // (1) out_both: Calculate logic 'both are 1' for neighbours to the left\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // (2) out_any: Calculate logic 'any are 1' for neighbours to the right\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // (3) out_different: Calculate logic 'are different' for neighbours, including wrap-around\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (a)\n\t\t\t3'b000: q = 16'h1232;\n\t\t\t3'b001: q = 16'haee0;\n\t\t\t3'b010: q = 16'h27d4;\n\t\t\t3'b011: q = 16'h5a0e;\n\t\t\t3'b100: q = 16'h2066;\n\t\t\t3'b101: q = 16'h64ce;\n\t\t\t3'b110: q = 16'hc526;\n\t\t\t3'b111: q = 16'h2f19;\n\t\t\tdefault: q = 16'h0000; // Just a fallback, though it\u2019s not strictly needed here.\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;  // Reset the counter to 0\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;  // Wrap around to 0\n            end else begin\n                q <= q + 4'd1;  // Increment the counter\n            end\n        end\n        // If slowena is low, do nothing (i.e., maintain the current count)\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    assign out = in1 & ~in2;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n\t// Continuous assignment: Directly assign the input to the output\n\tassign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State definitions\n    typedef enum reg [1:0] {A = 2'b00, B = 2'b01} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (in)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            B: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            default: next_state = B; // Default to a safe state (could be B)\n        endcase\n    end\n\n    // State update on clock edge\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= B;  // Asynchronous reset to state B\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic based only on the current state (Moore machine)\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 1;\n            default: out = 1;  // Safe output default\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    // Intermediate register to store the value of `d` at the negedge of the clock\n    reg d_negedge;\n\n    // Always block triggered at the negedge of the clock to capture `d`\n    always @(negedge clk) begin\n        d_negedge <= d;\n    end\n\n    // Always block triggered at the posedge of the clock to update `q` with captured `d`\n    always @(posedge clk) begin\n        q <= d_negedge; \n    end\n\nendmodule\n", "result": "failed: 108 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a ^ b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n\n// Module B: Implements specified simulation waveform logic\nmodule B(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\t// Truth table logic derived from the simulation waveform\n\tassign z = (~x & ~y) | (x & y);\nendmodule\n\n// Top-level module\nmodule top_module(\n\tinput x,\n\tinput y,\n\toutput z\n);\n\t// Internal wires for intermediate outputs\n\twire z_a1, z_a2;\n\twire z_b1, z_b2;\n\twire or_out, and_out;\n\n\t// Instantiate Modules A and B\n\tA A1(.x(x), .y(y), .z(z_a1));\n\tA A2(.x(x), .y(y), .z(z_a2));\n\tB B1(.x(x), .y(y), .z(z_b1));\n\tB B2(.x(x), .y(y), .z(z_b2));\n\n\t// Logic gates for intermediate outputs\n\tassign or_out = z_a1 | z_b1;    // OR gate\n\tassign and_out = z_a2 & z_b2;   // AND gate\n\tassign z = or_out ^ and_out;    // XOR gate producing the final output\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data; // Load the data into q\n\t\tend\n\t\telse begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: q <= {q[0], q[99:1]}; // Rotate right by 1 bit\n\t\t\t\t2'b10: q <= {q[98:0], q[99]}; // Rotate left by 1 bit\n\t\t\t\tdefault: q <= q; // No change for 2'b00 and 2'b11\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 10'd0; // reset the counter to 0\n\t\tend\n\t\telse begin\n\t\t\tif (q == 10'd999) begin\n\t\t\t\tq <= 10'd0; // wrap around to 0 after reaching 999\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 10'd1; // increment the counter by 1\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\t// Use 'assign' to perform combinational logic in Verilog\n\tassign out = ~in;  // The ~ operator is used for bitwise negation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default next_state is 0, and set the next_state bit according to transition table\n\t\tnext_state = 10'b0;\n\t\tcase (1) // One-hot encoding: only one bit will be '1' in the current state\n\t\t\tstate[0]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S0\n\t\t\tstate[1]: next_state = in ? 10'b0000000100 : 10'b0000000001; // S1\n\t\t\tstate[2]: next_state = in ? 10'b0000001000 : 10'b0000000001; // S2\n\t\t\tstate[3]: next_state = in ? 10'b0000010000 : 10'b0000000001; // S3\n\t\t\tstate[4]: next_state = in ? 10'b0000100000 : 10'b0000000001; // S4\n\t\t\tstate[5]: next_state = in ? 10'b0001000000 : 10'b0100000000; // S5\n\t\t\tstate[6]: next_state = in ? 10'b0010000000 : 10'b1000000000; // S6\n\t\t\tstate[7]: next_state = in ? 10'b0000000000 : 10'b0000000001; // S7\n\t\t\tstate[8]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S8\n\t\t\tstate[9]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S9\n\t\t\tdefault: next_state = 10'b0000000001; // default to S0 in case of unexpected states\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out1 = state[8] | state[9]; // S8 or S9\n\tassign out2 = state[7] | state[9]; // S7 or S9\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // Retain the previous state\n            2'b01: Q <= 0;       // Reset the state\n            2'b10: Q <= 1;       // Set the state\n            2'b11: Q <= ~Q;      // Toggle the state\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    // Count the number of '1's in the 3-bit input vector `in`\n    assign out = in[0] + in[1] + in[2];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    assign out[24] = ~(a ^ a);  // a with a\n    assign out[23] = ~(a ^ b);  // a with b\n    assign out[22] = ~(a ^ c);  // a with c\n    assign out[21] = ~(a ^ d);  // a with d\n    assign out[20] = ~(a ^ e);  // a with e\n\n    assign out[19] = ~(b ^ a);  // b with a\n    assign out[18] = ~(b ^ b);  // b with b\n    assign out[17] = ~(b ^ c);  // b with c\n    assign out[16] = ~(b ^ d);  // b with d\n    assign out[15] = ~(b ^ e);  // b with e\n\n    assign out[14] = ~(c ^ a);  // c with a\n    assign out[13] = ~(c ^ b);  // c with b\n    assign out[12] = ~(c ^ c);  // c with c\n    assign out[11] = ~(c ^ d);  // c with d\n    assign out[10] = ~(c ^ e);  // c with e\n\n    assign out[9]  = ~(d ^ a);  // d with a\n    assign out[8]  = ~(d ^ b);  // d with b\n    assign out[7]  = ~(d ^ c);  // d with c\n    assign out[6]  = ~(d ^ d);  // d with d\n    assign out[5]  = ~(d ^ e);  // d with e\n\n    assign out[4]  = ~(e ^ a);  // e with a\n    assign out[3]  = ~(e ^ b);  // e with b\n    assign out[2]  = ~(e ^ c);  // e with c\n    assign out[1]  = ~(e ^ d);  // e with d\n    assign out[0]  = ~(e ^ e);  // e with e\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n\t// State definitions\n    typedef enum reg [1:0] {WALK_LEFT, WALK_RIGHT} state_t;\n    state_t curr_state, next_state;\n\n    // State transition logic\n    always @* begin\n        // Default to current state\n        next_state = curr_state;\n        \n        case (curr_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n            end\n            \n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n            end\n        endcase\n    end\n\n    // State update logic on positive edge of clk or areset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            curr_state <= WALK_LEFT;  // Reset to walking left on areset\n        else\n            curr_state <= next_state; // Otherwise move to the next state\n    end\n\n    // Output logic based on states\n    assign walk_left = (curr_state == WALK_LEFT);\n    assign walk_right = (curr_state == WALK_RIGHT);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n    // Logical AND operation\n    assign q = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Intermediate wires to hold AND gate outputs for p1y computation\n    wire p1_and1;\n    wire p1_and2;\n    \n    // Intermediate wires to hold AND gate outputs for p2y computation\n    wire p2_and1;\n    wire p2_and2;\n\n    // 3-input AND gates for p1y computation\n    assign p1_and1 = p1a & p1b & p1c;\n    assign p1_and2 = p1d & p1e & p1f;\n\n    // Final OR gate for p1y output\n    assign p1y = p1_and1 | p1_and2;\n\n    // 2-input AND gates for p2y computation\n    assign p2_and1 = p2a & p2b;\n    assign p2_and2 = p2c & p2d;\n\n    // Final OR gate for p2y output\n    assign p2y = p2_and1 | p2_and2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n    reg [2:0] Y;\n\n    always @ (posedge clk) begin\n        case(y)\n            3'b000: begin\n                Y = (x == 0) ? 3'b000 : 3'b001;\n                z = 0;\n            end\n            3'b001: begin\n                Y = (x == 0) ? 3'b001 : 3'b100;\n                z = 0;\n            end\n            3'b010: begin\n                Y = (x == 0) ? 3'b010 : 3'b001;\n                z = 0;\n            end\n            3'b011: begin\n                Y = (x == 0) ? 3'b001 : 3'b010;\n                z = 1;\n            end\n            3'b100: begin\n                Y = (x == 0) ? 3'b011 : 3'b100;\n                z = 1;\n            end\n            default: begin\n                Y = 3'b000;\n                z = 0;\n            end\n        endcase\n        Y0 = Y[0];\n    end\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    assign out = ~(in1 | in2);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n\t// Connections\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar)\n            q <= 1'b0; // Asynchronous reset\n        else\n            q <= d;    // Sample input d at the rising edge of clk\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;  // sel = 0\n            3'b001: out = data1;  // sel = 1\n            3'b010: out = data2;  // sel = 2\n            3'b011: out = data3;  // sel = 3\n            3'b100: out = data4;  // sel = 4\n            3'b101: out = data5;  // sel = 5\n            default: out = 4'b0000;  // sel = 6 or 7\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;\n        end else if (counter > 0) begin\n            counter <= counter - 1;\n        end\n    end\n\n    // Terminal count output is asserted when counter is 0\n    assign tc = (counter == 0);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n    \n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE  = 3'b000,\n        S1    = 3'b001,\n        S11   = 3'b010,\n        S110  = 3'b011,\n        S1101 = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // State transition logic (next state)\n    always @(*) begin\n        case (state)\n            IDLE: if (data) next_state = S1; else next_state = IDLE;\n            S1: if (data) next_state = S11; else next_state = IDLE;\n            S11: if (~data) next_state = S110; else next_state = S11;\n            S110: if (data) next_state = S1101; else next_state = IDLE;\n            S1101: next_state = S1101; // Remain in this state once the sequence is detected\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // State flip-flops (synchronous with the clock)\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == S1101)\n            start_shifting <= 1;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0; // Reset all flip-flops to 0\n        end else begin\n            q <= d; // Capture the input 'd' at the rising edge of the clock\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n\treg [7:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\t// Detect edges\n\t\tanyedge <= (in & ~prev_in); // Set output if there is a 0 to 1 transition\n\t\tprev_in <= in;              // Update the previous input value\n\tend\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\t// Initial block to set the counter at 1 when instantiated\n\tinitial begin\n\t\tq = 4'd1;\n\tend\n\n\t// Always block for synchronous logic\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'd1; // Reset the counter to 1 when reset is high\n\t\telse if (q == 4'd10)\n\t\t\tq <= 4'd1; // Reset the counter to 1 when it exceeds 10\n\t\telse\n\t\t\tq <= q + 4'd1; // Increment the counter\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\ninitial begin\n\tq = 0; // Initialize q\nend\n\nalways @(posedge clk) begin\n\tif (a == 1) begin\n\t\tq <= 4;   // Set q to 4 when a is 1\n\tend\n\telse begin\n\t\tif (q == 6) begin\n\t\t\tq <= 0; // Reset q to 0 once it reaches 6\n\t\tend\n\t\telse begin\n\t\t\tq <= q + 1; // Increment q on each clock edge\n\t\tend\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// Synchronous reset: Set LFSR to 1\n\t\t\tq <= 5'b00001;\n\t\tend\n\t\telse begin\n\t\t\t// Shift and feedback logic for Galois LFSR\n\t\t\tq[0] <= q[4];                    // Feedback bit shifts into q[0]\n\t\t\tq[1] <= q[0];                    // q[1] takes value from q[0]\n\t\t\tq[2] <= q[1];                    // q[2] takes value from q[1]\n\t\t\tq[3] <= q[2] ^ q[4];             // Tap at bit 3: XOR with feedback bit\n\t\t\tq[4] <= q[3];                    // q[4] takes value from q[3]\n\t\tend\n\tend\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\n\t\tif (out == 0)\n\t\t\tresult_is_zero = 1;\n\t\telse\n\t\t\tresult_is_zero = 0;\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\nalways_comb begin\n    f = (x[1] & x[3] & ~x[4]) | (x[1] & x[3] & x[2]) | (x[3] & ~x[4]) | (x[4] & x[2]);\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1; end\n        8'h16: begin out = 4'd1; valid = 1; end\n        8'h1e: begin out = 4'd2; valid = 1; end\n        8'h26: begin out = 4'd3; valid = 1; end\n        8'h25: begin out = 4'd4; valid = 1; end\n        8'h2e: begin out = 4'd5; valid = 1; end\n        8'h36: begin out = 4'd6; valid = 1; end\n        8'h3d: begin out = 4'd7; valid = 1; end\n        8'h3e: begin out = 4'd8; valid = 1; end\n        8'h46: begin out = 4'd9; valid = 1; end\n        default: begin out = 4'd0; valid = 0; end\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    // Reverse the bit ordering of the input vector\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n    out = (~c & ~d) | (c & d) | (b & c);\nend\n\nendmodule\n", "result": "failed: 68 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= {q[2:0], data};  // Shift left, new data in MSB\n\t\telse if (count_ena)\n\t\t\tq <= q - 1;  // Decrement the value in register\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n\t// The output is directly assigned the value of the input\n\tassign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n    // Define state parameters\n    typedef enum reg [2:0] {\n        IDLE = 3'd0,\n        ENA1 = 3'd1,\n        ENA2 = 3'd2,\n        ENA3 = 3'd3,\n        ENA4 = 3'd4\n    } state_t;\n\n    state_t state, next_state;\n\n    // State update logic (sequential block)\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= ENA1;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic (combinational block)\n    always @(*) begin\n        case(state)\n            IDLE: next_state = IDLE; // Idle state waits for reset\n            ENA1: next_state = ENA2;\n            ENA2: next_state = ENA3;\n            ENA3: next_state = ENA4;\n            ENA4: next_state = IDLE; // Return to idle after 4 cycles\n            default: next_state = IDLE; // Default state\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        case(state)\n            IDLE: shift_ena = 1'b0;\n            ENA1, ENA2, ENA3, ENA4: shift_ena = 1'b1;\n            default: shift_ena = 1'b0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset counter to 0\n        end else begin\n            q <= q + 1; // Increment counter\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using an always block and if statement for combinational logic\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    // Implement the derived Boolean expression using an OR gate\n    assign out = a | b | c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // State encoding\n    localparam STATE_A = 2'b00;\n    localparam STATE_B = 2'b01;\n    localparam STATE_C = 2'b10;\n    localparam STATE_D = 2'b11;\n\n    reg [1:0] current_state, next_state;\n    \n    // State flip-flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) \n            current_state <= STATE_A;  // Reset state\n        else \n            current_state <= next_state;\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                // Stay in B if r1 is asserted, otherwise go back to A\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                // Stay in C if r2 is asserted, otherwise go back to A\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_D: begin\n                // D doesn't have its own state persistence logic; go back to A once entered\n                next_state = STATE_A;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: g = 3'b000;\n            STATE_B: g = 3'b100; // g1 = 1\n            STATE_C: g = 3'b010; // g2 = 1\n            STATE_D: g = 3'b001; // g3 = 1\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\t// On the positive edge of the clock:\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0 when reset is high\n\t\tend\n\t\telse begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000; // Wrap around to 0 when counter reaches 9\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 1; // Increment the counter otherwise\n\t\t\tend\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State definitions\n    typedef enum reg [1:0] {\n        WAIT   = 2'd0,  // Wait for the first byte with in[3] = 1\n        BYTE_1 = 2'd1,  // First byte of the message received\n        BYTE_2 = 2'd2,  // Second byte of the message received\n        DONE   = 2'd3   // Third byte received, assert \"done\" signal\n    } state_t;\n\n    state_t current_state, next_state;\n    reg done_reg;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= WAIT;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next-state logic\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        done_reg = 1'b0;\n\n        case (current_state)\n            WAIT: begin\n                if (in[3] == 1'b1) begin\n                    next_state = BYTE_1; // First byte detected\n                end\n            end\n\n            BYTE_1: begin\n                next_state = BYTE_2; // Move to receive the second byte\n            end\n\n            BYTE_2: begin\n                next_state = DONE; // Move to receive the third byte\n            end\n\n            DONE: begin\n                done_reg = 1'b1; // Assert done signal for one cycle\n                next_state = WAIT; // Return to WAIT state to detect next message\n            end\n        endcase\n    end\n\n    // Assign output\n    assign done = done_reg;\n\nendmodule\n", "result": "failed: 68 out of 400 samples.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\n\tassign out = (sel == 1'b0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Compute the 4-input AND\n    assign out_and = &in; // Performs bitwise AND across all bits\n\n    // Compute the 4-input OR\n    assign out_or = |in; // Performs bitwise OR across all bits\n\n    // Compute the 4-input XOR\n    assign out_xor = ^in; // Performs bitwise XOR across all bits\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tS0 = 3'b000, // 000\n\t\tS1 = 3'b001, // 001\n\t\tS2 = 3'b010, // 010\n\t\tS3 = 3'b011, // 011\n\t\tS4 = 3'b100  // 100\n\t} state_t;\n\n\t// State register\n\treg [2:0] state, next_state;\n\n\t// Synchronous state transition\n\talways @(posedge clk) begin\n\t\tif (reset) \n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: \n\t\t\t\tif (x) next_state = S1;\n\t\t\t\telse next_state = S0;\n\t\t\tS1: \n\t\t\t\tif (x) next_state = S4;\n\t\t\t\telse next_state = S1;\n\t\t\tS2: \n\t\t\t\tif (x) next_state = S1;\n\t\t\t\telse next_state = S2;\n\t\t\tS3: \n\t\t\t\tif (x) next_state = S2;\n\t\t\t\telse next_state = S1;\n\t\t\tS4: \n\t\t\t\tif (x) next_state = S4;\n\t\t\t\telse next_state = S3;\n\t\t\tdefault: \n\t\t\t\tnext_state = S0;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS3: z = 1;\n\t\t\tS4: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n\treg [2:0] state, next_state;\n\treg [1:0] y_counter;\n\n\tlocalparam A = 3'b000,\n\t           B = 3'b001,\n\t           C = 3'b010,\n\t           D = 3'b011,\n\t           E = 3'b100,\n\t           F = 3'b101;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tf <= 0;\n\t\t\tg <= 0;\n\t\t\ty_counter <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tf <= 0;\n\t\t\t\t\tg <= 0;\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tf <= 1;\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tf <= 0;\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tg <= 1;\n\t\t\t\t\ty_counter <= y_counter + 1;\n\t\t\t\tend\n\t\t\t\tE: begin\n\t\t\t\t\tg <= 1;\n\t\t\t\tend\n\t\t\t\tF: begin\n\t\t\t\t\tg <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (resetn)\n\t\t\t\t\tnext_state = B;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (x == 1)\n\t\t\t\t\tnext_state = D;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (y == 1)\n\t\t\t\t\tnext_state = E;\n\t\t\t\telse if (y_counter == 2)\n\t\t\t\t\tnext_state = F;\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tnext_state = E; // Maintain g = 1\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tnext_state = F; // Maintain g = 0\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34; // Set q to 0x34 when reset is active\n\t\tend else begin\n\t\t\tq <= d; // Load new data on the negative edge of clk\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // XOR all 8 bits to find the parity bit for even parity\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\n\t// Output logic: Assign `out` based on the current state\n\tassign out = (state == 2'b11) ? 1'b1 : 1'b0;\n\n\t// Next state logic: Determine `next_state` based on `state` and `in`\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // A -> A (in=0), B (in=1)\n\t\t\t2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // B -> C (in=0), B (in=1)\n\t\t\t2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // C -> A (in=0), D (in=1)\n\t\t\t2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // D -> C (in=0), B (in=1)\n\t\t\tdefault: next_state = 2'b00; // Default case to handle errors\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = (~x & ~y) | (x & y);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_E = 3'b100,\n        STATE_F = 3'b101\n    } state_t;\n\n    // Current state and next state variables\n    state_t current_state, next_state;\n\n    // State flip-flops (sequential logic)\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= STATE_A; // Reset to state A\n        end else begin\n            current_state <= next_state; // Move to next state\n        end\n    end\n\n    // State table (combinational logic)\n    always @(*) begin\n        case (current_state)\n            STATE_A:    next_state = (w) ? STATE_B : STATE_A;\n            STATE_B:    next_state = (w) ? STATE_C : STATE_D;\n            STATE_C:    next_state = (w) ? STATE_E : STATE_D;\n            STATE_D:    next_state = (w) ? STATE_F : STATE_A;\n            STATE_E:    next_state = (w) ? STATE_E : STATE_D;\n            STATE_F:    next_state = (w) ? STATE_C : STATE_D;\n            default:    next_state = STATE_A; // Default reset state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_E, STATE_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tq <= 16'b0;\n\t\telse begin\n\t\t\tif (byteena[1]) \n\t\t\t\tq[15:8] <= d[15:8];\n\t\t\tif (byteena[0])\n\t\t\t\tq[7:0] <= d[7:0];\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n    reg [7:0] prev_in; // Register to store the previous state of the input\n\n    always @(posedge clk) begin\n        // Positive edge detection logic\n        pedge <= (~prev_in) & in; // Detect 0 to 1 transition\n        prev_in <= in; // Update the previous state\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\talways @(posedge clock) begin\n\t\tp <= a;\n\tend\n\t\n\talways @(negedge clock) begin\n\t\tq <= p;\n\tend\nendmodule\n", "result": "failed: 138 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n\tinteger i;\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\t// Load the data into q\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\t// Update q according to Rule 90\n\t\t\treg [511:0] next_q;\n\n\t\t\t// Calculate next state for all cells from 0 to 511\n\t\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\t\tif (i == 0) begin\n\t\t\t\t\t// Special case for the first cell\n\t\t\t\t\tnext_q[i] = q[i+1] ^ 0; // q[-1] = 0\n\t\t\t\tend else if (i == 511) begin\n\t\t\t\t\t// Special case for the last cell\n\t\t\t\t\tnext_q[i] = 0 ^ q[i-1]; // q[512] = 0\n\t\t\t\tend else begin\n\t\t\t\t\t// Standard case for middle cells\n\t\t\t\t\tnext_q[i] = q[i-1] ^ q[i+1];\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tq <= next_q;\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n    // Assign z to be true if both bits of A and B are identical\n    assign z = (A[1] == B[1]) & (A[0] == B[0]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    // For out_both, bit n indicates whether in[n+1] and in[n] are both 1 (for n from 0 to 98)\n    assign out_both = in[99:1] & in[98:0];\n\n    // For out_any, bit n indicates if either in[n] or in[n-1] are 1 (for n from 1 to 99)\n    assign out_any = in[99:1] | in[98:0];\n\n    // For out_different, bit n indicates whether in[n] is different from in[n+1], wrapping the array\n    assign out_different[98:0] = in[99:1] ^ in[98:0];\n    assign out_different[99] = in[99] ^ in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n    always @(*) begin\n        if (ena) begin\n            q = d;  // When enable is high, output follows input\n        end\n        // Else, output retains its previous state (implied by 'q' holding its value implicitly)\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting index of the selected 4-bit section\n    wire [9:0] start_idx = sel * 4;\n\n    // Assign the sliced 4-bit vector to the output\n    assign out = in[start_idx +: 4];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\talways_comb begin\n\t\tcase (sel)\n\t\t\t4'd0: out = a;\n\t\t\t4'd1: out = b;\n\t\t\t4'd2: out = c;\n\t\t\t4'd3: out = d;\n\t\t\t4'd4: out = e;\n\t\t\t4'd5: out = f;\n\t\t\t4'd6: out = g;\n\t\t\t4'd7: out = h;\n\t\t\t4'd8: out = i;\n\t\t\tdefault: out = 16'b1111111111111111;\n\t\tendcase\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    assign out_or_bitwise = a | b;  // Bitwise OR\n    assign out_or_logical = |a | |b;  // Logical OR\n    assign out_not = {~b, ~a};  // Concatenate the NOT of b and a\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\n    always @(*) begin\n        case(state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // D\n            default: next_state = 4'b0001; // Default to A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1 : 0;\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @(*) begin\n    min = a;   // Start by assuming `a` is the smallest\n    if (b < min) begin\n        min = b; // Update if `b` is smaller\n    end\n    if (c < min) begin\n        min = c; // Update if `c` is smaller\n    end\n    if (d < min) begin\n        min = d; // Update if `d` is smaller\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n    // (1) AND operation\n    assign out_and = a & b;\n    // (2) OR operation\n    assign out_or = a | b;\n    // (3) XOR operation\n    assign out_xor = a ^ b;\n    // (4) NAND operation\n    assign out_nand = ~(a & b);\n    // (5) NOR operation\n    assign out_nor = ~(a | b);\n    // (6) XNOR operation\n    assign out_xnor = ~(a ^ b);\n    // (7) A AND NOT B operation\n    assign out_anotb = a & ~b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n    assign out = (~b & ~d) | (~c & ~d) | (~a & ~c) | (~a & d);\n\nendmodule\n", "result": "failed: 143 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n    // Define the states\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        B1 = 3'b010,\n        B2 = 3'b011,\n        B3 = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [1:0] w_counter;  // 2-bit counter to count w = 1 occurrences in each 3-cycle window\n\n    // Sequential logic for state transition\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else \n            state <= next_state;\n    end\n\n    // Sequential logic for counter\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            w_counter <= 2'b00;\n        else if (state == B || state == B1 || state == B2 || state == B3) begin\n            case (state)\n                B: w_counter <= (w ? 1 : 0);\n                B1: w_counter <= w_counter + (w ? 1 : 0);\n                B2: w_counter <= w_counter + (w ? 1 : 0);\n                default: w_counter <= w_counter; // No change in other states\n            endcase\n        end else\n            w_counter <= 2'b00;\n    end\n\n    // Combinational logic to determine next state\n    always_comb begin\n        next_state = state;\n        case (state)\n            A: if (s) next_state = B; \n            B: next_state = B1;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = B;  // Repeat counting for next window\n            default: next_state = A;\n        endcase\n    end\n\n    // Combinational logic to determine output z\n    always_ff @(posedge clk) begin\n        if (reset)\n            z <= 0;\n        else if (state == B3) begin\n            if (w_counter == 2'b10)\n                z <= 1;\n            else\n                z <= 0;\n        end else\n            z <= 0;\n    end\nendmodule\n", "result": "failed: 252 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\nassign out = {{24{in[7]}}, in};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n    reg [3:0] shift_reg;  // A 4-bit register to hold the shift register values\n    \n    // Sequential always block triggered on the clock edge\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;  // Synchronous active-low reset\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};  // Shift the register and insert 'in' at LSB\n        end\n    end\n    \n    // Assign the output to the most significant bit of the shift register\n    assign out = shift_reg[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\nalways @(*) begin\n    if (in[3])\n        pos = 2'd3;\n    else if (in[2])\n        pos = 2'd2;\n    else if (in[1])\n        pos = 2'd1;\n    else if (in[0])\n        pos = 2'd0;\n    else\n        pos = 2'd0; // Default value when all input bits are zero.\nend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// Define the states using localparam for better readability\n\tlocalparam OFF = 1'b0;\n\tlocalparam ON = 1'b1;\n\n\t// State register\n\treg state, next_state;\n\n\t// Asynchronous reset logic and state transition\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= OFF; // Reset state to OFF\n\t\tend else begin\n\t\t\tstate <= next_state; // State transition\n\t\tend\n\tend\n\n\t// Next state logic based on current state and inputs\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) \n\t\t\t\t\tnext_state = ON; \n\t\t\t\telse \n\t\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) \n\t\t\t\t\tnext_state = OFF; \n\t\t\t\telse \n\t\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\t\tdefault: next_state = OFF; // Default case\n\t\tendcase\n\tend\n\n\t// Output logic based on the current state\n\tassign out = (state == ON) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n    // Continuously drive the output with logic low\n    assign out = 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n    assign one = 1'b1; // Assigning constant logic high to the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n\n    // Intermediate wire for the XOR operation\n    logic xor_in_out;\n\n    // XOR gate: computes the XOR of 'in' and 'out'\n    assign xor_in_out = in ^ out;\n\n    // D flip-flop: updates 'out' on the positive edge of 'clk'\n    always_ff @(posedge clk) begin\n        out <= xor_in_out;\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset the register to zero\n        end\n        else if (load) begin\n            q <= data; // Load data into the register\n        end\n        else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, fill q[3] with 0\n        end\n        // No action needed if none of the above conditions are true\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n        q <= 8'b0;  // Active High Asynchronous Reset\n    else \n        q <= d;     // Capture data on positive edge of clk\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // AND all bits in the 'in' bus\n    assign out_and = &in;\n\n    // OR all bits in the 'in' bus\n    assign out_or = |in;\n\n    // XOR all bits in the 'in' bus\n    assign out_xor = ^in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\n    // XOR operation for sum\n    assign sum = a ^ b;\n\n    // AND operation for cout\n    assign cout = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;  // Adding else to cover the not overheated case\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;  // Adding else to define what happens if arrived\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // Define the states using local parameters\n    localparam OFF = 1'b0, ON = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // Sequential logic to update state\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= OFF;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Combinational logic to determine next state\n    always @(*) begin\n        case (current_state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON;\n                end else begin\n                    next_state = OFF;\n                end\n            end\n            \n            ON: begin\n                if (k) begin\n                    next_state = OFF;\n                end else begin\n                    next_state = ON;\n                end\n            end\n        endcase\n    end\n    \n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    // Concatenate inputs and append two '1' bits\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Split the concatenated vector into outputs\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (a ^ b ^ c) ^ d;\nendmodule\n", "result": "failed: 121 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\nassign out = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\tlocalparam A = 1'b0;\n\tlocalparam B = 1'b1;\n\t\n\treg state, next_state;\n\t\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tB: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B; // Stay in state B\n\t\t\t\telse\n\t\t\t\t\tnext_state = A; // Go to state A\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = A; // Stay in state A\n\t\t\t\telse\n\t\t\t\t\tnext_state = B; // Go to state B\n\t\t\tend\n\t\t\tdefault: next_state = B; // Default to state B\n\t\tendcase\n\tend\n\t\n\t// State register and synchronous reset\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= B; // Reset to state B\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\t// Output logic for the Moore machine\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: out = 1'b0;\n\t\t\tB: out = 1'b1;\n\t\t\tdefault: out = 1'b1;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n\t// Intermediate wire to hold the output of the XNOR gate\n\twire intermediate_xnor;\n\n\t// XNOR operation on in1 and in2\n\tassign intermediate_xnor = ~(in1 ^ in2);\n\n\t// XOR operation on intermediate_xnor and in3 to produce the final output\n\tassign out = intermediate_xnor ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    // mux_in[0] corresponds to ab = 00, so it results in 'd'\n    assign mux_in[0] = d;\n\n    // mux_in[1] corresponds to ab = 01, so it results in '0'\n    assign mux_in[1] = 0;\n\n    // mux_in[2] corresponds to ab = 11, so it results in 'c'\n    assign mux_in[2] = c;\n\n    // mux_in[3] corresponds to ab = 10, which results in (!c || d)\n    assign mux_in[3] = (~c | d);\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // State Declaration using One-Hot Encoding\n    reg state_A, state_B;\n\n    // State Transition using Sequential Logic with Asynchronous Reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;  // initial/reset state\n            state_B <= 1'b0;\n        end else begin\n            case ({state_A, state_B})\n                2'b10: begin // Currently in state A\n                    if (x) begin\n                        state_A <= 1'b0;\n                        state_B <= 1'b1;\n                    end // else remain in state A\n                end\n                2'b01: begin // Currently in state B\n                    // state_A remains 0\n                    if (x)\n                        state_B <= 1'b1;\n                    // else remain in state B\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    assign z = (state_A & x) | (state_B & ~x);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (a == 1 && b == 1) begin\n        q <= 0;\n    end else if (a == 0 && b == 1) begin\n        q <= 1;\n    end else if (a == 1 && b == 0) begin\n        q <= 1;\n    end else begin\n        q <= q; // Retain state\n    end\n    state <= q; // state mirrors q\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n    // Logical expression derived from Karnaugh map simplification\n    assign f = x[3] | (x[4] & ~x[1] & ~x[2]) | (x[4] & x[2] & ~x[1]) | (~x[3] & x[1] & x[4]);\n\nendmodule\n", "result": "failed: 50 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic[2:0] {\n\t\tIDLE = 3'b000,       // Initial state, behaves like previous was 0\n\t\tONE = 3'b001,        // After one 1\n\t\tTWO = 3'b010,        // After two 1s\n\t\tTHREE = 3'b011,      // After three 1s\n\t\tFOUR = 3'b100,       // After four 1s\n\t\tFIVE = 3'b101,       // After five 1s\n\t\tSIX = 3'b110,        // After six 1s (potential flag/discard)\n\t\tERROR = 3'b111       // Error state\n\t} state_t;\n\t\n\tstate_t state, next_state;\n\t\n\t// State transition\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\t// Next state and output logic\n\talways @(*) begin\n\t\t// Defaults\n\t\tnext_state = state;\n\t\tdisc = 1'b0;\n\t\tflag = 1'b0;\n\t\terr = 1'b0;\n\t\t\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in) next_state = ONE;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tONE: begin\n\t\t\t\tif (in) next_state = TWO;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tTWO: begin\n\t\t\t\tif (in) next_state = THREE;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tTHREE: begin\n\t\t\t\tif (in) next_state = FOUR;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tFOUR: begin\n\t\t\t\tif (in) next_state = FIVE;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tFIVE: begin\n\t\t\t\tif (in) next_state = SIX;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tSIX: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = ERROR;\n\t\t\t\t\terr = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tdisc = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tERROR: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = ERROR;\n\t\t\t\t\terr = 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\t\tflag = 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State encoding\n    typedef enum logic [1:0] {\n        WAIT_FOR_1101 = 2'b00,\n        RECEIVE_DELAY = 2'b01,\n        COUNT_DOWN = 2'b10,\n        WAIT_ACK = 2'b11\n    } state_t;\n    state_t state, next_state;\n\n    // Registers and wires\n    reg [3:0] pattern_shift;\n    reg [3:0] delay;\n    reg [9:0] cycle_counter;\n    reg [3:0] delay_counter;\n\n    // Sequential state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_FOR_1101;\n            pattern_shift <= 4'b0;\n            delay <= 4'b0;\n            cycle_counter <= 10'b0;\n            delay_counter <= 4'b0;\n            count <= 4'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            pattern_shift <= (state == WAIT_FOR_1101) ? {pattern_shift[2:0], data} : 4'b0;\n        end\n    end\n\n    // Output and state decisions\n    always @(*) begin\n        next_state = state; // Default stay in the current state\n        case (state)\n            WAIT_FOR_1101: begin\n                counting = 1'b0;\n                done = 1'b0;\n                if (pattern_shift == 4'b1101) begin\n                    next_state = RECEIVE_DELAY;\n                    delay = 4'b0;\n                end\n            end\n            RECEIVE_DELAY: begin\n                if (pattern_shift == 4'b0) begin\n                    delay <= {delay[2:0], data}; // Shift in delay bits\n                end\n                if (&delay) begin // If we have shifted in 4 bits\n                    next_state = COUNT_DOWN;\n                    delay_counter = delay;\n                    cycle_counter = 10'd999; // Start countdown from 999\n                end\n            end\n            COUNT_DOWN: begin\n                counting = 1'b1;\n                if (cycle_counter > 0) begin\n                    cycle_counter = cycle_counter - 1;\n                end else if (delay_counter > 0) begin\n                    delay_counter = delay_counter - 1;\n                    cycle_counter = 10'd999; // Reset cycle counter\n                end else begin\n                    counting = 1'b0;\n                    done = 1'b1;\n                    next_state = WAIT_ACK;\n                end\n                count = delay_counter; // Output remaining time\n            end\n            WAIT_ACK: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = WAIT_FOR_1101;\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n\t// State registers\n\treg [3:1] prev_s;\n\n\t// State transition and output logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// Reset: simulate state as if water level has been low for a long time\n\t\t\tfr3 <= 1;\n\t\t\tfr2 <= 1;\n\t\t\tfr1 <= 1;\n\t\t\tdfr <= 1;\n\t\t\tprev_s <= 3'b000; // Disable all sensors in previous state\n\t\tend else begin\n\t\t\tcase (s)\n\t\t\t\t3'b111: begin // Above s[3]\n\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\tdfr <= 0;\n\t\t\t\tend\n\t\t\t\t3'b011: begin // Between s[3] and s[2]\n\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\tdfr <= (prev_s > s) ? 1 : 0; // Supplemental flow valve for rising level\n\t\t\t\tend\n\t\t\t\t3'b001: begin // Between s[2] and s[1]\n\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\tdfr <= (prev_s > s) ? 1 : 0; // Supplemental flow valve for rising level\n\t\t\t\tend\n\t\t\t\t3'b000: begin // Below s[1]\n\t\t\t\t\tfr3 <= 1;\n\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\tdfr <= 1;\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\t// Default case (shouldn't occur)\n\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\tdfr <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\t\t// Update previous state\n\t\t\tprev_s <= s;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "failed: 336 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'd0,\n        START = 3'd1,\n        DATA_0 = 3'd2,\n        DATA_1 = 3'd3,\n        DATA_2 = 3'd4,\n        DATA_3 = 3'd5,\n        DATA_4 = 3'd6,\n        DATA_5 = 3'd7,\n        DATA_6 = 3'd8,\n        DATA_7 = 3'd9,\n        STOP = 3'd10\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg [3:0] bit_counter;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_counter <= 4'd0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state; // Default to staying in the current state\n        done = 1'b0;\n        \n        case (current_state)\n            IDLE: begin\n                if (in == 1'b0) begin // Detect start bit\n                    next_state = START;\n                end\n            end\n\n            START: begin\n                if (in == 1'b0) begin // Validating that the start bit is indeed 0\n                    next_state = DATA_0;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            DATA_0, DATA_1, DATA_2, DATA_3, DATA_4, DATA_5, DATA_6: begin\n                next_state = current_state + 1; // Transition through data states\n            end\n            \n            DATA_7: begin\n                next_state = STOP; // After last data bit, move to Stop state\n            end\n            \n            STOP: begin\n                if (in == 1'b1) begin // Check for correct stop bit\n                    done = 1'b1;\n                    next_state = IDLE;\n                end else begin\n                    next_state = STOP; // Stay until we see a valid stop bit\n                end\n            end\n            \n            default: begin\n                next_state = IDLE; \n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'd0,\n        START = 3'd1,\n        DATA = 3'd2,\n        STOP = 3'd3,\n        ERROR = 3'd4\n    } state_t;\n    \n    state_t state, next_state;\n    reg [7:0] data_reg;\n    reg [3:0] bit_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            data_reg <= 8'd0;\n            out_byte <= 8'd0;\n            done <= 1'b0;\n            bit_count <= 4'd0;\n        end else begin\n            state <= next_state;\n            \n            if (state == DATA) begin\n                data_reg <= {in, data_reg[7:1]}; // Shift the incoming bit into data_reg\n                bit_count <= bit_count + 1;\n            end\n            \n            if (state == STOP) begin\n                out_byte <= data_reg;\n                done <= 1'b1; // Assert done on successful byte reception\n            end else begin\n                done <= 1'b0; // De-assert done otherwise\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state; // Default to no state change\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) begin // Detect start bit\n                    next_state = START;\n                end\n            end\n            START: begin\n                next_state = DATA; // Move to data receiving state\n                bit_count = 4'd0;  // Reset bit counter\n            end\n            DATA: begin\n                if (bit_count == 4'd8) begin\n                    next_state = STOP; // After 8 bits, expect a stop bit\n                end\n            end\n            STOP: begin\n                if (in == 1'b1) begin // Check for stop bit\n                    next_state = IDLE;\n                end else begin\n                    next_state = ERROR; // Incorrect stop bit\n                end\n            end\n            ERROR: begin\n                if (in == 1'b1) begin // Wait for an idle condition to move back to IDLE\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    reg [1:0] PHT [0:127]; // Pattern history table with 128 2-bit entries\n    reg [6:0] GBR;         // Global History Register\n\n    integer i;\n    \n    // Asynchronous reset\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            GBR <= 7'b0;\n            for (i = 0; i < 128; i = i + 1)\n                PHT[i] <= 2'b01; // Initialize counters to weakly not taken\n        end else begin\n            if (train_valid) begin\n                // Update PHT using XOR of train_pc and train_history\n                integer index;\n                index = train_pc ^ train_history;\n                if (train_taken) begin\n                    // Branch was taken\n                    if (PHT[index] < 2'b11) \n                        PHT[index] <= PHT[index] + 1;\n                end else begin\n                    // Branch was not taken\n                    if (PHT[index] > 2'b00)\n                        PHT[index] <= PHT[index] - 1;\n                end\n\n                // Update GBR\n                if (train_mispredicted) begin\n                    GBR <= train_history; // Restore GBR to post-misprediction state\n                end else begin\n                    GBR <= {GBR[5:0], train_taken}; // Normal update\n                end\n            end else if (predict_valid) begin\n                GBR <= {GBR[5:0], predict_taken}; // Update GBR for prediction\n            end\n        end\n    end\n\n    // Prediction path\n    assign predict_history = GBR;\n    wire [6:0] predict_index = predict_pc ^ GBR;\n    assign predict_taken = PHT[predict_index] >= 2'b10;\n\nendmodule\n", "result": "failed: 551 out of 1083 samples.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define states using parameters\n    parameter WALK_LEFT = 0, WALK_RIGHT = 1, FALL_LEFT = 2, FALL_RIGHT = 3, \n              DIG_LEFT = 4, DIG_RIGHT = 5, SPLAT = 6;\n    \n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter; // 5-bit counter to count up to 20\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL_LEFT; // Fall has precedence\n                else if (dig && ground) next_state = DIG_LEFT; // Digging next precedence\n                else if (bump_left) next_state = WALK_RIGHT; // Change direction as last precedence\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig && ground) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) \n                    next_state = (fall_counter > 20) ? SPLAT : WALK_LEFT;\n                else \n                    next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) \n                    next_state = (fall_counter > 20) ? SPLAT : WALK_RIGHT;\n                else \n                    next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (ground) next_state = DIG_LEFT;\n                else next_state = FALL_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (ground) next_state = DIG_RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            SPLAT: begin\n                next_state = SPLAT; // Splatted Lemming stays in SPLAT state\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State flip-flops with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Fall counter logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            fall_counter <= 0;\n        else if (state == FALL_LEFT || state == FALL_RIGHT)\n            fall_counter <= fall_counter + 1;\n        else\n            fall_counter <= 0; // Reset counter when not falling\n    end\n\n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL_LEFT || state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n\nendmodule\n", "result": "failed: 156 out of 1003 samples.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State declaration\n    typedef enum reg [1:0] {IDLE, SHIFT, COUNT, NOTIFY} state_t;\n    state_t current_state, next_state;\n\n    // Shift count for detecting 1101 and shifting 4 bits\n    reg [3:0] shift_count;\n    reg [3:0] bit_sequence; \n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE; // Active high synchronous reset\n            shift_count <= 4'd0;\n            bit_sequence <= 4'b0000;\n        end else begin\n            current_state <= next_state;\n\n            // Update shift count\n            if (current_state == SHIFT) begin\n                shift_count <= shift_count + 1'b1;\n            end else begin\n                shift_count <= 4'd0;\n            end\n\n            // Update bit sequence for pattern detection\n            if (current_state == IDLE) begin\n                bit_sequence <= {bit_sequence[2:0], data};\n            end else begin\n                bit_sequence <= 4'b0000;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = current_state; // Default transition is stay in current state\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                if (bit_sequence == 4'b1101) begin\n                    next_state = SHIFT;\n                end\n            end\n\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_count == 4'd4) begin\n                    next_state = COUNT;\n                end\n            end\n\n            COUNT: begin\n                counting = 1'b1;\n                if (done_counting) begin\n                    next_state = NOTIFY;\n                end\n            end\n\n            NOTIFY: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n\n            default: begin\n                next_state = IDLE; // Safety fallback\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: 852 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n\tinteger i, j;\n\twire [3:0] neighbors [15:0][15:0];\n\n\t// Function to count the number of 1s in 3x3 grid around a point (k,l) considering toroidal wrapping\n\tfunction [3:0] count_neighbors;\n\t\tinput [15:0] grid_row[15:0];\n\t\tinput [3:0] row, col;\n\t\tinteger r, c;\n\t\tbegin\n\t\t\tcount_neighbors = 0;\n\t\t\tfor (r = row - 1; r <= row + 1; r = r + 1) begin\n\t\t\t\tfor (c = col - 1; c <= col + 1; c = c + 1) begin\n\t\t\t\t\tif ((r != row || c != col) && grid_row[r & 15][c & 15]) begin\n\t\t\t\t\t\tcount_neighbors = count_neighbors + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tendfunction\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\t// Create a copy of q to manipulate\n\t\t\treg [255:0] next_q;\n\t\t\t// Split the 256-bit vector into a 16x16 2D array for easier access\n\t\t\treg [15:0] grid [15:0];\n\t\t\tfor (i = 0; i < 16; i = i + 1) begin\n\t\t\t\tgrid[i] = q[16 * i +: 16];\n\t\t\tend\n\t\t\t\n\t\t\tfor (i = 0; i < 16; i = i + 1) begin\n\t\t\t\tfor (j = 0; j < 16; j = j + 1) begin\n\t\t\t\t\tneighbors[i][j] = count_neighbors(grid, i, j);\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tfor (i = 0; i < 16; i = i + 1) begin\n\t\t\t\tfor (j = 0; j < 16; j = j + 1) begin\n\t\t\t\t\tcase (neighbors[i][j])\n\t\t\t\t\t\t0, 1: next_q[16*i + j] = 0;\n\t\t\t\t\t\t2:     next_q[16*i + j] = q[16*i + j];\n\t\t\t\t\t\t3:     next_q[16*i + j] = 1;\n\t\t\t\t\t\tdefault: next_q[16*i + j] = 0;\n\t\t\t\t\tendcase\n\t\t\t\tend\n\t\t\tend\n\t\t\tq <= next_q;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define FSM states\n    typedef enum reg [1:0] {\n        WL = 2'b00,  // Walking Left\n        WR = 2'b01,  // Walking Right\n        F  = 2'b10,  // Falling\n        D  = 2'b11   // Digging\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg prev_walk_left;  // To remember the direction before falling\n\n    // State transition\n    always @(*) begin\n        case (current_state)\n            WL: begin\n                if (!ground)\n                    next_state = F;\n                else if (dig)\n                    next_state = D;\n                else if (bump_left)\n                    next_state = WR;\n                else\n                    next_state = WL;\n            end\n            \n            WR: begin\n                if (!ground)\n                    next_state = F;\n                else if (dig)\n                    next_state = D;\n                else if (bump_right)\n                    next_state = WL;\n                else\n                    next_state = WR;\n            end\n            \n            F: begin\n                if (ground) begin\n                    if (prev_walk_left)\n                        next_state = WL;\n                    else\n                        next_state = WR;\n                end\n                else\n                    next_state = F;\n            end\n            \n            D: begin\n                if (!ground)\n                    next_state = F;\n                else\n                    next_state = D;\n            end\n            \n            default: next_state = WL;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WL;\n            prev_walk_left <= 1;\n        end\n        else begin\n            current_state <= next_state;\n            if (current_state == WL)\n                prev_walk_left <= 1;\n            else if (current_state == WR)\n                prev_walk_left <= 0;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (current_state == WL);\n        walk_right = (current_state == WR);\n        aaah = (current_state == F);\n        digging = (current_state == D);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the clock to \"12:00:00 AM\"\n            hh <= 8'b0001_0010; // 12 in BCD\n            mm <= 8'b0000_0000; // 00 in BCD\n            ss <= 8'b0000_0000; // 00 in BCD\n            pm <= 0; // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b0101_1001) begin // 59 in BCD\n                ss <= 8'b0000_0000; // Reset to 00\n                // Increment minutes\n                if (mm == 8'b0101_1001) begin // 59 in BCD\n                    mm <= 8'b0000_0000; // Reset to 00\n                    // Increment hours\n                    if (hh == 8'b0001_0010) begin // 12 in BCD\n                        hh <= 8'b0000_0001; // Reset to 01\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'b0001_0001) begin // 11 in BCD\n                        hh <= hh + 1; // Increment to 12\n                        pm <= ~pm; // Toggle AM/PM\n                    end else begin\n                        hh <= hh + 1; // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 1; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 1; // Increment seconds\n            end\n        end\n    end\nendmodule\n", "result": "failed: 351978 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n    // Define states\n    typedef enum logic [1:0] {\n        WALK_LEFT  = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALL       = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Output logic\n    always_comb begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        \n        // Set outputs based on current state\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n        endcase\n    end\n\n    // State transitions\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;  // Asynchronous reset to WALK_LEFT\n        end else begin\n            current_state <= next_state; // Regular clocked state update\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL;          // Falling\n                else if (bump_left || bump_right) next_state = WALK_RIGHT; // Change direction if bumped\n                else next_state = WALK_LEFT;             // Keep walking left\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL;          // Falling\n                else if (bump_left || bump_right) next_state = WALK_LEFT;  // Change direction if bumped\n                else next_state = WALK_RIGHT;            // Keep walking right\n            end\n\n            FALL: begin\n                if (ground) begin                         // Ground reappears\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT; // Resume existing direction\n                end else begin\n                    next_state = FALL;                    // Continue falling\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n\t// Intermediate enable signals\n\tassign ena[1] = (q[3:0] == 4'd9); // Enable for tens place\n\tassign ena[2] = (q[7:4] == 4'd9 && q[3:0] == 4'd9); // Enable for hundreds place\n\tassign ena[3] = (q[11:8] == 4'd9 && q[7:4] == 4'd9 && q[3:0] == 4'd9); // Enable for thousands place\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'd0;\n\t\tend else begin\n\t\t\t// Ones digit logic\n\t\t\tif (q[3:0] == 4'd9) begin\n\t\t\t\tq[3:0] <= 4'd0;\n\t\t\t\t// Tens digit logic\n\t\t\t\tif (q[7:4] == 4'd9) begin\n\t\t\t\t\tq[7:4] <= 4'd0;\n\t\t\t\t\t// Hundreds digit logic\n\t\t\t\t\tif (q[11:8] == 4'd9) begin\n\t\t\t\t\t\tq[11:8] <= 4'd0;\n\t\t\t\t\t\t// Thousands digit logic\n\t\t\t\t\t\tif (q[15:12] == 4'd9) begin\n\t\t\t\t\t\t\tq[15:12] <= 4'd0;\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tq[15:12] <= q[15:12] + 4'd1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tq[11:8] <= q[11:8] + 4'd1;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\tq[7:4] <= q[7:4] + 4'd1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tq[3:0] <= q[3:0] + 4'd1;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\t// Continuous assignment using the conditional operator to implement the multiplexer\n\tassign out = sel ? b : a;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0; // A (000)\n            3'b001: Y2 = w; // B (001)\n            3'b010: Y2 = w ? 1 : 0; // C (010)\n            3'b011: Y2 = w ? 0 : 1; // D (011)\n            3'b100: Y2 = 1; // E (100)\n            3'b101: Y2 = 1; // F (101)\n            default: Y2 = 0; // Default case for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: 19 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\nalways @(*) begin\n\tif (ring) begin\n\t\tif (vibrate_mode) begin\n\t\t\tringer = 0;\n\t\t\tmotor = 1;\n\t\tend else begin\n\t\t\tringer = 1;\n\t\t\tmotor = 0;\n\t\tend\n\tend else begin\n\t\tringer = 0;\n\t\tmotor = 0;\n\tend\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Implement AND gate using assign statement\nassign out_assign = a & b;\n\n// Implement AND gate using always block\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\n    // Assign a constant 0 to the output `zero`\n    assign zero = 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (a == 0) begin\n            q <= 1;\n        end else begin\n            q <= 0;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // State declaration\n    typedef enum logic {WAIT, COMPLEMENT} state_t;\n    state_t current_state, next_state;\n    \n    // State transition on clock edge or asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= WAIT;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case(current_state)\n            WAIT: begin\n                if (x == 1)\n                    next_state = COMPLEMENT;\n                else\n                    next_state = WAIT;\n            end\n            COMPLEMENT: begin\n                next_state = COMPLEMENT; // Stay in COMPLEMENT once entered\n            end\n            default: next_state = WAIT;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            z <= 0;\n        else begin\n            case(current_state)\n                WAIT: begin\n                    z <= x;\n                end\n                COMPLEMENT: begin\n                    z <= ~x;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= A; // Reset to state A on reset\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        case (current_state)\n            A: begin\n                next_state = in ? B : A;\n                out = 0;\n            end\n            B: begin\n                next_state = in ? B : C;\n                out = 0;\n            end\n            C: begin\n                next_state = in ? D : A;\n                out = 0;\n            end\n            D: begin\n                next_state = in ? B : C;\n                out = 1;\n            end\n            default: begin\n                next_state = A;\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\nassign out = { in[7:0], in[15:8], in[23:16], in[31:24] };\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n\talways_ff @(posedge clk) begin\n\t\tif (r) begin\n\t\t\tq <= 0; // Synchronous reset, set output q to 0\n\t\tend else begin\n\t\t\tq <= d; // Regular D flip flop operation\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    \n    assign z = (x ^ y) & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= q << 1;   // shift left by 1 bit\n\t\t\t\t2'b01: q <= q << 8;   // shift left by 8 bits\n\t\t\t\t2'b10: q <= q >> 1;   // shift right by 1 bit (arithmetic)\n\t\t\t\t2'b11: q <= { {8{q[63]}}, q[63:8] }; // shift right by 8 bits (arithmetic)\n\t\t\t\t// Note: { {8{q[63]}}, q[63:8] } replicates the sign bit 8 times and then takes the upper 56 bits of q\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 944 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n\t// State Encoding\n\ttypedef enum logic [1:0] {\n\t\tS0 = 2'b00, // Initial state\n\t\tS1 = 2'b01, // After detecting '1'\n\t\tS2 = 2'b10  // After detecting '10'\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State Update Logic (Sequential)\n\talways @(negedge clk or negedge aresetn) begin\n\t\tif (!aresetn) begin\n\t\t\tcurrent_state <= S0; // Asynchronous reset\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Next State Logic (Combinational)\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS0: next_state = x ? S1 : S0;\n\t\t\tS1: next_state = x ? S1 : S2;\n\t\t\tS2: next_state = x ? S1 : S0;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\t// Output Logic (Combinational)\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS2: z = x ? 1 : 0; // Assert z on detecting '101'\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;  // Initial state\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state and output\n    always_comb begin\n        case (current_state)\n            A: begin\n                next_state = (w) ? A : B;\n                z = 0;\n            end\n            B: begin\n                next_state = (w) ? D : C;\n                z = 0;\n            end\n            C: begin\n                next_state = (w) ? D : E;\n                z = 0;\n            end\n            D: begin\n                next_state = (w) ? A : F;\n                z = 0;\n            end\n            E: begin\n                next_state = (w) ? D : E;\n                z = 1;\n            end\n            F: begin\n                next_state = (w) ? D : C;\n                z = 1;\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    \n    typedef enum reg [1:0] {IDLE, BYTE1, BYTE2, BYTE3} state_t;\n    state_t state, next_state;\n    \n    reg [7:0] byte1, byte2, byte3;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'dx;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                end\n                BYTE1: begin\n                    byte1 <= in;\n                end\n                BYTE2: begin\n                    byte2 <= in;\n                end\n                BYTE3: begin\n                    byte3 <= in;\n                    done <= 1;\n                    out_bytes <= {byte1, byte2, byte3};\n                end\n            endcase\n        end\n    end\n    \n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in[3] == 1'b1) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n        \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\n\tassign Y1 = y[0] & w; // State B from State A with w = 1\n\tassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w); // State D from States B, C, and F with w = 0\n\nendmodule\n", "result": "failed: 23 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Assign input vector to the output vector\n    assign outv = vec;\n    \n    // Split the input vector into separate outputs\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        // Sum of products based on Karnaugh map\n        out = (~c & ~d & b) | (c & ~d & a) | (~c & d & ~b) | (c & d & ~a);\n    end\nendmodule\n", "result": "failed: 114 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\nassign out_lo = in[7:0];    // Extract lower byte\nassign out_hi = in[15:8];   // Extract upper byte\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n    // Implement the NOR operation: out = !(a || b)\n    assign out = ~(a | b);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n    // 1. XOR using an assign statement\n    assign out_assign = a ^ b;\n\n    // 2. XOR using a combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3. XOR using a clocked always block (with a flip-flop)\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\nassign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & ~w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "result": "failed: 29 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    // The output is directly assigned the bit from the 'in' vector at position 'sel'.\n    assign out = in[sel];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (L) begin\n        // Load value R into Q when L is high\n        Q <= R;\n    end else if (E) begin\n        // Shift in the new value w when E is high and L is low\n        Q <= w;\n    end\n    // If both L and E are low, Q retains its value\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Declare internal signals to store flip-flop outputs\n    reg q1, q2, q3;\n    \n    wire d1, d2, d3;\n    wire q1_bar, q2_bar, q3_bar;\n    \n    // Complemented outputs of flip-flops\n    assign q1_bar = ~q1;\n    assign q2_bar = ~q2;\n    assign q3_bar = ~q3;\n    \n    // Next state logic for flip-flops\n    assign d1 = x ^ q1;         // XOR gate\n    assign d2 = x & q2_bar;     // AND gate\n    assign d3 = x | q3_bar;     // OR gate\n    \n    // Always block to update flip-flops on the rising edge of the clock\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n    \n    // Output logic using an XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (c | (b & (~c | ((a & ~d) | (b & d)))));\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    integer i;\n    reg [511:0] q_next;\n    \n    always @(*) begin\n        // Calculate next state according to Rule 110\n        // Considering the boundary conditions:\n        q_next[0] = (q[1] ^ q[0]);\n        q_next[511] = (q[510] & q[511]) | (~q[510] & q[511]) | (q[510] & ~q[511]);\n        \n        for (i = 1; i < 511; i = i + 1) begin\n            q_next[i] = (q[i-1] & ~q[i] & ~q[i+1]) | \n                        (~q[i-1] & q[i] & q[i+1]) | \n                        (~q[i-1] & q[i] & ~q[i+1]) |\n                        (~q[i-1] & ~q[i] & q[i+1]);\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= q_next;\n        end\n    end\n\nendmodule\n", "result": "failed: 6218 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// Define state parameters\n\tlocalparam A = 2'b00;\n\tlocalparam B = 2'b01;\n\tlocalparam C = 2'b10;\n\tlocalparam D = 2'b11;\n\n\t// Register to hold current state\n\treg [1:0] state, next_state;\n\n\t// State Transition Logic\n\talways_ff @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A; // Synchronous reset to state A\n\t\tend else begin\n\t\t\tstate <= next_state; // Transition to the next state\n\t\tend\n\tend\n\n\t// Determine next state based on current state and input\n\talways_comb begin\n\t\tcase(state)\n\t\t\tA: next_state = (in) ? B : A;\n\t\t\tB: next_state = (in) ? B : C;\n\t\t\tC: next_state = (in) ? D : A;\n\t\t\tD: next_state = (in) ? B : C;\n\t\t\tdefault: next_state = A; // Safe default\n\t\tendcase\n\tend\n\t\n\t// Determine output based solely on current state (Moore state machine)\n\talways_comb begin\n\t\tcase(state)\n\t\t\tA: out = 0;\n\t\t\tB: out = 0;\n\t\t\tC: out = 0;\n\t\t\tD: out = 1;\n\t\t\tdefault: out = 0; // Safe default\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase (c)\n\t\t\t4'd0: q = b;\n\t\t\t4'd1: q = e;\n\t\t\t4'd2: q = a;\n\t\t\t4'd3: q = d;\n\t\t\tdefault: q = 4'hf; // Constant value f for c >= 4\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n    \n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= q_in ^ Q;\n        end\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] r,\n    input [2:0] q_in,\n    output [2:0] Q);\n\n    sub_module u0 (.clk(clk), .L(L), .q_in(q_in[0]), .r_in(r[0]), .Q(Q[0]));\n    sub_module u1 (.clk(clk), .L(L), .q_in(q_in[1]), .r_in(r[1]), .Q(Q[1]));\n    sub_module u2 (.clk(clk), .L(L), .q_in(q_in[2]), .r_in(r[2]), .Q(Q[2]));\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n\t// Register to store the previous state of the input\n\treg [31:0] prev_in;\n\n\t// Always block triggered on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// If reset is high, clear the output register\n\t\t\tout <= 32'b0;\n\t\tend else begin\n\t\t\t// Iterate over each bit to detect a 1 to 0 transition\n\t\t\tfor (integer i = 0; i < 32; i = i + 1) begin\n\t\t\t\t// Check for transition from 1 to 0\n\t\t\t\tif (prev_in[i] == 1'b1 && in[i] == 1'b0) begin\n\t\t\t\t\tout[i] <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t// Update the previous input register with the current input\n\t\tprev_in <= in;\n\tend\n\nendmodule\n", "result": "failed: 8 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    // Calculate the sum of a and b\n    assign s = a + b;\n    \n    // Detect signed overflow\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // State definitions (one-hot encoded bits)\n    parameter S = 10'b0000000001;\n    parameter S1 = 10'b0000000010;\n    parameter S11 = 10'b0000000100;\n    parameter S110 = 10'b0000001000;\n    parameter B0 = 10'b0000010000;\n    parameter B1 = 10'b0000100000;\n    parameter B2 = 10'b0001000000;\n    parameter B3 = 10'b0010000000;\n    parameter Count = 10'b0100000000;\n    parameter Wait = 10'b1000000000;\n\n    // Next-state logic\n    assign S_next = (state == S && d == 0) || (state == S1 && d == 0) || (state == S110 && d == 0) || (state == Wait && ack == 1);\n    assign S1_next = (state == S && d == 1);\n    assign B3_next = (state == B2);\n    assign Count_next = (state == B3);\n    assign Wait_next = (state == Count && done_counting);\n\n    // Output logic\n    assign done = (state == Wait);\n    assign counting = (state == Count);\n    assign shift_ena = (state == B0) || (state == B1) || (state == B2) || (state == B3);\n\nendmodule\n", "result": "failed: 3000 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n    always_comb begin\n        state = 2'b01; // Default state on asynchronous reset\n    end\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // If reset is asserted, set to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) begin\n                    state <= state + 2'b01; // Increment state with upper limit of 3\n                end\n            end else begin\n                if (state > 2'b00) begin\n                    state <= state - 2'b01; // Decrement state with lower limit of 0\n                end\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tif (in[0])\n\t\t\tpos = 3'd0;\n\t\telse if (in[1])\n\t\t\tpos = 3'd1;\n\t\telse if (in[2])\n\t\t\tpos = 3'd2;\n\t\telse if (in[3])\n\t\t\tpos = 3'd3;\n\t\telse if (in[4])\n\t\t\tpos = 3'd4;\n\t\telse if (in[5])\n\t\t\tpos = 3'd5;\n\t\telse if (in[6])\n\t\t\tpos = 3'd6;\n\t\telse if (in[7])\n\t\t\tpos = 3'd7;\n\t\telse\n\t\t\tpos = 3'd0; // No bits are high\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default to no arrow key pressed\n\t\tleft = 0;\n\t\tdown = 0;\n\t\tright = 0;\n\t\tup = 0;\n\t\t\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;  // Left arrow\n\t\t\t16'he072: down = 1;  // Down arrow\n\t\t\t16'he074: right = 1; // Right arrow\n\t\t\t16'he075: up = 1;    // Up arrow\n\t\tendcase\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n    wire c1, c2, c3, c4;  // Internal carry wires\n    \n    // Instantiate four full adders for each bit position\n    full_adder fa0(.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    \n    // The sum's MSB (sum[4]) is the final carry-out (overflow bit)\n    assign sum[4] = c4;\n    \nendmodule\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Asynchronous reset: reset history to zero\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        // On misprediction: load train_history concatenated with train_taken\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        // Prediction occurs: shift predict_taken into the least significant bit\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\n    // If none of the conditions are met, the history does not change\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\t// Intermediate wires for AND gate outputs\n\twire and1_out;\n\twire and2_out;\n\n\t// First layer: AND gates\n\tassign and1_out = a & b;\n\tassign and2_out = c & d;\n\n\t// Second layer: OR gate\n\tassign out = and1_out | and2_out;\n\n\t// Inverted output\n\tassign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    always @(posedge clk) begin\n        q <= d; // Captures the value of 'd' at every rising edge of 'clk'\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    reg [7:0] Q; // 8-bit shift register\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S}; // Shift left and insert S at the LSB position\n        end\n    end\n\n    // Multiplexing and output logic\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // This case should not occur\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    // Heating mode\n    assign heater = mode & too_cold;\n    // Cooling mode\n    assign aircon = ~mode & too_hot;\n    // Fan control\n    assign fan = heater | aircon | fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n    // Minimum Sum-of-Products (SOP) expression\n    assign out_sop = (~a & b & ~c & d) | (a & ~b & c & d) | (a & b & c & d);\n\n    // Minimum Product-of-Sums (POS) expression\n    assign out_pos = (a | b | ~c | ~d) & (a | ~b | ~c | d) & (~a | ~b | c | d) & (~a | b | c | d);\n\nendmodule\n", "result": "failed: 82 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 32'h1;\n\t\tend else begin\n\t\t\t// Calculate feedback from the current MSB\n\t\t\twire feedback = q[31];\n\n\t\t\tq[31] <= q[30];\n\t\t\tq[30] <= q[29];\n\t\t\tq[29] <= q[28];\n\t\t\tq[28] <= q[27];\n\t\t\tq[27] <= q[26];\n\t\t\tq[26] <= q[25];\n\t\t\tq[25] <= q[24];\n\t\t\tq[24] <= q[23];\n\t\t\tq[23] <= q[22] ^ feedback;\n\t\t\tq[22] <= q[21];\n\t\t\tq[21] <= q[20];\n\t\t\tq[20] <= q[19];\n\t\t\tq[19] <= q[18];\n\t\t\tq[18] <= q[17];\n\t\t\tq[17] <= q[16];\n\t\t\tq[16] <= q[15];\n\t\t\tq[15] <= q[14];\n\t\t\tq[14] <= q[13];\n\t\t\tq[13] <= q[12];\n\t\t\tq[12] <= q[11];\n\t\t\tq[11] <= q[10];\n\t\t\tq[10] <= q[9];\n\t\t\tq[9] <= q[8];\n\t\t\tq[8] <= q[7];\n\t\t\tq[7] <= q[6];\n\t\t\tq[6] <= q[5];\n\t\t\tq[5] <= q[4];\n\t\t\tq[4] <= q[3];\n\t\t\tq[3] <= q[2];\n\t\t\tq[2] <= q[1] ^ feedback;\n\t\t\tq[1] <= q[0] ^ feedback;\n\t\t\tq[0] <= feedback;\n\t\tend\n\tend\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = b | d;\nendmodule\n", "result": "failed: 34 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // First 4-input NAND gate\n    nand (p1y, p1a, p1b, p1c, p1d);\n    \n    // Second 4-input NAND gate\n    nand (p2y, p2a, p2b, p2c, p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    integer i;\n    \n    always @(*) begin\n        out = 8'b0; // Initialize the output count to zero\n        for (i = 0; i < 255; i = i + 1) begin\n            if (in[i] == 1'b1) begin\n                out = out + 1'b1; // Increment count for each '1' found\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    // out_both calculation\n    assign out_both[0] = in[0] & in[1];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[2] = in[2] & in[3];\n    \n    // out_any calculation\n    assign out_any[1] = in[1] | in[0];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[3] = in[3] | in[2];\n\t\n    // out_different calculation\n    assign out_different[0] = in[0] ^ in[3]; // wrap-around neighbor for in[3] is in[0]\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[3] = in[3] ^ in[2];\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000; // Default case to handle undefined 'a'\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;  // Reset the counter to 0\n        end else if (slowena) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;  // Wrap around to 0 after reaching 9\n            end else begin\n                q <= q + 4'b0001;  // Increment the counter\n            end\n        end\n        // If slowena is low, hold current value of q\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Intermediate wire to hold the inverted value of in2\n    wire inverted_in2;\n    \n    // Invert in2\n    assign inverted_in2 = ~in2;\n    \n    // AND operation between in1 and inverted in2\n    assign out = in1 & inverted_in2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n    // Continuous assignment for combinational logic\n    assign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic [1:0] {A = 1'b0, B = 1'b1} state_t;\n\tstate_t current_state, next_state;\n\n\t// Asynchronous reset logic\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= B; // Reset to state B\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Output logic based on current state\n\talways_ff @(current_state) begin\n\t\tcase (current_state)\n\t\t\tA: out = 1'b0;\n\t\t\tB: out = 1'b1;\n\t\t\tdefault: out = 1'b0; // Default case to cover all possibilities\n\t\tendcase\n\tend\n\n\t// State transition logic based on input\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tA: next_state = (in) ? A : B;\n\t\t\tB: next_state = (in) ? B : A;\n\t\t\tdefault: next_state = B; // Default state to handle cases not covered explicitly\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\t// Internal signals for the output of each of the flip-flops\n\treg q_posedge;\n\treg q_negedge;\n\n\t// Positive edge triggered flip-flop\n\talways @(posedge clk) begin\n\t\tq_posedge <= d;\n\tend\n\n\t// Negative edge triggered flip-flop\n\talways @(negedge clk) begin\n\t\tq_negedge <= d;\n\tend\n\n\t// Combine the outputs of both flip-flops\n\talways @(*) begin\n\t\tif (clk)\n\t\t\tq = q_posedge;\n\t\telse\n\t\t\tq = q_negedge;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a ^ b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = x ? (y ? 1 : 0) : (y ? 0 : 1);\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_z, a2_z, b1_z, b2_z;\n    wire or_out, and_out;\n\n    // Instantiate submodule A twice\n    A u1_A (\n        .x(x),\n        .y(y),\n        .z(a1_z)\n    );\n\n    A u2_A (\n        .x(x),\n        .y(y),\n        .z(a2_z)\n    );\n\n    // Instantiate submodule B twice\n    B u1_B (\n        .x(x),\n        .y(y),\n        .z(b1_z)\n    );\n\n    B u2_B (\n        .x(x),\n        .y(y),\n        .z(b2_z)\n    );\n\n    // Connect outputs to gates\n    assign or_out = a1_z | b1_z;\n    assign and_out = a2_z & b2_z;\n\n    // Produce final output\n    assign z = or_out ^ and_out;\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the register synchronously\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: begin\n                    // Rotate right by 1 bit\n                    q <= {q[0], q[99:1]};\n                end\n                2'b10: begin\n                    // Rotate left by 1 bit\n                    q <= {q[98:0], q[99]};\n                end\n                default: begin\n                    // No rotation (2'b00 or 2'b11)\n                    // Retain the current value of q\n                    q <= q;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0; // Reset counter to 0\n        end else begin\n            q <= (q == 10'd999) ? 10'd0 : q + 10'd1; // Increment or wrap around\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\nassign out = ~in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default outputs\n\t\tout1 = 0;\n\t\tout2 = 0;\n\t\t\n\t\tcase (1'b1) // one-hot encoding, checking which state is active\n\t\t\tstate[0]: next_state = in ? 10'b0000000010 : 10'b0000000001; // S0\n\t\t\tstate[1]: next_state = in ? 10'b0000000100 : 10'b0000000001; // S1\n\t\t\tstate[2]: next_state = in ? 10'b0000001000 : 10'b0000000001; // S2\n\t\t\tstate[3]: next_state = in ? 10'b0000010000 : 10'b0000000001; // S3\n\t\t\tstate[4]: next_state = in ? 10'b0000100000 : 10'b0000000001; // S4\n\t\t\tstate[5]: next_state = in ? 10'b0001000000 : 10'b0010000000; // S5\n\t\t\tstate[6]: next_state = in ? 10'b0100000000 : 10'b1000000000; // S6\n\t\t\tstate[7]: begin // S7\n\t\t\t\tnext_state = in ? 10'b0000001000 : 10'b0000000001;\n\t\t\t\tout2 = 1;\n\t\t\tend\n\t\t\tstate[8]: begin // S8\n\t\t\t\tnext_state = in ? 10'b0000000010 : 10'b0000000001;\n\t\t\t\tout1 = 1;\n\t\t\tend\n\t\t\tstate[9]: begin // S9\n\t\t\t\tnext_state = in ? 10'b0000000010 : 10'b0000000001;\n\t\t\t\tout1 = 1;\n\t\t\t\tout2 = 1;\n\t\t\tend\n\t\t\tdefault: next_state = 10'b0000000001; // Undefined state, default to S0\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (j == 0 && k == 0)\n            Q <= Q;   // No change\n        else if (j == 0 && k == 1)\n            Q <= 0;   // Reset\n        else if (j == 1 && k == 0)\n            Q <= 1;   // Set\n        else if (j == 1 && k == 1)\n            Q <= ~Q;  // Toggle\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    // Count the number of '1's in the 3-bit input vector\n    assign out = in[2] + in[1] + in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    \n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg {\n        WALK_LEFT = 1'b0,\n        WALK_RIGHT = 1'b1\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (bump_left | bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (bump_left | bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n        endcase\n    end\n\n    // Output logic (Moore state machine)\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\n    // Implementing the AND operation\n    assign q = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Intermediate wires for AND gate outputs\n    wire and1_p1_result;\n    wire and2_p1_result;\n    wire and1_p2_result;\n    wire and2_p2_result;\n\n    // AND gates for p1y\n    assign and1_p1_result = p1a & p1b & p1c;\n    assign and2_p1_result = p1d & p1e & p1f;\n\n    // OR gate for p1y\n    assign p1y = and1_p1_result | and2_p1_result;\n\n    // AND gates for p2y\n    assign and1_p2_result = p2a & p2b;\n    assign and2_p2_result = p2c & p2d;\n\n    // OR gate for p2y\n    assign p2y = and1_p2_result | and2_p2_result;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\n    always @(*) begin\n        // Implementing the logic for Y0\n        Y0 = (~x & (y[2] & ~y[1] & ~y[0] | y[2] & y[1] & ~y[0] | ~y[2] & y[1] & y[0])) | \n             (x & (~y[2] & ~y[1] & y[0] | ~y[2] & y[1] & ~y[0]));\n             \n        // Implementing the logic for z\n        z = (~y[2] & y[1] & y[0]) | (y[2] & ~y[1] & ~y[0]);\n    end\n\nendmodule\n", "result": "failed: 33 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 0; // Asynchronous reset\n        end else begin\n            q <= d; // Capture 'd' on the rising edge of clk\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'd0: out = data0;\n\t\t\t3'd1: out = data1;\n\t\t\t3'd2: out = data2;\n\t\t\t3'd3: out = data3;\n\t\t\t3'd4: out = data4;\n\t\t\t3'd5: out = data5;\n\t\t\tdefault: out = 4'd0; // Output 0 if sel is out of the range 0-5\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter; // Register to store the current count value\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with new data value\n            counter <= data;\n        end else if (counter != 0) begin\n            // Decrement the counter if it is not already zero\n            counter <= counter - 1;\n        end\n    end\n\n    // tc should be 1 if the counter has reached zero, 0 otherwise\n    always @(*) begin\n        tc = (counter == 10'b0);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tS0 = 3'b000, // Initial state\n\t\tS1 = 3'b001, // Detected '1'\n\t\tS2 = 3'b010, // Detected '11'\n\t\tS3 = 3'b011, // Detected '110'\n\t\tS4 = 3'b100  // Detected '1101'\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// Sequential logic: State transitions\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tif (current_state == S4) begin\n\t\t\t\tstart_shifting <= 1;\n\t\t\tend\n\t\tend\n\tend\n\n\t// Combinational logic: Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS0: next_state = data ? S1 : S0;\n\t\t\tS1: next_state = data ? S2 : S0;\n\t\t\tS2: next_state = data ? S2 : S3;\n\t\t\tS3: next_state = data ? S4 : S0;\n\t\t\tS4: next_state = S4; // Stay in S4 once the sequence is detected\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b00000000;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Detect edges and set anyedge accordingly\n        anyedge <= (prev_in ^ in) & in;  // Sets the bit if there is a 0 to 1 transition\n\n        // Update prev_in to the current value of in for the next comparison\n        prev_in <= in;\n    end\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'd1; // Reset sets the counter to 1\n\t\tend\n\t\telse begin\n\t\t\tif (q == 4'd10) begin\n\t\t\t\tq <= 4'd1; // Wrap around once the counter reaches 10\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 4'd1; // Increment the counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (a == 1) begin\n        q <= 3'd4; // Set q to 4 when a is 1\n    end else begin\n        q <= q + 1; // Increment q when a is 0 and wrap around modulo 8 (3 bits)\n    end\nend\n\nendmodule\n", "result": "failed: 192 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Initialize LFSR to state '00001'\n        end else begin\n            // Feedback is XOR of the tapped bits\n            // Tap positions are (5, 3) --> indices (4, 1)\n            q <= {q[3:0], (q[4] ^ q[1])}; // Shift and apply XOR to produce next state\n        end\n    end\n\nendmodule\n", "result": "failed: 3852 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;  // Perform addition.\n            1: out = a - b;  // Perform subtraction.\n        endcase\n\n        // Correct zero detection by comparing out to zero\n        result_is_zero = (out == 8'b0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case (x)\n            4'b0101, 4'b0111, 4'b1000, 4'b1001, 4'b1010, 4'b1100, 4'b1101:\n                f = 1;\n            4'b0001, 4'b0110:\n                f = 0;\n            default:\n                f = 0;  // Default case: we set f to 0 based on the specified K-map\n        endcase\n    end\nendmodule\n", "result": "failed: 33 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'd0;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'd1;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'd2;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'd3;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'd4;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'd5;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'd6;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'd7;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'd8;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'd9;\n\t\t\t\tvalid = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'd0;\n\t\t\t\tvalid = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    assign out[7] = in[0]; // MSB of output gets LSB of input\n    assign out[6] = in[1];\n    assign out[5] = in[2];\n    assign out[4] = in[3];\n    assign out[3] = in[4];\n    assign out[2] = in[5];\n    assign out[1] = in[6];\n    assign out[0] = in[7]; // LSB of output gets MSB of input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n    // Check the conditions derived from the Karnaugh map\n    // ab = a & b, cd = c & d, \\overline{a}c\\overline{d} = ~a & c & ~d\n    out = (a & b) | (~a & c & ~b) | (c & d);\nend\n\nendmodule\n", "result": "failed: 37 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (shift_ena) begin\n\t\t\t// Shift operation: Shift right and load 'data' into MSB\n\t\t\tq <= {data, q[3:1]};\n\t\tend\n\t\telse if (count_ena) begin\n\t\t\t// Decrement operation\n\t\t\tq <= q - 1;\n\t\tend\n\t\t// No action needed if both are 0 or both are 1 (undefined behavior when both are 1)\n\tend\n\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n\tassign out = in; // directly connecting input to output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n\t// Internal counter to keep track of the cycles\n\treg [2:0] count;\n\t\n\t// Always block triggered on the positive edge of the clock\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcount <= 0;        // Reset the counter\n\t\t\tshift_ena <= 1;    // Enable shift register\n\t\tend\n\t\telse if (count < 4) begin\n\t\t\tcount <= count + 1;  // Increment the counter\n\t\t\tif (count == 3)      // After 4 clock cycles\n\t\t\t\tshift_ena <= 0;  // Disable shift register\n\t\tend\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            // Synchronous reset to 0\n            q <= 4'b0000;\n        end else begin\n            // Counting logic\n            q <= q + 1;\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n\t// Using continuous assignment\n\tassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n\t// Using a procedural if statement\n\talways @(*) begin\n\t\tif (sel_b1 && sel_b2)\n\t\t\tout_always = b;\n\t\telse\n\t\t\tout_always = a;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    assign out = (~a & b) | (a & c) | (b & c);\nendmodule\n", "result": "failed: 72 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n// States encoding\ntypedef enum logic [1:0] {\n\tA = 2'b00,\n\tB = 2'b01,\n\tC = 2'b10,\n\tD = 2'b11\n} state_t;\n\n// State registers\nstate_t current_state, next_state;\n\n// Always block for state transition logic (next_state logic)\nalways @(*) begin\n\tcase (current_state)\n\t\tA: begin\n\t\t\tif (r[1] == 1)\n\t\t\t\tnext_state = B;\n\t\t\telse if (r[1] == 0 && r[2] == 1)\n\t\t\t\tnext_state = C;\n\t\t\telse if (r[1] == 0 && r[2] == 0 && r[3] == 1)\n\t\t\t\tnext_state = D;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tB: begin\n\t\t\tif (r[1] == 1)\n\t\t\t\tnext_state = B;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tC: begin\n\t\t\tif (r[2] == 1)\n\t\t\t\tnext_state = C;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tD: begin\n\t\t\tif (r[3] == 1)\n\t\t\t\tnext_state = D;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tdefault: next_state = A;\n\tendcase\nend\n\n// Always block for state flip-flops (state update)\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn)\n\t\tcurrent_state <= A;\n\telse\n\t\tcurrent_state <= next_state;\nend\n\n// Always block for output logic (g signal assignments)\nalways @(*) begin\n\tcase (current_state)\n\t\tA: g = 3'b000;\n\t\tB: g = 3'b001;\n\t\tC: g = 3'b010;\n\t\tD: g = 3'b100;\n\t\tdefault: g = 3'b000;\n\tendcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;  // Reset the counter to 0 when reset is high\n    else if (q == 4'b1001)\n        q <= 4'b0000;  // Reset the counter to 0 when it reaches 9\n    else\n        q <= q + 4'b0001;  // Increment the counter\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // States enumeration\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE_1 = 2'b01,\n        BYTE_2 = 2'b10,\n        BYTE_3 = 2'b11\n    } state_t;\n\n    // State variables\n    state_t current_state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default output\n        done = 1'b0;\n        // Default next state\n        next_state = current_state;\n\n        case (current_state)\n            IDLE: begin\n                if (in[3]) begin\n                    next_state = BYTE_1;\n                end\n            end\n            BYTE_1: begin\n                next_state = BYTE_2;\n            end\n            BYTE_2: begin\n                next_state = BYTE_3;\n            end\n            BYTE_3: begin\n                done = 1'b1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    // Using a conditional operator to select the output based on sel\n    assign out = (sel == 0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n\tassign out_and = in[0] & in[1] & in[2] & in[3];\n\tassign out_or = in[0] | in[1] | in[2] | in[3];\n\tassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n\t// Define the states\n\treg [2:0] state;\n\treg [2:0] next_state;\n\n\t// Synchronous reset and state transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= 3'b000;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Combinational logic to determine the next state\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t3'b000: next_state = (x ? 3'b001 : 3'b000);\n\t\t\t3'b001: next_state = (x ? 3'b100 : 3'b001);\n\t\t\t3'b010: next_state = (x ? 3'b001 : 3'b010);\n\t\t\t3'b011: next_state = (x ? 3'b010 : 3'b001);\n\t\t\t3'b100: next_state = (x ? 3'b100 : 3'b011);\n\t\t\tdefault: next_state = 3'b000; // Default case to handle unspecified states\n\t\tendcase\n\tend\n\n\t// Combinational logic to determine the output z\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t3'b011, 3'b100: z = 1'b1;\n\t\t\tdefault: z = 1'b0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n\t// Define states as local parameters\n\tlocalparam A = 3'b000, B = 3'b001, C1 = 3'b010, C2 = 3'b011, C3 = 3'b100, D = 3'b101, E1 = 3'b110, E2 = 3'b111, F = 3'b001;\n\n\treg [2:0] state, next_state;\n\n\t// State transition logic (combinational)\n\talways @(*) begin\n\t\tcase(state)\n\t\t\tA: next_state = resetn ? B : A;\n\t\t\tB: next_state = C1;\n\t\t\tC1: next_state = x ? C2 : C1;\n\t\t\tC2: next_state = x ? C2 : C3;\n\t\t\tC3: next_state = x ? D : C1;\n\t\t\tD: next_state = E1;\n\t\t\tE1: next_state = (y || !resetn) ? E2 : F;\n\t\t\tE2: next_state = (y || !resetn) ? D : F;\n\t\t\tF: next_state = resetn ? F : A;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// State flip-flops (sequential)\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Output logic (combinational)\n\talways @(*) begin\n\t\t// Default outputs\n\t\tf = 0;\n\t\tg = 0;\n\n\t\tcase(state)\n\t\t\tB: f = 1;\n\t\t\tD, E1, E2: g = 1;\n\t\t\tdefault: ; // other states already default to f = 0 and g = 0\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b00110100;  // Reset to 0x34\n\t\tend else begin\n\t\t\tq <= d;  // Normal operation\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n\n    // Compute the even parity bit as XOR of all 8 bits\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    \n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00; // A: next_state is B if in=1, else A\n            2'b01: next_state = in ? 2'b01 : 2'b10; // B: next_state is B if in=1, else C\n            2'b10: next_state = in ? 2'b11 : 2'b00; // C: next_state is D if in=1, else A\n            2'b11: next_state = in ? 2'b01 : 2'b10; // D: next_state is B if in=1, else C\n            default: next_state = 2'b00; // Default to state A\n        endcase\n    end\n    \n    assign out = (state == 2'b11) ? 1 : 0; // Output is 1 if in state D, else 0\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    assign z = (!x && !y) || (x && y);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// State encoding\n\tparameter A = 3'b000;\n\tparameter B = 3'b001;\n\tparameter C = 3'b010;\n\tparameter D = 3'b011;\n\tparameter E = 3'b100;\n\tparameter F = 3'b101;\n\n\treg [2:0] current_state, next_state;\n\n\t// State transition logic (Combinational logic)\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: next_state = w ? B : A;\n\t\t\tB: next_state = w ? C : D;\n\t\t\tC: next_state = w ? E : D;\n\t\t\tD: next_state = w ? F : A;\n\t\t\tE: next_state = w ? E : D;\n\t\t\tF: next_state = w ? C : D;\n\t\t\tdefault: next_state = A; // Safety\n\t\tendcase\n\tend\n\n\t// State flip-flops (Sequential logic)\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A; // Synchronous reset\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tE, F: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) begin\n\t\t\t// Synchronous Reset: Set flip-flops to 0 when resetn is low\n\t\t\tq <= 16'b0;\n\t\tend\n\t\telse begin\n\t\t\t// Update lower byte if byteena[0] is asserted\n\t\t\tif (byteena[0]) \n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\t// Update upper byte if byteena[1] is asserted\n\t\t\tif (byteena[1]) \n\t\t\t\tq[15:8] <= d[15:8];\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n\treg [7:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\t// Compare previous state with current state for positive edge detection\n\t\tpedge <= (~prev_in & in);\n\t\t// Update prev_in to be current state\n\t\tprev_in <= in;\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n    always @(posedge clock) begin\n        p <= a;\n    end\n\n    always @(negedge clock) begin\n        q <= p;\n    end\nendmodule\n", "result": "failed: 138 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\t// Load the initial state from the input data\n\t\tq <= data;\n\tend else begin\n\t\t// Compute the next state according to Rule 90\n\t\treg [511:0] next_q;\n\t\tinteger i;\n\n\t\t// Update each cell in q\n\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\tif (i == 0) begin\n\t\t\t\t// Special case for the first cell\n\t\t\t\tnext_q[i] = q[1] ^ 0; // q[-1] is 0\n\t\t\tend else if (i == 511) begin\n\t\t\t\t// Special case for the last cell\n\t\t\t\tnext_q[i] = q[510] ^ 0; // q[512] is 0\n\t\t\tend else begin\n\t\t\t\t// Regular case for all other cells\n\t\t\t\tnext_q[i] = q[i-1] ^ q[i+1];\n\t\t\tend\n\t\tend\n\t\t\n\t\t// Update q with the new state\n\t\tq <= next_q;\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n    // Compare the two 2-bit inputs\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    // Task 1: Compute out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin: both_logic\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Task 2: Compute out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin: any_logic\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Task 3: Compute out_different\n    assign out_different[0] = in[0] ^ in[99]; // Wrap around case\n    generate\n        for (i = 1; i < 100; i = i + 1) begin: different_logic\n            assign out_different[i] = in[i] ^ in[i-1];\n        end\n    endgenerate\n    \nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n    always @(d or ena) begin\n        if (ena) begin\n            q = d;\n        end\n        // No else statement is needed because q should retain its value when ena is low.\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\n    // Calculate the starting position of the 4-bit segment\n    wire [9:0] start_bit;\n    assign start_bit = sel * 4; // Multiply sel by 4 to get the starting index\n\n    // Slice the 4-bit segment from the input\n    assign out = in[start_bit +: 4]; // Use the +: operator for bit slicing\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\n\talways_comb begin\n\t\tcase (sel)\n\t\t\t4'd0: out = a;\n\t\t\t4'd1: out = b;\n\t\t\t4'd2: out = c;\n\t\t\t4'd3: out = d;\n\t\t\t4'd4: out = e;\n\t\t\t4'd5: out = f;\n\t\t\t4'd6: out = g;\n\t\t\t4'd7: out = h;\n\t\t\t4'd8: out = i;\n\t\t\tdefault: out = 16'b1111_1111_1111_1111; // For sel = 9 to 15\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n\t// Bitwise-OR of a and b\n\tassign out_or_bitwise = a | b;\n\n\t// Logical-OR of a and b\n\tassign out_or_logical = |a | |b;\n\n\t// Inverse of a and b\n\tassign out_not = { ~b, ~a };\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: next_state = (in == 1'b0) ? 4'b0001 : 4'b0010; // A\n\t\t\t4'b0010: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // B\n\t\t\t4'b0100: next_state = (in == 1'b0) ? 4'b0001 : 4'b1000; // C\n\t\t\t4'b1000: next_state = (in == 1'b0) ? 4'b0100 : 4'b0010; // D\n\t\t\tdefault: next_state = 4'b0001;                           // default to A for safety\n\t\tendcase\n\tend\n\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0; // output for state D, otherwise 0\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tmin = a; // Start by assuming 'a' is minimum\n\t\t\n\t\tif (b < min) \n\t\t\tmin = b; // If b is smaller, update min\n\t\t\n\t\tif (c < min)\n\t\t\tmin = c; // If c is smaller, update min\n\t\t\n\t\tif (d < min)\n\t\t\tmin = d; // If d is smaller, update min\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n    assign out_and = a & b;      // AND gate\n    assign out_or = a | b;       // OR gate\n    assign out_xor = a ^ b;      // XOR gate\n    assign out_nand = ~(a & b);  // NAND gate\n    assign out_nor = ~(a | b);   // NOR gate\n    assign out_xnor = ~(a ^ b);  // XNOR gate\n    assign out_anotb = a & ~b;   // AND-NOT (a and not b)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\nassign out = (~c & ~d) | (c & ~b) | (c & b);\n\nendmodule\n", "result": "failed: 89 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n\t// State definitions\n\ttypedef enum reg [1:0] {\n\t\tSTATE_A = 2'b00,\n\t\tSTATE_B = 2'b01\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\treg [1:0] w_count;\n\treg [1:0] cycle_count;\n\n\t// Synchronous reset and state transition\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= STATE_A;\n\t\t\tw_count <= 0;\n\t\t\tcycle_count <= 0;\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tSTATE_A: begin\n\t\t\t\tif (s == 1) begin\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\t\t\tz = 0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STATE_A;\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTATE_B: begin\n\t\t\t\tif (cycle_count == 3) begin\n\t\t\t\t\tif (w_count == 2) begin\n\t\t\t\t\t\tz = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tz = 0;\n\t\t\t\t\tend\n\t\t\t\t\t// Reset counters for next 3 cycles\n\t\t\t\t\tw_count = 0;\n\t\t\t\t\tcycle_count = 0;\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Counter logic\n\talways @(posedge clk) begin\n\t\tif (current_state == STATE_B) begin\n\t\t\tcycle_count <= cycle_count + 1;\n\t\t\tif (w == 1) begin\n\t\t\t\tw_count <= w_count + 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 362 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Replicate the sign bit 24 times, then concatenate with the original 8-bit input\n    assign out = {{24{in[7]}}, in};\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\treg [3:0] shift_reg; // 4 bit shift register to hold the states of the four D flip-flops\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\t// If resetn is low, reset the shift register\n\t\t\tshift_reg <= 4'b0000;\n\t\tend\n\t\telse begin\n\t\t\t// On clock edge and when resetn is high, perform shifting\n\t\t\tshift_reg[3:0] <= {shift_reg[2:0], in}; // Shifting and loading the serial input\n\t\tend\n\tend\n\t\n\tassign out = shift_reg[3]; // Output from the last flip-flop\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tif (in[3])\n\t\t\tpos = 2'b11;\n\t\telse if (in[2])\n\t\t\tpos = 2'b10;\n\t\telse if (in[1])\n\t\t\tpos = 2'b01;\n\t\telse if (in[0])\n\t\t\tpos = 2'b00;\n\t\telse\n\t\t\tpos = 2'b00;\n\tend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // Define state values\n    reg state, next_state;\n    parameter OFF = 0, ON = 1;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j == 1)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k == 1)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n        endcase\n    end\n\n    // State register and asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on current state\n    always @(state) begin\n        case (state)\n            OFF: out = 0;\n            ON:  out = 1;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n    // Assign a constant logic low value to the output.\n    assign out = 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n\tassign one = 1'b1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\n    always @(*) begin\n        // Loop to reverse bit positions\n        integer i;\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n\n\t// XOR gate to produce the input for the D flip-flop\n\tlogic xor_out;\n\n\tassign xor_out = in ^ out;  // XOR operation\n\n\t// Positive edge triggered D flip-flop\n\talways_ff @(posedge clk) begin\n\t\tout <= xor_out;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\t// Asynchronous reset to initialize the shift register to zero\n\t\t\tq <= 4'b0000;\n\t\tend else begin\n\t\t\tif (load) begin\n\t\t\t\t// Load the data into the shift register\n\t\t\t\tq <= data;\n\t\t\tend else if (ena) begin\n\t\t\t\t// Shift right (with q[3] becoming zero)\n\t\t\t\tq <= {1'b0, q[3:1]};\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\n\tassign f = (~x3 & x2) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0;  // Asynchronously reset all outputs to 0\n        end else begin\n            q <= d;  // On positive edge of clk, update q with d\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    assign out_and = &in;    // Bitwise reduction AND operation\n    assign out_or = |in;     // Bitwise reduction OR operation\n    assign out_xor = ^in;    // Bitwise reduction XOR operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\nassign sum = a ^ b;\nassign cout = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        // Default value assignment to avoid latches\n        shut_off_computer = 0;\n        \n        if (cpu_overheated) begin\n            shut_off_computer = 1; // Shut off computer if CPU is overheated\n        end\n    end\n\n    always @(*) begin\n        // Default value assignment to avoid latches\n        keep_driving = 0;\n        \n        if (~arrived) begin\n            keep_driving = ~gas_tank_empty; // Keep driving if not arrived and tank is not empty\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic { OFF = 1'b0, ON = 1'b1 } state_t;\n\tstate_t state, next_state;\n\n\t// State transition logic\n\talways_comb begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j == 1'b1)\n\t\t\t\t\tnext_state = ON;\n\t\t\t\telse\n\t\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k == 1'b1)\n\t\t\t\t\tnext_state = OFF;\n\t\t\t\telse\n\t\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// State and output update\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= OFF;\n\t\t\tout <= 1'b0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tout <= (next_state == ON) ? 1'b1 : 1'b0;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    // Step 1: Concatenate all input vectors (a to f) to create a 30-bit vector\n    wire [29:0] concatenated_input = {a, b, c, d, e, f};\n    \n    // Step 2: Create a 32-bit vector by adding two 1-bits at the LSB\n    wire [31:0] full_vector = {concatenated_input, 2'b11};\n    \n    // Step 3: Split the 32-bit vector into four 8-bit output vectors\n    assign w = full_vector[31:24];\n    assign x = full_vector[23:16];\n    assign y = full_vector[15:8];\n    assign z = full_vector[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\nassign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & c & ~d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d);\n\nendmodule\n", "result": "failed: 18 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n    // AND gate logic\n    assign out = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    localparam A = 0, B = 1;\n\n    // State register\n    reg current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= B; // Reset to state B\n        end else begin\n            current_state <= next_state; // Transition to the next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            B: next_state = (in == 0) ? A : B; // Transition from B\n            A: next_state = (in == 0) ? B : A; // Transition from A\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            B: out = 1; // Output for state B\n            A: out = 0; // Output for state A\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    \n    // Intermediate signals\n    wire sum1;\n    wire carry1;\n    \n    // Calculate sum1 and carry1\n    assign sum1 = a ^ b;\n    assign carry1 = a & b;\n    \n    // Calculate the final sum\n    assign sum = sum1 ^ cin;\n    \n    // Calculate the final carry-out\n    assign cout = carry1 | (sum1 & cin);\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n\t// Step 1: Perform XNOR operation on in1 and in2\n    logic xnor1;\n\tassign xnor1 = in1 ~^ in2;\n\n\t// Step 2: Perform XOR operation with the result from XNOR and in3\n\tassign out = xnor1 ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    assign mux_in[0] = d | ~c;\n    assign mux_in[1] = 0;\n    assign mux_in[2] = c & d;\n    assign mux_in[3] = ~c | d;\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// State encoding: One-hot encoding\n\treg state_A, state_B;\n\treg z;\n\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\t// Reset state into state A\n\t\t\tstate_A <= 1'b1;\n\t\t\tstate_B <= 1'b0;\n\t\tend else begin\n\t\t\t// Transition based on current state and input x\n\t\t\tif (state_A) begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tstate_A <= 1'b0;\n\t\t\t\t\tstate_B <= 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_A <= 1'b1;\n\t\t\t\t\tstate_B <= 1'b0;\n\t\t\t\tend\n\t\t\tend else if (state_B) begin\n\t\t\t\tstate_A <= 1'b0;\n\t\t\t\tstate_B <= 1'b1; // State B loops back to itself regardless of x\n\t\t\tend\n\t\tend\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tif (state_A) begin\n\t\t\tz = x ? 1 : 0;\n\t\tend else if (state_B) begin\n\t\t\tz = x ? 0 : 1;\n\t\tend else begin\n\t\t\tz = 0; // Default case (should never happen)\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\t// Determine state behavior\n\tif (a == 1 && b == 1) begin\n\t\tstate <= 0;\n\tend else if (a == 1 && b == 0) begin\n\t\tstate <= ~state;\n\tend\n\n\t// Determine q behavior\n\tif (b == 1) begin\n\t\tq <= 1;\n\tend else begin\n\t\tq <= state;\n\tend\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always @(*)\n        f = (~x[1] & ~x[4]) | (x[3] & ~x[1]) | (x[2] & x[3]);\nendmodule\n", "result": "failed: 27 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n\treg [2:0] state, next_state;\n\t\n\t// State encoding\n\tlocalparam S0 = 3'd0,  // Initial state (as if previous input was 0)\n\t           S1 = 3'd1,\n\t           S2 = 3'd2,\n\t           S3 = 3'd3,\n\t           S4 = 3'd4,\n\t           S5 = 3'd5,\n\t           S6 = 3'd6,\n\t           SF = 3'd7,  // Flag state\n\t           S7 = 3'd8;  // Error state\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = in ? S1 : S0;\n\t\t\tS1: next_state = in ? S2 : S0;\n\t\t\tS2: next_state = in ? S3 : S0;\n\t\t\tS3: next_state = in ? S4 : S0;\n\t\t\tS4: next_state = in ? S5 : S0;\n\t\t\tS5: next_state = in ? S6 : S0;\n\t\t\tS6: begin\n\t\t\t\tif (in) \n\t\t\t\t\tnext_state = S7; // Error if 7th '1' is encountered\n\t\t\t\telse \n\t\t\t\t\tnext_state = SF; // If '0', it's a disc\n\t\t\tend\n\t\t\tSF: next_state = in ? S1 : S0;\n\t\t\tS7: next_state = in ? S7 : S0; // Remain in error state if continuous '1's, reset on '0'\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\t\n\t// Output logic (Moore machine outputs depend only on the state)\n\talways @(*) begin\n\t\tdisc = 1'b0;\n\t\tflag = 1'b0;\n\t\terr = 1'b0;\n\t\t\n\t\tcase (state)\n\t\t\tS6: disc = ~in;   // Output disc if the next input is '0' after S6\n\t\t\tSF: flag = 1'b1;  // Output flag in the flag state\n\t\t\tS7: err = 1'b1;   // Error state for 7+ '1's\n\t\tendcase\n\tend\n\n\t// State register\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= S0;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tIDLE = 3'b000,\n\t\tREAD_DELAY = 3'b001,\n\t\tCOUNT = 3'b010,\n\t\tNOTIFY = 3'b011\n\t} state_t;\n\n\t// Internal signals and registers\n\tstate_t current_state, next_state;\n\treg [3:0] delay;\n\treg [11:0] timer;\n\treg [3:0] bit_counter;\n\t\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\t\tdelay <= 4'b0000;\n\t\t\ttimer <= 12'b000000000000;\n\t\t\tcount <= 4'b0000;\n\t\t\tcounting <= 0;\n\t\t\tdone <= 0;\n\t\t\tbit_counter <= 4'b0000;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\t\n\t// State Machine\n\talways @(*) begin\n\t\t// Default values\n\t\tnext_state = current_state;\n\t\t\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\t\t\n\t\t\t\t// Detect input pattern 1101\n\t\t\t\tif (data == 1) bit_counter = bit_counter + 1;\n\t\t\t\telse bit_counter = 0;\n\t\t\t\t\n\t\t\t\tif (bit_counter == 4 && data == 1) begin\n\t\t\t\t\tbit_counter = 0;\n\t\t\t\t\tnext_state = READ_DELAY;\n\t\t\t\tend\n\t\t\tend\n\t\t\tREAD_DELAY: begin\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\t\t\n\t\t\t\t// Shift in the delay bits\n\t\t\t\tbit_counter = bit_counter + 1;\n\t\t\t\tdelay = {delay[2:0], data};\n\t\t\t\t\n\t\t\t\tif (bit_counter == 4) begin\n\t\t\t\t\tnext_state = COUNT;\n\t\t\t\t\ttimer = (delay + 1) * 1000;\n\t\t\t\t\tbit_counter = 0;\n\t\t\t\t\tcount = delay;\n\t\t\t\tend\n\t\t\tend\n\t\t\tCOUNT: begin\n\t\t\t\tcounting = 1;\n\t\t\t\tdone = 0;\n\t\t\t\t\n\t\t\t\t// Count down the timer\n\t\t\t\tif (timer > 0) begin\n\t\t\t\t\tif (timer % 1000 == 0) count = count - 1;\n\t\t\t\t\ttimer = timer - 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = NOTIFY;\n\t\t\t\tend\n\t\t\tend\n\t\t\tNOTIFY: begin\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 1;\n\t\t\t\t\n\t\t\t\t// Wait for acknowledgment\n\t\t\t\tif (ack == 1) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        STATE_ABOVE_S3     = 2'b00,\n        STATE_BETWEEN_S3_S2 = 2'b01,\n        STATE_BETWEEN_S2_S1 = 2'b10,\n        STATE_BELOW_S1 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg was_lower_level;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_ABOVE_S3: begin\n                if (s[3] == 0) begin\n                    if (s[2] == 0)\n                        next_state = STATE_BELOW_S1;\n                    else\n                        next_state = STATE_BETWEEN_S3_S2;\n                end else begin\n                    next_state = STATE_ABOVE_S3;\n                end\n                was_lower_level = 1'b0;\n            end\n            STATE_BETWEEN_S3_S2: begin\n                if (s[2] == 0) begin\n                    if (s[1] == 0)\n                        next_state = STATE_BELOW_S1;\n                    else\n                        next_state = STATE_BETWEEN_S2_S1;\n                end else begin\n                    next_state = STATE_BETWEEN_S3_S2;\n                end\n                was_lower_level = (state < next_state);\n            end\n            STATE_BETWEEN_S2_S1: begin\n                if (s[1] == 0) begin \n                    next_state = STATE_BELOW_S1;\n                end else begin\n                    next_state = STATE_BETWEEN_S2_S1;\n                end\n                was_lower_level = (state < next_state);\n            end\n            STATE_BELOW_S1: begin\n                if (s[1] == 1) begin\n                    next_state = STATE_BETWEEN_S2_S1;\n                end else begin\n                    next_state = STATE_BELOW_S1;\n                end\n                was_lower_level = 1'b1;\n            end\n            default: begin\n                next_state = STATE_BELOW_S1;\n                was_lower_level = 1'b1;\n            end\n        endcase\n    end\n\n    // State update and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= STATE_BELOW_S1;\n            fr1 <= 1'b1;\n            fr2 <= 1'b1;\n            fr3 <= 1'b1;\n            dfr <= 1'b1;\n        end else begin\n            state <= next_state;\n            \n            case (state)\n                STATE_ABOVE_S3: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n                STATE_BETWEEN_S3_S2: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b1;\n                    dfr <= was_lower_level;\n                end\n                STATE_BETWEEN_S2_S1: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= was_lower_level;\n                end\n                STATE_BELOW_S1: begin\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: 1428 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n    \n    state_t state, next_state;\n    reg [2:0] bit_counter; // Counter for counting the 8 bits of data\n\n    // State Register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        done = 0; // Default done signal to 0\n        next_state = state; // Default next state to current state\n        case (state)\n            IDLE: begin\n                if (in == 0) // detecting start bit\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA; // Move to data state immediately after confirming start bit\n            end\n            DATA: begin\n                if (bit_counter == 7)\n                    next_state = STOP; // Received 8 data bits, move to stop bit state\n            end\n            STOP: begin\n                if (in == 1) begin // Correct stop bit\n                    done = 1;\n                    next_state = IDLE;\n                end\n                else\n                    next_state = ERROR; // Incorrect stop bit\n            end\n            ERROR: begin\n                if (in == 1)\n                    next_state = IDLE; // Wait until we see a stop bit\n            end\n        endcase\n    end\n\n    // Bit counter logic for DATA state\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            bit_counter <= 0;\n        else if (state == DATA) begin\n            if (bit_counter == 7)\n                bit_counter <= 0; // Reset counter after 8 bits\n            else\n                bit_counter <= bit_counter + 1;\n        end\n        else\n            bit_counter <= 0; // Reset counter in other states\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    // State enumeration\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        DATA,\n        STOP\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] bit_count; // 4-bit counter to count the number of data bits\n\n    // State transition logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            out_byte <= 8'b0;\n            done <= 1'b0;\n            bit_count <= 4'b0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic and data processing\n    always_comb begin\n        // Default assignments\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            IDLE: begin\n                // Wait for start bit (0)\n                if (in == 1'b0) begin\n                    next_state = START;\n                end\n            end\n\n            START: begin\n                // Transition directly to DATA state\n                next_state = DATA;\n                bit_count = 4'b0;\n            end\n\n            DATA: begin\n                // Collect 8 data bits\n                if (bit_count < 8) begin\n                    out_byte[bit_count] = in;\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = STOP;\n                end\n            end\n\n            STOP: begin\n                // Verify stop bit (1)\n                if (in == 1'b1) begin\n                    done = 1'b1;\n                    next_state = IDLE; // Byte successfully received\n                end else begin\n                    next_state = IDLE; // Incorrect stop bit sends FSM back to IDLE\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    // 2-bit saturating counter PHT with 128 entries\n    reg [1:0] PHT [0:127];\n\n    // 7-bit Global History Register\n    reg [6:0] GHR;\n\n    // Combinational logic for prediction\n    wire [6:0] predict_index;\n    assign predict_index = predict_pc ^ GHR;\n\n    // PHT entry before training\n    wire [1:0] current_PHT_entry;\n    assign current_PHT_entry = PHT[predict_index];\n\n    // Predict taken decision\n    assign predict_taken = (current_PHT_entry >= 2); // taken if counter is 2 or 3\n\n    // Predict history output\n    assign predict_history = GHR;\n\n    // Update logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            GHR <= 7'b0;\n            // Reset all PHT entries to weakly not taken, which is \"01\" (1)\n            integer i;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b01;\n            end\n        end else begin\n            if (train_valid) begin\n                // Calculate training index\n                wire [6:0] train_index;\n                train_index = train_pc ^ train_history;\n\n                // Update PHT\n                if (train_taken) begin\n                    if (PHT[train_index] < 3) begin\n                        PHT[train_index] <= PHT[train_index] + 1;\n                    end\n                end else begin\n                    if (PHT[train_index] > 0) begin\n                        PHT[train_index] <= PHT[train_index] - 1;\n                    end\n                end\n                \n                // Update or rollback GHR based on misprediction\n                if (train_mispredicted) begin\n                    GHR <= {train_history[6:1], train_taken}; // Recover history on misprediction\n                end else if (predict_valid) begin\n                    GHR <= {GHR[6:1], predict_taken}; // Update GHR with prediction result if no misprediction\n                end\n            end else if (predict_valid) begin\n                GHR <= {GHR[6:1], predict_taken}; // Update GHR for predictions\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    typedef enum reg [2:0] {\n        WL = 3'd0,\n        WR = 3'd1,\n        FL = 3'd2,\n        FR = 3'd3,\n        DL = 3'd4,\n        DR = 3'd5,\n        SPLAT = 3'd6\n    } state_t;\n\n    state_t state, next_state;\n    reg [4:0] fall_count;  // Count falling cycles\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL;   // Reset to walking left\n            fall_count <= 0;\n        end else begin\n            if (state == FL || state == FR)\n                fall_count <= fall_count + 1;  // Increment fall counter if falling\n            else\n                fall_count <= 0;\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;  // Default to current state\n        case (state)\n            WL: begin\n                if (~ground) next_state = FL;\n                else if (dig) next_state = DL;\n                else if (bump_left) next_state = WR;\n            end\n            WR: begin\n                if (~ground) next_state = FR;\n                else if (dig) next_state = DR;\n                else if (bump_right) next_state = WL;\n            end\n            FL: begin\n                if (ground) begin\n                    next_state = (fall_count > 20) ? SPLAT : WL;\n                end\n            end\n            FR: begin\n                if (ground) begin\n                    next_state = (fall_count > 20) ? SPLAT : WR;\n                end\n            end\n            DL: begin\n                if (~ground) next_state = FL;\n            end\n            DR: begin\n                if (~ground) next_state = FR;\n            end\n        endcase\n\n        if (state == SPLAT) next_state = SPLAT;  // SPLAT state is terminal\n    end\n\n    always @(*) begin\n        walk_left = (state == WL);\n        walk_right = (state == WR);\n        aaah = (state == FL || state == FR);\n        digging = (state == DL || state == DR);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        SHIFT = 3'b001,\n        COUNT = 3'b010,\n        DONE = 3'b011\n    } state_type;\n\n    state_type state, next_state;\n    reg [3:0] shift_reg;\n    reg [2:0] shift_counter;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'b0000;\n            shift_counter <= 3'b000;\n            shift_ena <= 1'b0;\n            counting <= 1'b0;\n            done <= 1'b0;\n        end\n        else begin\n            state <= next_state;\n            if (state == IDLE) begin\n                shift_reg <= {shift_reg[2:0], data}; // shift in the new bit\n            end\n            if (state == SHIFT) begin\n                shift_counter <= shift_counter + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        // Default output values\n        next_state = state;\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT;\n                    shift_ena = 1'b1;\n                    shift_counter = 3'b000;\n                end\n            end\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_counter == 3'b011) // shift counter has reached 3 (4 shifts)\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n            end\n            DONE: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 902 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\ninteger i, j;\nreg [3:0] neighbors;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbors = 0;\n                \n                // Count neighbors wrapping around edges\n                neighbors = q[((i+15)%16)*16 + ((j+15)%16)] + q[((i+15)%16)*16 + j] + q[((i+15)%16)*16 + ((j+1)%16)] +\n                            q[i*16 + ((j+15)%16)] + q[i*16 + ((j+1)%16)] +\n                            q[((i+1)%16)*16 + ((j+15)%16)] + q[((i+1)%16)*16 + j] + q[((i+1)%16)*16 + ((j+1)%16)];\n\n                // Apply game rules\n                if (neighbors < 2 || neighbors > 3)\n                    q[i*16 + j] <= 1'b0; // 0-1 or 4+ neighbors case: cell becomes dead\n                else if (neighbors == 3)\n                    q[i*16 + j] <= 1'b1; // 3 neighbors case: cell becomes alive\n                // else if neighbors == 2, q[i*16 + j] remains the same\n            end\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define state encoding\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL_LEFT,\n        FALL_RIGHT,\n        DIG_LEFT,\n        DIG_RIGHT\n    } state_t;\n\n    state_t state, next_state;\n\n    // Combinational logic: next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else if (dig) next_state = DIG_LEFT;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else if (dig) next_state = DIG_RIGHT;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL_LEFT: begin\n                if (ground) next_state = WALK_LEFT;\n                else next_state = FALL_LEFT;\n            end\n            FALL_RIGHT: begin\n                if (ground) next_state = WALK_RIGHT;\n                else next_state = FALL_RIGHT;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL_LEFT;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL_RIGHT;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // default case for state\n        endcase\n    end\n\n    // Sequential logic: state update\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Reset to initial state on asynchronous reset\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL_LEFT) || (state == FALL_RIGHT);\n    assign digging = (state == DIG_LEFT) || (state == DIG_RIGHT);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// Reset to 12:00:00 AM\n\t\t\thh <= 8'b0001_0010; // 12 in BCD\n\t\t\tmm <= 8'b0000_0000; // 00 in BCD\n\t\t\tss <= 8'b0000_0000; // 00 in BCD\n\t\t\tpm <= 1'b0; // AM\n\t\tend\n\t\telse if (ena) begin\n\t\t\t// Handle seconds\n\t\t\tif (ss[3:0] == 4'd9) begin\n\t\t\t\tss[3:0] <= 4'd0;\n\t\t\t\tif (ss[7:4] == 4'd5) begin\n\t\t\t\t\tss[7:4] <= 4'd0;\n\t\t\t\t\t// Handle minutes\n\t\t\t\t\tif (mm[3:0] == 4'd9) begin\n\t\t\t\t\t\tmm[3:0] <= 4'd0;\n\t\t\t\t\t\tif (mm[7:4] == 4'd5) begin\n\t\t\t\t\t\t\tmm[7:4] <= 4'd0;\n\t\t\t\t\t\t\t// Handle hours\n\t\t\t\t\t\t\tif (hh == 8'b0001_0010) begin // If 12\n\t\t\t\t\t\t\t\thh <= 8'b0000_0001; // Set to 01\n\t\t\t\t\t\t\t\tpm <= ~pm; // Toggle AM/PM\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse if (hh[3:0] == 4'd9) begin\n\t\t\t\t\t\t\t\thh[3:0] <= 4'd0;\n\t\t\t\t\t\t\t\thh[7:4] <= hh[7:4] + 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\thh[3:0] <= hh[3:0] + 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\tmm[7:4] <= mm[7:4] + 1'b1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\tmm[3:0] <= mm[3:0] + 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tss[7:4] <= ss[7:4] + 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tss[3:0] <= ss[3:0] + 1'b1;\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "failed: 316800 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tSTATE_WALK_LEFT = 2'b00,\n\t\tSTATE_WALK_RIGHT = 2'b01,\n\t\tSTATE_FALL_LEFT = 2'b10,\n\t\tSTATE_FALL_RIGHT = 2'b11\n\t} state_t;\n\n\tstate_t state, next_state;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tSTATE_WALK_LEFT: begin\n\t\t\t\tif (!ground) \n\t\t\t\t\tnext_state = STATE_FALL_LEFT;\n\t\t\t\telse if (bump_left || bump_right)\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\tend\n\t\t\tSTATE_WALK_RIGHT: begin\n\t\t\t\tif (!ground) \n\t\t\t\t\tnext_state = STATE_FALL_RIGHT;\n\t\t\t\telse if (bump_left || bump_right)\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\tend\n\t\t\tSTATE_FALL_LEFT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_FALL_LEFT;\n\t\t\tend\n\t\t\tSTATE_FALL_RIGHT: begin\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_FALL_RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = STATE_WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// State flip-flops\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= STATE_WALK_LEFT;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\twalk_left = (state == STATE_WALK_LEFT);\n\t\twalk_right = (state == STATE_WALK_RIGHT);\n\t\taaah = (state == STATE_FALL_LEFT) || (state == STATE_FALL_RIGHT);\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    reg [3:0] dig0, dig1, dig2, dig3; // 4-bit registers for each digit\n\n    always @(posedge clk) begin\n        if (reset) begin\n            dig0 <= 4'b0000;\n            dig1 <= 4'b0000;\n            dig2 <= 4'b0000;\n            dig3 <= 4'b0000;\n        end else begin\n            // Increment logic\n            if (dig0 == 4'b1001) begin\n                dig0 <= 4'b0000;\n                if (dig1 == 4'b1001) begin\n                    dig1 <= 4'b0000;\n                    if (dig2 == 4'b1001) begin\n                        dig2 <= 4'b0000;\n                        if (dig3 == 4'b1001) begin\n                            dig3 <= 4'b0000;\n                        end else begin\n                            dig3 <= dig3 + 4'b0001;\n                        end\n                    end else begin\n                        dig2 <= dig2 + 4'b0001;\n                    end\n                end else begin\n                    dig1 <= dig1 + 4'b0001;\n                end\n            end else begin\n                dig0 <= dig0 + 4'b0001;\n            end\n        end\n        q <= {dig3, dig2, dig1, dig0}; // Concatenate digits into q\n    end\n\n    // Enable signals generation\n    assign ena[1] = (dig0 == 4'b1001);\n    assign ena[2] = (dig1 == 4'b1001) && (dig0 == 4'b1001);\n    assign ena[3] = (dig2 == 4'b1001) && (dig1 == 4'b1001) && (dig0 == 4'b1001);\n\nendmodule\n", "result": "failed: 39794 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n    assign out = sel ? b : a; // If sel is 1, choose b. Otherwise, choose a.\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n    \n    always @(*) begin\n        case (y)\n            3'b000: Y2 = w ? 0 : 0; // A -> A or B -> y2 remains 0\n            3'b001: Y2 = w ? 1 : 1; // B -> D or C -> y2 becomes 1\n            3'b010: Y2 = w ? 1 : 0; // C -> D or E -> y2 becomes 0\n            3'b011: Y2 = w ? 1 : 0; // D -> A or F -> y2 becomes 0\n            3'b100: Y2 = w ? 1 : 1; // E -> D or E -> y2 remains 1\n            3'b101: Y2 = w ? 1 : 1; // F -> D or C -> y2 remains 1\n            default: Y2 = 0; // Default case, should not occur\n        endcase\n    end\nendmodule\n", "result": "failed: 9 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\nassign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n       // Implementing AND gate using assign statement\n       assign out_assign = a & b;\n\n       // Implementing AND gate using combinational always block\n       always @(*) begin\n           out_alwaysblock = a & b;\n       end\n\n   endmodule\n   ", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n    assign zero = 1'b0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (a == 1) begin\n\t\t\tq <= 0;\n\t\tend else begin\n\t\t\tq <= 1;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// Define state encoding\n\tparameter IDLE = 1'b0, FOUND_ONE = 1'b1;\n\t\n\t// State register\n\treg state, next_state;\n\n\t// Next state logic (combinational)\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (x == 1'b1) begin\n\t\t\t\t\tnext_state = FOUND_ONE;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFOUND_ONE: begin\n\t\t\t\tnext_state = FOUND_ONE; // Stay in FOUND_ONE once entered\n\t\t\tend\n\t\t\tdefault: next_state = IDLE; // Default state to IDLE\n\t\tendcase\n\tend\n\n\t// State register logic (sequential)\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= IDLE;\n\t\t\tz <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Output logic (Moore machine, so only depend on the current state)\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tz <= 1'b0;\n\t\tend\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: z <= x; // Direct output of input\n\t\t\t\tFOUND_ONE: z <= ~x; // Output is the inverse of input\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    typedef enum reg [1:0] {STATE_A = 2'b00, STATE_B = 2'b01, STATE_C = 2'b10, STATE_D = 2'b11} state_t;\n    state_t current_state, next_state;\n    \n    // Asynchronous reset and current_state update\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= STATE_A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n    \n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = (in) ? STATE_B : STATE_A;\n                out = 0;\n            end\n            STATE_B: begin\n                next_state = (in) ? STATE_B : STATE_C;\n                out = 0;\n            end\n            STATE_C: begin\n                next_state = (in) ? STATE_D : STATE_A;\n                out = 0;\n            end\n            STATE_D: begin\n                next_state = (in) ? STATE_B : STATE_C;\n                out = 1;\n            end\n            default: begin\n                next_state = STATE_A;\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out[31:24] = in[7:0];   // Reversing the least significant byte to most significant\n    assign out[23:16] = in[15:8];  // Moving the second byte\n    assign out[15:8]  = in[23:16]; // Moving the third byte\n    assign out[7:0]   = in[31:24]; // Reversing the most significant byte to least significant\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n\talways_ff @(posedge clk) begin\n\t\tif (r) \n\t\t\tq <= 0;  // If reset is high, set q to 0\n\t\telse \n\t\t\tq <= d;  // If reset is low, set q to d\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = (x ^ y) & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= q << 1;\n\t\t\t\t2'b01: q <= q << 8;\n\t\t\t\t2'b10: q <= $signed(q) >>> 1;  // Arithmetic right shift by 1 bit\n\t\t\t\t2'b11: q <= $signed(q) >>> 8;  // Arithmetic right shift by 8 bits\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n\t// State Definitions\n\ttypedef enum logic [1:0] {STATE_A, STATE_B, STATE_C} state_t;\n\tstate_t state, next_state;\n\n\t// State Transition and Output Logic\n\talways_ff @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) begin\n\t\t\tstate <= STATE_A;\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tz <= (state == STATE_C) && (x == 1); // Output logic for Mealy FSM\n\t\tend\n\tend\n\t\n\t// Next State Logic\n\talways_comb begin\n\t\tcase (state)\n\t\t\tSTATE_A: begin\n\t\t\t\tnext_state = (x) ? STATE_B : STATE_A;\n\t\t\tend\n\t\t\t\n\t\t\tSTATE_B: begin\n\t\t\t\tnext_state = (x) ? STATE_B : STATE_C;\n\t\t\tend\n\t\t\t\n\t\t\tSTATE_C: begin\n\t\t\t\tnext_state = (x) ? STATE_B : STATE_A;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: next_state = STATE_A;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w ? A : B);\n            B: next_state = (w ? D : C);\n            C: next_state = (w ? D : E);\n            D: next_state = (w ? A : F);\n            E: next_state = (w ? D : E);\n            F: next_state = (w ? D : C);\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n// State Definitions\ntypedef enum logic [1:0] {\n\tWAIT = 2'b00,\n\tBYTE1 = 2'b01,\n\tBYTE2 = 2'b10,\n\tBYTE3 = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\nreg [7:0] byte1, byte2, byte3;\n\n// Sequential Logic for State Transition\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tcurrent_state <= WAIT;\n\t\tbyte1 <= 8'b0;\n\t\tbyte2 <= 8'b0;\n\t\tbyte3 <= 8'b0;\n\t\tout_bytes <= 24'b0;\n\t\tdone <= 1'b0;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\t\t\n\t\tif (current_state == BYTE3) begin\n\t\t\tout_bytes <= {byte1, byte2, byte3};\n\t\tend\n\tend\nend\n\n// Combinational Logic for Next State Logic and Datapath\nalways @(*) begin\n\tnext_state = current_state;\n\tdone = 1'b0;\n\t\n\tcase (current_state)\n\t\tWAIT: begin\n\t\t\tif (in[3] == 1) begin\n\t\t\t\tnext_state = BYTE1;\n\t\t\tend\n\t\tend\n\t\tBYTE1: begin\n\t\t\tbyte1 = in;\n\t\t\tnext_state = BYTE2;\n\t\tend\n\t\tBYTE2: begin\n\t\t\tbyte2 = in;\n\t\t\tnext_state = BYTE3;\n\t\tend\n\t\tBYTE3: begin\n\t\t\tbyte3 = in;\n\t\t\tdone = 1;\n\t\t\tnext_state = WAIT;\n\t\tend\n\tendcase\nend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\n    // State encoding\n    // y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n    \n    // Determine Y1: y[1] corresponds to state B\n    // Y1 is high if moving to B\n    assign Y1 = y[0] & w; // Transition from A to B \n\n    // Determine Y3: y[3] corresponds to state D\n    // Y3 is high if moving to D\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n    assign outv = vec;    // Assign the entire vec to outv\n    assign o0 = vec[0];   // Assign the least significant bit to o0\n    assign o1 = vec[1];   // Assign the middle bit to o1\n    assign o2 = vec[2];   // Assign the most significant bit to o2\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        out = (~c & ~d & a & ~b) | // cd=00, ab=01\n              (~c & ~d & ~a & b) | // cd=00, ab=10\n              (~c & d & ~a & ~b) | // cd=01, ab=00\n              (c & d & a & b) |    // cd=01, ab=11\n              (c & ~d & a & ~b) |  // cd=11, ab=01\n              (c & ~d & ~a & b) |  // cd=11, ab=10\n              (~c & d & a & ~b) |  // cd=10, ab=00\n              (c & ~a & b);        // cd=10, ab=11\n    end\nendmodule\n", "result": "failed: 125 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\n    // Assign lower 8 bits of the input to out_lo\n    assign out_lo = in[7:0];\n    \n    // Assign upper 8 bits of the input to out_hi\n    assign out_hi = in[15:8];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // NOR gate implementation\n    assign out = ~(a | b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n    // 1. Using assign statement\n    assign out_assign = a ^ b;\n\n    // 2. Using combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // 3. Using clocked always block\n    always @(posedge clk) begin\n        out_always_ff = a ^ b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n    // Logic for state B (Y2)\n    assign Y2 = y[1] & ~w;\n\n    // Logic for state D (Y4)\n    assign Y4 = (y[2] | y[3] | y[5] | y[6]) & w;\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\n    // Use the 'sel' as an index to select the bit from 'in'\n    assign out = in[sel];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R;  // Load new value\n\t\tend\n\t\telse if (E) begin\n\t\t\tQ <= w;  // Shift register\n\t\tend\n\t\telse begin\n\t\t\tQ <= Q;  // Retain current value\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // Intermediate flip-flop outputs declaration\n    reg q1, q2, q3;\n\n    // Logic gate outputs declaration\n    wire d1, d2, d3;\n\n    // Compute the inputs for the D flip-flops\n    assign d1 = x ^ q1;\n    assign d2 = x & ~q2;\n    assign d3 = x | ~q3;\n\n    // D flip-flops\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n\n    // Compute the final output Z\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // The output q is high if b or c is high\n    assign q = b | c;\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    // Temporary wire to hold the next state of q\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q if load signal is high\n            q <= data;\n        end else begin\n            // Iterate over each cell and apply the rule\n            for (integer i = 0; i < 512; i = i + 1) begin\n                // Get left, center, and right cells\n                // Boundary conditions: Consider q[-1] and q[512] as zero\n                integer left = (i == 0) ? 0 : q[i-1];\n                integer center = q[i];\n                integer right = (i == 511) ? 0 : q[i+1];\n                \n                // Apply Rule 110 for the next state of the center cell\n                case( {left, center, right} )\n                    3'b111: next_q[i] = 0;\n                    3'b110: next_q[i] = 1;\n                    3'b101: next_q[i] = 1;\n                    3'b100: next_q[i] = 0;\n                    3'b011: next_q[i] = 1;\n                    3'b010: next_q[i] = 1;\n                    3'b001: next_q[i] = 1;\n                    3'b000: next_q[i] = 0;\n                endcase\n            end\n            // Update q with next_q\n            q <= next_q;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (in) ? B : A;\n            B: next_state = (in) ? B : C;\n            C: next_state = (in) ? D : A;\n            D: next_state = (in) ? B : C;\n            default: next_state = A; // default state\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: 3 out of 230 samples.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'b1111; // Representing 'f' as all high state\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\nassign out = (sel) ? b : a;\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;            // Load operation\n        end else begin\n            Q <= q_in;            // Logic transformation operation\n        end\n    end\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    reg [31:0] prev_in; // Register to hold the value of 'in' from the previous clock cycle.\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0; // Clear the output when reset is asserted.\n            prev_in <= 32'b0; // Initialize prev_in on reset.\n        end else begin\n            // Detect transition from 1 to 0\n            out <= out | (prev_in & ~in); // Update out where 1->0 transition is detected.\n            prev_in <= in; // Update prev_in with the current input.\n        end\n    end\n\nendmodule\n", "result": "failed: 91 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        q <= d; // On the rising edge of the clock, capture the input 'd' and store it in 'q'\n    end\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n    assign s = a + b;\n\n    // Detect overflow\n    assign overflow = (~a[7] & ~b[7] & s[7]) | (a[7] & b[7] & ~s[7]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // State transition logic\n    assign S_next       = state[0] & ~d | state[2] & ~d | state[3] & ~d | state[9] & ack;\n    assign S1_next      = state[0] & d;\n    assign S11_next     = state[1] & d | state[2] & d;\n    assign S110_next    = state[3] & ~d;\n    assign B0_next      = state[3] & d;\n    assign B1_next      = state[4];\n    assign B2_next      = state[5];\n    assign B3_next      = state[6];\n    assign Count_next   = state[7] | (state[8] & ~done_counting);\n    assign Wait_next    = state[8] & done_counting | state[9] & ~ack;\n\n    // Output logic\n    assign done         = state[9];\n    assign counting     = state[8];\n    assign shift_ena    = state[4] | state[5] | state[6] | state[7];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Initially weakly not-taken on reset\n        end\n        else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    // Increment the counter, saturate at 3 (2'b11)\n                    if (state < 2'b11) begin\n                        state <= state + 1;\n                    end\n                end\n                else begin\n                    // Decrement the counter, saturate at 0 (2'b00)\n                    if (state > 2'b00) begin\n                        state <= state - 1;\n                    end\n                end\n            end\n            // If train_valid is 0, the state remains unchanged\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\talways @(*) begin\n\t\t// Default output for no active bits is 0\n\t\tpos = 3'd0;\n\t\t\n\t\t// Check from least to most significant bit\n\t\tif (in[0])\n\t\t\tpos = 3'd0;\n\t\telse if (in[1])\n\t\t\tpos = 3'd1;\n\t\telse if (in[2])\n\t\t\tpos = 3'd2;\n\t\telse if (in[3])\n\t\t\tpos = 3'd3;\n\t\telse if (in[4])\n\t\t\tpos = 3'd4;\n\t\telse if (in[5])\n\t\t\tpos = 3'd5;\n\t\telse if (in[6])\n\t\t\tpos = 3'd6;\n\t\telse if (in[7])\n\t\t\tpos = 3'd7;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\n    always @(*) begin\n        // Initialize all outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        // Check the scancode and assert the correct output\n        case (scancode)\n            16'he06b: left = 1;    // Left arrow\n            16'he072: down = 1;    // Down arrow\n            16'he074: right = 1;   // Right arrow\n            16'he075: up = 1;      // Up arrow\n            default: begin\n                // Ensure outputs are all 0 by default case\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    // Full adder logic\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\n// Define the top_module\nmodule top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n    // Intermediate signals for carry\n    wire c1, c2, c3;\n\n    // Instantiate four full adders\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n    \n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n    \n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n    \n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(sum[4]) // sum[4] is the final carry-out which acts as overflow bit\n    );\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset the history register to zero on asynchronous reset\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // Handle branch misprediction: Load the recovery value into the history\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            // Handle branch prediction: Shift history and insert predict_taken at LSB\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n        // If neither condition occurs, the predict_history remains unchanged\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n    // Declare intermediate wires for the outputs of the AND gates\n    wire and1_out, and2_out;\n\n    // First layer: two AND gates\n    assign and1_out = a & b;  // AND gate 1 with inputs a and b\n    assign and2_out = c & d;  // AND gate 2 with inputs c and d\n\n    // Second layer: OR gate that takes the outputs of the AND gates\n    assign out = and1_out | and2_out;\n\n    // NOT gate to invert the output\n    assign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\t// Always block triggered on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tq <= d; // Transfer the input d to output q on rising edge of clock\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\n    // Declare the shift register storage\n    reg [7:0] Q;\n\n    // Implement the shift register\n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift in the input 'S' into Q[0]\n            Q[7:0] <= {Q[6:0], S};\n        end\n    end\n\n    // Implement the 8-to-1 multiplexer for output Z\n    always @(*) begin\n        case ({A, B, C}) // Combine A, B, C to form a 3-bit select signal\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Default case to handle unexpected values\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n\t// Heater logic: Only active in heating mode when too cold\n\tassign heater = mode & too_cold;\n\t\n\t// Air conditioning logic: Only active in cooling mode when too hot\n\tassign aircon = ~mode & too_hot;\n\t\n\t// Fan logic: On if heater or aircon is on, or when fan_on is requested\n\tassign fan = heater | aircon | fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n    \n    assign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n    \n    assign out_pos = (a | b | c | ~d) & (a | ~b | ~c | d) & (~a | ~b | c) & (~a | b | d);\n    \nendmodule\n", "result": "failed: 43 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Initialize LFSR value on reset\n        end else begin\n            // Implement the XOR feedback based on the tap positions\n            q[31:1] <= q[30:0]; // Shift the register except the last bit\n            q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0]; // XOR taps to get feedback for q[0]\n        end\n    end\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n    assign q = b & (c | d);\n    \nendmodule\n", "result": "failed: 23 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    integer i;\n    always @(*) begin\n        out = 0; // Initialize count to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\n    // Calculations for out_both\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Calculations for out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Calculations for out_different\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232; // a = 0 -> q = 1232\n            3'b001: q = 16'haee0; // a = 1 -> q = aee0\n            3'b010: q = 16'h27d4; // a = 2 -> q = 27d4\n            3'b011: q = 16'h5a0e; // a = 3 -> q = 5a0e\n            3'b100: q = 16'h2066; // a = 4 -> q = 2066\n            3'b101: q = 16'h64ce; // a = 5 -> q = 64ce\n            3'b110: q = 16'hc526; // a = 6 -> q = c526\n            3'b111: q = 16'h2f19; // a = 7 -> q = 2f19\n            default: q = 16'h0000; // Default case for safety\n        endcase\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0\n\t\tend else if (slowena) begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000; // Reset to 0 after reaching 9\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\t\tend\n\t\tend\n\t\t// If slowena is low, retain current value (do nothing)\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n\t// Negate in2 for the AND gate input (since there is a bubble)\n\twire not_in2 = ~in2;  // NOT operation on in2\n\n\t// Perform AND operation with in1 and not_in2\n\tassign out = in1 & not_in2;  // AND gate operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n    // Combinationally assign the output to the input\n    assign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// Define state parameters\n\ttypedef enum reg [1:0] {\n\t\tA = 2'b00,\n\t\tB = 2'b01\n\t} state_t;\n\t\n\t// Declare state registers\n\tstate_t current_state, next_state;\n\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= B;  // Asynchronous reset to state B\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = A;  // Stay in A if input is 1\n\t\t\t\telse\n\t\t\t\t\tnext_state = B;  // Go to B if input is 0\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B;  // Stay in B if input is 1\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;  // Go to A if input is 0\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = B;   // Default state\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: out = 1'b0;\n\t\t\tB: out = 1'b1;\n\t\t\tdefault: out = 1'b1;  // Default output\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    reg [1:0] data; // Holds both values sampled at positive and negative edges\n    reg sel; // Selector to decide which value to output\n\n    always @(posedge clk) begin\n        data[1] <= d;\n        sel <= ~sel; // Toggle the selector on every positive edge\n    end\n\n    always @(negedge clk) begin\n        data[0] <= d;\n        sel <= ~sel; // Toggle the selector on every negative edge\n    end\n\n    always @(*) begin\n        if (sel)\n            q = data[1];\n        else\n            q = data[0];\n    end\n\nendmodule\n", "result": "failed: 41 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of submodule B\nmodule B (\n    input x,\n    input y,\n    output reg z\n);\n    // Note: We are assuming posedge of a clock for behavioral change, which is generally needed in waveform-driven implementations.\n    always @*\n    begin\n        if ((x == 0) && (y == 0))\n            z = 1;\n        else if ((x == 1) && (y == 0))\n            z = 0;\n        else if ((x == 0) && (y == 1))\n            z = 0;\n        else if ((x == 1) && (y == 1))\n            z = 1;\n    end\nendmodule\n\n// Top-level module\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n\n    wire zA1, zB1, zA2, zB2;\n    wire or_out, and_out;\n\n    // Instantiate first A and B modules\n    A a1_inst (.x(x), .y(y), .z(zA1));\n    B b1_inst (.x(x), .y(y), .z(zB1));\n\n    // Instantiate second A and B modules\n    A a2_inst (.x(x), .y(y), .z(zA2));\n    B b2_inst (.x(x), .y(y), .z(zB2));\n\n    // Connect outputs of first A and B to an OR gate\n    assign or_out = zA1 | zB1;\n\n    // Connect outputs of second A and B to an AND gate\n    assign and_out = zA2 & zB2;\n\n    // Connect OR and AND outputs to an XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the register\n            q <= data;\n        end else begin\n            // Rotate logic\n            case (ena)\n                2'b01: begin\n                    // Rotate right\n                    q <= {q[0], q[99:1]};\n                end\n                2'b10: begin\n                    // Rotate left\n                    q <= {q[98:0], q[99]};\n                end\n                default: begin\n                    // No rotation (2'b00 or 2'b11), hold the current value\n                    q <= q;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'b0; // Set counter to 0\n        end else if (q == 10'd999) begin\n            q <= 10'b0; // Wrap around when reaching 999\n        end else begin\n            q <= q + 1'b1; // Increment counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Implement NOT gate\n    assign out = ~in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    always @(*) begin\n        // Default initialize next_state to zero\n        next_state = 10'b0;\n        \n        case (1'b1)  // One-hot encoding: one of these should be true\n            state[0]: next_state = in ? (10'b00000000010) : (10'b00000000001); // S0\n            state[1]: next_state = in ? (10'b00000000100) : (10'b00000000001); // S1\n            state[2]: next_state = in ? (10'b00000001000) : (10'b00000000001); // S2\n            state[3]: next_state = in ? (10'b00000010000) : (10'b00000000001); // S3\n            state[4]: next_state = in ? (10'b00000100000) : (10'b00000000001); // S4\n            state[5]: next_state = in ? (10'b00001000000) : (10'b00010000000); // S5\n            state[6]: next_state = in ? (10'b00010000000) : (10'b00100000000); // S6\n            state[7]: next_state = in ? (10'b00010000000) : (10'b00000000001); // S7\n            state[8]: next_state = in ? (10'b00000000010) : (10'b00000000001); // S8\n            state[9]: next_state = in ? (10'b00000000010) : (10'b00000000001); // S9\n            default: next_state = 10'b0; // Invalid state handling\n        endcase\n    end\n\n    assign out1 = state[8] | state[9]; // out1 is 1 when in S8 or S9\n    assign out2 = state[7] | state[9]; // out2 is 1 when in S7 or S9\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tcase ({j, k})\n\t\t\t2'b00: Q <= Q;       // No change\n\t\t\t2'b01: Q <= 0;       // Reset\n\t\t\t2'b10: Q <= 1;       // Set\n\t\t\t2'b11: Q <= ~Q;      // Toggle\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[0] + in[1] + in[2];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    \n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    \n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    \n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    \n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n\t// State declaration\n\tlocalparam WALK_LEFT = 1'b0;\n\tlocalparam WALK_RIGHT = 1'b1;\n\n\t// State register\n\treg current_state, next_state;\n\n\t// Sequential Logic: State Transition\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= WALK_LEFT;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Combinational Logic: Determining Next State\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (bump_left || bump_right) begin\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (bump_left || bump_right) begin\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Combinational Logic: Output Logic based on Current State\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\nassign q = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Intermediate wires for AND gates outputs\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n    wire and4_out;\n    \n    // AND gate calculations\n    assign and1_out = p1a & p1b & p1c;\n    assign and2_out = p1d & p1e & p1f;\n    assign and3_out = p2a & p2b;\n    assign and4_out = p2c & p2d;\n    \n    // OR gate calculations\n    assign p1y = and1_out | and2_out;\n    assign p2y = and3_out | and4_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\nalways @ (posedge clk) begin\n    case(y)\n        3'b000: \n            if (x) begin\n                Y0 <= 1;\n            end else begin\n                Y0 <= 0;\n            end\n        3'b001: \n            if (x) begin\n                Y0 <= 0;\n            end else begin\n                Y0 <= 1;\n            end\n        3'b010: \n            if (x) begin\n                Y0 <= 1;\n            end else begin\n                Y0 <= 0;\n            end\n        3'b011: \n            if (x) begin\n                Y0 <= 0;\n            end else begin\n                Y0 <= 1;\n            end\n        3'b100:\n            if (x) begin\n                Y0 <= 0;\n            end else begin\n                Y0 <= 1;\n            end\n        default: Y0 <= 0; \n    endcase\nend\n\nalways @ (posedge clk) begin\n    case(y)\n        3'b011, 3'b100: z <= 1;\n        default: z <= 0;\n    endcase\nend\n\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Implementing the NOR gate\n    assign out = !(in1 | in2);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n    assign w = a; // Connect input a to output w\n    assign x = b; // Connect input b to output x\n    assign y = b; // Connect input b to output y\n    assign z = c; // Connect input c to output z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n    always @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 0; // Asynchronous reset: set q to 0\n        end else begin\n            q <= d; // Capture input d at the rising edge of clk\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000; // Default when `sel` is invalid\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter; // Register to hold the current count\n    \n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;  // Load the counter with the new data\n        end else if (counter != 0) begin\n            counter <= counter - 1;  // Decrement the counter only if it's not zero\n        end\n    end\n\n    always @(*) begin\n        tc = (counter == 10'd0);  // tc is high when counter is zero\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n\t// Define states using an enumerated type (parameter)\n\ttypedef enum reg [2:0] {\n\t\tIDLE = 3'b000,\n\t\tS1 = 3'b001,\n\t\tS11 = 3'b010,\n\t\tS110 = 3'b011,\n\t\tSEQ_DETECTED = 3'b100\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\n\t// Synchronous reset and state transition\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\t\tstart_shifting <= 1'b0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data) next_state = S1;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (data) next_state = S11;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tS11: begin\n\t\t\t\tif (data) next_state = S11; // Remain on '11' if another '1' is received\n\t\t\t\telse next_state = S110;\n\t\t\tend\n\t\t\tS110: begin\n\t\t\t\tif (data) next_state = SEQ_DETECTED;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tSEQ_DETECTED: begin\n\t\t\t\tnext_state = SEQ_DETECTED; // Remain in this state once sequence is detected\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstart_shifting <= 1'b0;\n\t\tend else if (current_state == SEQ_DETECTED) begin\n\t\t\tstart_shifting <= 1'b1;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;  // Set output to zero if reset is high\n    end else begin\n        q <= d;    // Otherwise, capture the input data\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n    // Register to store the previous state of 'in'\n    reg [7:0] prev_in;\n\n    // Always block triggered on the rising edge of the clock\n    always @(posedge clk) begin\n        // Iterate through each bit in 'in'\n        integer i;\n        // Check each bit for an edge change from 0 to 1\n        for (i = 0; i < 8; i = i+1) begin\n            if (prev_in[i] == 0 && in[i] == 1)\n                anyedge[i] <= 1;  // Set the output bit 'anyedge' for the next cycle\n            else\n                anyedge[i] <= 0;  // Else clear the output bit\n        end\n        // Update prev_in with the current state of 'in'\n        prev_in <= in;\n    end\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001; // When reset is high, set q to 1\n\t\tend else begin\n\t\t\tif (q == 4'b1010) begin\n\t\t\t\tq <= 4'b0001; // Wrap around to 1 when the counter reaches 10\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (a) begin\n        q <= 4;\n    end else begin\n        q <= q + 1;\n        if (q == 6) begin\n            q <= 0;\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tq <= 5'b00001; // Active high synchronous reset sets the LFSR to 1\n\t\tend else begin\n\t\t\tq[0] <= q[4]; // Output of the shift register feeding into the first bit\n\t\t\tq[1] <= q[0];\n\t\t\tq[2] <= q[1] ^ q[4]; // Tap at position 3\n\t\t\tq[3] <= q[2];\n\t\t\tq[4] <= q[3]; // Tap at position 5 (this is the feedback bit)\n\t\tend\n\tend\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\n\t\tif (out == 8'b0)\n\t\t\tresult_is_zero = 1;\n\t\telse\n\t\t\tresult_is_zero = 0;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // Derived Boolean expression based on K-map simplification:\n    assign f = (x[3] & ~x[4]) | (x[4] & ~x[2]) | (x[3] & x[1]); \nendmodule\n", "result": "failed: 26 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\nassign out[0] = in[7];\nassign out[1] = in[6];\nassign out[2] = in[5];\nassign out[3] = in[4];\nassign out[4] = in[3];\nassign out[5] = in[2];\nassign out[6] = in[1];\nassign out[7] = in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t// We directly instantiate the simplified logic from Karnaugh map analysis\n\talways @(*) begin\n\t    case ({c, d, a, b})\n\t        4'b0010, 4'b0011, 4'b1101, 4'b1110, 4'b1111, 4'b1010, 4'b1011, 4'b1001: out = 1;\n\t        default: out = 0;\n\t    endcase\n\tend\nendmodule\n", "result": "failed: 58 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in data MSB first\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement the current value in the register\n            q <= q - 1;\n        end\n        // No need to handle the case when both are 1, as per the problem description\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n    // Define state parameters\n    parameter IDLE = 1'b0;\n    parameter COUNT = 1'b1;\n    \n    // State register\n    reg state, next_state;\n    \n    // Counter register\n    reg [2:0] count;\n    \n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (reset)\n                    next_state = COUNT;\n                else\n                    next_state = IDLE;\n            end\n            COUNT: begin\n                if (count == 3'd4)\n                    next_state = IDLE;\n                else\n                    next_state = COUNT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // State flip-flops (sequential)\n    always @(posedge clk) begin\n        if (reset)\n            state <= COUNT;\n        else\n            state <= next_state;\n    end\n    \n    // Counter logic\n    always @(posedge clk) begin\n        if (state == COUNT) begin\n            if (count < 3'd4)\n                count <= count + 1;\n        end\n        if (state == IDLE || reset)\n            count <= 3'd0;\n    end\n    \n    // Output logic\n    always @(*) begin\n        if (state == COUNT)\n            shift_ena = 1;\n        else\n            shift_ena = 0;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;  // Synchronous reset: set counter to 0\n        end\n        else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n    // Implementing using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Implementing using procedural if inside an always block\n    always @(*) begin\n        if (sel_b1 & sel_b2) begin\n            out_always = b;\n        end else begin\n            out_always = a;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    assign out = a | (b & c);\nendmodule\n", "result": "failed: 53 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n\t// State declarations\n\ttypedef enum logic [1:0] {\n\t\tS_A = 2'b00,\n\t\tS_B = 2'b01,\n\t\tS_C = 2'b10,\n\t\tS_D = 2'b11\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State flip-flops\n\talways_ff @(posedge clk or negedge resetn) begin\n\t\tif (~resetn)\n\t\t\tcurrent_state <= S_A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// State transition always block\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tS_A: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = S_B;\n\t\t\t\telse if (r[2])\n\t\t\t\t\tnext_state = S_C;\n\t\t\t\telse if (r[3])\n\t\t\t\t\tnext_state = S_D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S_A;\n\t\t\tend\n\t\t\tS_B: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = S_B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S_A;\n\t\t\tend\n\t\t\tS_C: begin\n\t\t\t\tif (r[2])\n\t\t\t\t\tnext_state = S_C;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S_A;\n\t\t\tend\n\t\t\tS_D: begin\n\t\t\t\tif (r[3])\n\t\t\t\t\tnext_state = S_D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S_A;\n\t\t\tend\n\t\t\tdefault: next_state = S_A;\n\t\tendcase\n\tend\n\n\t// Output assignments\n\tassign g[1] = (current_state == S_B);\n\tassign g[2] = (current_state == S_C);\n\tassign g[3] = (current_state == S_D);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset state\n        end else if (q == 4'b1001) begin\n            q <= 4'b0000; // Wrap around after reaching 9\n        end else begin\n            q <= q + 1; // Increment q\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // States for FSM\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10,\n        BYTE3 = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                done = 1'b0;\n                if (in[3] == 1'b1)\n                    next_state = BYTE1;  // Detected start of a message\n                else\n                    next_state = IDLE;\n            end\n\n            BYTE1: begin\n                done = 1'b0;\n                next_state = BYTE2;  // Moving to second byte\n            end\n\n            BYTE2: begin\n                done = 1'b0;\n                next_state = BYTE3;  // Moving to third byte\n            end\n\n            BYTE3: begin\n                done = 1'b1;  // Message complete after the third byte\n                if (in[3] == 1'b1)\n                    next_state = BYTE1;  // New message starts again immediately\n                else\n                    next_state = IDLE;\n            end\n\n            default: begin\n                done = 1'b0;\n                next_state = IDLE;\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\n    // The multiplexer logic\n    assign out = (sel == 0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // 4-input AND gate\n    assign out_and = in[3] & in[2] & in[1] & in[0];\n\n    // 4-input OR gate\n    assign out_or = in[3] | in[2] | in[1] | in[0];\n\n    // 4-input XOR gate\n    assign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            3'b000: begin\n                next_state = x ? 3'b001 : 3'b000;\n                z = 0;\n            end\n            3'b001: begin\n                next_state = x ? 3'b100 : 3'b001;\n                z = 0;\n            end\n            3'b010: begin\n                next_state = x ? 3'b001 : 3'b010;\n                z = 0;\n            end\n            3'b011: begin\n                next_state = x ? 3'b010 : 3'b001;\n                z = 1;\n            end\n            3'b100: begin\n                next_state = x ? 3'b100 : 3'b011;\n                z = 1;\n            end\n            default: begin\n                next_state = 3'b000;\n                z = 0;\n            end\n        endcase\n    end\n\n    // State flip-flop with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000;\n        end else begin\n            state <= next_state;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000, // Initial state, waiting for reset de-assertion\n        STATE_B = 3'b001, // Output f=1 for one cycle\n        STATE_WAIT_1 = 3'b010, // Wait for x=1 for the first occurrence\n        STATE_WAIT_0 = 3'b011, // Wait for x=0 after seeing x=1\n        STATE_WAIT_1_AGAIN = 3'b100, // Wait for x=1 again after x=0\n        STATE_MONITOR_Y_1 = 3'b101, // Monitor y for the first clock cycle after g=1\n        STATE_MONITOR_Y_2 = 3'b110, // Monitor y for the second clock cycle after g=1\n        STATE_G_SET = 3'b111 // Final state, maintain g permanently\n    } state_t;\n\n    // State and next state variables\n    state_t state, next_state;\n\n    // Sequential logic for state transitions\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= STATE_A; // Reset to initial state\n        else\n            state <= next_state; // Transition to the next state\n    end\n\n    // Combinational logic for state transitions\n    always @(*) begin\n        next_state = state;\n        case (state)\n            STATE_A: begin\n                if (!resetn)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            STATE_B: begin\n                next_state = STATE_WAIT_1;\n            end\n            STATE_WAIT_1: begin\n                if (x)\n                    next_state = STATE_WAIT_0;\n            end\n            STATE_WAIT_0: begin\n                if (!x)\n                    next_state = STATE_WAIT_1_AGAIN;\n            end\n            STATE_WAIT_1_AGAIN: begin\n                if (x)\n                    next_state = STATE_MONITOR_Y_1;\n            end\n            STATE_MONITOR_Y_1: begin\n                if (y)\n                    next_state = STATE_G_SET;\n                else\n                    next_state = STATE_MONITOR_Y_2;\n            end\n            STATE_MONITOR_Y_2: begin\n                if (y)\n                    next_state = STATE_G_SET;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_G_SET: begin\n                next_state = STATE_G_SET;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            f <= 1'b0;\n            g <= 1'b0;\n        end\n        else begin\n            f <= 1'b0; // Default value for f in the absence of state B\n            case (state)\n                STATE_B: begin\n                    f <= 1'b1;\n                end\n                STATE_MONITOR_Y_1: begin\n                    g <= 1'b1;\n                end\n                STATE_MONITOR_Y_2: begin\n                    g <= 1'b1;\n                end\n                STATE_G_SET: begin\n                    g <= 1'b1;\n                end\n                default: begin\n                    g <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34;  // Reset to 0x34\n\t\tend else begin\n\t\t\tq <= d;      // Normal operation: store input 'd'\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Calculate the even parity bit using XOR on all input bits\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    // Define the output based on the current state.\n    always @(*) begin\n        case (state)\n            2'b00: out = 0; // State A\n            2'b01: out = 0; // State B\n            2'b10: out = 0; // State C\n            2'b11: out = 1; // State D\n            default: out = 0; // Default case to cover any unforeseen states\n        endcase\n    end\n\n    // Define the next state based on the current state and input.\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // State A: A->A if in=0, A->B if in=1\n            2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State B: B->C if in=0, B->B if in=1\n            2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // State C: C->A if in=0, C->D if in=1\n            2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State D: D->C if in=0, D->B if in=1\n            default: next_state = 2'b00; // Default case to cover any unforeseen states\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // Implementing the XNOR operation for z\n    assign z = ~(x ^ y);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// Define state codes\n\ttypedef enum logic [2:0] {\n\t\tA = 3'b000,\n\t\tB = 3'b001,\n\t\tC = 3'b010,\n\t\tD = 3'b011,\n\t\tE = 3'b100,\n\t\tF = 3'b101\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State flip-flops (sequential logic): update state or reset\n\talways_ff @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// State table (combinational logic): determine next state\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tA: next_state = (w) ? B : A;\n\t\t\tB: next_state = (w) ? C : D;\n\t\t\tC: next_state = (w) ? E : D;\n\t\t\tD: next_state = (w) ? F : A;\n\t\t\tE: next_state = (w) ? E : D;\n\t\t\tF: next_state = (w) ? C : D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// Output logic: assign output z based on current state\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tE, F: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Reset 'q' to zero synchronously when reset is active-low\n        end else begin\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // Write upper byte if enabled\n            end\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // Write lower byte if enabled\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n\t// Register to store the previous state of 'in'\n\treg [7:0] prev_in;\n    \n\talways @(posedge clk) begin\n\t\t// Positive edge detection for each bit\n\t\tpedge <= (~prev_in) & in;\n\t\t// Update the previous state\n\t\tprev_in <= in;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\n\talways @(posedge clock) begin\n\t\tif (a == 1) begin\n\t\t\tp <= 1;  // Set p to 1 when clock is high and a is 1\n\t\tend else begin\n\t\t\tp <= 0;  // Maintain p as 0 when clock is high and a is 0\n\t\tend\n\tend\n\n\talways @(negedge clock) begin\n\t\tq <= p;  // Copy p's value to q on clock falling edge\n\tend\n\nendmodule\n", "result": "failed: 138 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data; // Load data into q\n\tend else begin\n\t\t// Compute next state using Rule 90\n\t\t// q[i] is updated to q[i-1] ^ q[i+1] with boundary conditions\n\t\tinteger i;\n\t\treg [511:0] next_q;\n\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\tif (i == 0) begin\n\t\t\t\tnext_q[i] = 0 ^ q[i+1]; // Boundary condition: q[-1] is 0\n\t\t\tend else if (i == 511) begin\n\t\t\t\tnext_q[i] = q[i-1] ^ 0; // Boundary condition: q[512] is 0\n\t\t\tend else begin\n\t\t\t\tnext_q[i] = q[i-1] ^ q[i+1];\n\t\t\tend\n\t\tend\n\t\tq <= next_q; // Update q with next state values\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    // out_both[98:0] logic: Check if both the bit and its left neighbor are '1'\n    generate\n        genvar i;\n        for (i = 0; i < 99; i = i + 1) begin : out_both_gen\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // out_any[99:1] logic: Check if either the bit or its right neighbor are '1'\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : out_any_gen\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // out_different[99:0] logic: Check if the bit is different from its left neighbor\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : out_different_gen\n            if (i == 0) begin\n                // Wrap-around case\n                assign out_different[i] = in[i] ^ in[99];\n            end else begin\n                // Default case\n                assign out_different[i] = in[i] ^ in[i-1];\n            end\n        end\n    endgenerate\n    \nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tif (ena) begin\n\t\t\tq = d;\n\t\tend\n\t\t// else branch is not needed because q retains its value when ena is low\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    assign out = in[4*sel +: 4];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\n\talways_comb begin\n\t\tcase (sel)\n\t\t\t4'd0: out = a;\n\t\t\t4'd1: out = b;\n\t\t\t4'd2: out = c;\n\t\t\t4'd3: out = d;\n\t\t\t4'd4: out = e;\n\t\t\t4'd5: out = f;\n\t\t\t4'd6: out = g;\n\t\t\t4'd7: out = h;\n\t\t\t4'd8: out = i;\n\t\t\tdefault: out = 16'hFFFF; // For all unused cases (sel=9 to 15), set all output bits to '1'\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Bitwise OR operation\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR operation: Reduction OR on both vectors\n    assign out_or_logical = |a || |b;\n    \n    // Inverse (NOT) operation\n    assign out_not[2:0] = ~a;  // Inverse of a in lower half\n    assign out_not[5:3] = ~b;  // Inverse of b in upper half\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    parameter A = 4'b0001, B = 4'b0010, C = 4'b0100, D = 4'b1000;\n    \n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 4'b0000;\n        endcase\n    end\n\n    assign out = (state == D) ? 1 : 0;\n\nendmodule\n", "result": "failed: 273 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n    always @(*) begin\n        // Find the minimum of a and b\n        reg [7:0] min_ab;\n        if (a < b)\n            min_ab = a;\n        else\n            min_ab = b;\n        \n        // Find the minimum of c and d\n        reg [7:0] min_cd;\n        if (c < d)\n            min_cd = c;\n        else\n            min_cd = d;\n        \n        // Find the minimum of min_ab and min_cd\n        if (min_ab < min_cd)\n            min = min_ab;\n        else\n            min = min_cd;\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\t\n\tassign out_and = a & b;\n\tassign out_or = a | b;\n\tassign out_xor = a ^ b;\n\tassign out_nand = ~(a & b);\n\tassign out_nor = ~(a | b);\n\tassign out_xnor = a ~^ b; // Alternatively: assign out_xnor = !(a ^ b);\n\tassign out_anotb = a & ~b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\t// Declare internal wires for the expression components\n\twire cd_not = ~c & ~d;\n\twire cd_b = ~c & d & b;\n\twire ca = ~c & a;\n\twire cb_d = c & ~d & b;\n\twire cb = c & d & b;\n\t\n\t// Combine the components to form the final output\n\tassign out = cd_not | cd_b | ca | cb_d | cb;\n\nendmodule\n", "result": "failed: 107 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n\t// State declaration\n\ttypedef enum reg [2:0] {\n\t\tA = 3'b000,  // Initial state\n\t\tB = 3'b001,  // State after s becomes 1\n\t\tCOUNT1 = 3'b010,  // First counting cycle\n\t\tCOUNT2 = 3'b011,  // Second counting cycle\n\t\tCOUNT3 = 3'b100   // Third counting cycle\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\treg [1:0] count_w1;  // Counter for 'w' being 1\n\t\n\t// State register update with synchronous reset\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\t\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: begin\n\t\t\t\tif (s)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: next_state = COUNT1;\n\t\t\tCOUNT1: next_state = COUNT2;\n\t\t\tCOUNT2: next_state = COUNT3;\n\t\t\tCOUNT3: next_state = B;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\t\n\t// Output logic and 'w' counter update\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcount_w1 <= 0;\n\t\t\tz <= 0;\n\t\tend\n\t\telse begin\n\t\t\tcase (current_state)\n\t\t\t\tA: begin\n\t\t\t\t\tcount_w1 <= 0;\n\t\t\t\t\tz <= 0;\n\t\t\t\tend\n\t\t\t\tB: count_w1 <= 0;  // Reset counter for next 3 cycle count\n\t\t\t\tCOUNT1: count_w1 <= count_w1 + w;\n\t\t\t\tCOUNT2: count_w1 <= count_w1 + w;\n\t\t\t\tCOUNT3: begin\n\t\t\t\t\tcount_w1 <= count_w1 + w;\n\t\t\t\t\tz <= (count_w1 == 2) ? 1 : 0;  // Set output z\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 403 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\nassign out = {{24{in[7]}}, in};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    reg [3:0] shift_reg; // Declare a 4-bit register to hold the state of the shift register\n    \n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Synchronous active-low reset: When resetn = 0, reset the shift register\n            shift_reg <= 4'b0000;\n        end else begin\n            // Shift logic: On the rising edge of the clock, shift input values\n            shift_reg[0] <= in;               // Load the input into the first flop\n            shift_reg[1] <= shift_reg[0];     // Shift the values through subsequent flops\n            shift_reg[2] <= shift_reg[1];\n            shift_reg[3] <= shift_reg[2];\n        end\n    end\n\n    assign out = shift_reg[3]; // Output from the last flip-flop\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\t4'b1zzz: pos = 2'd3;\n\t\t\t4'b01zz: pos = 2'd2;\n\t\t\t4'b001z: pos = 2'd1;\n\t\t\t4'b0001: pos = 2'd0;\n\t\t\tdefault: pos = 2'd0; // if no bits are high, output zero\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [0:0] {\n        OFF = 1'b0,\n        ON  = 1'b1\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF; // Asynchronous reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 0;\n            ON:  out = 1;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n    // Assign logic 0 to 'out'\n    assign out = 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n\t// Continuously assign a logic high value to the output\n\tassign one = 1'b1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\tinteger i;\n\talways @(*) begin\n\t\t// Loop for reversing the bits\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99 - i];\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out; // XOR operation and assign to D input of flip-flop\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end\n        else if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    \n    assign f = (~x3 & x2 & ~x1) |  // Corresponds to (0, 1, 0)\n               (~x3 & x2 & x1)  |  // Corresponds to (0, 1, 1)\n               (x3 & ~x2 & x1)  |  // Corresponds to (1, 0, 1)\n               (x3 & x2 & x1);     // Corresponds to (1, 1, 1)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b0;  // Reset output to 0 when areset is active\n\t\tend else begin\n\t\t\tq <= d;  // Update output with input d at positive edge of clk\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Perform reduction operations to compute outputs\n    assign out_and = &in;  // Reduction AND\n    assign out_or = |in;   // Reduction OR\n    assign out_xor = ^in;  // Reduction XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\nassign sum = a ^ b;  // XOR operation for sum\nassign cout = a & b;  // AND operation for carry-out\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        // Default value\n        shut_off_computer = 0;\n        \n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        // Default value\n        keep_driving = 0;\n        \n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State definitions\n    typedef enum logic [1:0] {\n        OFF = 2'b00,  // Representing OFF state\n        ON  = 2'b01   // Representing ON state\n    } state_t;\n    \n    // State registers\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            OFF: if (j) next_state = ON;\n                 else next_state = OFF;\n            ON:  if (k) next_state = OFF;\n                 else next_state = ON;\n            default: next_state = OFF;\n        endcase\n    end\n    \n    // State register update logic including reset handling\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= OFF;\n        else \n            current_state <= next_state;\n    end\n    \n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            OFF: out = 0;\n            ON:  out = 1;\n            default: out = 0;\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    // Concatenate all input vectors and append '11' at the LSB end\n    wire [31:0] concatenated_input;\n    assign concatenated_input = {a, b, c, d, e, f, 2'b11};\n\n    // Assign the respective bits to output vectors\n    assign w = concatenated_input[31:24];\n    assign x = concatenated_input[23:16];\n    assign y = concatenated_input[15:8];\n    assign z = concatenated_input[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n\tassign q = (a) ? \n               ((b) ? (~c & d) : (c ^ ~d)) :\n               ((b) ? (c & d) : (~c | ~d));\n\nendmodule\n", "result": "failed: 105 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n    // Perform the AND operation\n    assign out = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// States\n\ttypedef enum reg [1:0] {\n\t\tSTATE_A = 2'b00,\n\t\tSTATE_B = 2'b01\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\t\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tSTATE_B: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_A;\n\t\t\tend\n\t\t\tSTATE_A: begin\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = STATE_A;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_B;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\t// State register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= STATE_B;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\t\n\t// Output logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tSTATE_B: out = 1;\n\t\t\tSTATE_A: out = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n// Intermediate wire to hold the output of the XNOR gate\nwire xnor_out;\n\n// Instantiate the XNOR gate\nassign xnor_out = ~(in1 ^ in2);\n\n// Instantiate the XOR gate\nassign out = xnor_out ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    // Implementing the logic for `mux_in`\n    // Based on the Karnaugh map provided, we can derive the logic for mux inputs:\n    assign mux_in[0] = (~c & d) | (c & ~d); // cd = 00 -> 0=sin, 10->1=sout\n    assign mux_in[1] = c & ~d;              // cd = 01 -> 0=sin\n    assign mux_in[2] = d;                   // cd = 11 -> 1=sout\n    assign mux_in[3] = (~c & d) | (c & ~d); // cd = 10 -> 0=sin, 10->1=sout \n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// State encoding: one-hot encoding\n\tparameter A = 2'b01;\n\tparameter B = 2'b10;\n\n\t// State register\n\treg [1:0] state, next_state;\n\n\t// State transition logic (combinational)\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (x == 0) begin\n\t\t\t\t\tnext_state = A;\n\t\t\t\t\tz = 0;\n\t\t\t\tend else begin // x == 1\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tz = 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (x == 0) begin\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tz = 1;\n\t\t\t\tend else begin // x == 1\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tz = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = A;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// State register update (sequential logic)\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\n\treg state_reg;\n\n\tassign state = state_reg;\n\n\talways @(posedge clk) begin\n\t\tif (a == 1'b1 && b == 1'b0)\n\t\t\tstate_reg <= 1'b0;\n\t\telse if (a == 1'b0 && b == 1'b1)\n\t\t\tstate_reg <= ~state_reg;\n\t\telse if (a == 1'b1 && b == 1'b1)\n\t\t\tstate_reg <= 1'b1;\n\t\t// if a == 0 and b == 0, retain current state so no action needed\n\t\t\n\t\tq <= state_reg;\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // Simplified logic expression is: f = x[3]'x[4]' + x[3]x[1]' + x[3]x[4]'\n    assign f = (~x[3] & ~x[4]) | (x[3] & ~x[1]) | (x[3] & ~x[4]);\nendmodule\n", "result": "failed: 25 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    // Define state register\n    reg [2:0] state, next_state;\n    \n    // State encoding\n    localparam S0  = 3'b000,\n               S1  = 3'b001,\n               S2  = 3'b010,\n               S3  = 3'b011,\n               S4  = 3'b100,\n               S5  = 3'b101,\n               S6  = 3'b110,\n               S7  = 3'b111,\n               ERR = 3'b110; // Note: ERR overlaps but distinguished by output.\n    \n    // State transitions\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0; // If 0 detected, indicate disc\n            S7: next_state = in ? ERR : S0; // If 0 detected, indicate flag\n            ERR: next_state = reset ? S0 : (in ? ERR : S0);\n            default: next_state = S0;\n        endcase\n    end\n    \n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end\n        else begin\n            disc <= (state == S6 && next_state == S0);\n            flag <= (state == S7 && next_state == S0);\n            err <= (state == ERR && next_state != S0);\n        end\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State Definition\n    typedef enum reg [1:0] {\n        IDLE, \n        PATTERN_MATCHED, \n        COUNTING, \n        DONE\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // Internal Registers\n    reg [3:0] delay;\n    reg [12:0] cycle_counter;  // Counting up to 999, hence 13 bits\n    \n    // Shift Register for Pattern detection\n    reg [3:0] shift_reg;\n    \n    // State Register logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State and Output Logic\n    always @(*) begin\n        // Default assignments\n        done = 0;\n        counting = 0;\n\n        next_state = state; // Default to hold state\n        case (state)\n            IDLE: begin\n                // Shift in the new data\n                if (reset) begin\n                    shift_reg = 4'b0000;\n                end else begin\n                    shift_reg = {shift_reg[2:0], data};\n                end\n                if (shift_reg == 4'b1101) begin\n                    next_state = PATTERN_MATCHED;\n                    cycle_counter = 0; // reset cycle counter\n                end\n            end\n            \n            PATTERN_MATCHED: begin\n                // Shift to capture delay (4 bits)\n                delay = {shift_reg[2:0], data};  // Most significant to least significant\n                count = delay;  // initializing the count\n                next_state = COUNTING;\n            end\n            \n            COUNTING: begin\n                counting = 1;\n                \n                if (cycle_counter < 999) begin\n                    cycle_counter = cycle_counter + 1;\n                end else begin\n                    cycle_counter = 0;\n                    if (count > 0) begin\n                        count = count - 1;\n                    end else begin\n                        next_state = DONE;\n                    end\n                end\n            end\n            \n            DONE: begin\n                done = 1;\n                if (ack) begin\n                    next_state = IDLE; // After ack reset to IDLE\n                end\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n\t// FSM state definitions\n\tparameter S_ABOVE_S3 = 2'b00;\n\tparameter S_BETWEEN_S3_S2 = 2'b01;\n\tparameter S_BETWEEN_S2_S1 = 2'b10;\n\tparameter S_BELOW_S1 = 2'b11;\n\t\n\t// State register\n\treg [1:0] current_state, next_state;\n\t\n\t// State Transition Logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS_ABOVE_S3: begin\n\t\t\t\tif (!s[3]) next_state = S_BETWEEN_S3_S2;\n\t\t\t\telse next_state = S_ABOVE_S3;\n\t\t\tend\n\t\t\tS_BETWEEN_S3_S2: begin\n\t\t\t\tif (s[3]) next_state = S_ABOVE_S3;\n\t\t\t\telse if (!s[2]) next_state = S_BETWEEN_S2_S1;\n\t\t\t\telse next_state = S_BETWEEN_S3_S2;\n\t\t\tend\n\t\t\tS_BETWEEN_S2_S1: begin\n\t\t\t\tif (s[2]) next_state = S_BETWEEN_S3_S2;\n\t\t\t\telse if (!s[1]) next_state = S_BELOW_S1;\n\t\t\t\telse next_state = S_BETWEEN_S2_S1;\n\t\t\tend\n\t\t\tS_BELOW_S1: begin\n\t\t\t\tif (s[1]) next_state = S_BETWEEN_S2_S1;\n\t\t\t\telse next_state = S_BELOW_S1;\n\t\t\tend\n\t\t\tdefault: next_state = S_BELOW_S1;\n\t\tendcase\n\tend\n\t\n\t// Output Logic\n\talways @(*) begin\n\t\t{fr3, fr2, fr1, dfr} = 4'b0000; // default values\n\t\tcase (current_state)\n\t\t\tS_ABOVE_S3: begin\n\t\t\t\t// No outputs asserted\n\t\t\tend\n\t\t\tS_BETWEEN_S3_S2: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tif (next_state == S_BETWEEN_S2_S1) dfr = 1'b1;\n\t\t\tend\n\t\t\tS_BETWEEN_S2_S1: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tfr2 = 1'b1;\n\t\t\t\tif (next_state == S_BELOW_S1) dfr = 1'b1;\n\t\t\tend\n\t\t\tS_BELOW_S1: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tfr2 = 1'b1;\n\t\t\t\tfr3 = 1'b1;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\t// State Register\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tcurrent_state <= S_BELOW_S1;\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\nendmodule\n", "result": "failed: 1252 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State declarations\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] bit_count;  // Counter for data bits\n\n    // State transitions\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;    // Reset state to IDLE\n            bit_count <= 0;   // Reset bit counter\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        done = 0;  // Default: not done\n        next_state = state;  // Default: remain in current state\n        case (state)\n            IDLE: begin\n                if (in == 0)  // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA;  // Move to DATA state\n                bit_count = 0;      // Clear data bit counter\n            end\n            DATA: begin\n                if (bit_count < 8) begin\n                    next_state = DATA;  // Collect all 8 data bits\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = STOP;  // Transition to STOP check\n                end\n            end\n            STOP: begin\n                if (in == 1) begin\n                    done = 1;           // Byte correctly received\n                    next_state = IDLE;  // Ready for next byte\n                end else begin\n                    next_state = ERROR; // Invalid stop bit detected\n                end\n            end\n            ERROR: begin\n                if (in == 1) begin\n                    next_state = IDLE;  // Wait for stop bit, then start over\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n\treg [3:0] state;\n\treg [2:0] bit_index;\n\treg [7:0] byte_data;\n\n\tparameter IDLE = 4'd0;\n\tparameter START = 4'd1;\n\tparameter DATA0 = 4'd2;\n\tparameter DATA1 = 4'd3;\n\tparameter DATA2 = 4'd4;\n\tparameter DATA3 = 4'd5;\n\tparameter DATA4 = 4'd6;\n\tparameter DATA5 = 4'd7;\n\tparameter DATA6 = 4'd8;\n\tparameter DATA7 = 4'd9;\n\tparameter STOP = 4'd10;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_index <= 3'd0;\n\t\t\tout_byte <= 8'd0;\n\t\t\tbyte_data <= 8'd0;\n\t\t\tdone <= 1'b0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tdone <= 1'b0;\n\t\t\t\t\tif (in == 1'b0) begin\n\t\t\t\t\t\tstate <= START;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSTART: begin\n\t\t\t\t\tstate <= DATA0;\n\t\t\t\t\tbit_index <= 3'd0;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA0: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA1;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA1: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA2;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA2: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA3;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA3: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA4;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA4: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA5;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA5: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA6;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA6: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= DATA7;\n\t\t\t\t\tbit_index <= bit_index + 1;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tDATA7: begin\n\t\t\t\t\tbyte_data[bit_index] <= in;\n\t\t\t\t\tstate <= STOP;\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tSTOP: begin\n\t\t\t\t\tif (in == 1'b1) begin\n\t\t\t\t\t\tout_byte <= byte_data;\n\t\t\t\t\t\tdone <= 1'b1;\n\t\t\t\t\t\tstate <= IDLE;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tstate <= IDLE;  // Wait for next start bit\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\t\n\t\t\t\tdefault: state <= IDLE;\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    // Global history register\n    reg [6:0] GHR;\n    \n    // 128-entry Pattern History Table with 2-bit counters\n    reg [1:0] PHT [127:0];\n    \n    // Compute index for prediction\n    wire [6:0] predict_index = predict_pc ^ GHR;\n    // Compute index for training\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    // PHT state constants\n    localparam STRONGLY_NOT_TAKEN = 2'b00;\n    localparam WEAKLY_NOT_TAKEN   = 2'b01;\n    localparam WEAKLY_TAKEN       = 2'b10;\n    localparam STRONGLY_TAKEN     = 2'b11;\n\n    // Prediction logic\n    always @(*) begin\n        if(predict_valid) begin\n            predict_history = GHR; // Output the current history\n            case (PHT[predict_index])\n                STRONGLY_NOT_TAKEN, WEAKLY_NOT_TAKEN: predict_taken = 0;\n                WEAKLY_TAKEN, STRONGLY_TAKEN: predict_taken = 1;\n                default: predict_taken = 0;\n            endcase\n        end\n        else begin\n            predict_taken = 0; // Default\n            predict_history = GHR; // Default: keep current GHR state\n        end\n    end\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            GHR <= 0;\n        end\n        else if (train_valid) begin\n            // Update PHT\n            case (PHT[train_index])\n                STRONGLY_NOT_TAKEN:   if (train_taken) PHT[train_index] <= WEAKLY_NOT_TAKEN;\n                WEAKLY_NOT_TAKEN:     PHT[train_index] <= train_taken ? WEAKLY_TAKEN : STRONGLY_NOT_TAKEN;\n                WEAKLY_TAKEN:         PHT[train_index] <= train_taken ? STRONGLY_TAKEN : WEAKLY_NOT_TAKEN;\n                STRONGLY_TAKEN:       if (!train_taken) PHT[train_index] <= WEAKLY_TAKEN;\n            endcase\n            \n            // Update GHR\n            if (train_mispredicted) begin\n                GHR <= {train_history[5:0], train_taken};\n            end\n            else begin\n                GHR <= {GHR[5:0], predict_taken};\n            end\n        end\n        else if (predict_valid) begin\n            // Only update GHR if not mispredicted and predict_valid\n            GHR <= {GHR[5:0], predict_taken};\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n\t// States\n\ttypedef enum reg [2:0] {\n\t\tWALK_LEFT   = 3'b000,\n\t\tWALK_RIGHT  = 3'b001,\n\t\tFALL_LEFT   = 3'b010,\n\t\tFALL_RIGHT  = 3'b011,\n\t\tDIG_LEFT    = 3'b100,\n\t\tDIG_RIGHT   = 3'b101,\n\t\tSPLATTERED  = 3'b110\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\treg [4:0] fall_counter;  // 5-bit counter can count up to 31\n    \n    // Control fall counter\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            fall_counter <= 0;\n        else begin\n            if (current_state == FALL_LEFT || current_state == FALL_RIGHT)\n\t\t\t\tfall_counter <= fall_counter + 1;\n\t\t\telse\n\t\t\t\tfall_counter <= 0;\n        end\n    end\n\n    // State transition logic\n\talways @(*) begin\n        case (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t    next_state = FALL_LEFT;\n\t\t\t    else if (dig && ground)\n\t\t\t\t    next_state = DIG_LEFT;\n\t\t\t    else if (bump_left || bump_right)\n\t\t\t\t    next_state = WALK_RIGHT;\n\t\t\t    else\n\t\t\t\t    next_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t    next_state = FALL_RIGHT;\n\t\t\t    else if (dig && ground)\n\t\t\t\t    next_state = DIG_RIGHT;\n\t\t\t    else if (bump_right || bump_left)\n\t\t\t\t    next_state = WALK_LEFT;\n\t\t\t    else\n\t\t\t\t    next_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tFALL_LEFT: begin\n\t\t\t\tif (ground && fall_counter > 20)\n\t\t\t\t    next_state = SPLATTERED;\n\t\t\t    else if (ground)\n\t\t\t\t    next_state = WALK_LEFT;\n\t\t\t    else\n\t\t\t\t    next_state = FALL_LEFT;\n\t\t\tend\n\t\t\tFALL_RIGHT: begin\n\t\t\t\tif (ground && fall_counter > 20)\n\t\t\t\t    next_state = SPLATTERED;\n\t\t\t    else if (ground)\n\t\t\t\t    next_state = WALK_RIGHT;\n\t\t\t    else\n\t\t\t\t    next_state = FALL_RIGHT;\n\t\t\tend\n\t\t\tDIG_LEFT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t    next_state = FALL_LEFT;\n\t\t\t    else\n\t\t\t\t    next_state = DIG_LEFT;\n\t\t\tend\n\t\t\tDIG_RIGHT: begin\n\t\t\t\tif (!ground)\n\t\t\t\t    next_state = FALL_RIGHT;\n\t\t\t    else\n\t\t\t\t    next_state = DIG_RIGHT;\n\t\t\tend\n\t\t\tSPLATTERED: begin\n\t\t\t\tnext_state = SPLATTERED;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\t// State update\n\talways @(posedge clk or posedge areset) begin\n        if (areset)\n\t\t\tcurrent_state <= WALK_LEFT;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n    end\n\n\t// Output logic\n\talways @(*) begin\n        case (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tFALL_LEFT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 1;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tFALL_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 1;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\t\tDIG_LEFT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 1;\n\t\t\tend\n\t\t\tDIG_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 1;\n\t\t\tend\n\t\t\tSPLATTERED: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\t\tdigging = 0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'd0,    // Searching for sequence 1101\n        SHIFT = 3'd1,   // Shift 4 bits\n        COUNT = 3'd2,   // Waiting for counters to finish\n        DONE = 3'd3     // Notify user and wait for acknowledgment\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal shift register to detect `1101`\n    reg [3:0] shift_register;\n    reg [2:0] shift_counter; // Counter for 4 shift cycles\n\n    // Synchronous state and internal storage transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_register <= 4'd0;\n            shift_counter <= 3'd0;\n        end else begin\n            state <= next_state;\n\n            // Shift register updates for `1101` detection\n            if (state == IDLE)\n                shift_register <= {shift_register[2:0], data};\n            \n            // Shift counter updates to count 4 cycles\n            if (state == SHIFT)\n                shift_counter <= shift_counter + 1'b1;\n            else\n                shift_counter <= 3'd0; // Reset on other states\n        end\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default values for outputs\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                // Detect the `1101` pattern\n                if (shift_register == 4'b1101)\n                    next_state = SHIFT;\n                else\n                    next_state = IDLE;\n            end\n\n            SHIFT: begin\n                // Enable shifting for exactly 4 clock cycles\n                shift_ena = 1'b1;\n                if (shift_counter == 3'd3) // After 4 cycles\n                    next_state = COUNT;\n                else\n                    next_state = SHIFT;\n            end\n\n            COUNT: begin\n                // Wait for the `done_counting` signal\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = DONE;\n                else\n                    next_state = COUNT;\n            end\n\n            DONE: begin\n                // Notify the user and wait for acknowledgment\n                done = 1'b1;\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n\n            default: next_state = IDLE; // Default to IDLE state\n        endcase\n    end\n\nendmodule\n", "result": "failed: 486 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\ninteger i, j;\nreg [3:0] count;  // To store neighbor count for a cell\n\n// Define function to get the index with wrapping\nfunction automatic integer wrap_index(input integer index);\n    begin\n        wrap_index = (index + 16) % 16;  // Wrap index around 16 (for toroidal effect)\n    end\nendfunction\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;  // Load initial state\n    end else begin\n        // Compute next state\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                // Calculate indices of neighbors with wrapping\n                integer up = wrap_index(i-1);\n                integer down = wrap_index(i+1);\n                integer left = wrap_index(j-1);\n                integer right = wrap_index(j+1);\n                \n                // Count living neighbors\n                count = 0;\n                count = q[up*16+left] + q[up*16+j] + q[up*16+right] +\n                        q[i*16+left] + q[i*16+right] +\n                        q[down*16+left] + q[down*16+j] + q[down*16+right];\n                \n                // Calculate next state for cell (i,j)\n                case (count)\n                    2: q[i*16+j] <= q[i*16+j];   // No change, same state\n                    3: q[i*16+j] <= 1;           // Come to life\n                    default: q[i*16+j] <= 0;     // Becomes dead\n                endcase\n            end\n        end\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic [2:0] {\n\t\tLEFT    = 3'b000,  // walking left\n\t\tRIGHT   = 3'b001,  // walking right\n\t\tFALL_L  = 3'b010,  // falling from walking left\n\t\tFALL_R  = 3'b011,  // falling from walking right\n\t\tDIG_L   = 3'b100,  // digging while originally walking left\n\t\tDIG_R   = 3'b101   // digging while originally walking right\n\t} state_t;\n\n\tstate_t state, next_state;\n\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= LEFT;  // reset to initial state\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\talways_comb begin\n\t\t// Default Outputs\n\t\twalk_left = 0;\n\t\twalk_right = 0;\n\t\taaah = 0;\n\t\tdigging = 0;\n\t\n\t\t// State transition logic\n\t\tcase (state)\n\t\t\tLEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_L;\n\t\t\t\telse if (dig)\n\t\t\t\t\tnext_state = DIG_L;\n\t\t\t\telse if (bump_left)\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = LEFT;\n\t\t\tend\n\t\t\t\n\t\t\tRIGHT: begin\n\t\t\t\twalk_right = 1;\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_R;\n\t\t\t\telse if (dig)\n\t\t\t\t\tnext_state = DIG_R;\n\t\t\t\telse if (bump_right)\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\tend\n\n\t\t\tFALL_L: begin\n\t\t\t\taaah = 1;\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_L;\n\t\t\tend\n\n\t\t\tFALL_R: begin\n\t\t\t\taaah = 1;\n\t\t\t\tif (ground)\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_R;\n\t\t\tend\n\n\t\t\tDIG_L: begin\n\t\t\t\tdigging = 1;\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_L;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DIG_L;\n\t\t\tend\n\n\t\t\tDIG_R: begin\n\t\t\t\tdigging = 1;\n\t\t\t\tif (!ground)\n\t\t\t\t\tnext_state = FALL_R;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DIG_R;\n\t\t\tend\n\n\t\t\tdefault:\n\t\t\t\tnext_state = LEFT;\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // On reset, set the time to 12:00 AM\n            hh <= 8'b0001_0010; // BCD for 12\n            mm <= 8'b0000_0000; // BCD for 00\n            ss <= 8'b0000_0000; // BCD for 00\n            pm <= 0;            // Set to AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b0101_1001) begin // Check if seconds reach 59\n                ss <= 8'b0000_0000; // Reset seconds to 00\n                // Increment minutes\n                if (mm == 8'b0101_1001) begin // Check if minutes reach 59\n                    mm <= 8'b0000_0000; // Reset minutes to 00\n                    // Increment hours\n                    if (hh == 8'b0001_0010) begin // Check if hours reach 12\n                        hh <= 8'b0000_0001; // Reset hours to 1\n                        pm <= ~pm;          // Toggle AM/PM\n                    end else if (hh == 8'b0001_0001) begin // Check if hours reach 11 (transition to 12)\n                        hh <= 8'b0001_0010; // Set to 12\n                    end else begin\n                        hh <= hh + 8'b0000_0001; // Increment hours\n                    end\n                end else if (mm[3:0] == 4'b1001) begin // Check if minutes units reach 9\n                    mm <= {mm[7:4] + 4'b0001, 4'b0000}; // Increment tens part, reset units part\n                end else begin\n                    mm <= mm + 8'b0000_0001; // Increment minutes\n                end\n            end else if (ss[3:0] == 4'b1001) begin // Check if seconds units reach 9\n                ss <= {ss[7:4] + 4'b0001, 4'b0000}; // Increment tens part, reset units part\n            end else begin\n                ss <= ss + 8'b0000_0001; // Increment seconds\n            end\n        end\n    end\nendmodule\n", "result": "failed: 265552 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALL = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            FALL: begin\n                if (ground)\n                    next_state = (state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n    \n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset all BCD digits to zero\n            q <= 16'b0;\n        end else begin\n            // Default condition for enable signals\n            ena[1] <= (q[3:0] == 4'd9);\n            ena[2] <= (q[7:4] == 4'd9) && ena[1];\n            ena[3] <= (q[11:8] == 4'd9) && ena[2];\n\n            // BCD counting logic for each digit\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n            end else begin\n                q[3:0] <= q[3:0] + 4'd1;\n            end\n            \n            if (ena[1]) begin\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                end else begin\n                    q[7:4] <= q[7:4] + 4'd1;\n                end\n            end\n            \n            if (ena[2]) begin\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'd0;\n                end else begin\n                    q[11:8] <= q[11:8] + 4'd1;\n                end\n            end\n\n            if (ena[3]) begin\n                if (q[15:12] == 4'd9) begin\n                    q[15:12] <= 4'd0;\n                end else begin\n                    q[15:12] <= q[15:12] + 4'd1;\n                end\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n    \n    // Use a ternary operator to select between 'a' and 'b' based on 'sel'\n    assign out = sel ? b : a;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000: Y2 = 0; // A\n\t\t\t3'b001: Y2 = 1; // B\n\t\t\t3'b010: Y2 = (w) ? 1 : 0; // C\n\t\t\t3'b011: Y2 = (w) ? 0 : 1; // D\n\t\t\t3'b100: Y2 = 1; // E\n\t\t\t3'b101: Y2 = 1; // F\n\t\t\tdefault: Y2 = 0; // Default case for safety\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 11 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\n\t// Assign outputs based on the conditions\n\tassign motor = ring & vibrate_mode; // Motor is on when ring and vibrate_mode are both 1\n\tassign ringer = ring & ~vibrate_mode; // Ringer is on when ring is 1 and vibrate_mode is 0 \n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Using assign statement to implement AND gate\nassign out_assign = a & b;\n\n// Using combinational always block to implement AND gate\nalways @ (a or b) begin\n\tout_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\t\n      assign zero = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= ~q;  // Toggle q when a is 1\n        end\n        // No else needed because when a is 0, q remains the same\n    end\n    \nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// Define the state encoding\n\ttypedef enum logic [1:0] {\n\t\tIDLE = 2'b00,         // Initial state\n\t\tINVERT_BITS = 2'b01,  // State to invert the bits\n\t\tPASS_THROUGH = 2'b10  // After first 1 add and done complementing\n\t} state_t;\n\n\tstate_t state, next_state;\n\t\n\t// Synchronous state transition logic\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= IDLE;  // Reset to IDLE state\n\t\telse\n\t\t\tstate <= next_state;  // Transition to next state\n\tend\n\n\t// State transition and output logic\n\talways_comb begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state = PASS_THROUGH;\n\t\t\t\t\tz = 1;  // 2's complement start by inverting and then add 1: hence 1 is output\n\t\t\t\t} else begin\n\t\t\t\t\tnext_state = INVERT_BITS;\n\t\t\t\t\tz = 0;  // same bit as input until first 1 is encountered\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tINVERT_BITS: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state = PASS_THROUGH;\n\t\t\t\t\tz = 1;  // Meet the first 1, invert and then continue passing bits\n\t\t\t\t} else begin\n\t\t\t\t\tnext_state = INVERT_BITS;\n\t\t\t\t\tz = 1;  // Have not met 1 yet, inverting bits\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tPASS_THROUGH: begin\n\t\t\t\tnext_state = PASS_THROUGH;\n\t\t\t\tz = x;  // Just passing remaining bits directly.\n\t\t\tend\n\t\t\t\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // Define the states encoded in 2 bits\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n    \n    // Current and next state registers\n    reg state_t current_state, next_state;\n    \n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = (in == 1'b0) ? STATE_A : STATE_B;\n            STATE_B: next_state = (in == 1'b0) ? STATE_C : STATE_B;\n            STATE_C: next_state = (in == 1'b0) ? STATE_A : STATE_D;\n            STATE_D: next_state = (in == 1'b0) ? STATE_C : STATE_B;\n            default: next_state = STATE_A; // Default or undefined state\n        endcase\n    end\n    \n    // State register update with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b0;\n            STATE_C: out = 1'b0;\n            STATE_D: out = 1'b1;\n            default: out = 1'b0; // Default or undefined state\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\tassign out[31:24] = in[7:0];\n\tassign out[23:16] = in[15:8];\n\tassign out[15:8] = in[23:16];\n\tassign out[7:0] = in[31:24];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk) begin\n        if (r) begin\n            q <= 1'b0; // synchronous reset\n        end else begin\n            q <= d; // capture input d\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // Use wire to store intermediate results\n    wire xor_result;\n    \n    // First, compute x XOR y\n    assign xor_result = x ^ y;\n    \n    // Then, compute (x XOR y) AND x\n    assign z = xor_result & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data; // Load data\n\t\tend\n\t\telse if (ena) begin\n\t\t\tcase(amount)\n\t\t\t\t2'b00: q <= q << 1; // Shift left by 1 bit\n\t\t\t\t2'b01: q <= q << 8; // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00,  // Initial state\n        S1 = 2'b01,  // Recognized \"1\"\n        S2 = 2'b10   // Recognized \"10\"\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        z = 1'b0;\n        \n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n            end\n            \n            S1: begin\n                if (!x)\n                    next_state = S2;\n                // Remain in S1 if x is 1\n            end\n            \n            S2: begin\n                if (x) begin\n                    next_state = S1;  // Transition from S2 to S1 when x is 1\n                    z = 1'b1;  // Recognizing \"101\"\n                end else begin\n                    next_state = S0;  // Go back to S0 if x is 0\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic (combinational)\n    always @(*) begin\n        case (state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A; // In case of invalid state, reset to A\n        endcase\n    end\n\n    // Sequential state update logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A; // Reset to state A\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A, B, C, D: z = 1'b0;\n            E, F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    typedef enum reg [1:0] {WAIT_FOR_START, BYTE_1, BYTE_2, BYTE_3} state_t;\n    state_t state, next_state;\n    reg [7:0] byte1, byte2, byte3;\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            WAIT_FOR_START: next_state = (in[3] == 1'b1) ? BYTE_1 : WAIT_FOR_START;\n            BYTE_1: next_state = BYTE_2;\n            BYTE_2: next_state = BYTE_3;\n            BYTE_3: next_state = WAIT_FOR_START;\n            default: next_state = WAIT_FOR_START;\n        endcase\n    end\n\n    // State update and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_FOR_START;\n            done <= 0;\n            out_bytes <= 24'b0;\n        end else begin\n            state <= next_state;\n            case(state)\n                WAIT_FOR_START: done <= 0;\n                BYTE_1: begin\n                    byte1 <= in;\n                    done <= 0;\n                end\n                BYTE_2: begin\n                    byte2 <= in;\n                    done <= 0;\n                end\n                BYTE_3: begin\n                    byte3 <= in;\n                    done <= 1;\n                    out_bytes <= {byte1, byte2, byte3};\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    // Y1 logic: Transition to state B\n    assign Y1 = y[0] & w;\n\n    // Y3 logic: Transition to state D\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Assign the entire vector to outv\n    assign outv = vec;\n    \n    // Assign each individual bit to the corresponding outputs\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n    out = (c & ~d) | (~c & d) | (~a & b & d) | (a & ~b & ~d);\nend\n\nendmodule\n", "result": "failed: 111 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\n    // Assign upper byte of the input to out_hi\n    assign out_hi = in[15:8];\n    \n    // Assign lower byte of the input to out_lo\n    assign out_lo = in[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n    // Perform OR operation and then NOT operation\n    assign out = ~(a | b);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n    // Method 1: Using assign statement\n    assign out_assign = a ^ b;\n\n    // Method 2: Using always block for combinational logic\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Method 3: Using always block for clocked logic\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\n    // Logic equations based on one-hot encoding and state transitions\n    assign Y2 = y[1] & ~w;   // Transition from state A to B on w = 0\n    assign Y4 = (y[2] | y[3] | y[5] | y[6]) & w; // Transitions to D on w = 1 from B, C, E, and F\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\nassign out = in[sel];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R;  // Load operation\n\t\tend \n\t\telse if (E) begin\n\t\t\tQ <= w;  // Shift operation\n\t\tend\n\t\t// Else case is implicit, retaining the value of Q\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    reg q1, q2, q3; // D flip-flops\n\n    // Compute the values to be stored in the flip-flops in the next clock cycle\n    wire d1 = x ^ q1;         // XOR gate\n    wire d2 = x & ~q2;        // AND gate\n    wire d3 = x | ~q3;        // OR gate\n    \n    // D flip-flops update their values on the positive edge of the clock\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n\n    // Output z is the result of three-input XNOR gate of current flip-flop outputs\n    assign z = ~(q1 ^ q2 ^ q3);\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (~a & c) | (a & b) | (a & ~b & c);\nendmodule\n", "result": "failed: 12 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tinteger i;\n\t\t\treg [511:0] next_q;\n\t\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\t\tcase ({(i == 0 ? 0 : q[i-1]), q[i], (i == 511 ? 0 : q[i+1])})\n\t\t\t\t\t3'b111: next_q[i] = 0;\n\t\t\t\t\t3'b110: next_q[i] = 1;\n\t\t\t\t\t3'b101: next_q[i] = 1;\n\t\t\t\t\t3'b100: next_q[i] = 0;\n\t\t\t\t\t3'b011: next_q[i] = 1;\n\t\t\t\t\t3'b010: next_q[i] = 1;\n\t\t\t\t\t3'b001: next_q[i] = 1;\n\t\t\t\t\t3'b000: next_q[i] = 0;\n\t\t\t\t\tdefault: next_q[i] = 0; // Handles undefined cases, though there shouldn't be any\n\t\t\t\tendcase\n\t\t\tend\n\t\t\tq <= next_q;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // Define states using parameters\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;    // Reset state to A\n        end else begin\n            state <= next_state;    // Transition to next state\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in) next_state = B;\n                else next_state = A;\n            end\n            B: begin\n                if (in) next_state = B;\n                else next_state = C;\n            end\n            C: begin\n                if (in) next_state = D;\n                else next_state = A;\n            end\n            D: begin\n                if (in) next_state = B;\n                else next_state = C;\n            end\n            default: next_state = A;    // Default case\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @(*) begin\n\tcase (c)\n\t\t4'd0: q = b;\n\t\t4'd1: q = e;\n\t\t4'd2: q = a;\n\t\t4'd3: q = d;\n\t\tdefault: q = 4'd15; // `f` translates to 15 in 4-bit binary representation\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n  \nalways @(posedge clk) begin\n    if (L) begin\n        Q <= r_in;\n    end else begin\n        Q <= q_in;\n    end\nend\n\nendmodule\n\n// Define the top module\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] r,  // r_in for three instances\n    output [2:0] q  // Q output for three instances\n);\n  \n// Wire declarations to connect submodules\nwire q0_in, q1_in, q2_in;\n\n// Initial values to wire connections\nassign q0_in = q[1] ^ q[2];\nassign q1_in = q[0];\nassign q2_in = q[2];\n\n// Instantiate three ff_mux submodules\nff_mux u0 (\n    .clk(clk),\n    .L(L),\n    .q_in(q0_in),\n    .r_in(r[0]),\n    .Q(q[0])\n);\n  \nff_mux u1 (\n    .clk(clk),\n    .L(L),\n    .q_in(q1_in),\n    .r_in(r[1]),\n    .Q(q[1])\n);\n  \nff_mux u2 (\n    .clk(clk),\n    .L(L),\n    .q_in(q2_in),\n    .r_in(r[2]),\n    .Q(q[2])\n);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    // Internal register to store the previous state of 'in'\n    reg [31:0] in_prev;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the output when reset is high\n            out <= 32'b0;\n        end else begin\n            // Detect falling edge transition (1 to 0)\n            out <= out | (in_prev & ~in);\n        end\n        // Store current input state for the next cycle comparison\n        in_prev <= in;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n    // Perform the addition\n    assign s = a + b;\n\n    // Check for overflow\n    // overflow = ((a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]))\n    assign overflow = ((a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]));\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // Next-state logic for each state\n    assign B3_next = state[7];  // B3 always transitions to Count\n    assign S_next = state[1] ? !d :       // S1 -> S on d=0\n                    state[3] ? !d :       // S11 -> S on d=0\n                    state[4] ? !d :       // S110 -> S on d=0\n                    state[9] ? ack :      // Wait -> S on ack=1\n                    state[0];             // S -> S on d=0\n    \n    assign S1_next = state[0] & d;        // S -> S1 on d=1\n    assign Count_next = state[8] & !done_counting; // Count -> Count if not done_counting\n    assign Wait_next = (state[8] & done_counting) | // Count -> Wait if done_counting\n                       state[9] & !ack;             // Wait -> Wait if ack=0\n    \n    // Output logic based on current state\n    assign done = state[9];   // Wait state has done=1\n    assign counting = state[8];   // Count state has counting=1\n    assign shift_ena = state[4] | state[5] | state[6] | state[7];   // B0, B1, B2, B3 have shift_ena=1\n\nendmodule\n", "result": "failed: 2293 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) begin\n                    state <= state + 2'b01;  // Increment up to maximum 3\n                end\n            end else begin\n                if (state > 2'b00) begin\n                    state <= state - 2'b01;  // Decrement down to minimum 0\n                end\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @(*) begin\n        if (in[0])\n            pos = 3'd0;\n        else if (in[1])\n            pos = 3'd1;\n        else if (in[2])\n            pos = 3'd2;\n        else if (in[3])\n            pos = 3'd3;\n        else if (in[4])\n            pos = 3'd4;\n        else if (in[5])\n            pos = 3'd5;\n        else if (in[6])\n            pos = 3'd6;\n        else if (in[7])\n            pos = 3'd7;\n        else\n            pos = 3'd0; // No bits are high\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n    // Default values\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    // Internal signals for carry between stages\n    wire c1, c2, c3, c4;\n\n    // Instantiate four full adders to calculate each bit's sum and carry\n    full_adder fa0 (\n        .a(x[0]),\n        .b(y[0]),\n        .cin(1'b0), // Initial carry-in is 0\n        .sum(sum[0]),\n        .cout(c1)\n    );\n\n    full_adder fa1 (\n        .a(x[1]),\n        .b(y[1]),\n        .cin(c1), // Carry from previous stage\n        .sum(sum[1]),\n        .cout(c2)\n    );\n\n    full_adder fa2 (\n        .a(x[2]),\n        .b(y[2]),\n        .cin(c2), // Carry from previous stage\n        .sum(sum[2]),\n        .cout(c3)\n    );\n\n    full_adder fa3 (\n        .a(x[3]),\n        .b(y[3]),\n        .cin(c3), // Carry from previous stage\n        .sum(sum[3]),\n        .cout(c4)\n    );\n\n    // Assign final carry-out as the overflow bit\n    assign sum[4] = c4;\n\nendmodule\n\n// Full adder module definition\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;       // XOR the inputs to get the sum bit\n    assign cout = (a & b) | (a & cin) | (b & cin); // Compute carry-out\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;  // Reset history to zeros on asynchronous reset\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};  // Load corrected history on misprediction\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};  // Shift in prediction result\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\t// Intermediate wires to hold the outputs of the AND gates\n\twire and_ab, and_cd;\n\t\n\t// AND gates\n\tassign and_ab = a & b;\n\tassign and_cd = c & d;\n\t\n\t// OR gate\n\tassign out = and_ab | and_cd;\n\t\n\t// NOT gate to generate the inverted output\n\tassign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\n\t// Define a register to store the outputs of the shift register\n\treg [7:0] Q;\n\n\t// Shift register logic\n\talways @(posedge clk) begin\n\t\tif (enable) begin\n\t\t\tQ <= {S, Q[7:1]}; // Shift in `S` to MSB and shift other bits right\n\t\tend\n\tend\n\n\t// Multiplexer logic\n\talways @(*) begin\n\t\tcase ({A, B, C}) // Case statement to select output based on A, B, C\n\t\t\t3'b000: Z = Q[0];\n\t\t\t3'b001: Z = Q[1];\n\t\t\t3'b010: Z = Q[2];\n\t\t\t3'b011: Z = Q[3];\n\t\t\t3'b100: Z = Q[4];\n\t\t\t3'b101: Z = Q[5];\n\t\t\t3'b110: Z = Q[6];\n\t\t\t3'b111: Z = Q[7];\n\t\t\tdefault: Z = 1'b0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    // Determine heater status: Only on in heating mode and if too_cold is high\n    assign heater = mode & too_cold;\n\n    // Determine air conditioner status: Only on in cooling mode and if too_hot is high\n    assign aircon = ~mode & too_hot;\n\n    // Determine fan status: Fan turns on if heater or aircon is on, or if fan_on is high\n    assign fan = heater | aircon | fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n    // Minimum Sum-of-Products (SOP) form\n    assign out_sop = (~a & b & ~c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Minimum Product-of-Sums (POS) form\n    assign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) &\n                     (a | ~b | ~c | d) & (~a | b | c | ~d) & (~a | b | ~c | d) & (~a | ~b | c | ~d) &\n                     (~a | b | ~c | d);\n\nendmodule\n", "result": "failed: 36 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // reset value\n        end else begin\n            // Compute the feedback bit, based on the Galois LFSR taps\n            // Note: bit_positions are 31, 21, 1, 0 due to 0-indexing in the array\n            q <= { q[30], q[29], q[28], q[27], q[26], q[25], q[24], q[23], q[22] ^ q[31], q[21],\n                   q[20], q[19], q[18], q[17], q[16], q[15], q[14], q[13], q[12], q[11], q[10],\n                   q[9], q[8], q[7], q[6], q[5], q[4], q[3], q[2], q[1] ^ q[31], q[0] ^ q[31] };\n        end\n    end\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (b & d) | (a & (c | d));\nendmodule\n", "result": "failed: 7 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Implementing the 4-input NAND gates\n    // The output will be 0 only if all inputs are 1, otherwise, it will be 1.\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n    integer i; // Integer to use in the loop\n    always @(*) begin\n        out = 8'b0; // Initialize the counting result\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Add the value of each bit to the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\nassign out_both[2] = in[2] & in[3];\nassign out_both[1] = in[1] & in[2];\nassign out_both[0] = in[0] & in[1];\n\nassign out_any[3] = in[3] | in[2];\nassign out_any[2] = in[2] | in[1];\nassign out_any[1] = in[1] | in[0];\n\nassign out_different[3] = in[3] ^ in[0];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000; // Should never happen with 3-bit input\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\t// Always block triggered on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// Synchronous reset: when reset is high, set q to 0\n\t\t\tq <= 4'd0;\n\t\tend\n\t\telse if (slowena) begin\n\t\t\t// Increment counter only if slowena is high\n\t\t\tif (q == 4'd9) begin\n\t\t\t\tq <= 4'd0; // Wrap back to 0 if q reaches 9\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tq <= q + 4'd1; // Increment counter\n\t\t\tend\n\t\tend\n\t\t// If slowena is low, retain the current value of q\n\t\t// No explicit action required as q holds its value\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t// Invert the input in2\n\tlogic in2_inv;\n\tassign in2_inv = ~in2;\n\n\t// AND gate\n\tassign out = in1 & in2_inv;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Assigning the output value to the input value combinationally\n    assign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tA = 2'b00,\n\t\tB = 2'b01\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tA: next_state = (in) ? A : B;\n\t\t\tB: next_state = (in) ? B : A;\n\t\tendcase\n\tend\n\n\t// State transition logic with asynchronous reset\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tcurrent_state <= B; // Reset to state B\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Output logic based on current state\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tA: out = 0;\n\t\t\tB: out = 1;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    // Internal registers to store values for each edge\n    reg q_pos, q_neg;\n\n    always @(posedge clk) begin\n        // Update on posedge clock\n        q_pos <= d;\n        q <= d;\n    end\n\n    always @(negedge clk) begin\n        // Update on negedge clock\n        q_neg <= d;\n        q <= d;  // Output is updated on both edges\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a ~^ b; // This performs the XNOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Submodule A implementing z = (x^y) & x\n    module A(\n        input x,\n        input y,\n        output z\n    );\n        assign z = (x ^ y) & x;\n    endmodule\n    \n    // Submodule B based on the waveform provided\n    module B(\n        input x,\n        input y,\n        output z\n    );\n        assign z = (x ~^ y);\n    endmodule\n    \n    // Wires for connecting outputs of submodules to gates\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n    \n    // Instantiate two submodules A\n    A A1 (.x(x), .y(y), .z(a1_out));\n    A A2 (.x(x), .y(y), .z(a2_out));\n    \n    // Instantiate two submodules B\n    B B1 (.x(x), .y(y), .z(b1_out));\n    B B2 (.x(x), .y(y), .z(b2_out));\n    \n    // OR gate for first A and first B outputs\n    assign or_out = a1_out | b1_out;\n    \n    // AND gate for second A and second B outputs\n    assign and_out = a2_out & b2_out;\n    \n    // XOR gate for the outputs of OR and AND gates\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;  // Load data into register\n\t\tend\n\t\telse begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: q <= {q[0], q[99:1]};   // Rotate right\n\t\t\t\t2'b10: q <= {q[98:0], q[99]};  // Rotate left\n\t\t\t\tdefault: q <= q;               // No operation\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'b0; // Reset counter to zero\n        end else if (q == 10'd999) begin\n            q <= 10'b0; // Wrap around to zero after reaching 999\n        end else begin\n            q <= q + 1; // Increment counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Implementing the NOT gate\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Initialize outputs\n\t\tout1 = 0;\n\t\tout2 = 0;\n\n\t\t// Default next_state is all zeros\n\t\tnext_state = 10'b0;\n\n\t\t// State transitions\n\t\tcase (1'b1) // because this is a one-hot encoding, only one bit in state is high\n\t\t\tstate[0]: begin // S0\n\t\t\t\tif (in) next_state[1] = 1; // S1\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[1]: begin // S1\n\t\t\t\tif (in) next_state[2] = 1; // S2\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[2]: begin // S2\n\t\t\t\tif (in) next_state[3] = 1; // S3\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[3]: begin // S3\n\t\t\t\tif (in) next_state[4] = 1; // S4\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[4]: begin // S4\n\t\t\t\tif (in) next_state[5] = 1; // S5\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[5]: begin // S5\n\t\t\t\tif (in) next_state[6] = 1; // S6\n\t\t\t\telse    next_state[8] = 1; // S8\n\t\t\tend\n\t\t\tstate[6]: begin // S6\n\t\t\t\tif (in) next_state[7] = 1; // S7\n\t\t\t\telse    next_state[9] = 1; // S9\n\t\t\tend\n\t\t\tstate[7]: begin // S7\n\t\t\t\tout2 = 1;\n\t\t\t\tif (in) next_state[7] = 1; // S7\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[8]: begin // S8\n\t\t\t\tout1 = 1;\n\t\t\t\tif (in) next_state[1] = 1; // S1\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tstate[9]: begin // S9\n\t\t\t\tout1 = 1;\n\t\t\t\tout2 = 1;\n\t\t\t\tif (in) next_state[1] = 1; // S1\n\t\t\t\telse    next_state[0] = 1; // S0\n\t\t\tend\n\t\t\tdefault: next_state = 10'b0; // Safe default state if needed\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // Retains its previous value\n            2'b01: Q <= 0;       // Reset to 0\n            2'b10: Q <= 1;       // Set to 1\n            2'b11: Q <= ~Q;      // Toggle its value\n        endcase\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\n    // Count the number of '1's in the input vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\t// State definitions\n\ttypedef enum reg [1:0] {LEFT = 2'b00, RIGHT = 2'b01} state_t;\n\tstate_t state, next_state;\n\n\t// Asynchronous reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= LEFT;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tLEFT: begin\n\t\t\t\tif (bump_left || bump_right) begin\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\tend\n\t\t\tend \n\t\t\tRIGHT: begin\n\t\t\t\tif (bump_left || bump_right) begin\n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = LEFT;  // Default state for safety\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tLEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\tend \n\t\t\tRIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\twalk_left = 1;  // Default state for safety\n\t\t\t\twalk_right = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\n    assign q = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Internal wires for the AND gate outputs\n    wire and1_out, and2_out, and3_out, and4_out;\n\n    // First 3-input AND gate for p1y\n    assign and1_out = p1a & p1b & p1c;\n\n    // Second 3-input AND gate for p1y\n    assign and2_out = p1d & p1e & p1f;\n\n    // OR gate to produce p1y\n    assign p1y = and1_out | and2_out;\n\n    // First 2-input AND gate for p2y\n    assign and3_out = p2a & p2b;\n\n    // Second 2-input AND gate for p2y\n    assign and4_out = p2c & p2d;\n\n    // OR gate to produce p2y\n    assign p2y = and3_out | and4_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        case (y)\n            3'b000: Y0 <= x ? 1'b1 : 1'b0;\n            3'b001: Y0 <= x ? 1'b0 : 1'b1;\n            3'b010: Y0 <= x ? 1'b1 : 1'b0;\n            3'b011: Y0 <= x ? 1'b0 : 1'b1;\n            3'b100: Y0 <= x ? 1'b0 : 1'b1;\n            default: Y0 <= 1'b0;\n        endcase\n\n        case (y)\n            3'b011: z <= 1'b1;\n            3'b100: z <= 1'b1;\n            default: z <= 1'b0;\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n    // Implementing the NOR operation\n    assign out = ~(in1 | in2);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n\t// Connecting inputs to outputs\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n\talways_ff @(posedge clk or posedge ar) begin\n\t\tif (ar) begin\n\t\t\tq <= 0; // Asynchronous reset\n\t\tend else begin\n\t\t\tq <= d; // Capture data on positive edge of clock\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\nalways @(*) begin\n    case (sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000; // output 0 when sel is not between 0 and 5\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with data\n            counter <= data;\n        end else if (counter > 0) begin\n            // Decrement the counter if it is greater than 0\n            counter <= counter - 1;\n        end\n        // If counter is 0, it should remain 0\n    end\n\n    // Terminal count is high when the counter is 0\n    assign tc = (counter == 0);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tIDLE = 3'b000,\n\t\tS1 = 3'b001,\n\t\tS11 = 3'b010,\n\t\tS110 = 3'b011,\n\t\tFOUND = 3'b100\n\t} state_t;\n\n\t// State registers\n\treg [2:0] current_state, next_state;\n\n\t// State transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tif (data) next_state = S1;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (data) next_state = S11;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tS11: begin\n\t\t\t\tif (!data) next_state = S110;\n\t\t\t\telse next_state = S1;\n\t\t\tend\n\t\t\tS110: begin\n\t\t\t\tif (data) next_state = FOUND;\n\t\t\t\telse next_state = IDLE;\n\t\t\tend\n\t\t\tFOUND: begin\n\t\t\t\tnext_state = FOUND;\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstart_shifting <= 0;\n\t\tend else if (current_state == FOUND) begin\n\t\t\tstart_shifting <= 1;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0;  // Set output to zero when reset is active high\n\t\tend else begin\n\t\t\tq <= d;  // Transfer input to output on positive edge of clk\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Detect any edge (0 -> 1 transition) and set output\n        anyedge <= (~prev_in) & in;\n        // Update previous state\n        prev_in <= in;\n    end\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001; // Reset the counter to 1\n\t\tend else begin\n\t\t\tif (q == 4'b1010) begin // If the counter reaches 10\n\t\t\t\tq <= 4'b0001; // Wrap around to 1\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (a == 1) begin\n            q <= 3'b100; // hold q at 4 when a is 1\n        end\n        else begin\n            if (q == 3'b110) begin\n                q <= 3'b000; // reset to 0 when q reaches 6\n            end\n            else begin\n                q <= q + 1; // increment q\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset state, ensure non-zero initial value\n        end\n        else begin\n            // Implementing the Galois LFSR logic with taps at bit[4] and bit[2]\n            q <= {q[3:0], q[4] ^ q[2]};\n        end\n    end\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n    always @(*) begin\n        // Determine the output based on the operation (addition or subtraction)\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Check if the output is zero\n        if (out == 8'b0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        f = x[3]; // After simplifying the K-map using minimal minterms\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    assign out[7] = in[0];\n    assign out[6] = in[1];\n    assign out[5] = in[2];\n    assign out[4] = in[3];\n    assign out[3] = in[4];\n    assign out[2] = in[5];\n    assign out[1] = in[6];\n    assign out[0] = in[7];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\talways @(*) begin\n\t\tout = (c & ~d & a & ~b) | (~c & ~d & a) | (c & d) | (b & d);\n\tend\nendmodule\n", "result": "failed: 57 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data in, MSB first\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement the current value in the register\n            q <= q - 1;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\nassign out = in; // Direct assign statement for the wire behavior\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n\t// FSM states\n\ttypedef enum logic [1:0] {\n\t\tIDLE,\n\t\tSHIFT\n\t} state_t;\n\n\t// Current and next state variables\n\tstate_t current_state, next_state;\n\t// Counter to track the number of cycles in the SHIFT state\n\treg [2:0] shift_counter;\n\n\t// Synchronous process to handle state transitions and counter\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= SHIFT;\n\t\t\tshift_counter <= 3'd0;\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tif (current_state == SHIFT)\n\t\t\t\tshift_counter <= shift_counter + 3'd1;\n\t\t\telse\n\t\t\t\tshift_counter <= 3'd0;\n\t\tend\n\tend\n\n\t// Combinational process to determine next state and shift_ena output\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tshift_ena = 1'b0;\n\t\t\t\tif (reset)\n\t\t\t\t\tnext_state = SHIFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tSHIFT: begin\n\t\t\t\tshift_ena = 1'b1;\n\t\t\t\tif (shift_counter == 3'd3)\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\telse\n\t\t\t\t\tnext_state = SHIFT;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tshift_ena = 1'b0;\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Reset the counter to 0\n        end else begin\n            q <= q + 4'd1; // Increment the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using always block with if statement for procedural implementation\n    always @(*) begin\n        if (sel_b1 & sel_b2) begin\n            out_always = b;\n        end else begin\n            out_always = a;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\nassign out = a | b | (~b & c);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_D: begin\n                if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // State flip flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Output logic\n    assign g[1] = (current_state == STATE_B);\n    assign g[2] = (current_state == STATE_C);\n    assign g[3] = (current_state == STATE_D);\n\nendmodule\n", "result": "failed: 4 out of 1054 samples.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // If reset is high, set q to 0\n\t\tend else begin\n\t\t\tif (q == 4'b1001) begin // If q is at 9\n\t\t\t\tq <= 4'b0000; // Reset q to 0\n\t\t\tend else begin\n\t\t\t\tq <= q + 4'b0001; // Increment q by 1\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // Define states using localparams for readability.\n    localparam IDLE  = 2'b00;\n    localparam BYTE1 = 2'b01;\n    localparam BYTE2 = 2'b10;\n    localparam BYTE3 = 2'b11;\n\n    // State register to hold the current state\n    reg [1:0] state, next_state;\n\n    // Sequential logic for the state transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for the next state and output signal\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                done = 1'b1; // Signal that a complete message has been received\n                next_state = IDLE; // Return to idle state\n            end\n            default: begin\n                // Should never reach here\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\n    assign out = sel ? b : a;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Perform 4-input AND operation\n    assign out_and = &in;\n    \n    // Perform 4-input OR operation\n    assign out_or = |in;\n    \n    // Perform 4-input XOR operation\n    assign out_xor = ^in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // State encoding\n    localparam S0 = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, S4 = 3'b100;\n\n    reg [2:0] state, next_state;\n\n    // State transition and output logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                next_state = x ? S1 : S0;\n                z = 0;\n            end\n            S1: begin\n                next_state = x ? S4 : S1;\n                z = 0;\n            end\n            S2: begin\n                next_state = x ? S1 : S2;\n                z = 0;\n            end\n            S3: begin\n                next_state = x ? S2 : S1;\n                z = 1;\n            end\n            S4: begin\n                next_state = x ? S4 : S3;\n                z = 1;\n            end\n            default: begin\n                next_state = S0;\n                z = 0;\n            end\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_E = 3'b100\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg [1:0] x_pattern; // To monitor the sequence of 'x'\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            current_state <= STATE_A;\n            x_pattern <= 2'b00;\n        end else begin\n            current_state <= next_state;\n            if (current_state == STATE_C) x_pattern <= {x_pattern[0], x};\n        end\n    end\n\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        f = 0;\n        g = 0;\n        \n        case (current_state)\n            STATE_A: begin\n                if (resetn) next_state = STATE_B;\n            end\n\n            STATE_B: begin\n                f = 1;\n                next_state = STATE_C;\n            end\n\n            STATE_C: begin\n                if (x_pattern == 2'b01 && x) begin\n                    next_state = STATE_D;\n                end\n            end\n\n            STATE_D: begin\n                g = 1;\n                if (y) next_state = STATE_E; // Transition to state E and keep g = 1\n                else if (y == 0 && current_state == STATE_D) next_state = STATE_E;\n            end\n            \n            STATE_E: begin\n                g = 1; // Remain stable in E after confirming y\n            end\n\n            default: next_state = STATE_A;\n        endcase \n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 8'h34;  // 0x34 in hexadecimal\n\t\telse\n\t\t\tq <= d;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    \n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\n    // Output logic based on the current state in a Moore state machine\n    assign out = (state == 2'b11) ? 1 : 0;\n\n    always @(*) begin\n        // State transition logic based on current state and input\n        case (state)\n            2'b00: begin // State A\n                if (in == 1) \n                    next_state = 2'b01; // Transition to State B\n                else \n                    next_state = 2'b00; // Remain in State A\n            end\n            2'b01: begin // State B\n                if (in == 1) \n                    next_state = 2'b01; // Remain in State B\n                else \n                    next_state = 2'b10; // Transition to State C\n            end\n            2'b10: begin // State C\n                if (in == 1) \n                    next_state = 2'b11; // Transition to State D\n                else \n                    next_state = 2'b00; // Transition to State A\n            end\n            2'b11: begin // State D\n                if (in == 1) \n                    next_state = 2'b01; // Transition to State B\n                else \n                    next_state = 2'b10; // Transition to State C\n            end\n            default: begin\n                next_state = 2'b00; // Default safe state option\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    assign z = (~x & ~y) | (x & y);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// State Encoding\n\tlocalparam [2:0] A = 3'b000,\n\t                 B = 3'b001,\n\t                 C = 3'b010,\n\t                 D = 3'b011,\n\t                 E = 3'b100,\n\t                 F = 3'b101;\n\n\treg [2:0] current_state, next_state;\n\n\t// State flip-flops\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tcurrent_state <= A;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// State transition logic (state table)\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: next_state = (w ? B : A);\n\t\t\tB: next_state = (w ? C : D);\n\t\t\tC: next_state = (w ? E : D);\n\t\t\tD: next_state = (w ? F : A);\n\t\t\tE: next_state = (w ? E : D);\n\t\t\tF: next_state = (w ? C : D);\n\t\t\tdefault: next_state = A; // Default or safe state\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tE, F: z = 1'b1;\n\t\t\tdefault: z = 1'b0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Active low reset: when resetn is 0, reset q to 0\n            q <= 16'b0;\n        end\n        else begin\n            if (byteena[1]) begin\n                // Update upper byte only if byteena[1] is asserted\n                q[15:8] <= d[15:8];\n            end\n            if (byteena[0]) begin\n                // Update lower byte only if byteena[0] is asserted\n                q[7:0] <= d[7:0];\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n\t// Register to hold the previous state of the input\n\treg [7:0] prev_in;\n\n\talways @(posedge clk) begin\n\t\t// Iterate over each bit to check for 0-to-1 transition\n\t\tfor (integer i = 0; i < 8; i = i + 1) begin\n\t\t\tif (prev_in[i] == 0 && in[i] == 1) begin\n\t\t\t\tpedge[i] <= 1;\n\t\t\tend else begin\n\t\t\t\tpedge[i] <= 0;\n\t\t\tend\n\t\tend\n\t\t\n\t\t// Update prev_in with the current state\n\t\tprev_in <= in;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\n    // Always block for rising edge of clock to capture p\n    always @(posedge clock) begin\n        p <= a;\n    end\n    \n    // Always block for falling edge of clock to capture q\n    always @(negedge clock) begin\n        q <= p;\n    end\n\nendmodule\n", "result": "failed: 138 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tinteger i;\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\t// Temporary array holding the next state of the system\n\t\t\treg [511:0] next_q;\n\t\t\t// Update each cell according to Rule 90\n\t\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\t\tif (i == 0) begin\n\t\t\t\t\t// First cell (no left neighbor, assume 0)\n\t\t\t\t\tnext_q[i] = 0 ^ q[1];\n\t\t\t\tend else if (i == 511) begin\n\t\t\t\t\t// Last cell (no right neighbor, assume 0)\n\t\t\t\t\tnext_q[i] = q[510] ^ 0;\n\t\t\t\tend else begin\n\t\t\t\t\t// All other cells\n\t\t\t\t\tnext_q[i] = q[i-1] ^ q[i+1];\n\t\t\t\tend\n\t\t\tend\n\t\t\t// Update the current state\n\t\t\tq <= next_q;\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n    assign z = (A[1] == B[1]) && (A[0] == B[0]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n\t// Calculate out_both: in[i] & in[i+1] for i from 0 to 98\n\tgenvar i;\n\tgenerate\n\t\tfor (i=0; i<99; i=i+1) begin: gen_out_both\n\t\t\tassign out_both[i] = in[i] & in[i+1];\n\t\tend\n\tendgenerate\n\t\n\t// Calculate out_any: in[i] | in[i-1] for i from 1 to 99\n\tgenerate\n\t\tfor (i=1; i<100; i=i+1) begin: gen_out_any\n\t\t\tassign out_any[i] = in[i] | in[i-1];\n\t\tend\n\tendgenerate\n\t\n\t// Calculate out_different: in[i] ^ in[(i+1)%100] for i from 0 to 99\n\tgenerate\n\t\tfor (i=0; i<100; i=i+1) begin: gen_out_different\n\t\t\tassign out_different[i] = in[i] ^ in[(i+1)%100];\n\t\tend\n\tendgenerate\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n    always @(d or ena) begin\n        if (ena) begin\n            q = d;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\n    assign out = in[sel*4 +: 4];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // For sel=9 to 15\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR\n    assign out_or_logical = |a | |b;\n    \n    // Bitwise NOT and concatenation\n    assign out_not = {~b, ~a};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\n    // Combinational logic for state transition\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001;  // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100;  // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001;  // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100;  // State D\n            default: next_state = 4'b0001;                 // Reset to State A if an invalid state\n        endcase\n    end\n\n    // Combinational logic for output\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0;  // Output is 1 when in State D\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\n\talways @(*) begin\n\t\treg [7:0] min_ab;\n\t\treg [7:0] min_abc;\n\n\t\t// Find minimum of a and b\n\t\tif (a < b)\n\t\t\tmin_ab = a;\n\t\telse\n\t\t\tmin_ab = b;\n\n\t\t// Find minimum of min_ab and c\n\t\tif (min_ab < c)\n\t\t\tmin_abc = min_ab;\n\t\telse\n\t\t\tmin_abc = c;\n\n\t\t// Find minimum of min_abc and d\n\t\tif (min_abc < d)\n\t\t\tmin = min_abc;\n\t\telse\n\t\t\tmin = d;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n\tassign out_and = a & b;       // AND gate operation\n\tassign out_or = a | b;        // OR gate operation\n\tassign out_xor = a ^ b;       // XOR gate operation\n\tassign out_nand = ~(a & b);   // NAND gate operation\n\tassign out_nor = ~(a | b);    // NOR gate operation\n\tassign out_xnor = ~(a ^ b);   // XNOR gate operation\n\tassign out_anotb = a & ~b;    // AND NOT operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n    assign out = (~a & ~b) | (~b & c & d) | (a & b & c & d) | (a & ~c & ~d);\nendmodule\n", "result": "failed: 92 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum {A, B, C} state_t;\n\tstate_t state, next_state;\n\n\t// Counter variables\n\treg [1:0] count;\n\treg [1:0] cycle_count;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\t\tcount <= 0;\n\t\t\tcycle_count <= 0;\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (state == B) begin\n\t\t\t\tcycle_count <= cycle_count + 1;\n\t\t\t\tif (w == 1)\n\t\t\t\t\tcount <= count + 1;\n\t\t\t\tif (cycle_count == 3) begin\n\t\t\t\t\tif (count == 2)\n\t\t\t\t\t\tz <= 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tz <= 0;\n\n\t\t\t\t\t// reset counters for next cycle\n\t\t\t\t\tcount <= 0;\n\t\t\t\t\tcycle_count <= 0;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tcount <= 0;\n\t\t\t\tcycle_count <= 0;\n\t\t\tend\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s == 1)\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (cycle_count == 3)\n\t\t\t\t\tnext_state = B; // Continue checking in B indefinitely\n\t\t\t\telse\n\t\t\t\t\tnext_state = B; // Condition met, stay in B\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tnext_state = A; // not used in this code design.\n\t\t\tend\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 571 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Replicate the most significant bit (in[7]) 24 times and concatenate with the original 8-bit input\n    assign out = { {24{in[7]}}, in };\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\t// Register to hold the 4 bits\n\treg [3:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\t// Reset the register to all zeroes if reset is active (low)\n\t\t\tshift_reg <= 4'b0000;\n\t\tend else begin\n\t\t\t// Shift the register to the right, load the new bit\n\t\t\tshift_reg <= {shift_reg[2:0], in};\n\t\tend\n\tend\n\n\t// Assign the output as the last bit in the shift register\n\tassign out = shift_reg[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\nalways @(*) begin\n\t// Priority logic to detect the first high bit from LSB to MSB\n\tif (in[0]) begin\n\t\tpos = 2'd0;\n\tend else if (in[1]) begin\n\t\tpos = 2'd1;\n\tend else if (in[2]) begin\n\t\tpos = 2'd2;\n\tend else if (in[3]) begin\n\t\tpos = 2'd3;\n\tend else begin\n\t\tpos = 2'd0; // If none are high, output should be zero\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // Define state encoding\n    typedef enum reg [0:0] {OFF = 1'b0, ON = 1'b1} state_t;\n    state_t state, next_state;\n\n    // Sequential logic to update state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF; // Asynchronous reset to OFF state\n        end else begin\n            state <= next_state; // Update state\n        end\n    end\n\n    // Combinational logic to determine next state and output\n    always @(*) begin\n        case (state)\n            OFF: begin\n                next_state = (j == 1'b1) ? ON : OFF; // State transition logic\n                out = 1'b0;                        // Output in OFF state\n            end\n            ON: begin\n                next_state = (k == 1'b1) ? OFF : ON; // State transition logic\n                out = 1'b1;                        // Output in ON state\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n\t// Assign constant logic low (0) to the output\n\tassign out = 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n    // Assign the constant logic high value to the output\n    assign one = 1'b1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n\n    always_ff @(posedge clk) begin\n        out <= in ^ out;  // Compute the XOR and assign to out on posedge clk\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;  // Asynchronous reset\n        end else begin\n            if (load) begin\n                q <= data;  // Load data if load is active\n            end else if (ena) begin\n                q <= {1'b0, q[3:1]};  // Shift right; q[3] becomes 0\n            end\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    assign f = (~x3 & x2 & ~x1) | \n               (~x3 & x2 & x1) | \n               (x3 & ~x2 & x1) | \n               (x3 & x2 & x1);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            q <= 8'b0;  // Reset all bits of q to 0 asynchronously when areset is high\n        else \n            q <= d;     // Transfer value of d to q on positive edge of clk\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Compute the AND of all input bits\n    assign out_and = &in;\n\n    // Compute the OR of all input bits\n    assign out_or = |in;\n\n    // Compute the XOR of all input bits\n    assign out_xor = ^in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n    \n    assign sum = a ^ b;  // XOR gate for sum output\n    assign cout = a & b; // AND gate for carry output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // Define state parameters\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register to hold the current state\n    reg state, next_state;\n\n    // Sequential block for state transition handling\n    always @(posedge clk) begin\n        if (reset) begin\n            // Synchronous reset to OFF state\n            state <= OFF;\n        end else begin\n            // Transition to next state\n            state <= next_state;\n        end\n    end\n\n    // Combinational block to determine next state\n    always @(*) begin\n        case(state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON;\n                end else begin\n                    next_state = OFF;\n                end\n            end\n            ON: begin\n                if (k) begin\n                    next_state = OFF;\n                end else begin\n                    next_state = ON;\n                end\n            end\n        endcase\n    end\n\n    // Output logic based on Moore state machine principle\n    always @(*) begin\n        case(state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    // Step 1: Concatenate the input vectors\n    wire [29:0] concat_input;\n    assign concat_input = {a, b, c, d, e, f}; // Concatenate the 5-bit pieces\n\n    // Step 2: Append two '1' bits to create a 32-bit vector\n    wire [31:0] final_vector;\n    assign final_vector = {concat_input, 2'b11}; // Appending two '1' bits to LSB\n\n    // Step 3: Split the 32-bit vector into four 8-bit output vectors\n    assign w = final_vector[31:24];\n    assign x = final_vector[23:16];\n    assign y = final_vector[15:8];\n    assign z = final_vector[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\nassign q = a ^ b ^ c ^ d;\n\nendmodule\n", "result": "failed: 121 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n    // Perform the AND operation\n    assign out = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\tparameter A = 1'b0, B = 1'b1;\n\t\n\t// State registers\n\treg state, next_state;\n\t\n\t// Sequential logic for state transition\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= B; // Reset to state B\n\t\telse\n\t\t\tstate <= next_state; // Transition to next state\n\tend\n\t\n\t// Combinational logic for state transitions and output\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tB: begin\n\t\t\t\tout = 1'b1; // Output for state B\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = B; // Stay in B\n\t\t\t\telse\n\t\t\t\t\tnext_state = A; // Transition to A\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tout = 1'b0; // Output for state A\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = A; // Stay in A\n\t\t\t\telse\n\t\t\t\t\tnext_state = B; // Transition to B\n\t\t\tend\n\t\t\tdefault: next_state = B; // Default transition to B\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\n    // Calculate the sum\n    assign sum = a ^ b ^ cin;\n\n    // Calculate the carry-out\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n    // Intermediate wire to hold the result of the XNOR operation\n    wire w1;\n\n    // XNOR gate: Perform XNOR operation on in1 and in2\n    assign w1 = ~(in1 ^ in2);\n\n    // XOR gate: Perform XOR operation on w1 and in3\n    assign out = w1 ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n\tassign mux_in[0] = d;        // ab = 00, (let d pass)\n\tassign mux_in[1] = 0;        // ab = 01, always 0\n\tassign mux_in[2] = ~c | ~d;  // ab = 11, use ~c + ~d\n\tassign mux_in[3] = ~(c ^ d); // ab = 10, use c XNOR d (c ~^ d)\n\nendmodule\n", "result": "failed: 49 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n// State encoding using one-hot\nparameter A = 2'b01;\nparameter B = 2'b10;\n\n// Current state and next state registers\nreg [1:0] state, next_state;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tstate <= A; // Reset to state A\n\telse\n\t\tstate <= next_state; // Update state on clock edge\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (x == 0) begin\n\t\t\t\tnext_state = A;\n\t\t\t\tz = 0;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tz = 1;\n\t\t\tend\n\t\tend\n\t\tB: begin\n\t\t\tif (x == 0) begin\n\t\t\t\tnext_state = B;\n\t\t\t\tz = 1;\n\t\t\tend else begin\n\t\t\t\tnext_state = B;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state = A;\n\t\t\tz = 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (state == 0) begin\n        if (b == 1)\n            q <= 1;\n        else\n            q <= 0;\n            \n        if (a == 1)\n            state <= 1;\n    end else begin\n        if (a == 1)\n            q <= 0;\n        else\n            q <= 1;\n            \n        if (b == 1)\n            state <= 0;\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n    // Compute the output logic 'f'\n    assign f = (~x[1] & x[3]) | (x[3] & x[4]) | (~x[3] & ~x[2]);\n\nendmodule\n", "result": "failed: 33 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    // State encoding\n    typedef enum reg [3:0] {\n        S0, // No 1s seen (equivalent to last bit being 0)\n        S1, // Last input was 01\n        S2, // Last two inputs were 11\n        S3, // Last three inputs were 111\n        S4, // Last four inputs were 1111\n        S5, // Last five inputs were 11111\n        S6, // Last six inputs were 111111 (0111111 sequence ending)\n        S_err // More than 6 consecutive 1s\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // State register\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0; // 0 seen\n            S1: next_state = in ? S2 : S0; // 01 seen\n            S2: next_state = in ? S3 : S0; // 011 seen\n            S3: next_state = in ? S4 : S0; // 0111 seen\n            S4: next_state = in ? S5 : S0; // 01111 seen\n            S5: next_state = in ? S6 : S0; // 011111 seen\n            S6: next_state = in ? S_err : S0; // 0111111 or more seen\n            S_err: next_state = in ? S_err : S0; // Stay in error state until a 0 is seen\n            default: next_state = S0;\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        disc = 0;\n        flag = 0;\n        err = 0;\n        case (state)\n            S5: disc = ~in;            // When state is S5 and next in is 0 (0111110)\n            S6: flag = ~in;            // When state is S6 and next in is 0 (01111110)\n            S_err: err = 1;            // For more than 6 consecutive 1s\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        DETECT_START = 3'b001,\n        SHIFT_DELAY = 3'b010,\n        COUNTING = 3'b011,\n        WAIT_ACK = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n    reg [3:0] shift_reg; // To detect the '1101' pattern\n    reg [3:0] delay;     // To store delay\n    reg [15:0] timer;    // Timer counter to track 1000*(delay+1) cycles\n    reg [3:0] remain_time; // Remaining time for output\n\n    assign count = (state == COUNTING) ? remain_time : 4'bxxxx; // Don't care when not counting\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default values\n        next_state = state;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (data == 1'b1) begin // Begin sequence detection\n                    shift_reg[3:1] <= shift_reg[2:0]; // Shift in data\n                    shift_reg[0] <= data;\n                    if (shift_reg == 4'b1101) begin\n                        next_state = SHIFT_DELAY;\n                    end else begin\n                        next_state = DETECT_START;\n                    end\n                end else begin\n                    next_state = DETECT_START;\n                end\n            end\n            DETECT_START: begin\n                shift_reg <= {shift_reg[2:0], data}; // Shift in data for pattern detection\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT_DELAY;\n                end\n            end\n            SHIFT_DELAY: begin\n                delay <= {delay[2:0], data}; // Shift in delay bits\n                if (delay[0] !== 1'bx) begin // Once all 4 bits are captured\n                    remain_time <= delay;\n                    timer <= 16'd1000;\n                    next_state = COUNTING;\n                end \n            end\n            COUNTING: begin\n                counting = 1'b1;\n                if (timer == 16'd0) begin\n                    if (remain_time == 4'd0) begin\n                        done = 1'b1;\n                        next_state = WAIT_ACK;\n                    end else begin\n                        timer <= 16'd1000;\n                        remain_time <= remain_time - 1;\n                    end\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            WAIT_ACK: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 234318 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n\t// State and next state registers\n\treg [1:0] state, next_state;\n\treg was_lower; // Flag indicating previous state was lower\n\n\t// State encoding\n\tlocalparam LOW_LEVEL = 2'b00;\n\tlocalparam MID_LEVEL = 2'b01;\n\tlocalparam HIGH_LEVEL = 2'b10;\n\tlocalparam FULL_LEVEL = 2'b11;\n\n\t// State machine sequential logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= LOW_LEVEL;\n\t\t\twas_lower <= 1'b1;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\twas_lower <= (next_state > state) ? 1'b1 : 1'b0;\n\t\tend\n\tend\n\n\t// State machine combinational logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tLOW_LEVEL: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\tnext_state = FULL_LEVEL;\n\t\t\t\tend else if (s[1] && s[2]) begin\n\t\t\t\t\tnext_state = MID_LEVEL;\n\t\t\t\tend else if (s[1]) begin\n\t\t\t\t\tnext_state = HIGH_LEVEL;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = LOW_LEVEL;\n\t\t\t\tend\n\t\t\tend\n\t\t\tMID_LEVEL: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\tnext_state = FULL_LEVEL;\n\t\t\t\tend else if (s[1] && s[2]) begin\n\t\t\t\t\tnext_state = MID_LEVEL;\n\t\t\t\tend else if (s[1]) begin\n\t\t\t\t\tnext_state = HIGH_LEVEL;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = LOW_LEVEL;\n\t\t\t\tend\n\t\t\tend\n\t\t\tHIGH_LEVEL: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\tnext_state = FULL_LEVEL;\n\t\t\t\tend else if (s[1] && s[2]) begin\n\t\t\t\t\tnext_state = MID_LEVEL;\n\t\t\t\tend else if (s[1]) begin\n\t\t\t\t\tnext_state = HIGH_LEVEL;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = LOW_LEVEL;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFULL_LEVEL: begin\n\t\t\t\tif (s[1] && s[2] && s[3]) begin\n\t\t\t\t\tnext_state = FULL_LEVEL;\n\t\t\t\tend else if (s[1] && s[2]) begin\n\t\t\t\t\tnext_state = MID_LEVEL;\n\t\t\t\tend else if (s[1]) begin\n\t\t\t\t\tnext_state = HIGH_LEVEL;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = LOW_LEVEL;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = LOW_LEVEL;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\t// Default outputs\n\t\tfr1 = 1'b0;\n\t\tfr2 = 1'b0;\n\t\tfr3 = 1'b0;\n\t\tdfr = 1'b0;\n\n\t\tcase (state)\n\t\t\tLOW_LEVEL: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tfr2 = 1'b1;\n\t\t\t\tfr3 = 1'b1;\n\t\t\t\tdfr = 1'b0;\n\t\t\tend\n\t\t\tMID_LEVEL: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tfr2 = 1'b1;\n\t\t\t\tdfr = was_lower;\n\t\t\tend\n\t\t\tHIGH_LEVEL: begin\n\t\t\t\tfr1 = 1'b1;\n\t\t\t\tdfr = was_lower;\n\t\t\tend\n\t\t\tFULL_LEVEL: begin\n\t\t\t\t// No output asserts needed\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 1807 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        ERROR = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [3:0] bit_counter;   // Counter for data bits\n    logic done_reg;            // Register for done signal\n    \n    // State Register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_counter <= 4'd0;\n            done_reg <= 0;\n        end else begin\n            current_state <= next_state;\n            // Maintain bit_counter and done_reg\n            if (current_state == DATA) begin\n                bit_counter <= bit_counter + 1;\n            end else begin\n                bit_counter <= 4'd0;\n            end\n            done_reg <= (current_state == STOP && in == 1);\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (in == 0) begin\n                    next_state = START; // Found start bit\n                end\n            end\n            START: begin\n                next_state = DATA; // Move to data state after detecting start\n            end\n            DATA: begin\n                if (bit_counter == 4'd7) begin\n                    next_state = STOP; // After 8 bits, go to stop\n                end\n            end\n            STOP: begin\n                if (in == 1) begin\n                    next_state = IDLE; // Correct stop bit, go to idle\n                end else begin\n                    next_state = ERROR; // Incorrect stop bit\n                end\n            end\n            ERROR: begin\n                if (in == 1) begin\n                    next_state = IDLE; // Wait for idle state (signal high)\n                end\n            end\n        endcase\n    end\n\n    assign done = done_reg; // Output assignment\n\nendmodule\n", "result": "failed: 55 out of 905 samples.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    // Define states as parameters\n    parameter IDLE = 3'd0,\n              START = 3'd1,\n              DATA_0 = 3'd2,\n              DATA_1 = 3'd3,\n              DATA_2 = 3'd4,\n              DATA_3 = 3'd5,\n              DATA_4 = 3'd6,\n              DATA_5 = 3'd7,\n              DATA_6 = 3'd8,\n              DATA_7 = 3'd9,\n              STOP = 3'd10,\n              DONE = 3'd11;\n\n    // State register\n    reg [3:0] state;\n    reg [7:0] data;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset state and outputs\n            state <= IDLE;\n            out_byte <= 8'b0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in == 1'b0)  // Detect start bit\n                        state <= START;\n                    done <= 1'b0;\n                end\n                \n                START: begin\n                    // Transition to collect first data bit\n                    state <= DATA_0;\n                end\n                \n                DATA_0: begin\n                    data[0] <= in;   // Collect LSB\n                    state <= DATA_1;\n                end\n                \n                DATA_1: begin\n                    data[1] <= in;\n                    state <= DATA_2;\n                end\n\n                DATA_2: begin\n                    data[2] <= in;\n                    state <= DATA_3;\n                end\n\n                DATA_3: begin\n                    data[3] <= in;\n                    state <= DATA_4;\n                end\n\n                DATA_4: begin\n                    data[4] <= in;\n                    state <= DATA_5;\n                end\n\n                DATA_5: begin\n                    data[5] <= in;\n                    state <= DATA_6;\n                end\n\n                DATA_6: begin\n                    data[6] <= in;\n                    state <= DATA_7;\n                end\n\n                DATA_7: begin\n                    data[7] <= in;\n                    state <= STOP;\n                end\n\n                STOP: begin\n                    if (in == 1'b1) begin  // Expect stop bit\n                        state <= DONE;\n                        out_byte <= data;  // Output valid data\n                        done <= 1'b1;\n                    end else begin\n                        // Stay in stop state waiting for correct stop bit\n                        state <= STOP;\n                    end\n                end\n\n                DONE: begin\n                    state <= IDLE;  // Transition back to IDLE\n                    done <= 1'b0;\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n\t// Global Branch History Register\n\treg [6:0] global_history;\n\n\t// 128-entry table of 2-bit saturating counters\n\treg [1:0] PHT [127:0];\n\n\t// Generate index using XOR\n\twire [6:0] predict_index = predict_pc ^ global_history;\n\twire [6:0] train_index = train_pc ^ train_history;\n\n\t// PHT Update Helper Function\n\tfunction [1:0] update_counter;\n\t\tinput [1:0] counter;\n\t\tinput taken;\n\t\tbegin\n\t\t\tcase(counter)\n\t\t\t\t2'b00: update_counter = taken ? 2'b01 : 2'b00;\n\t\t\t\t2'b01: update_counter = taken ? 2'b10 : 2'b00;\n\t\t\t\t2'b10: update_counter = taken ? 2'b11 : 2'b01;\n\t\t\t\t2'b11: update_counter = taken ? 2'b11 : 2'b10;\n\t\t\tendcase\n\t\tend\n\tendfunction\n\n\t// Predict valid logic\n\talways @(*) begin\n\t\tif (predict_valid) begin\n\t\t\tpredict_taken = PHT[predict_index] >= 2'b10;\n\t\t\tpredict_history = global_history;\n\t\tend else begin\n\t\t\tpredict_taken = 0;\n\t\t\tpredict_history = 7'd0;\n\t\tend\n\tend\n\n\t// Sequential logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tglobal_history <= 7'd0;\n\t\t\tinteger i;\n\t\t\tfor (i = 0; i < 128; i = i + 1) begin\n\t\t\t\tPHT[i] <= 2'b01; // Weakly not taken\n\t\t\tend\n\t\tend else begin\n\t\t\tif (train_valid) begin\n\t\t\t\t// Update the PHT entry based on actual branch outcome\n\t\t\t\tPHT[train_index] <= update_counter(PHT[train_index], train_taken);\n\t\t\t\tif (train_mispredicted) begin\n\t\t\t\t\tglobal_history <= train_history; // Recover global history register\n\t\t\t\tend else begin\n\t\t\t\t\tglobal_history <= {global_history[5:0], train_taken}; // Update history standard way\n\t\t\t\tend\n\t\t\tend else if (predict_valid) begin\n\t\t\t\tglobal_history <= {global_history[5:0], predict_taken}; // Update history based on prediction\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define the states\n    typedef enum reg [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALLING,\n        DIGGING,\n        SPLATTERED\n    } state_t;\n\n    state_t state, next_state;\n    state_t prev_walk_state; // To remember the last walking direction (left or right)\n    reg [4:0] falling_counter; // To count clock cycles spent in FALLING state\n\n    // State transition logic: Combinational\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            FALLING: begin\n                if (falling_counter > 20 && ground)\n                    next_state = SPLATTERED;\n                else if (ground)\n                    next_state = prev_walk_state;\n                else\n                    next_state = FALLING;\n            end\n\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALLING;\n                else\n                    next_state = DIGGING;\n            end\n\n            SPLATTERED: begin\n                next_state = SPLATTERED; // Stay splattered forever\n            end\n\n            default: next_state = WALK_LEFT; // Default state to reset\n        endcase\n    end\n\n    // State flip-flops: Sequential\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            prev_walk_state <= WALK_LEFT;\n            falling_counter <= 0;\n        end\n        else begin\n            state <= next_state;\n            if (state == WALK_LEFT || state == WALK_RIGHT)\n                prev_walk_state <= state; // Update last walking state\n            if (state == FALLING)\n                falling_counter <= falling_counter + 1; // Increment falling counter\n            else\n                falling_counter <= 0; // Reset counter in states other than FALLING\n        end\n    end\n\n    // Output logic: Combinational\n    always @(*) begin\n        // Default all outputs to 0\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING: aaah = 1;\n            DIGGING: digging = 1;\n            SPLATTERED: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n\t// State Declaration\n\ttypedef enum logic [2:0] {\n\t\tIDLE,\n\t\tPATTERN_DETECTED,\n\t\tSHIFTING,\n\t\tCOUNTING,\n\t\tDONE_NOTIFY,\n\t\tWAIT_ACK\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\treg [2:0] shift_count;\n\treg [3:0] pattern;\n\n\talways_ff @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\t\tshift_count <= 3'b0;\n\t\t\tpattern <= 4'b0;\n\t\t\tshift_ena <= 0;\n\t\t\tcounting <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tif (current_state == SHIFTING) begin\n\t\t\t\tshift_count <= shift_count + 1;\n\t\t\tend else begin\n\t\t\t\tshift_count <= 3'b0;\n\t\t\tend\n\t\t\t\n\t\t\tif (current_state == IDLE) begin\n\t\t\t\tpattern <= {pattern[2:0], data};\n\t\t\tend else if (current_state == PATTERN_DETECTED) begin\n\t\t\t\tpattern <= 4'b0;  // Clear pattern matching\n\t\t\tend\n\t\tend\n\tend\n\n\talways_comb begin\n\t\tnext_state = current_state;\n\t\tshift_ena = 0;\n\t\tcounting = 0;\n\t\tdone = 0;\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tif (pattern == 4'b1101) begin\n\t\t\t\t\tnext_state = PATTERN_DETECTED;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tPATTERN_DETECTED: begin\n\t\t\t\tshift_ena = 1;\n\t\t\t\tnext_state = SHIFTING;\n\t\t\tend\n\t\t\t\n\t\t\tSHIFTING: begin\n\t\t\t\tshift_ena = 1;\n\t\t\t\tif (shift_count == 3) begin\n\t\t\t\t\tnext_state = COUNTING;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tCOUNTING: begin\n\t\t\t\tcounting = 1;\n\t\t\t\tif (done_counting) begin\n\t\t\t\t\tnext_state = DONE_NOTIFY;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tDONE_NOTIFY: begin\n\t\t\t\tdone = 1;\n\t\t\t\tnext_state = WAIT_ACK;\n\t\t\tend\n\t\t\t\n\t\t\tWAIT_ACK: begin\n\t\t\t\tdone = 1;\n\t\t\t\tif (ack) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 832 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n    integer i, j;\n    reg [3:0] dx, dy;\n    reg [255:0] next_state;\n    reg [3:0] num_neighbors;\n    \n    // Directions for neighbor cells relative position (clockwise)\n    localparam signed [1:0] DIRECTION [7:0] = { {-1, -1}, {-1,  0}, {-1,  1},\n                                                 { 0, -1}, { 0,  1},\n                                                 { 1, -1}, { 1,  0}, { 1,  1} };\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            // Compute next state of each cell\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    // Count living neighbors\n                    num_neighbors = 0;\n                    for (dx = 0; dx < 8; dx = dx + 1) begin\n                        // Toroidal coordinates\n                        num_neighbors = num_neighbors +\n                                        q[((i + DIRECTION[dx][0] + 16) % 16) * 16 + (j + DIRECTION[dy][1] + 16) % 16];\n                    end\n                    \n                    // Determine next state based on neighbor count\n                    if (num_neighbors == 3 || (num_neighbors == 2 && q[i * 16 + j])) \n                        next_state[i * 16 + j] = 1;\n                    else\n                        next_state[i * 16 + j] = 0;\n                end\n            end\n            \n            q <= next_state; // Update state\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define states as integer constants\n    typedef enum logic [1:0] {\n        WALK_LEFT   = 2'b00,\n        WALK_RIGHT  = 2'b01,\n        FALL        = 2'b10,\n        DIG         = 2'b11\n    } lemming_state_t;\n\n    lemming_state_t state, next_state;\n    \n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // State transition logic\n    always_comb begin\n        next_state = state; // Default state transition is same state\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_left || bump_right) next_state = WALK_RIGHT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_left || bump_right) next_state = WALK_LEFT;\n            end\n            \n            FALL: begin\n                if (ground) begin\n                    if (state == WALK_LEFT) next_state = WALK_LEFT;\n                    else next_state = WALK_RIGHT;\n                end\n            end\n\n            DIG: begin\n                if (!ground) next_state = FALL;\n            end\n\n        endcase\n    end\n\n    // Output logic based on current state\n    always_comb begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    // Initialize outputs    \n    initial begin\n        hh = 8'b00010010; // 12 in BCD\n        mm = 8'b00000000; // 00 in BCD\n        ss = 8'b00000000; // 00 in BCD\n        pm = 0; // AM\n    end\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'b00010010; // 12 in BCD\n            mm <= 8'b00000000; // 00 in BCD\n            ss <= 8'b00000000; // 00 in BCD\n            pm <= 0; // AM\n        end\n        else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b01011001) begin // 59 in BCD\n                ss <= 8'b00000000; // Reset to 00\n                // Increment minutes\n                if (mm == 8'b01011001) begin // 59 in BCD\n                    mm <= 8'b00000000; // Reset to 00\n                    // Increment hours\n                    if (hh == 8'b00010010) begin // 12 in BCD\n                        hh <= 8'b00000001; // Set to 01\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'b00001001) begin // 09 in BCD\n                        hh <= 8'b00010000; // Set to 10\n                    end else begin\n                        hh <= hh + 1;\n                    end\n                end else if ((mm[3:0] == 4'b1001)) begin // If low nibble 9\n                    mm <= {mm[7:4] + 1'b1, 4'b0000}; // increment high nibble and reset low nibble to 0\n                end else begin\n                    mm <= mm + 1;\n                end\n            end else if ((ss[3:0] == 4'b1001)) begin // If low nibble 9\n                ss <= {ss[7:4] + 1'b1, 4'b0000}; // increment high nibble and reset low nibble to 0\n            end else begin\n                ss <= ss + 1;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 316800 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n    //State encoding\n    typedef enum reg [1:0] {\n        WL = 2'b00, // Walking Left\n        WR = 2'b01, // Walking Right\n        FL = 2'b10, // Falling Left\n        FR = 2'b11  // Falling Right\n    } state_t;\n\n    reg [1:0] state, next_state;\n\n    // Asynchronous reset and state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WL; // Reset to Walking Left\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WL: begin\n                if (ground == 0) begin\n                    next_state = FL; // Falling left if ground disappears\n                end else if (bump_left || bump_right) begin\n                    next_state = WR; // Switch to walk right if bumped\n                end else begin\n                    next_state = WL; // Continue walking left\n                end\n            end\n            WR: begin\n                if (ground == 0) begin\n                    next_state = FR; // Falling right if ground disappears\n                end else if (bump_left || bump_right) begin\n                    next_state = WL; // Switch to walk left if bumped\n                end else begin\n                    next_state = WR; // Continue walking right\n                end\n            end\n            FL: begin\n                if (ground == 1) begin\n                    next_state = WL; // Resume walking left when ground returns\n                end else begin\n                    next_state = FL; // Continue falling\n                end\n            end\n            FR: begin\n                if (ground == 1) begin\n                    next_state = WR; // Resume walking right when ground returns\n                end else begin\n                    next_state = FR; // Continue falling\n                end\n            end\n            default: next_state = WL; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            WL: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n            end\n            WR: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n            end\n            FL: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n            FR: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n            default: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    // Enable signals for the higher digits\n    assign ena[1] = (q[3:0] == 4'd9);\n    assign ena[2] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9);\n    assign ena[3] = (q[3:0] == 4'd9) && (q[7:4] == 4'd9) && (q[11:8] == 4'd9);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0; // Reset all digits to 0\n        end else begin\n            // Ones place\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                \n                // Tens place\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                    \n                    // Hundreds place\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0;\n                        \n                        // Thousands place\n                        if (q[15:12] == 4'd9) begin\n                            q[15:12] <= 4'd0;\n                        end else begin\n                            q[15:12] <= q[15:12] + 4'd1;\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 4'd1;\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 4'd1;\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 4'd1;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 26 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\n    assign out = (sel == 1'b0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0; // State A\n            3'b001: Y2 = (w) ? 1 : 0; // State B\n            3'b010: Y2 = 1; // State C\n            3'b011: Y2 = (w) ? 0 : 1; // State D\n            3'b100: Y2 = (w) ? 1 : 1; // State E\n            3'b101: Y2 = (w) ? 1 : 0; // State F\n            default: Y2 = 0; // Default case (shouldn't happen)\n        endcase\n    end\nendmodule\n", "result": "failed: 28 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\n    // Assign the outputs based on vibrate_mode\n    assign ringer = ring & ~vibrate_mode;  // Ringer is enabled if ring is active and vibrate_mode is inactive\n    assign motor  = ring & vibrate_mode;   // Motor is enabled if ring is active and vibrate_mode is active\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n    // Sub-task 1: Using assign statement\n    assign out_assign = a & b;\n    \n    // Sub-task 2: Using always block\n    always @ (a or b) begin\n        out_alwaysblock = a & b;\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\n    // Assign the constant value 0 to the output 'zero'\n    assign zero = 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (a) begin\n            q <= ~q; // Toggle q if a is 1\n        end else begin\n            // q remains the same if a is 0\n        end\n    end\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// State definition using enumerated constants\n\ttypedef enum logic [1:0] {\n\t\tIDLE = 2'b00,\n\t\tCOMPLEMENT = 2'b01\n\t} state_t;\n\n\t// State variables\n\tstate_t current_state, next_state;\n\n\t// Sequential logic: State transition logic on positive edge\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= IDLE;  // Reset to IDLE state\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;  // Transition to next state\n\t\tend\n\tend\n\n\t// Combinational logic: Define next state logic and output logic\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tz = x;  // Output is the input\n\t\t\t\tif (x == 1) begin\n\t\t\t\t\tnext_state = COMPLEMENT;  // Transition to complementing state upon receiving 1\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE;  // Stay in IDLE otherwise\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tCOMPLEMENT: begin\n\t\t\t\tz = ~x;  // Output is the complement of the input\n\t\t\t\tnext_state = COMPLEMENT;  // Stay in COMPLEMENT state\n\t\t\tend\n\n\t\t\tdefault: begin\n\t\t\t\tnext_state = IDLE;  // Default state to IDLE\n\t\t\t\tz = x;  // Default output is input\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {S_A, S_B, S_C, S_D} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S_A: next_state = in ? S_B : S_A;\n            S_B: next_state = in ? S_B : S_C;\n            S_C: next_state = in ? S_D : S_A;\n            S_D: next_state = in ? S_B : S_C;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S_A, S_B, S_C: out = 0;\n            S_D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= S_A;\n        else\n            state <= next_state;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out[31:24] = in[7:0];   // Reverse Byte 0 to Byte 3\n    assign out[23:16] = in[15:8];  // Reverse Byte 1 to Byte 2\n    assign out[15:8]  = in[23:16]; // Reverse Byte 2 to Byte 1\n    assign out[7:0]   = in[31:24]; // Reverse Byte 3 to Byte 0\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n\talways_ff @(posedge clk) begin\n\t\tif (r) begin\n\t\t\tq <= 1'b0;  // Reset q to 0 if r is high\n\t\tend else begin\n\t\t\tq <= d;  // Otherwise, capture the input d\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    \n    // Perform XOR operation\n    wire xor_result;\n    assign xor_result = x ^ y;\n    \n    // Perform AND operation with the result of XOR and x\n    assign z = xor_result & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\t// Load data if load is active\n\t\t\tq <= data;\n\t\tend else if (ena) begin\n\t\t\t// Perform shift operation based on 'amount'\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= q << 1;          // Shift left by 1 bit\n\t\t\t\t2'b01: q <= q << 8;          // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {{1{q[63]}}, q[63:1]}; // Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n\t\t\t\tdefault: ; // Should not occur\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // First '1' detected\n        S2 = 2'b10  // '10' detected\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        z = (state == S2 && x);\n    end\n\n    // State register with asynchronous reset\n    always @(negedge aresetn or posedge clk) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// State encoding using localparam\n\tlocalparam A = 3'b000,\n\t\t\t   B = 3'b001,\n\t\t\t   C = 3'b010,\n\t\t\t   D = 3'b011,\n\t\t\t   E = 3'b100,\n\t\t\t   F = 3'b101;\n\t\n\treg [2:0] state, next_state;\n\n\t// State transition based on the input w and current state\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = (w == 1'b0) ? B : A;\n\t\t\tB: next_state = (w == 1'b0) ? C : D;\n\t\t\tC: next_state = (w == 1'b0) ? E : D;\n\t\t\tD: next_state = (w == 1'b0) ? F : A;\n\t\t\tE: next_state = (w == 1'b0) ? E : D;\n\t\t\tF: next_state = (w == 1'b0) ? C : D;\n\t\t\tdefault: next_state = A; // Default case to handle unsupported states\n\t\tendcase\n\tend\n\n\t// Sequential block for state update\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\t// Output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA, B, C, D: z = 1'b0;\n\t\t\tE, F: z = 1'b1;\n\t\t\tdefault: z = 1'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    // State Definitions\n    typedef enum reg [1:0] {\n        IDLE   = 2'b00,\n        BYTE1  = 2'b01,\n        BYTE2  = 2'b10,\n        BYTE3  = 2'b11\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg [7:0] byte1, byte2, byte3;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                next_state = (in[3] == 1) ? BYTE1 : IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = (reset ? IDLE : BYTE1); // Return to checking for new message\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic and Register Updates\n    always @(posedge clk) begin\n        if (reset) begin\n            byte1 <= 8'b0;\n            byte2 <= 8'b0;\n            byte3 <= 8'b0;\n            out_bytes <= 24'b0;\n            done <= 0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    done <= 0;\n                end\n                BYTE1: begin\n                    byte1 <= in;\n                    done <= 0;\n                end\n                BYTE2: begin\n                    byte2 <= in;\n                    done <= 0;\n                end\n                BYTE3: begin\n                    byte3 <= in;\n                    out_bytes <= {byte1, byte2, byte3};\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\n\tassign Y1 = y[0] & w; // y[0] corresponds to state A\n\tassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w); // y[1] = B, y[2] = C, y[5] = F\n\nendmodule\n", "result": "failed: 23 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n    // Assign the 3-bit input vector directly to the output vector\n    assign outv = vec;\n\n    // Assign each bit of the input vector to the corresponding individual outputs\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        out = (b & ~d) | (~b & d) | (~a & ~c) | (a & c);\n    end\nendmodule\n", "result": "failed: 173 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\n    assign out_hi = in[15:8]; // Extract the upper byte\n    assign out_lo = in[7:0];  // Extract the lower byte\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a | b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n    // XOR using assign statement\n    assign out_assign = a ^ b;\n\n    // XOR using a combinational always block\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // XOR using a clocked always block\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\nassign Y2 = y[1] & ~w;\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\n    assign out = in[sel];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R; // Load operation\n\t\tend else if (E) begin\n\t\t\tQ <= w; // Shift operation\n\t\tend // If neither L nor E is asserted, Q retains its value automatically.\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\t// Declare flip-flop outputs\n\treg q1, q2, q3;\n\t\n\t// Intermediate signals (gate outputs)\n\twire xor_out, and_out, or_out;\n\n\t// Update intermediate signals based on gate operations\n\tassign xor_out = x ^ q1;         // XOR gate\n\tassign and_out = x & ~q2;        // AND gate\n\tassign or_out = x | ~q3;         // OR gate\n\n\t// Three input XNOR gate for final output\n\tassign z = ~(xor_out ^ and_out ^ or_out);\n\n\t// D flip-flops updating on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tq1 <= xor_out;\n\t\tq2 <= and_out;\n\t\tq3 <= or_out;\n\tend\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n\tassign q = c | (a & b);\n\nendmodule\n", "result": "failed: 12 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n\tinteger i;\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data; // Load the initial state\n\t\tend\n\t\telse begin\n\t\t\t// Apply Rule 110 to update the state\n\t\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\t\tcase ({q[i-1], q[i], q[i+1]})\n\t\t\t\t\t3'b111: q[i] <= 1'b0;\n\t\t\t\t\t3'b110: q[i] <= 1'b1;\n\t\t\t\t\t3'b101: q[i] <= 1'b1;\n\t\t\t\t\t3'b100: q[i] <= 1'b0;\n\t\t\t\t\t3'b011: q[i] <= 1'b1;\n\t\t\t\t\t3'b010: q[i] <= 1'b1;\n\t\t\t\t\t3'b001: q[i] <= 1'b1;\n\t\t\t\t\t3'b000: q[i] <= 1'b0;\n\t\t\t\tendcase\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {A=2'b00, B=2'b01, C=2'b10, D=2'b11} state_t;\n    state_t current_state, next_state;\n    \n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset to state A\n        end else begin\n            current_state <= next_state; // Update state\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = C;\n            end\n            C: begin\n                if (in)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = C;\n            end\n            default: next_state = A; // Default state\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default output\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @(*) begin\n\tcase (c)\n\t\t4'd0: q = b;\n\t\t4'd1: q = e;\n\t\t4'd2: q = a;\n\t\t4'd3: q = d;\n\t\tdefault: q = 4'd15; // equivalent to 4'b1111, which is 'f'\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tout = (sel) ? b : a;\n\tend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    always @(posedge clk) begin\n        if (L)\n            q_out <= r_in;\n        else\n            q_out <= {q_in[1] ^ q_in[2], q_in[0], q_in[2]};\n    end\nendmodule\n\nmodule top_module(\n    input clk,\n    input L,\n    input [2:0] r_in,\n    output [2:0] Q\n);\n    reg [2:0] q;\n    \n    // Instantiate three submodules\n    submodule sub0(.clk(clk), .L(L), .r_in(r_in[0]), .q_in(q), .q_out(Q[0]));\n    submodule sub1(.clk(clk), .L(L), .r_in(r_in[1]), .q_in(q), .q_out(Q[1]));\n    submodule sub2(.clk(clk), .L(L), .r_in(r_in[2]), .q_in(q), .q_out(Q[2]));\n\n    always @(posedge clk) q <= Q;  // Keep q updated with output Q\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            prev_in <= in;\n            out <= out | (prev_in & ~in); // Capture 1->0 transitions\n        end\n    end\n\nendmodule\n", "result": "failed: 91 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n\t// On the positive edge of the clk, update q with the value of d\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\nassign s = a + b;\nassign overflow = (~a[7] & ~b[7] & s[7]) | (a[7] & b[7] & ~s[7]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    \n    // Next-state logic:\n    assign S_next      = state[0] & ~d | state[1] & ~d | state[3] & ~d | state[9] & ack;\n    assign S1_next     = state[0] & d | state[1] & d;\n    assign B3_next     = state[6];\n    assign Count_next  = state[7];\n    assign Wait_next   = state[8] & done_counting;\n    \n    // Output logic:\n    assign shift_ena = state[4] | state[5] | state[6] | state[7];\n    assign counting  = state[8] & ~done_counting;\n    assign done      = state[9];\n\nendmodule\n", "result": "failed: 1822 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset to weakly not-taken state 2'b01\n            state <= 2'b01;\n        end else if (train_valid) begin\n            // Counter logic when training is valid\n            if (train_taken) begin\n                // Increment the counter up to a maximum of 3\n                if (state < 2'b11) begin\n                    state <= state + 2'b01;\n                end\n            end else begin\n                // Decrement the counter down to a minimum of 0\n                if (state > 2'b00) begin\n                    state <= state - 2'b01;\n                end\n            end\n        end\n        // Else, when train_valid is 0, maintain the current state implicitly\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\n    always @(*) begin\n        case (1'b1)\n            in[0]: pos = 3'd0;\n            in[1]: pos = 3'd1;\n            in[2]: pos = 3'd2;\n            in[3]: pos = 3'd3;\n            in[4]: pos = 3'd4;\n            in[5]: pos = 3'd5;\n            in[6]: pos = 3'd6;\n            in[7]: pos = 3'd7;\n            default: pos = 3'd0;  // Output zero if no bits are high\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default case: initialize all outputs to zero\n\t\tleft = 0;\n\t\tdown = 0;\n\t\tright = 0;\n\t\tup = 0;\n\n\t\t// Determine which output(s) to assert based on scancode\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;  // Left arrow key\n\t\t\t16'he072: down = 1;  // Down arrow key\n\t\t\t16'he074: right = 1; // Right arrow key\n\t\t\t16'he075: up = 1;    // Up arrow key\n\t\t\t// No default output required because all outputs are already initialized to 0\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n    wire c1, c2, c3, c4; // Carry wires\n\n    // Instantiate the 4 full adders\n    assign {c1, sum[0]} = x[0] + y[0] + 1'b0; // First stage, cin is 0\n    assign {c2, sum[1]} = x[1] + y[1] + c1;   // Second stage\n    assign {c3, sum[2]} = x[2] + y[2] + c2;   // Third stage\n    assign {c4, sum[3]} = x[3] + y[3] + c3;   // Fourth stage\n    \n    // Final carry-out is the overflow bit\n    assign sum[4] = c4;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    \n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset the history register to zero\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken}; // Overwrite with corrected history\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken}; // Update history with predicted branch direction\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\t// Intermediate wires\n\twire w1, w2;\n\n\t// First layer: AND gates\n\tassign w1 = a & b;\n\tassign w2 = c & d;\n\n\t// Second layer: OR gate\n\tassign out = w1 | w2;\n\n\t// Inverted output\n\tassign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    reg [7:0] Q;  // 8-bit register array\n    \n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {Q[6:0], S};  // Shift left and insert S at Q[0]\n        end\n    end\n    \n    // Multiplexer logic to select Q based on ABC\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'bx;  // X as default for safety\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    // Heater and Air Conditioner Logic\n    assign heater = mode && too_cold; // Heater is on if mode is heating and it's too cold\n    assign aircon = ~mode && too_hot; // Aircon is on if mode is cooling and it's too hot\n\n    // Fan Logic\n    assign fan = heater || aircon || fan_on; // Fan is on if either heater or aircon is on, or requested by fan_on signal\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n\t// out_sop for minimum SOP (Sum of Products)\n\tassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n\t// Calculating out_pos using minimum POS (Product of Sums)\n\tassign out_pos = (a | b | ~c | d) & (a | b | c | ~d) & (a | ~b | ~c | d) & (a | ~b | c | ~d) & (~a | ~b | c | d) & (~a | b | ~c | ~d) & (~a | b | c | ~d);\n\nendmodule\n", "result": "failed: 61 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset the LFSR to 1\n        end else begin\n            // Calculate the feedback bit using the taps\n            wire feedback = q[31] ^ q[21] ^ q[1] ^ q[0];\n            // Shift and insert the feedback at the MSB\n            q <= {q[30:0], feedback};\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\nassign q = (a & b) ? (c | d) : ((a ^ b) ? d : 0);\n\nendmodule\n", "result": "failed: 16 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n\t// First 4-input NAND gate\n\tassign p1y = ~(p1a & p1b & p1c & p1d);\n\t\n\t// Second 4-input NAND gate\n\tassign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    \n    integer i;\n    \n    always @(*) begin\n        out = 0; // Initialize the output to zero\n        for (i = 0; i < 255; i = i + 1) begin\n            if (in[i]) begin\n                out = out + 1'b1; // Increment the count if the bit is '1'\n            end\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\nassign out_both[2] = in[2] & in[3];\nassign out_both[1] = in[1] & in[2];\nassign out_both[0] = in[0] & in[1];\n\nassign out_any[3] = in[3] | in[2];\nassign out_any[2] = in[2] | in[1];\nassign out_any[1] = in[1] | in[0];\n\nassign out_different[3] = in[3] ^ in[0];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'h0000; // Default case\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0;               // Reset counter to 0\n        end else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0;           // Wrap the counter back to 0\n            end else begin\n                q <= q + 4'd1;       // Increment counter\n            end\n        end\n        // If slowena is low, do nothing. Counter value remains the same.\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\nassign out = in1 & ~in2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n    assign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [1:0] {STATE_A = 2'b00, STATE_B = 2'b01} state_t;\n\tstate_t state, next_state;\n\n\t// Combinational logic for state transition and output\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tSTATE_A: begin\n\t\t\t\tnext_state = (in) ? STATE_A : STATE_B; // State transitions\n\t\t\t\tout = 0; // Output for State A\n\t\t\tend\n\t\t\tSTATE_B: begin\n\t\t\t\tnext_state = (in) ? STATE_B : STATE_A; // State transitions\n\t\t\t\tout = 1; // Output for State B\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Sequential logic with asynchronous reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= STATE_B; // Asynchronously reset to State B\n\t\telse\n\t\t\tstate <= next_state; // Update state\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    reg q_pos; // flip-flop to capture value on the positive edge of clk\n    reg q_neg; // flip-flop to capture value on the negative edge of clk\n\n    always @(posedge clk) begin\n        q_pos <= d;\n    end\n\n    always @(negedge clk) begin\n        q_neg <= d;\n    end\n\n    always @(posedge clk or negedge clk) begin\n        if (clk) begin\n            q <= q_neg;  // Update q with the value captured on the negative edge\n        end else begin\n            q <= q_pos;  // Update q with the value captured on the positive edge\n        end\n    end\n\nendmodule\n", "result": "failed: 93 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\nassign out = ~(a ^ b);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\nwire a1_out, a2_out, b1_out, b2_out;  // Intermediary connections\nwire or_out, and_out;                // Final intermediary connections\n\n// Instantiate submodules\nmod_A subA1 (.x(x), .y(y), .z(a1_out));\nmod_A subA2 (.x(x), .y(y), .z(a2_out));\nmod_B subB1 (.x(x), .y(y), .z(b1_out));\nmod_B subB2 (.x(x), .y(y), .z(b2_out));\n\n// OR gate for the first pair of submodules\nassign or_out = a1_out | b1_out;\n\n// AND gate for the second pair of submodules\nassign and_out = a2_out & b2_out;\n\n// XOR gate for the outputs of OR and AND gates\nassign z = or_out ^ and_out;\n\nendmodule\n\n// Definitions for Module A and Module B\nmodule mod_A(\n    input x,\n    input y,\n    output z\n);\nassign z = (x ^ y) & x;\nendmodule\n\nmodule mod_B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\t// Load the data into q if load is high\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tif (ena == 2'b01) begin\n\t\t\t\t// Rotate right\n\t\t\t\tq <= {q[0], q[99:1]};\n\t\t\tend else if (ena == 2'b10) begin\n\t\t\t\t// Rotate left\n\t\t\t\tq <= {q[98:0], q[99]};\n\t\t\tend\n\t\t\t// If ena is 2'b00 or 2'b11, do nothing\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 10'b0; // Reset the counter to 0\n\tend else if (q == 10'd999) begin\n\t\tq <= 10'b0; // Wrap around to 0 if it reaches 999\n\tend else begin\n\t\tq <= q + 10'b1; // Increment the counter\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\t// Assign the output to be the negation of the input\n\tassign out = ~in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    // State transition logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in) | (state[7] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (j == 0 && k == 0) begin\n            Q <= Q;  // No change\n        end\n        else if (j == 0 && k == 1) begin\n            Q <= 0;  // Reset\n        end\n        else if (j == 1 && k == 0) begin\n            Q <= 1;  // Set\n        end\n        else if (j == 1 && k == 1) begin\n            Q <= ~Q; // Toggle\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[2] + in[1] + in[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\n\t// Comparing each signal with itself\n\tassign out[24] = ~(a ^ a); // a XNOR a\n\tassign out[19] = ~(b ^ b); // b XNOR b\n\tassign out[14] = ~(c ^ c); // c XNOR c\n\tassign out[9]  = ~(d ^ d); // d XNOR d\n\tassign out[4]  = ~(e ^ e); // e XNOR e\n\t\n\t// Comparing a with others\n\tassign out[23] = ~(a ^ b); // a XNOR b\n\tassign out[22] = ~(a ^ c); // a XNOR c\n\tassign out[21] = ~(a ^ d); // a XNOR d\n\tassign out[20] = ~(a ^ e); // a XNOR e\n\n\t// Comparing b with others\n\tassign out[18] = ~(b ^ a); // b XNOR a (already evaluated in out[23])\n\tassign out[17] = ~(b ^ c); // b XNOR c\n\tassign out[16] = ~(b ^ d); // b XNOR d\n\tassign out[15] = ~(b ^ e); // b XNOR e\n\n\t// Comparing c with others\n\tassign out[13] = ~(c ^ a); // c XNOR a (already evaluated in out[22])\n\tassign out[12] = ~(c ^ b); // c XNOR b (already evaluated in out[17])\n\tassign out[11] = ~(c ^ d); // c XNOR d\n\tassign out[10] = ~(c ^ e); // c XNOR e\n\n\t// Comparing d with others\n\tassign out[8] = ~(d ^ a);  // d XNOR a (already evaluated in out[21])\n\tassign out[7] = ~(d ^ b);  // d XNOR b (already evaluated in out[16])\n\tassign out[6] = ~(d ^ c);  // d XNOR c (already evaluated in out[11])\n\tassign out[5] = ~(d ^ e);  // d XNOR e\n\n\t// Comparing e with others\n\tassign out[3] = ~(e ^ a);  // e XNOR a (already evaluated in out[20])\n\tassign out[2] = ~(e ^ b);  // e XNOR b (already evaluated in out[15])\n\tassign out[1] = ~(e ^ c);  // e XNOR c (already evaluated in out[10])\n\tassign out[0] = ~(e ^ d);  // e XNOR d (already evaluated in out[5])\n\nendmodule\n", "result": "failed: 94 out of 100 samples.", "passed": false}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n\t// State declarations\n\ttypedef enum logic [1:0] {\n\t\tLEFT = 2'b01,\n\t\tRIGHT = 2'b10\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State transition on clock edge\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= LEFT; // Asynchronous reset to walk_left\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= next_state; // Regular state transition\n\t\tend\n\tend\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tLEFT: begin\n\t\t\t\tif (bump_left) begin\n\t\t\t\t\tnext_state = RIGHT; // Switch to walk_right if bumped on the left\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = LEFT; // Remain in walk_left if no bumps\n\t\t\t\tend\n\t\t\tend\n\t\t\tRIGHT: begin\n\t\t\t\tif (bump_right) begin\n\t\t\t\t\tnext_state = LEFT; // Switch to walk_left if bumped on the right\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tnext_state = RIGHT; // Remain in walk_right if no bumps\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = LEFT; // Default to LEFT as safety\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Output logic based on current state\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tLEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\tend\n\t\t\tRIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\twalk_left = 0; // Safety\n\t\t\t\twalk_right = 0; // Safety\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\nassign q = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    // Intermediate wires for AND gates\n    wire and1_out_3input; // Output for the AND gate with p1a, p1b, p1c\n    wire and2_out_3input; // Output for the AND gate with p1d, p1e, p1f\n    wire and1_out_2input; // Output for the AND gate with p2a, p2b\n    wire and2_out_2input; // Output for the AND gate with p2c, p2d\n\n    // AND gates for p1y\n    assign and1_out_3input = p1a & p1b & p1c;\n    assign and2_out_3input = p1d & p1e & p1f;\n    // OR gate for p1y\n    assign p1y = and1_out_3input | and2_out_3input;\n\n    // AND gates for p2y\n    assign and1_out_2input = p2a & p2b;\n    assign and2_out_2input = p2c & p2d;\n    // OR gate for p2y\n    assign p2y = and1_out_2input | and2_out_2input;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\nalways @(*) begin\n\t// Determine the next state's Y0 based on the current state and input x\n\tcase (y)\n\t\t3'b000: Y0 = 1'b0; // Next state is 000 or 001, both have Y0 = 0 or 1\n\t\t3'b001: Y0 = x ? 0 : 1; // Next state is 001 (Y0=1) or 100 (Y0=0)\n\t\t3'b010: Y0 = x ? 1 : 0; // Next state is 001 (Y0=1 or 010 (Y0=0)\n\t\t3'b011: Y0 = x ? 0 : 1; // Next state is 010 (Y0=0) or 001 (Y0=1)\n\t\t3'b100: Y0 = x ? 1 : 1; // Next state is 011 (Y0=1 or 100 (Y0=0)\n\t\tdefault: Y0 = 1'b0;\n\tendcase\n\n\t// Determine output z based on the current state\n\tcase (y)\n\t\t3'b000: z = 1'b0;\n\t\t3'b001: z = 1'b0;\n\t\t3'b010: z = 1'b0;\n\t\t3'b011: z = 1'b1;\n\t\t3'b100: z = 1'b1;\n\t\tdefault: z = 1'b0;\n\tendcase\nend\n\nendmodule\n", "result": "failed: 18 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Calculate NOR using OR and NOT\n    assign out = ~(in1 | in2);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\t//  Always block sensitive to positive edge of clock or asynchronous reset\n\talways @(posedge clk or posedge ar) begin\n\t\tif (ar) begin\n\t\t\t// Asynchronous reset active, reset q to 0\n\t\t\tq <= 0;\n\t\tend else begin\n\t\t\t// On positive edge of clock, update q to the value of d\n\t\t\tq <= d;\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\n\talways @* begin\n\t\tcase (sel)\n\t\t\t3'b000: out = data0; // sel = 0\n\t\t\t3'b001: out = data1; // sel = 1\n\t\t\t3'b010: out = data2; // sel = 2\n\t\t\t3'b011: out = data3; // sel = 3\n\t\t\t3'b100: out = data4; // sel = 4\n\t\t\t3'b101: out = data5; // sel = 5\n\t\t\tdefault: out = 4'b0000; // sel = 6, 7, or others should output 0\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load)\n            counter <= data;\n        else if (counter != 10'b0)\n            counter <= counter - 10'b1;\n    end\n\n    assign tc = (counter == 10'b0);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE    = 3'b000,\n        S1      = 3'b001,\n        S11     = 3'b010,\n        S110    = 3'b011,\n        S1101   = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic (Sequential)\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic (Combinational)\n    always @(*) begin\n        case (current_state)\n            IDLE: next_state = (data == 1) ? S1 : IDLE;\n            S1: next_state = (data == 1) ? S11 : IDLE;\n            S11: next_state = (data == 0) ? S110 : IDLE;\n            S110: next_state = (data == 1) ? S1101 : IDLE;\n            S1101: next_state = S1101; // Remain in S1101 if sequence is found\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            start_shifting <= 0;\n        end else begin\n            if (current_state == S1101) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;  // If reset is high, set q to zero\n        end else begin\n            q <= d;  // Otherwise, set q to the input d\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n    // Register to store the previous state of 'in'\n    reg [7:0] prev_in;\n    \n    always @(posedge clk) begin\n        // Compare current input with previous input to detect any edge\n        anyedge <= in ^ prev_in;\n        \n        // Update prev_in with the current state of 'in' for the next cycle\n        prev_in <= in;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd1; // Reset the counter to 1\n        end\n        else begin\n            if (q == 4'd10) begin\n                q <= 4'd1; // Wrap back to 1 after reaching 10\n            end\n            else begin\n                q <= q + 4'd1; // Increment the counter\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 4; // When a=1, q is forced to be 4\n        end else begin\n            q <= q + 3'b001; // When a=0, q increments by 1\n            if (q == 3'b110) // Reset when q reaches 6 \n                q <= 3'b000;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001;  // Reset the LFSR output to 1\n        end else begin\n            q[4] <= q[3];           // Shift into the bit from the previous position q[3]\n            q[3] <= q[2];           // Shift into the bit from the previous position q[2]\n            q[2] <= q[1] ^ q[4];    // Apply XOR on tapped position\n            q[1] <= q[0];           // Shift into the bit from the previous position q[0]\n            q[0] <= q[4];           // The output bit also needs a simple shift into the lowest pos\n        end\n    end\n\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n            1: out = a - b;\n        endcase\n\n        if (out == 0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n    always_comb begin\n        f = (x[3] & x[4]) |                  // Covers x3x4 (11)\n            (x[3] & !x[4]) |                 // Covers x3!x4 (10)\n            (!x[3] & x[1]) |                 // Covers !x3x1 (utilizing don't-care)\n            (x[1] & x[2] & x[4]) |           // Covers x1x2x4 (utilizing don't-care)\n            (x[2] & x[3]);                   // Grouped from simplification\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\n    // Combinational logic to determine scancode recognition\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'b0000; // Key '0'\n                valid = 1;\n            end\n            8'h16: begin\n                out = 4'b0001; // Key '1'\n                valid = 1;\n            end\n            8'h1e: begin\n                out = 4'b0010; // Key '2'\n                valid = 1;\n            end\n            8'h26: begin\n                out = 4'b0011; // Key '3'\n                valid = 1;\n            end\n            8'h25: begin\n                out = 4'b0100; // Key '4'\n                valid = 1;\n            end\n            8'h2e: begin\n                out = 4'b0101; // Key '5'\n                valid = 1;\n            end\n            8'h36: begin\n                out = 4'b0110; // Key '6'\n                valid = 1;\n            end\n            8'h3d: begin\n                out = 4'b0111; // Key '7'\n                valid = 1;\n            end\n            8'h3e: begin\n                out = 4'b1000; // Key '8'\n                valid = 1;\n            end\n            8'h46: begin\n                out = 4'b1001; // Key '9'\n                valid = 1;\n            end\n            default: begin\n                out = 4'b0000; // Default case\n                valid = 0;     // Invalid input\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n\tout = (c & d) | (c & ~d & a) | (~c & ~d & a & b);\nend\n\nendmodule\n", "result": "failed: 31 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data in MSB first\n            q <= {q[2:0], data}; // Shift left and input new data at LSB\n        end\n        else if (count_ena) begin\n            // Decrement the value in the register\n            q <= q - 1;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n    // Directly connect the input to the output\n    assign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n    reg [2:0] count;  // 3-bit counter to count up to 4 (0 to 3)\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 3'b000;  // Initialize counter\n            shift_ena <= 1'b1;  // Assert shift_ena on reset\n        end else begin\n            if (count < 3'd3) begin\n                count <= count + 3'b001;  // Increment counter\n                shift_ena <= 1'b1;  // Keep shift_ena asserted\n            end else begin\n                shift_ena <= 1'b0;  // Deassert shift_ena after 4 cycles\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Reset the counter to 0\n        end else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\t\n\t// Using assign statement\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\t\n\t// Using always block and if statement\n\talways @(*) begin\n\t\tif (sel_b1 && sel_b2) begin\n\t\t\tout_always = b;\n\t\tend else begin\n\t\t\tout_always = a;\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    assign out = (~b & ~c & a) | (b & ~c) | (b & c);\nendmodule\n", "result": "failed: 57 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // State Encoding\n    parameter STATE_A = 2'b00, STATE_B = 2'b01, STATE_C = 2'b10, STATE_D = 2'b11;\n    \n    reg [1:0] current_state, next_state;\n\n    // State Flip-Flops\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_D: begin\n                if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            default: next_state = STATE_A;  // Default state in case of any error\n        endcase\n    end\n\n    // Output Logic\n    assign g[1] = (current_state == STATE_B);\n    assign g[2] = (current_state == STATE_C);\n    assign g[3] = (current_state == STATE_D);\n\nendmodule\n", "result": "failed: 4 out of 1054 samples.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) \n            q <= 4'd0; // Reset the counter to 0\n        else if (q == 4'd9)\n            q <= 4'd0; // Wrap around the counter to 0 if it reaches 9\n        else \n            q <= q + 1; // Increment the counter by 1\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // Declare states\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00, // Waiting for `in[3] = 1`\n        BYTE1 = 2'b01, // First byte detected\n        BYTE2 = 2'b10, // Second byte detected\n        BYTE3 = 2'b11  // Third byte detected, assert `done`\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State transition logic (sequential)\n    always @(posedge clk) begin\n        if (reset) \n            state <= IDLE;\n        else \n            state <= next_state;\n    end\n\n    // Next-state logic and output logic (combinational)\n    always @(*) begin\n        // Default values\n        next_state = state;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                // Wait for `in[3] = 1` to detect the first byte of a message\n                if (in[3]) \n                    next_state = BYTE1;\n            end\n\n            BYTE1: begin\n                // Transition to capture the second byte\n                next_state = BYTE2;\n            end\n\n            BYTE2: begin\n                // Transition to capture the third byte\n                next_state = BYTE3;\n            end\n\n            BYTE3: begin\n                // Assert `done` for one cycle, then return to IDLE\n                done = 1'b1;\n                next_state = IDLE;\n            end\n\n            default: next_state = IDLE; // Failsafe default state\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\n    assign out = sel ? b : a;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Assign outputs based on the respective logic operations\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    // Define state register\n    reg [2:0] state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (state)\n            3'b000: if (x) next_state = 3'b001; else next_state = 3'b000;\n            3'b001: if (x) next_state = 3'b100; else next_state = 3'b001;\n            3'b010: if (x) next_state = 3'b001; else next_state = 3'b010;\n            3'b011: if (x) next_state = 3'b010; else next_state = 3'b001;\n            3'b100: if (x) next_state = 3'b100; else next_state = 3'b011;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    // State Flip-Flop Logic\n    always @(posedge clk) begin\n        if (reset) state <= 3'b000;\n        else state <= next_state;\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (state)\n            3'b011: z = 1;\n            3'b100: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'd0, // Beginning state\n        B = 3'd1, // Output f=1 for one cycle, then go to C\n        C = 3'd2, // Monitor x for sequence 1, 0, 1\n        D = 3'd3, // Set g=1, monitor y for up to two cycles\n        E = 3'd4, // g = 1 permanently\n        F = 3'd5  // g = 0 permanently\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] y_counter; // To monitor y input for at most 2 cycles\n\n    // Sequential logic for state transition\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        f = 1'b0;\n        g = 1'b0;\n        \n        case (state)\n            A: begin\n                // Stay in A while resetn is asserted\n                if (~resetn)\n                    next_state = B; // Move to state B once resetn is de-asserted\n            end\n            B: begin\n                f = 1'b1; // Set f to 1 for one clock cycle\n                next_state = C; // After one cycle, move to state C\n            end\n            C: begin\n                // Monitor x for sequence 1, 0, 1\n                if (x == 1'b1)\n                    next_state = D;\n            end\n            D: begin\n                g = 1'b1; // Set g to 1\n                if (y == 1'b1)\n                    next_state = E;  // Maintain g = 1 permanently\n                else if (y_counter == 2) \n                    next_state = F; // Set g to 0 permanently if y doesn't become 1 in 2 cycles\n            end\n            E: begin\n                g = 1'b1; // Maintain g = 1 permanently\n            end\n            F: begin\n                g = 1'b0; // Maintain g = 0 permanently\n            end\n        endcase\n    end\n\n    // Counter logic for monitoring y for up to 2 cycles\n    always @(posedge clk or negedge resetn) begin\n        if (~resetn) begin\n            y_counter <= 2'b0;\n        end else if (state == D) begin\n            y_counter <= y_counter + 1;\n        end else begin\n            y_counter <= 2'b0;\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'h34;\n\t\tend else begin\n\t\t\tq <= d;\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n\n    // Perform XOR operation across all 8 bits of the input\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    assign out = (state == 2'b11) ? 1 : 0;  // Output logic based on state\n\n    always @(*) begin\n        case(state)\n            2'b00: next_state = (in == 0) ? 2'b00 : 2'b01;  // State A\n            2'b01: next_state = (in == 0) ? 2'b10 : 2'b01;  // State B\n            2'b10: next_state = (in == 0) ? 2'b00 : 2'b11;  // State C\n            2'b11: next_state = (in == 0) ? 2'b10 : 2'b01;  // State D\n            default: next_state = 2'b00;  // Default case (should not happen)\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // XNOR operation for the equivalence of the two inputs.\n    assign z = ~(x ^ y);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tA = 3'b000,\n\t\tB = 3'b001,\n\t\tC = 3'b010,\n\t\tD = 3'b011,\n\t\tE = 3'b100,\n\t\tF = 3'b101\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\n\t// State flip-flops with reset\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= A; // Reset to state A\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// State transition logic (state table)\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tA: next_state = (w) ? B : A;\n\t\t\tB: next_state = (w) ? C : D;\n\t\t\tC: next_state = (w) ? E : D;\n\t\t\tD: next_state = (w) ? F : A;\n\t\t\tE: next_state = (w) ? E : D;\n\t\t\tF: next_state = (w) ? C : D;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// Output logic for z\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tE, F: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[1])\n            q[15:8] <= d[15:8];\n        if (byteena[0])\n            q[7:0] <= d[7:0];\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n\treg [7:0] prev_in;\n\t\n\talways @(posedge clk) begin\n\t\tpedge <= (prev_in & ~in);\n\t\tprev_in <= in;\n\tend\n\nendmodule\n", "result": "failed: 208 out of 227 samples.", "passed": false}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\n\t// Update `p` on positive edge of the clock\n\talways @(posedge clock) begin\n\t\tif (a)\n\t\t\tp <= 1;\n\t\telse\n\t\t\tp <= 0;\n\tend\n\n\t// Update `q` on negative edge of the clock\n\talways @(negedge clock) begin\n\t\tq <= p;\n\tend\n\nendmodule\n", "result": "failed: 138 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when the load signal is high\n            q <= data;\n        end else begin\n            // Compute the next state for Rule 90 cellular automaton\n            q[0] <= q[1];  // q[-1] is treated as zero\n            q[511] <= q[510]; // q[512] is treated as zero\n            // Iterate over the cells from 1 to 510\n            for (int i = 1; i < 511; i = i + 1) begin\n                q[i] <= q[i-1] ^ q[i+1];\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n    // Assign output z based on the comparison between A and B.\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    // Calculate out_both: Each bit indicates if both the current and left-neighbor input bits are 1.\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Calculate out_any: Each bit indicates if either the current or right-neighbor input bits are 1.\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Calculate out_different: Each bit indicates if the current input bit is different from the left neighbor.\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : gen_out_different\n            assign out_different[i] = in[i] ^ in[(i+1) % 100];\n        end\n    endgenerate\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\nalways @(d or ena) begin\n    if (ena) begin\n        q = d;\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting index for the 4-bit segment\n    // sel * 4 gives the base index to fetch 4 bits from the 'in' array\n    assign out = in[sel*4 +: 4];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\nalways @(*) begin\n\tcase (sel)\n\t\t4'd0: out = a;\n\t\t4'd1: out = b;\n\t\t4'd2: out = c;\n\t\t4'd3: out = d;\n\t\t4'd4: out = e;\n\t\t4'd5: out = f;\n\t\t4'd6: out = g;\n\t\t4'd7: out = h;\n\t\t4'd8: out = i;\n\t\tdefault: out = 16'hFFFF;\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n\t// Compute bitwise OR of a and b\n\tassign out_or_bitwise = a | b;\n\n\t// Compute logical OR of a and b\n\tassign out_or_logical = |a | |b;\n\n\t// Compute bitwise NOT (inverse) of a and b\n\tassign out_not = {~b, ~a};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        case(state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n    \n    assign out = (state == 4'b1000) ? 1 : 0; // Output is 1 only in state D\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @(*) begin\n    reg [7:0] temp1, temp2;\n\n    // Compare first two numbers\n    if (a < b) begin\n        temp1 = a;\n    end else begin\n        temp1 = b;\n    end\n\n    // Compare result with third number\n    if (temp1 < c) begin\n        temp2 = temp1;\n    end else begin\n        temp2 = c;\n    end\n\n    // Compare result with fourth number to get final min\n    if (temp2 < d) begin\n        min = temp2;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n    \n    // AND gate\n    assign out_and = a & b;\n    \n    // OR gate\n    assign out_or = a | b;\n    \n    // XOR gate\n    assign out_xor = a ^ b;\n    \n    // NAND gate\n    assign out_nand = ~(a & b);\n    \n    // NOR gate\n    assign out_nor = ~(a | b);\n    \n    // XNOR gate\n    assign out_xnor = ~(a ^ b);\n    \n    // A AND-NOT B gate (A and the complement of B)\n    assign out_anotb = a & ~b;\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n    assign out = (~c & ~d) | (a & ~b & ~d) | (b & d) | (~a & b & c);\n\nendmodule\n", "result": "failed: 129 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n    // State declaration\n    typedef enum reg [2:0] {\n        STATE_A = 3'd0,\n        STATE_B1 = 3'd1,\n        STATE_B2 = 3'd2,\n        STATE_B3 = 3'd3,\n        STATE_B4 = 3'd4\n    } state_t;\n    \n    state_t state, next_state;\n    reg [1:0] count_w1s;  // Counter to count '1's in w over three cycles\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_A;\n            z <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(state, s, w, count_w1s) begin\n        next_state = state;  // Default to stay in the same state\n        z = 0;               // Default output\n\n        case (state)\n            STATE_A: begin \n                if (s == 1)\n                    next_state = STATE_B1;\n            end\n\n            STATE_B1: begin\n                count_w1s = (w == 1) ? 1 : 0;  // Start counting if w == 1\n                next_state = STATE_B2;\n            end\n\n            STATE_B2: begin\n                if (w == 1) count_w1s = count_w1s + 1;\n                next_state = STATE_B3;\n            end\n\n            STATE_B3: begin\n                if (w == 1) count_w1s = count_w1s + 1;\n                next_state = STATE_B4;\n            end\n\n            STATE_B4: begin\n                z = (count_w1s == 2) ? 1 : 0;  // Set output based on count\n                next_state = STATE_B1; // Go back to start checking again\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 272 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Replicate the sign bit (in[7]) 24 times and concatenate with the original 8-bit input\n    assign out = { {24{in[7]}}, in };\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\t// Internal signal to hold the state of the four flip-flops\n\treg [3:0] q;\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\t// If resetn is low, reset all flip-flops to 0\n\t\t\tq <= 4'b0000;\n\t\tend\n\t\telse begin\n\t\t\t// Shift operation: shift bits to the right and insert 'in' at the MSB\n\t\t\tq <= {q[2:0], in};\n\t\tend\n\tend\n\t\n\t// Output the last bit of the shift register\n\tassign out = q[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (1'b1) // Evaluate each bit in 'in' and output the corresponding position\n\t\t\tin[3]: pos = 2'd3; // Highest priority\n\t\t\tin[2]: pos = 2'd2;\n\t\t\tin[1]: pos = 2'd1;\n\t\t\tin[0]: pos = 2'd0;\n\t\t\tdefault: pos = 2'd0; // If no bits are high, output zero\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // Define states:\n    typedef enum reg {OFF, ON} state_t;\n    state_t state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j) ? ON : OFF;\n            ON : next_state = (k) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Output logic (Moore machine: output depends only on state)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            out <= 0;\n        end else begin\n            case (state)\n                OFF: out <= 0;\n                ON : out <= 1;\n                default: out <= 0;\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n\tassign out = 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n\t// Assign constant value 1 to the output 'one'\n\tassign one = 1'b1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\ninteger i;\nalways @(*) begin\n\tfor (i = 0; i < 100; i = i + 1) begin\n\t\tout[i] = in[99-i];\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n\n\t// Intermediate signal for XOR output\n\tlogic xor_out;\n\n\t// XOR gate logic\n\tassign xor_out = in ^ out;\n\n\t// D Flip-Flop logic (positive edge-triggered)\n\talways_ff @(posedge clk) begin\n\t\tout <= xor_out;\n\tend\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 4'b0000; // Asynchronously reset the register to zero\n\t\tend else if (load) begin\n\t\t\tq <= data; // Load the shift register with input data\n\t\tend else if (ena) begin\n\t\t\tq <= {1'b0, q[3:1]}; // Shift right, q[3] becomes 0\n\t\tend\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\n    // Combinational logic for f based on the simplified expression\n    assign f = x2 | (x3 & x1);\n\nendmodule\n", "result": "failed: 2 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n\t// Reduction AND for out_and\n\tassign out_and = &in;\n\n\t// Reduction OR for out_or\n\tassign out_or = |in;\n\n\t// Reduction XOR for out_xor\n\tassign out_xor = ^in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\nassign sum = a ^ b;  // XOR gate for sum\nassign cout = a & b; // AND gate for carry-out\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\treg current_state, next_state;\n\t\n    // State constants\n\tlocalparam OFF = 1'b0, ON = 1'b1;\n\t\n\t// State transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= OFF;  // Synchronous reset to OFF state\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\t\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tOFF: next_state = j ? ON : OFF;\n\t\t\tON: next_state = k ? OFF : ON;\n\t\tendcase\n\tend\n\t\n\t// Output logic based on Moore machine (output depends on current state)\n\talways @(*) begin\n\t\tout = current_state;\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    // Concatenate inputs and additional \"11\" bits to form a 32-bit vector\n    wire [31:0] combined;\n    assign combined = {a, b, c, d, e, f, 2'b11};\n    \n    // Assign the split sections to the output vectors\n    assign w = combined[31:24];\n    assign x = combined[23:16];\n    assign y = combined[15:8];\n    assign z = combined[7:0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = ~(a & b & c & d);\nendmodule\n", "result": "failed: 64 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a & b; // The & operator represents the AND operation in Verilog.\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State definitions\n    typedef enum logic [1:0] {\n        B = 1'b1, // State B: out = 1\n        A = 1'b0  // State A: out = 0\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            current_state <= B; // reset state is B\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always_comb begin\n        case (current_state)\n            B: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            A: begin\n                if (in)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n        endcase\n    end\n\n    // Output logic based on current state\n    always_comb begin\n        case (current_state)\n            B: out = 1;\n            A: out = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n    // Intermediate wire to connect XNOR output to XOR input\n    wire xnor_out;\n\n    // First gate: XNOR\n    assign xnor_out = ~(in1 ^ in2);\n\n    // Second gate: XOR\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    // Create the output using mux\n    assign mux_in[0] = ~c;      // Implement !c (invert operator or single inverter does effectively)\n    assign mux_in[1] = 1'b0;    // Always 0 for ab = 01\n    \n    // Use mux for implementing logic; two possible paths based on logic.\n    // Although for simple gates generally we would use !c and !d directly, simulate the mux behavior by direct assign.\n    \n    assign mux_in[2] = c & d;   // Implement c & d\n    assign mux_in[3] = c | d;   // Implement c | d\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // State encoding using one-hot\n    typedef enum reg [1:0] {\n        A = 2'b01, // State A encoded as 01\n        B = 2'b10  // State B encoded as 10\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition\n    always @(*) begin\n        case (state)\n            A: next_state = (x) ? B : A;\n            B: next_state = (x) ? B : B;\n            default: next_state = A; // default to state A\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = x;\n            B: z = ~x;\n            default: z = 1'b0; // default output value\n        endcase\n    end\n    \n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (a == 1 && b == 1) begin\n\t\tstate <= ~state;\n\tend else begin\n\t\tstate <= b;\n\tend\n\tq <= state;\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n    always_comb begin\n        f = (~x[3] & ~x[4] & ~x[1] & ~x[2]) | // x[3]x[4] = 00, x[1]x[2] = 00\n            (~x[3] & ~x[4] &  x[1] & ~x[2]) | // x[3]x[4] = 00, x[1]x[2] = 10\n            ( x[3] &  x[4] & ~x[1] & ~x[2]) | // x[3]x[4] = 11, x[1]x[2] = 00\n            ( x[3] &  x[4] & ~x[1] &  x[2]) | // x[3]x[4] = 11, x[1]x[2] = 01\n            ( x[3] &  x[4] &  x[1] &  x[2]) | // x[3]x[4] = 11, x[1]x[2] = 11\n            ( x[3] & ~x[4] & ~x[1] & ~x[2]) | // x[3]x[4] = 10, x[1]x[2] = 00\n            ( x[3] & ~x[4] & ~x[1] &  x[2]) | // x[3]x[4] = 10, x[1]x[2] = 01\n            ( x[3] & ~x[4] &  x[1] & ~x[2]);  // x[3]x[4] = 10, x[1]x[2] = 10\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    // State declaration\n    typedef enum reg [3:0] {\n        STATE_0,  // 0 consecutive 1s\n        STATE_1,  // 1 consecutive 1s\n        STATE_2,  // 2 consecutive 1s\n        STATE_3,  // 3 consecutive 1s\n        STATE_4,  // 4 consecutive 1s\n        STATE_5,  // 5 consecutive 1s\n        STATE_6,  // 6 consecutive 1s (flag)\n        STATE_7   // error\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // FSM sequential logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_0; // Reset to initial state\n        end else begin\n            current_state <= next_state; // Transition to next state\n        end\n    end\n\n    // FSM combinational logic\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n        \n        case (current_state)\n            STATE_0: next_state = in ? STATE_1 : STATE_0;\n            STATE_1: next_state = in ? STATE_2 : STATE_0;\n            STATE_2: next_state = in ? STATE_3 : STATE_0;\n            STATE_3: next_state = in ? STATE_4 : STATE_0;\n            STATE_4: next_state = in ? STATE_5 : STATE_0;\n            STATE_5: begin\n                if (in) next_state = STATE_6;\n                else begin\n                    next_state = STATE_0;\n                    disc = 1;  // Signal to discard a bit\n                end\n            end\n            STATE_6: begin\n                if (in) next_state = STATE_7;\n                else begin\n                    next_state = STATE_0;\n                    flag = 1;  // Signal the flag condition\n                end\n            end\n            STATE_7: begin\n                next_state = in ? STATE_7 : STATE_0;\n                err = 1;  // Signal an error condition\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n\t// State declaration\n\ttypedef enum reg [2:0] {\n\t\tIDLE,        // Waiting for 1101\n\t\tGET_DELAY,   // Reading 4 bits for delay\n\t\tCOUNTING,    // Counting for (delay + 1) * 1000 cycles\n\t\tDONE         // Indicate the timer has completed\n\t} state_t;\n\n\tstate_t state, next_state;\n\treg [3:0] delay;\n\treg [3:0] bit_counter;\n\treg [12:0] cycle_counter;  // Allows counting up to 8191, sufficient for 8000\n\treg [3:0] shift_reg;\n\n\t// Sequential state transition\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tcycle_counter <= 0;\n\t\t\tbit_counter <= 0;\n\t\t\tshift_reg <= 0;\n\t\t\tcounting <= 0;\n\t\t\tdone <= 0;\n\t\tend\n\t\telse begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tIDLE: begin\n\t\t\t\t\tif (data == 1) shift_reg <= {shift_reg[2:0], data};\n\t\t\t\t\tif (shift_reg == 4'b1101) begin\n\t\t\t\t\t\tbit_counter <= 0;\n\t\t\t\t\t\tdelay <= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tGET_DELAY: begin\n\t\t\t\t\tbit_counter <= bit_counter + 1;\n\t\t\t\t\tdelay <= {delay[2:0], data};\n\t\t\t\t\tif (bit_counter == 3) begin\n\t\t\t\t\t\tcycle_counter <= 13'b0;  // Reset cycle counter\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNTING: begin\n\t\t\t\t\tcycle_counter <= cycle_counter + 1;\n\t\t\t\t\tif (cycle_counter == 1000) begin\n\t\t\t\t\t\tcycle_counter <= 0;\n\t\t\t\t\t\tcount <= delay;\n\t\t\t\t\t\tif (delay != 0) begin\n\t\t\t\t\t\t\tdelay <= delay - 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tDONE: begin\n\t\t\t\t\tif (ack) next_state <= IDLE;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Combinational state transition\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (shift_reg == 4'b1101) next_state = GET_DELAY;\n\t\t\tGET_DELAY: if (bit_counter == 4) next_state = COUNTING;\n\t\t\tCOUNTING: if (delay == 0 && cycle_counter == 1000) next_state = DONE;\n\t\t\tDONE: if (ack) next_state = IDLE;\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tCOUNTING: begin\n\t\t\t\tcounting = 1;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\t\tDONE: begin\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tcounting = 0;\n\t\t\t\tdone = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum logic [1:0] {\n        LOW = 2'b00,\n        BETWEEN_S1_S2 = 2'b01,\n        BETWEEN_S2_S3 = 2'b10,\n        HIGH = 2'b11\n    } state_t;\n    \n    // State Variable Declaration\n    state_t current_state, next_state;\n\n    // Sequential Logic for State Transition\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            // Reset state to LOW\n            current_state <= LOW;\n        end else begin\n            // State transition\n            current_state <= next_state;\n        end\n    end\n\n    // Combinational Logic for Next State\n    always_comb begin\n        case (current_state)\n            LOW: begin\n                if (s[1]) next_state = BETWEEN_S1_S2; else next_state = LOW;\n            end\n            BETWEEN_S1_S2: begin\n                if (s[2]) next_state = BETWEEN_S2_S3;\n                else if (!s[1]) next_state = LOW;\n                else next_state = BETWEEN_S1_S2;\n            end\n            BETWEEN_S2_S3: begin\n                if (s[3]) next_state = HIGH;\n                else if (!s[2]) next_state = BETWEEN_S1_S2;\n                else next_state = BETWEEN_S2_S3;\n            end\n            HIGH: begin\n                if (!s[3]) next_state = BETWEEN_S2_S3; else next_state = HIGH;\n            end\n            default: next_state = LOW; // Safe default state\n        endcase\n    end\n\n    // Output Logic based on State\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            fr3 <= 1'b1;\n            fr2 <= 1'b1;\n            fr1 <= 1'b1;\n            dfr <= 1'b1;\n        end else begin\n            case (next_state)\n                LOW: begin\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n                BETWEEN_S1_S2: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b0;\n                end\n                BETWEEN_S2_S3: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n                HIGH: begin\n                    fr3 <= 1'b0;\n                    fr2 <= 1'b0;\n                    fr1 <= 1'b0;\n                    dfr <= 1'b0;\n                end\n                default: begin\n                    fr3 <= 1'b1;\n                    fr2 <= 1'b1;\n                    fr1 <= 1'b1;\n                    dfr <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State enumeration\n    typedef enum logic [3:0] {\n        IDLE = 4'd0,\n        START = 4'd1,\n        DATA0 = 4'd2,\n        DATA1 = 4'd3,\n        DATA2 = 4'd4,\n        DATA3 = 4'd5,\n        DATA4 = 4'd6,\n        DATA5 = 4'd7,\n        DATA6 = 4'd8,\n        DATA7 = 4'd9,\n        STOP = 4'd10\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State transition logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state; // Default state transition\n        done = 1'b0; // Default done signal\n        case (current_state)\n            IDLE: begin\n                if (in == 1'b0)\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA0;\n            end\n            DATA0: begin\n                next_state = DATA1;\n            end\n            DATA1: begin\n                next_state = DATA2;\n            end\n            DATA2: begin\n                next_state = DATA3;\n            end\n            DATA3: begin\n                next_state = DATA4;\n            end\n            DATA4: begin\n                next_state = DATA5;\n            end\n            DATA5: begin\n                next_state = DATA6;\n            end\n            DATA6: begin\n                next_state = DATA7;\n            end\n            DATA7: begin\n                next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1'b1) begin\n                    next_state = IDLE;\n                    done = 1'b1;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    reg [3:0] state, next_state;\n    reg [3:0] bit_counter;\n    reg [7:0] data_buffer;\n\n    localparam IDLE = 0, \n               START = 1, \n               DATA = 2, \n               STOP = 3, \n               VALID = 4;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_counter <= 0;\n            data_buffer <= 0;\n        end else begin\n            state <= next_state;\n            if (state == DATA) begin\n                data_buffer[bit_counter] <= in;\n                bit_counter <= bit_counter + 1;\n            end else if (state == VALID) begin\n                out_byte <= data_buffer;\n            end\n            if (state == VALID || state == STOP) begin\n                bit_counter <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        done = 0;\n        case (state)\n            IDLE: begin\n                if (in == 0) //Detects start bit (0)\n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA; // Move to data bits collection\n            end\n            DATA: begin\n                if (bit_counter == 8)\n                    next_state = STOP; // Collect all 8 bits, move to stop check\n            end\n            STOP: begin\n                if (in == 1) begin // Check stop bit\n                    done = 1;\n                    next_state = VALID;\n                end else begin\n                    next_state = IDLE; // Error, wait for valid idle line\n                end\n            end\n            VALID: begin\n                done = 1; // Data ready, process next frame\n                if (in == 1)\n                    next_state = IDLE; // Stay here until finding next start bit\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n\treg [6:0] global_history;\n\treg [1:0] PHT [0:127]; // 128 2-bit counters\n    \n\tinteger i;\n\n\t// Asynchronous reset\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\t// Reset global history register and PHT\n\t\t\tglobal_history <= 7'b0;\n\t\t\tfor (i = 0; i < 128; i = i + 1) begin\n\t\t\t\tPHT[i] <= 2'b10;  // weakly taken state\n\t\t\tend\n\t\tend else begin\n\t\t\tif (train_valid) begin\n\t\t\t\t// Compute index\n\t\t\t\tinteger train_index = train_pc ^ train_history;\n\n\t\t\t\t// Update PHT based on actual result\n\t\t\t\tif (train_taken) begin\n\t\t\t\t\tif (PHT[train_index] < 2'b11)\n\t\t\t\t\t\tPHT[train_index] <= PHT[train_index] + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tif (PHT[train_index] > 2'b00)\n\t\t\t\t\t\tPHT[train_index] <= PHT[train_index] - 1;\n\t\t\t\tend\n\n\t\t\t\t// Recover history if mispredicted\n\t\t\t\tif (train_mispredicted)\n\t\t\t\t\tglobal_history <= train_history;\n\t\t\t\telse\n\t\t\t\t\tglobal_history <= {global_history[5:0], train_taken};\n\t\t\tend else if (predict_valid) begin\n\t\t\t\t// Compute index for prediction\n\t\t\t\tinteger predict_index = predict_pc ^ global_history;\n\t\t\t\t\n\t\t\t\t// Predict based on PHT and update global history\n\t\t\t\tpredict_taken <= PHT[predict_index][1];\n\t\t\t\tpredict_history <= global_history;\n\t\t\t\t\n\t\t\t\t// Update global history with prediction\n\t\t\t\tglobal_history <= {global_history[5:0], predict_taken};\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    // States encoding\n    typedef enum reg [2:0] {\n        STATE_WALK_LEFT = 3'b000,\n        STATE_WALK_RIGHT = 3'b001,\n        STATE_FALL = 3'b010,\n        STATE_DIG = 3'b011,\n        STATE_SPLATTERED = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [4:0] fall_counter; // Allows counting up to 31\n\n    // State transition logic (sequential)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_WALK_LEFT;\n            fall_counter <= 0;\n        end\n        else begin\n            current_state <= next_state;\n            if (current_state == STATE_FALL && ground == 0) begin\n                fall_counter <= fall_counter + 1;\n            end else if (ground == 1) begin\n                fall_counter <= 0; // Reset if on ground\n            end\n        end\n    end\n\n    // Next state logic (combinatorial)\n    always @(*) begin\n        case (current_state)\n            STATE_WALK_LEFT: begin\n                if (~ground) next_state = STATE_FALL;\n                else if (dig && ground) next_state = STATE_DIG;\n                else if (bump_left && ground) next_state = STATE_WALK_RIGHT;\n                else next_state = STATE_WALK_LEFT;\n            end\n\n            STATE_WALK_RIGHT: begin\n                if (~ground) next_state = STATE_FALL;\n                else if (dig && ground) next_state = STATE_DIG;\n                else if (bump_right && ground) next_state = STATE_WALK_LEFT;\n                else next_state = STATE_WALK_RIGHT;\n            end\n\n            STATE_FALL: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = STATE_SPLATTERED;\n                    else if (current_state == STATE_WALK_LEFT) next_state = STATE_WALK_LEFT;\n                    else next_state = STATE_WALK_RIGHT;\n                end else begin\n                    next_state = STATE_FALL;\n                end\n            end\n\n            STATE_DIG: begin\n                if (~ground) next_state = STATE_FALL;\n                else next_state = STATE_DIG;\n            end\n\n            default: begin // Else implies STATE_SPLATTERED\n                next_state = STATE_SPLATTERED;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (current_state)\n            STATE_WALK_LEFT: walk_left = 1;\n            STATE_WALK_RIGHT: walk_right = 1;\n            STATE_FALL: aaah = 1;\n            STATE_DIG: digging = 1;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    \n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        PATTERN_DETECTED = 3'b001,\n        SHIFT = 3'b010,\n        COUNT = 3'b011,\n        DONE_WAIT = 3'b100\n    } state_t;\n    \n    reg [2:0] current_state, next_state;\n    reg [3:0] shift_counter;\n    \n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_counter <= 4'd0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == SHIFT) begin\n                shift_counter <= shift_counter + 1;\n            end else begin\n                shift_counter <= 4'd0;\n            end\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if ({data, data, data, data} == 4'b1101) begin\n                    next_state = PATTERN_DETECTED;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            PATTERN_DETECTED: begin\n                next_state = SHIFT;\n            end\n            SHIFT: begin\n                if (shift_counter == 4'd3) begin\n                    next_state = COUNT;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            COUNT: begin\n                if (done_counting) begin\n                    next_state = DONE_WAIT;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            DONE_WAIT: begin\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = DONE_WAIT;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        shift_ena = (current_state == SHIFT);\n        counting = (current_state == COUNT);\n        done = (current_state == DONE_WAIT);\n    end\n\nendmodule\n", "result": "failed: 4152 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n    reg [3:0] x, y;  // Loop indices for row and column\n    integer i, j, idx;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the grid\n            q <= data;\n        end else begin\n            reg [255:0] next_state;\n            next_state = 256'd0; // initialize next_state\n\n            // Iterate through each cell\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    idx = i*16 + j; // Index in the 1D vector\n\n                    // Calculate neighbors with wrapping\n                    integer neighbors;\n                    neighbors =\n                        q[((i-1+16) % 16) * 16 + ((j-1+16) % 16)] +\n                        q[((i-1+16) % 16) * 16 + j] +\n                        q[((i-1+16) % 16) * 16 + ((j+1) % 16)] +\n\n                        q[(i * 16) + ((j-1+16) % 16)] +\n                        q[(i * 16) + ((j+1) % 16)] +\n\n                        q[((i+1) % 16) * 16 + ((j-1+16) % 16)] +\n                        q[((i+1) % 16) * 16 + j] +\n                        q[((i+1) % 16) * 16 + ((j+1) % 16)];\n\n                    // Apply the rules\n                    if (neighbors < 2 || neighbors > 3) begin\n                        next_state[idx] = 0; // Dead\n                    end else if (neighbors == 3) begin\n                        next_state[idx] = 1; // Alive\n                    end else begin\n                        next_state[idx] = q[idx]; // Remains the same\n                    end\n                end\n            end\n            q <= next_state; // Update state for the next timestep\n        end\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    typedef enum logic [2:0] {\n        STATE_WALK_LEFT, \n        STATE_WALK_RIGHT, \n        STATE_FALL_LEFT, \n        STATE_FALL_RIGHT, \n        STATE_DIG_LEFT, \n        STATE_DIG_RIGHT\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (state)\n            STATE_WALK_LEFT: begin\n                if (!ground)\n                    next_state = STATE_FALL_LEFT;\n                else if (dig)\n                    next_state = STATE_DIG_LEFT;\n                else if (bump_left || bump_right)\n                    next_state = STATE_WALK_RIGHT;\n                else\n                    next_state = STATE_WALK_LEFT;\n            end\n            \n            STATE_WALK_RIGHT: begin\n                if (!ground)\n                    next_state = STATE_FALL_RIGHT;\n                else if (dig)\n                    next_state = STATE_DIG_RIGHT;\n                else if (bump_left || bump_right)\n                    next_state = STATE_WALK_LEFT;\n                else\n                    next_state = STATE_WALK_RIGHT;\n            end\n            \n            STATE_FALL_LEFT: begin\n                if (ground)\n                    next_state = STATE_WALK_LEFT;\n                else\n                    next_state = STATE_FALL_LEFT;\n            end\n            \n            STATE_FALL_RIGHT: begin\n                if (ground)\n                    next_state = STATE_WALK_RIGHT;\n                else\n                    next_state = STATE_FALL_RIGHT;\n            end\n            \n            STATE_DIG_LEFT: begin\n                if (!ground)\n                    next_state = STATE_FALL_LEFT;\n                else\n                    next_state = STATE_DIG_LEFT;\n            end\n            \n            STATE_DIG_RIGHT: begin\n                if (!ground)\n                    next_state = STATE_FALL_RIGHT;\n                else\n                    next_state = STATE_DIG_RIGHT;\n            end\n            \n            default: next_state = STATE_WALK_LEFT;\n        endcase\n    end\n\n    // State register update logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= STATE_WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        walk_left = (state == STATE_WALK_LEFT);\n        walk_right = (state == STATE_WALK_RIGHT);\n        aaah = (state == STATE_FALL_LEFT || state == STATE_FALL_RIGHT);\n        digging = (state == STATE_DIG_LEFT || state == STATE_DIG_RIGHT);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    // Initializing all the outputs.\n    initial begin\n        hh = 8'b0001_0010; // 12 in BCD\n        mm = 8'b0000_0000; \n        ss = 8'b0000_0000;\n        pm = 0; // AM\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // On reset, set to 12:00 AM\n            hh <= 8'b0001_0010; // 12 in BCD\n            mm <= 8'b0000_0000;\n            ss <= 8'b0000_0000;\n            pm <= 0; // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b0101_1001) begin // If 59\n                ss <= 8'b0000_0000;\n                \n                // Increment minutes\n                if (mm == 8'b0101_1001) begin // If 59\n                    mm <= 8'b0000_0000;\n                    \n                    // Increment hours\n                    if (hh == 8'b0001_0010) begin // If 12\n                        hh <= 8'b0000_0001; // Wrap to 1\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'b0001_0001) begin // If 11\n                        hh <= hh + 1; // Increment to 12\n                        pm <= ~pm; // Toggle AM/PM\n                    end else begin\n                        hh <= hh + 1;\n                    end\n                end else begin\n                    mm <= mm + 1;\n                end\n            end else begin\n                ss <= ss + 1;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 351978 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n\t// State declaration\n\ttypedef enum {WALK_LEFT, WALK_RIGHT, FALL_LEFT, FALL_RIGHT} state_t;\n\tstate_t current_state, next_state;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground) \n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\t\telse if (bump_left || bump_right) \n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse \n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\t\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground) \n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\t\telse if (bump_left || bump_right) \n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse \n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\t\t\n\t\t\tFALL_LEFT: begin\n\t\t\t\tif (ground) \n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_LEFT;\n\t\t\tend\n\t\t\t\n\t\t\tFALL_RIGHT: begin\n\t\t\t\tif (ground) \n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FALL_RIGHT;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: \n\t\t\t\tnext_state = WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// State update logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tcurrent_state <= WALK_LEFT;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\tend\n\t\t\t\n\t\t\tWALK_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 1;\n\t\t\t\taaah = 0;\n\t\t\tend\n\t\t\t\n\t\t\tFALL_LEFT, FALL_RIGHT: begin\n\t\t\t\twalk_left = 0;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 1;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\twalk_left = 1;\n\t\t\t\twalk_right = 0;\n\t\t\t\taaah = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 16'b0; // Set all counters to zero on reset\n        end else begin\n            if (q[3:0] == 4'd9) begin\n                q[3:0] <= 4'd0;\n                if (q[7:4] == 4'd9) begin\n                    q[7:4] <= 4'd0;\n                    if (q[11:8] == 4'd9) begin\n                        q[11:8] <= 4'd0;\n                        if (q[15:12] == 4'd9) begin\n                            q[15:12] <= 4'd0;\n                        end else begin\n                            q[15:12] <= q[15:12] + 1;\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 1;\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1;\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1;\n            end\n        end\n    end\n\n    // Generate enable signals based on rollover condition\n    assign ena[1] = (q[3:0] == 4'd9);      // Enable tens digit increment\n    assign ena[2] = (q[7:4] == 4'd9) && (q[3:0] == 4'd9); // Enable hundreds digit increment\n    assign ena[3] = (q[11:8] == 4'd9) && (q[7:4] == 4'd9) && (q[3:0] == 4'd9); // Enable thousands digit increment\n\nendmodule\n", "result": "passed", "passed": true}
