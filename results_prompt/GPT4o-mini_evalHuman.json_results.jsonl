{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\n\tassign out = sel ? b : a;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(*) begin\n    case (y)\n        3'b010: Y2 = (w == 0) ? 1 : 0; // State C\n        3'b011: Y2 = (w == 0) ? 1 : 0; // State D\n        3'b100: Y2 = 1;                 // State E\n        default: Y2 = 0;                // States A, B, F\n    endcase\nend\n\nendmodule\n", "result": "failed: 48 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\nassign motor = vibrate_mode; // Motor is on if vibrate_mode is 1\nassign ringer = ~vibrate_mode & ring; // Ringer is on if vibrate_mode is 0 and ring is 1\n\nendmodule\n", "result": "failed: 4 out of 19 samples.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Using assign statement for out_assign\nassign out_assign = a & b;\n\n// Using always block for out_alwaysblock\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\nassign zero = 1'b0; // Always drive zero to LOW\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (a == 1) begin\n\t\tq <= 0; // If a is high, reset q to 0\n\tend else begin\n\t\tq <= 1; // If a is low, set q to 1\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] tmp;   // Temporary register to hold the inverted bits\n    reg [5:0] count;  // Counter for number of bits received\n    reg finished;     // State indicator for completion    \n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            tmp <= 0;\n            count <= 0;\n            z <= 0;\n            finished <= 0;    \n        end else if (count < 32) begin // Assuming a max of 32 bits for simplicity\n            tmp[count] <= ~x; // Invert the incoming bit\n            count <= count + 1;    \n        end else begin\n            finished <= 1; // We have finished processing the input\n        end\n    end\n\n    // Generate output after all bits have been taken\n    always @(posedge clk) begin\n        if (finished) begin\n            z <= tmp[0] ^ 1; // Adding 1 to the least significant result bit\n            finished <= 0; // Reset the finished state\n            count <= 0; // Reset count for a new number\n        end else begin\n            // Shift left tmp to add incoming data\n            tmp <= {tmp[30:0], tmp[31]};\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State Encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_type;\n\n    // State registers\n    state_type current_state, next_state;\n\n    // Asynchronous Reset and State Transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= A;  // Reset state to A\n        end else begin\n            current_state <= next_state;  // Update current state\n        end\n    end\n\n    // Next State Logic\n    always @* begin\n        case (current_state)\n            A: begin\n                if (in) next_state = B;\n                else next_state = A;\n            end\n            B: begin\n                if (in) next_state = B;\n                else next_state = C;\n            end\n            C: begin\n                if (in) next_state = D;\n                else next_state = A;\n            end\n            D: begin\n                if (in) next_state = B;\n                else next_state = C;\n            end\n            default: next_state = A;  // Default state\n        endcase\n    end\n\n    // Output Logic\n    always @* begin\n        case (current_state)\n            A, B, C: out = 0;   // Output is 0 in states A, B, and C\n            D: out = 1;         // Output is 1 in state D\n            default: out = 0;   // Default output\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]}; // Concatenate bytes in reversed order\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk) begin\n        if (r) begin\n            q <= 0; // Active high reset sets q to 0\n        end else begin\n            q <= d; // On clock edge, assign d to q\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\twire xor_result;\n\n\tassign xor_result = x ^ y; // Compute x XOR y\n\tassign z = xor_result & x; // Compute z as (x XOR y) AND x\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load data into q\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;         // Shift left by 1 bit\n                2'b01: q <= q << 8;         // Shift left by 8 bits\n                2'b10: q <= {q[62:0], q[63]}; // Arithmetic right shift by 1 bit\n                2'b11: q <= {q[55:0], q[63:56]}; // Arithmetic right shift by 8 bits\n                default: q <= q;            // No change\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: 3354 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [1:0] {\n\tS0 = 2'b00,\n\tS1 = 2'b01,\n\tS2 = 2'b10\n} state_t;\n\n// Current state and next state\nstate_t current_state, next_state;\n\n// Asynchronous reset\nalways @(posedge clk or negedge aresetn) begin\n\tif (!aresetn) begin\n\t\tcurrent_state <= S0;  // Reset to state S0\n\t\tz <= 0;               // Output reset\n\tend else begin\n\t\tcurrent_state <= next_state; // Transition to next state\n\tend\nend\n\n// Next state logic and output logic\nalways @(*) begin\n\t// Default assignments\n\tnext_state = current_state;\n\tz = 0; // Default output is 0\n\n\tcase (current_state)\n\t\tS0: begin\n\t\t\tif (x == 1) begin\n\t\t\t\tnext_state = S1; // Move to state S1\n\t\t\tend\n\t\tend\n\n\t\tS1: begin\n\t\t\tif (x == 0) begin\n\t\t\t\tnext_state = S2; // Move to state S2 upon receiving '0'\n\t\t\tend else if (x == 1) begin\n\t\t\t\tnext_state = S1; // Stay in S1\n\t\t\tend\n\t\tend\n\n\t\tS2: begin\n\t\t\tif (x == 1) begin\n\t\t\t\tz = 1; // Output z is 1 as we detected \"101\" sequence\n\t\t\t\tnext_state = S2; // Stay in S2\n\t\t\tend else if (x == 0) begin\n\t\t\t\tnext_state = S0; // Transition back to S0\n\t\t\tend\n\t\tend\n\n\t\tdefault: begin\n\t\t\tnext_state = S0; // Default case should never occur\n\t\tend\n\tendcase\nend\n\nendmodule\n", "result": "failed: 38 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @ (posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= A; // reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (current_state)\n            A: next_state = (w == 0) ? B : A;\n            B: next_state = (w == 0) ? C : D;\n            C: next_state = (w == 0) ? E : D;\n            D: next_state = (w == 0) ? F : A;\n            E: next_state = (w == 0) ? E : D;\n            F: next_state = (w == 0) ? C : D;\n            default: next_state = A; // Default to A\n        endcase\n    end\n\n    // Output logic\n    always @ (*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    // State definition\n    typedef enum reg [1:0] {\n        WAIT_FOR_HEADER = 2'b00,\n        RECEIVE_BYTE1   = 2'b01,\n        RECEIVE_BYTE2   = 2'b10,\n        RECEIVE_BYTE3   = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= WAIT_FOR_HEADER;\n            out_bytes <= 24'b0;\n            done <= 1'b0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Combinational logic for the next state and outputs\n    always @(*) begin\n        // Default values\n        next_state = current_state;\n        done = 1'b0;\n\n        case (current_state)\n            WAIT_FOR_HEADER: begin\n                if (in[3]) begin\n                    next_state = RECEIVE_BYTE1; // Transition to first byte\n                end\n            end\n            \n            RECEIVE_BYTE1: begin\n                out_bytes[23:16] = in; // Store first byte\n                next_state = RECEIVE_BYTE2; // Transition to second byte\n            end\n            \n            RECEIVE_BYTE2: begin\n                out_bytes[15:8] = in; // Store second byte\n                next_state = RECEIVE_BYTE3; // Transition to third byte\n            end\n            \n            RECEIVE_BYTE3: begin\n                out_bytes[7:0] = in; // Store third byte\n                done = 1'b1; // Signal done\n                next_state = WAIT_FOR_HEADER; // Go back to waiting for header\n            end\n            \n            default: begin\n                next_state = WAIT_FOR_HEADER; // Default state\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    // Logic for Y1\n    assign Y1 = y[0] & w;\n\n    // Logic for Y3\n    assign Y3 = (!w & (y[1] | y[2]));\n\nendmodule\n", "result": "failed: 59 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n// Assign the input vector to the output vector\nassign outv = vec;\n\n// Assign separate bits to the individual outputs\nassign o2 = vec[2]; // Most significant bit\nassign o1 = vec[1]; // Middle bit\nassign o0 = vec[0]; // Least significant bit\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    \n    always @(*) begin\n        out = (b & ~d) | (~a & c & d) | (a & ~b) | (a & c & ~d);\n    end\n\nendmodule\n", "result": "failed: 120 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\tassign out_lo = in[7:0];  // Lower byte\n\tassign out_hi = in[15:8]; // Upper byte\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a | b); // NOR gate logic\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Continuous assignment for XOR\nassign out_assign = a ^ b;\n\n// Combinational always block for XOR\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block for XOR with flip-flop behavior\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n    assign Y2 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & w) | (y[5] & w) | (y[6] & ~w);\n    assign Y4 = (y[2] & w) | (y[3] & 1) | (y[4] & ~w) | (y[6] & 1);\nendmodule\n", "result": "failed: 373 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    assign out = in[sel]; // assign the output to the selected input bit\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (L) begin\n            Q <= R;  // Load value R into Q\n        end else if (E) begin\n            Q <= w;  // Shift the input w into Q\n        end\n        // If neither L nor E is asserted, Q retains its value\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Declare flip-flop outputs as registers\n    reg dff1_out;\n    reg dff2_out;\n    reg dff3_out;\n\n    // To hold the outputs of the gates\n    wire xor_out;\n    wire and_out;\n    wire or_out;\n\n    // Logic for the gates\n    assign xor_out = x ^ dff1_out; // XOR gate\n    assign and_out = x & ~dff2_out; // AND gate (with complemented output)\n    assign or_out = x | ~dff3_out; // OR gate (with complemented output)\n\n    // Clock event: update flip-flops\n    always @(posedge clk) begin\n        dff1_out <= xor_out; // D flip-flop 1\n        dff2_out <= and_out; // D flip-flop 2\n        dff3_out <= or_out;  // D flip-flop 3\n    end\n\n    // Output Z is the three-input XNOR of the D flip-flop outputs\n    assign z = ~(dff1_out ^ dff2_out ^ dff3_out); // Z is the output of the three-input XNOR\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\nassign q = (b) || (a == 0 && c && !d);\n\nendmodule\n", "result": "failed: 22 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    \n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            // Compute the next state based on Rule 110\n            next_q[0] = 0; // Left boundary cell is considered 0\n            for (int i = 1; i < 511; i = i + 1) begin\n                next_q[i] = (q[i-1] & q[i]) | (q[i] & ~q[i+1]) | (~q[i-1] & q[i+1]);\n            end\n            next_q[511] = 0; // Right boundary cell is considered 0\n            q <= next_q; // Update to the next state\n        end\n    end\n\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    typedef enum logic [1:0] {A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always_comb begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // State update and output logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output logic\n    always_ff @(current_state) begin\n        out = (current_state == D) ? 1 : 0;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @(*) begin\n\tcase(c)\n\t\t4'd0: q = b;\n\t\t4'd1: q = e;\n\t\t4'd2: q = a;\n\t\t4'd3: q = d;\n\t\t4'd4, 4'd5, 4'd6, 4'd7, 4'd8, 4'd9: q = 4'hf;\n\t\tdefault: q = 4'hf; // Assuming values beyond 9 result in the same output.\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\nalways @(*) begin\n\tif (sel) begin\n\t\tout = b;  // when sel is high, select input b\n\tend else begin\n\t\tout = a;  // when sel is low, select input a\n\tend\nend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;  // Load r_in into Q when L is high\n        end else begin\n            Q <= q_in;  // Otherwise take the value from q_in\n        end\n    end\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    reg [31:0] previous; // Register to hold the previous input value\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0; // Reset output to 0 when reset is high\n            previous <= 32'b0; // Optionally reset previous too\n        end else begin\n            // Check for transitions from 1 to 0\n            out <= out | (~in & previous); // Set out for each transition from 1 to 0\n            previous <= in; // Update the previous value to current\n        end\n    end\n\nendmodule\n", "result": "failed: 91 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    q <= d; // Capture the current value of d into q on the positive edge of clk\nend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n    // Perform the addition\n    wire [7:0] sum;\n    assign sum = a + b;\n\n    // Assign the output sum\n    assign s = sum;\n\n    // Calculate overflow condition\n    wire a_sign = a[7];\n    wire b_sign = b[7];\n    wire s_sign = sum[7];\n\n    assign overflow = (a_sign == b_sign) && (a_sign != s_sign);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // State transitions\n    assign B3_next = state[9]; // In B3\n    assign S_next = state[0] & ~d; // In S and d=0\n    assign S1_next = state[1] & ~d; // In S1 and d=0\n    assign Count_next = state[8] & done_counting; // In Count and done_counting=1\n    assign Wait_next = state[9] & done_counting; // In Wait and done_counting=1\n\n    // Output logic\n    assign done = state[9]; // done is high if in Wait state\n    assign counting = state[8]; // counting is high if in Count state\n    assign shift_ena = state[4] | state[5] | state[6] | state[7]; // Shift enabled in B0, B1, B2, B3\n\nendmodule\n", "result": "failed: 3040 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    // Initialize the state to weakly not-taken (2'b01)\n    initial begin\n        state = 2'b01;\n    end\n\n    // Always block to handle the state changes\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset the counter to weakly not-taken\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken) begin\n                // Increment the counter, saturating at 3\n                if (state < 2'b11) begin\n                    state <= state + 1;\n                end\n            end else begin\n                // Decrement the counter, saturating at 0\n                if (state > 2'b00) begin\n                    state <= state - 1;\n                end\n            end\n        end\n        // When train_valid is 0, state is unchanged\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\nalways @* begin\n    pos = 3'b000; // Default value for pos if no bits are set\n    case (in)\n        8'b00000000: pos = 3'b000; // All bits are low\n        8'b00000001: pos = 3'b000; // First bit is high\n        8'b0000001x: pos = 3'b000; // First bit is high\n        8'b000001??: pos = 3'b001; // Second bit is high\n        8'b00001???: pos = 3'b010; // Third bit is high\n        8'b0001????: pos = 3'b011; // Fourth bit is high\n        8'b001?????: pos = 3'b100; // Fifth bit is high\n        8'b01??????: pos = 3'b101; // Sixth bit is high\n        8'b1??????? : pos = 3'b110; // Seventh bit is high\n        default: pos = 3'b000; // Fallback case\n    endcase\nend\n\nendmodule\n", "result": "failed: 173 out of 346 samples.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n    // Initialize outputs to zero\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check scancode and set corresponding output\n    case (scancode)\n        16'hE06B: left = 1;   // Left arrow\n        16'hE072: down = 1;   // Down arrow\n        16'hE074: right = 1;  // Right arrow\n        16'hE075: up = 1;     // Up arrow\n        default: ;             // No action for other scancodes\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    wire [3:0] carry; // Carry wires between full adders\n\n    // Full adder for least significant bit\n    assign sum[0] = x[0] ^ y[0]; // Sum output for bit 0\n    assign carry[0] = (x[0] & y[0]);\n\n    // Full adder for bit 1\n    assign sum[1] = x[1] ^ y[1] ^ carry[0]; // Sum output for bit 1\n    assign carry[1] = (x[1] & y[1]) | (carry[0] & (x[1] ^ y[1]));\n\n    // Full adder for bit 2\n    assign sum[2] = x[2] ^ y[2] ^ carry[1]; // Sum output for bit 2\n    assign carry[2] = (x[2] & y[2]) | (carry[1] & (x[2] ^ y[2]));\n\n    // Full adder for bit 3\n    assign sum[3] = x[3] ^ y[3] ^ carry[2]; // Sum output for bit 3\n    assign carry[3] = (x[3] & y[3]) | (carry[2] & (x[3] ^ y[3]));\n\n    // Overall carry (overflow bit) into sum[4]\n    assign sum[4] = carry[3]; // Overflow bit takes the final carry out\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Asynchronously reset the history to zero\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        // Load the branch history with the train_history and train_taken\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        // Shift in the new prediction from the LSB\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\n    // If neither condition is met, the history remains unchanged\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n    // Intermediate wires to hold the outputs of the AND gates\n    wire and1_out;\n    wire and2_out;\n\n    // First AND gate\n    assign and1_out = a & b;   // AND gate connecting a and b\n    // Second AND gate\n    assign and2_out = c & d;   // AND gate connecting c and d\n\n    // OR gate connecting the outputs of the AND gates\n    assign out = and1_out | and2_out; // Output of the OR gate\n\n    // NOT gate to invert the output\n    assign out_n = ~out; // Invert the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    always @(posedge clk) begin\n        q <= d; // Update q with d at the rising edge of clk\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\n    // 8-bit shift register\n    reg [7:0] Q;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]}; // Shift left and input S into Q[0]\n        end\n    end\n\n    // Multiplexer to select Q based on ABC inputs\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];  // When ABC = 000\n            3'b001: Z = Q[1];  // When ABC = 001\n            3'b010: Z = Q[2];  // When ABC = 010\n            3'b011: Z = Q[3];  // When ABC = 011\n            3'b100: Z = Q[4];  // When ABC = 100\n            3'b101: Z = Q[5];  // When ABC = 101\n            3'b110: Z = Q[6];  // When ABC = 110\n            3'b111: Z = Q[7];  // When ABC = 111\n            default: Z = 1'b0; // Default case to avoid latches\n        endcase\n    end\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n  \n    assign heater = (mode == 1 && too_cold == 1);\n    assign aircon = (mode == 0 && too_hot == 1);\n    assign fan = (heater || aircon || fan_on);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n    assign out_sop = ( (~a & ~b & c & ~d) |    // 2\n                       (~a & b & c & d) |     // 7\n                       (a & b & c & d) );     // 15\n\n    assign out_pos = ( (a | b | c | d) &       // 0\n                       (a | b | c | ~d) &      // 1\n                       (a | ~b | c | d) &      // 4\n                       (a | ~b | ~c | d) &      // 5\n                       (a | ~b | ~c | ~d) &     // 6\n                       (~a | b | ~c | d) &      // 9\n                       (~a | b | c | ~d) &      // 10\n                       (~a | ~b | c | d) &      // 13\n                       (~a | ~b | ~c | d));     // 14\nendmodule\n", "result": "failed: 42 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset the output to 32'h1 when reset is high\n    end else begin\n        // Calculate next state based on taps at positions 32, 22, 2, and 1\n        // - q[31] (bit 32)\n        // - q[21] (bit 22)\n        // - q[1]  (bit 2)\n        // - q[0]  (bit 1)\n        \n        // The new input bit is the XOR of tapped positions\n        q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])}; // Shift left and add new bit\n    end\nend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (d && (b || (a && c))) || (b && d) || (a && !b && c);\nendmodule\n", "result": "failed: 21 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    \n    // NAND gate for the first output\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    \n    // NAND gate for the second output\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n    integer i;\n    \n    always @* begin\n        out = 0; // Initialize output to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Add the count of '1's\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    assign out_both[0] = in[0] & in[1]; // Compare in[0] and in[1]\n    assign out_both[1] = in[1] & in[2]; // Compare in[1] and in[2]\n    assign out_both[2] = in[2] & in[3]; // Compare in[2] and in[3]\n    \n    assign out_any[1] = in[1] | in[0]; // Compare in[1] and in[0]\n    assign out_any[2] = in[2] | in[1]; // Compare in[2] and in[1]\n    assign out_any[3] = in[3] | in[2]; // Compare in[3] and in[2]\n    \n    assign out_different[0] = in[0] != in[3]; // Compare in[0] and in[3]\n    assign out_different[1] = in[1] != in[0]; // Compare in[1] and in[0]\n    assign out_different[2] = in[2] != in[1]; // Compare in[2] and in[1]\n    assign out_different[3] = in[3] != in[2]; // Compare in[3] and in[2]\n\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\nalways @(*) begin\n\tcase (a)\n\t\t3'b000: q = 16'h1232; // a = 0\n\t\t3'b001: q = 16'haee0; // a = 1\n\t\t3'b010: q = 16'h27d4; // a = 2\n\t\t3'b011: q = 16'h5a0e; // a = 3\n\t\t3'b100: q = 16'h2066; // a = 4\n\t\t3'b101: q = 16'h64ce; // a = 5\n\t\t3'b110: q = 16'hc526; // a = 6\n\t\t3'b111: q = 16'h2f19; // a = 7\n\t\tdefault: q = 16'h0000; // Default case\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000; // Reset counter to 0\n    end else if (slowena) begin\n        if (q == 4'b1001) begin\n            q <= 4'b0000; // Reset counter to 0 after reaching 9\n        end else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n\tassign out = in1 & ~in2; // AND operation with in1 and inverted in2\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\n\tassign out = in; // Directly assign input to output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    reg state;  // state variable (0 for A, 1 for B)\n\n    // State encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;  // Reset to State B\n        end\n        else begin\n            case (state)\n                B: begin\n                    if (in == 0)\n                        state <= A;  // Transition to State A\n                    else\n                        state <= B;  // Stay in State B\n                end\n                A: begin\n                    if (in == 0)\n                        state <= B;  // Transition to State B\n                    else\n                        state <= A;  // Stay in State A\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(state) begin\n        if (state == B)\n            out = 1;  // Output is 1 in State B\n        else \n            out = 0;  // Output is 0 in State A\n    end\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\nalways @(posedge clk or negedge clk) begin\n\tq <= d; // Capture data on both edges\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n// Implementing the XNOR logic\nassign out = ~(a ^ b); // XNOR can be implemented as NOT of XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & y) | (~x & ~y); // Using universal sum of products for B\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate first pair of A and B\n    A a1 (\n        .x(x),\n        .y(y),\n        .z(a1_out)\n    );\n\n    B b1 (\n        .x(x),\n        .y(y),\n        .z(b1_out)\n    );\n\n    // Instantiate the second pair of A and B\n    A a2 (\n        .x(x),\n        .y(y),\n        .z(a2_out)\n    );\n\n    B b2 (\n        .x(x),\n        .y(y),\n        .z(b2_out)\n    );\n\n    // OR gate for outputs of A1 and B1\n    assign or_out = a1_out | b1_out;\n\n    // AND gate for outputs of A2 and B2\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate for final output z\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;  // Load new data synchronously\n    end else begin\n        case (ena)\n            2'b01: begin\n                q <= {q[0], q[99:1]}; // Rotate right\n            end\n            2'b10: begin\n                q <= {q[98:0], q[99]}; // Rotate left\n            end\n            2'b00, 2'b11: begin\n                q <= q; // No rotation\n            end\n        endcase\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0; // Reset to 0\n        end else if (q == 10'd999) begin\n            q <= 10'd0; // Wrap around to 0 after reaching 999\n        end else begin\n            q <= q + 10'd1; // Increment the counter\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n    assign out = ~in; // Continuous assignment that applies the NOT operation.\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n// Decode the current state\nwire S0 = state[0];\nwire S1 = state[1];\nwire S2 = state[2];\nwire S3 = state[3];\nwire S4 = state[4];\nwire S5 = state[5];\nwire S6 = state[6];\nwire S7 = state[7];\nwire S8 = state[8];\nwire S9 = state[9];\n\n// State transition logic\nassign next_state[0] = (S0 && !in) || (S1 && !in) || (S2 && !in) || (S3 && !in) || (S4 && !in) || (S8 && 1); // S0\nassign next_state[1] = (S0 && in) || (S1 && in) || (S8 && in); // S1\nassign next_state[2] = (S1 && !in) || (S4 && 1); // S2\nassign next_state[3] = (S2 && in); // S3\nassign next_state[4] = (S3 && in); // S4\nassign next_state[5] = (S4 && in); // S5\nassign next_state[6] = (S5 && in); // S6\nassign next_state[7] = (S6 && in); // S7\nassign next_state[8] = (S5 && !in); // S8\nassign next_state[9] = (S6 && !in); // S9\n\n// Outputs logic\nassign out1 = S7 || S8 || S9; // out1 is 1 for states S7, S8, S9\nassign out2 = S7; // out2 is 1 only for state S7\n\nendmodule\n", "result": "failed: 1090 out of 1424 samples.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (j == 0 && k == 0) begin\n\t\t// Qold condition, maintain current state\n\t\tQ <= Q; // No change\n\tend\n\telse if (j == 0 && k == 1) begin\n\t\t// Reset condition\n\t\tQ <= 0; // Set output to 0\n\tend\n\telse if (j == 1 && k == 0) begin\n\t\t// Set condition\n\t\tQ <= 1; // Set output to 1\n\tend\n\telse if (j == 1 && k == 1) begin\n\t\t// Toggle condition\n\t\tQ <= ~Q; // Toggle current output\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\n\tassign out = in[0] + in[1] + in[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\nassign out[24] = (a == a) ? 1 : 0;\nassign out[23] = (a == b) ? 1 : 0;\nassign out[22] = (a == c) ? 1 : 0;\nassign out[21] = (a == d) ? 1 : 0;\nassign out[20] = (a == e) ? 1 : 0;\nassign out[19] = (b == a) ? 1 : 0;\nassign out[18] = (b == b) ? 1 : 0;\nassign out[17] = (b == c) ? 1 : 0;\nassign out[16] = (b == d) ? 1 : 0;\nassign out[15] = (b == e) ? 1 : 0;\nassign out[14] = (c == a) ? 1 : 0;\nassign out[13] = (c == b) ? 1 : 0;\nassign out[12] = (c == c) ? 1 : 0;\nassign out[11] = (c == d) ? 1 : 0;\nassign out[10] = (c == e) ? 1 : 0;\nassign out[9]  = (d == a) ? 1 : 0;\nassign out[8]  = (d == b) ? 1 : 0;\nassign out[7]  = (d == c) ? 1 : 0;\nassign out[6]  = (d == d) ? 1 : 0;\nassign out[5]  = (d == e) ? 1 : 0;\nassign out[4]  = (e == a) ? 1 : 0;\nassign out[3]  = (e == b) ? 1 : 0;\nassign out[2]  = (e == c) ? 1 : 0;\nassign out[1]  = (e == d) ? 1 : 0;\nassign out[0]  = (e == e) ? 1 : 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n\t// State declaration\n\ttypedef enum logic [1:0] {\n\t\tSTATE_WALK_LEFT,\n\t\tSTATE_WALK_RIGHT\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State transition\n\talways_ff @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tcurrent_state <= STATE_WALK_LEFT; // Reset to walk left state\n\t\telse \n\t\t\tcurrent_state <= next_state;\n\tend\n\n\t// Next state logic\n\talways_comb begin\n\t\t// Default state should be hold\n\t\tnext_state = current_state; // No change by default\n\t\twalk_left = 0;\n\t\twalk_right = 0;\n\n\t\tcase (current_state)\n\t\t\tSTATE_WALK_LEFT: begin\n\t\t\t\twalk_left = 1;   // Output for walk left\n\t\t\t\tif (bump_left) \n\t\t\t\t\tnext_state = STATE_WALK_RIGHT; // Bumped left, go right\n\t\t\tend\n\n\t\t\tSTATE_WALK_RIGHT: begin\n\t\t\t\twalk_right = 1;  // Output for walk right\n\t\t\t\tif (bump_right)\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;  // Bumped right, go left\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\nassign q = a & b; // Combinational logic for AND operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n// Intermediate signals for p1y\nwire and1_out; // Output of first 3-input AND gate\nwire and2_out; // Output of second 3-input AND gate\n\n// AND gates for p1y\nassign and1_out = p1a & p1b & p1c; // p1a AND p1b AND p1c\nassign and2_out = p1d & p1e & p1f; // p1d AND p1e AND p1f\nassign p1y = and1_out | and2_out; // p1y = OR of the two AND outputs\n\n// Intermediate signals for p2y\nwire and3_out; // Output of first 2-input AND gate\nwire and4_out; // Output of second 2-input AND gate\n\n// AND gates for p2y\nassign and3_out = p2a & p2b; // p2a AND p2b\nassign and4_out = p2c & p2d; // p2c AND p2d\nassign p2y = and3_out | and4_out; // p2y = OR of the two AND outputs\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tcase (y)\n\t\t\t3'b000: begin\n\t\t\t\tY0 <= x ? 1'b1 : 1'b0; // Next state = 001 or stays in 000\n\t\t\t\tz <= 1'b0;\n\t\t\tend\n\t\t\t3'b001: begin\n\t\t\t\tY0 <= x ? 3'b100 : 3'b001; // Next state = 100 or stays in 001\n\t\t\t\tz <= 1'b0;\n\t\t\tend\n\t\t\t3'b010: begin\n\t\t\t\tY0 <= x ? 3'b001 : 3'b010; // Next state = 001 or stays in 010\n\t\t\t\tz <= 1'b0;\n\t\t\tend\n\t\t\t3'b011: begin\n\t\t\t\tY0 <= x ? 3'b010 : 3'b001; // Next state = 010 or goes to 001\n\t\t\t\tz <= 1'b1;\n\t\t\tend\n\t\t\t3'b100: begin\n\t\t\t\tY0 <= x ? 3'b100 : 3'b011; // Next state = 100 or goes to 011\n\t\t\t\tz <= 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tY0 <= 1'b0; // Safe default state (not specified)\n\t\t\t\tz <= 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n    assign out = ~(in1 | in2); // NOR operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n    assign w = a; // Connect input a to output w\n    assign x = b; // Connect input b to output x\n    assign y = b; // Connect input b to output y\n    assign z = c; // Connect input c to output z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 0; // Asynchronous reset\n        end else begin\n            q <= d; // Transfer d to q on rising edge of clk\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\n    always @(*) begin\n        case (sel)\n            3'b000: out = data0; // when sel is 0\n            3'b001: out = data1; // when sel is 1\n            3'b010: out = data2; // when sel is 2\n            3'b011: out = data3; // when sel is 3\n            3'b100: out = data4; // when sel is 4\n            3'b101: out = data5; // when sel is 5\n            default: out = 4'b0000; // when sel is outside the range of 0 to 5\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter; // Internal counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the data into the counter\n            tc <= 0; // Reset terminal count when loading new value\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement counter\n            if (counter == 1) begin\n                tc <= 1; // Assert terminal count one clock before it reaches 0\n            end\n        end\n    end\n    \n    always @(posedge clk) begin\n        if (counter == 0) \n            tc <= 1; // Assert terminal count when counter is 0\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tS0 = 3'b000,\n\t\tS1 = 3'b001,\n\t\tS2 = 3'b010,\n\t\tS3 = 3'b011,\n\t\tS4 = 3'b100\n\t} state_t;\n\t\n\tstate_t current_state, next_state;\n\n\t// Reset and state transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= S0;\n\t\t\tstart_shifting <= 0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS0: begin\n\t\t\t\tif (data)\n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tstart_shifting = 0;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (data)\n\t\t\t\t\tnext_state = S2;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tstart_shifting = 0;\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (data)\n\t\t\t\t\tnext_state = S1; // Go to S1 if '1', restart search\n\t\t\t\telse\n\t\t\t\t\tnext_state = S3; // Go to S3 if '0', expected '1' next\n\t\t\t\tstart_shifting = 0;\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif (data)\n\t\t\t\t\tnext_state = S4; // Found '1101'\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0; // Go back to S0 if '0'\n\t\t\t\tstart_shifting = 0;\n\t\t\tend\n\t\t\tS4: begin\n\t\t\t\tnext_state = S4; // Stay in S4 once found\n\t\t\t\tstart_shifting = 1; // Signal found sequence\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = S0;\n\t\t\t\tstart_shifting = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b00000000; // Set output to zero\n        end else begin\n            q <= d; // Load data on positive clock edge\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n\treg [7:0] prev_in; // to store previous state of `in`\n\n\talways @(posedge clk) begin\n\t\tanyedge <= 8'b00000000; // Reset anyedge to 0 at the start of each clock cycle\n\t\t// Check for 0 to 1 transitions\n\t\tanyedge[0] <= (prev_in[0] == 1'b0 && in[0] == 1'b1) ? 1'b1 : anyedge[0];\n\t\tanyedge[1] <= (prev_in[1] == 1'b0 && in[1] == 1'b1) ? 1'b1 : anyedge[1];\n\t\tanyedge[2] <= (prev_in[2] == 1'b0 && in[2] == 1'b1) ? 1'b1 : anyedge[2];\n\t\tanyedge[3] <= (prev_in[3] == 1'b0 && in[3] == 1'b1) ? 1'b1 : anyedge[3];\n\t\tanyedge[4] <= (prev_in[4] == 1'b0 && in[4] == 1'b1) ? 1'b1 : anyedge[4];\n\t\tanyedge[5] <= (prev_in[5] == 1'b0 && in[5] == 1'b1) ? 1'b1 : anyedge[5];\n\t\tanyedge[6] <= (prev_in[6] == 1'b0 && in[6] == 1'b1) ? 1'b1 : anyedge[6];\n\t\tanyedge[7] <= (prev_in[7] == 1'b0 && in[7] == 1'b1) ? 1'b1 : anyedge[7];\n\t\tprev_in <= in; // Update the previous input state\n\tend\n\nendmodule\n", "result": "failed: 225 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 4'd1;  // Reset to 1\n\tend else if (q < 4'd10) begin\n\t\tq <= q + 4'd1;  // Count up\n\tend\n\t// If q == 10, it remains 10 and does not increment further\nend\n\nendmodule\n", "result": "failed: 314 out of 439 samples.", "passed": false}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\t\n\t// Initialize q to 0\n\talways @(posedge clk) begin\n\t\tif (a) begin\n\t\t\t// Hold the previous value of q\n\t\t\tq <= q; // This line is effectively a no-operation\n\t\tend else begin\n\t\t\tif (q == 3'd6) begin\n\t\t\t\t// Reset condition when q is maximum (6)\n\t\t\t\tq <= 3'd0;\n\t\t\tend else begin\n\t\t\t\t// Increment q\n\t\t\t\tq <= q + 1;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset all bits to 1 when reset signal is high\n            q <= 5'b11111;\n        end else begin\n            // Calculate the new incoming bit\n            // Using taps at positions 5 (q[4]) and 3 (q[2])\n            q[4] <= q[3] ^ q[1];  // New value for q[4]\n            q[3] <= q[4];         // Shift q[4] to q[3]\n            q[2] <= q[3];         // Shift q[3] to q[2]\n            q[1] <= q[2];         // Shift q[2] to q[1]\n            q[0] <= q[1];         // Shift q[1] to q[0]\n        end\n    end\nendmodule\n", "result": "failed: 4310 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default output\n\t\tout = 8'b0;  // Initialize out\n\t\tresult_is_zero = 0; // Initialize result_is_zero\n\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\n\t\t// Check if the result is zero\n\t\tif (out == 8'b0)\n\t\t\tresult_is_zero = 1;\n\t\telse\n\t\t\tresult_is_zero = 0;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n// Implementing the function based on the derived minterms\nalways_comb begin\n    case (x)\n        4'b1101, // x[3] x[4] = 11, x[1] x[2] = 01 => Output 1\n        4'b1110, // x[3] x[4] = 11, x[1] x[2] = 10 => Output 1\n        4'b0110, // x[3] x[4] = 01, x[1] x[2] = 10 => Output 1\n        4'b0011: // x[3] x[4] = 00, x[1] x[2] = 11 => Output 1\n            f = 1;\n        default: \n            f = 0; // Other combinations set to 0\n    endcase\nend\n\nendmodule\n", "result": "failed: 13 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @(*) begin\n    // Initialize outputs\n    out = 4'b0000;  // Default output for invalid case\n    valid = 1'b0;   // Default valid signal\n\n    // Check input code against known scancodes\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end // Scancode for '0'\n        8'h16: begin out = 4'd1; valid = 1'b1; end // Scancode for '1'\n        8'h1e: begin out = 4'd2; valid = 1'b1; end // Scancode for '2'\n        8'h26: begin out = 4'd3; valid = 1'b1; end // Scancode for '3'\n        8'h25: begin out = 4'd4; valid = 1'b1; end // Scancode for '4'\n        8'h2e: begin out = 4'd5; valid = 1'b1; end // Scancode for '5'\n        8'h36: begin out = 4'd6; valid = 1'b1; end // Scancode for '6'\n        8'h3d: begin out = 4'd7; valid = 1'b1; end // Scancode for '7'\n        8'h3e: begin out = 4'd8; valid = 1'b1; end // Scancode for '8'\n        8'h46: begin out = 4'd9; valid = 1'b1; end // Scancode for '9'\n        default: begin out = 4'b0000; valid = 1'b0; end // Invalid key default\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    assign out[0] = in[7];\n    assign out[1] = in[6];\n    assign out[2] = in[5];\n    assign out[3] = in[4];\n    assign out[4] = in[3];\n    assign out[5] = in[2];\n    assign out[6] = in[1];\n    assign out[7] = in[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        // Out logic derived from K-map analysis\n        out = (b & c) | (b & ~d) | (a & c);  // Here we utilize d as flexibility\n    end\nendmodule\n", "result": "failed: 67 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in data at the MSB position\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Decrement the current value in the shift register\n            q <= q - 1;\n        end\n        // If both are disabled, q will retain its value\n    end\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\t\n\tassign out = in; // Directly assign the input to the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    \n    reg [2:0] count; // 3-bit counter to hold the count (0 to 4)\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1; // Enable shift for 1 cycle on reset\n            count <= 0;     // Start counting from 0\n        end else if (count < 3) begin\n            count <= count + 1; // Increment counter until 3\n            shift_ena <= 1; // Keep shift_ena asserted\n        end else begin\n            shift_ena <= 0; // Deassert shift_ena after 4 cycles\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;  // Reset q to 0\n        end else begin\n            if (q == 4'b1111) begin\n                q <= 4'b0000;  // Wrap around to 0 after reaching 15\n            end else begin\n                q <= q + 1;  // Increment q\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n// Continuous assignment for out_assign\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Procedural assignment for out_always\nalways @(*) begin\n    if (sel_b1 && sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\nassign out = a | (b & ~c);\n\nendmodule\n", "result": "failed: 55 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n// State encoding\ntypedef enum logic [1:0] {A, B, C, D} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways_ff @(posedge clk or negedge resetn) begin\n    if (!resetn)\n        current_state <= A; // Reset to state A\n    else\n        current_state <= next_state; // Transition to the next state\nend\n\n// Next state logic\nalways_comb begin\n    // Default values\n    next_state = current_state;\n    g = 3'b000; // All outputs low by default\n\n    case (current_state)\n        A: begin\n            if (r[1]) begin   // Device 1 requests\n                next_state = B;\n                g[1] = 1;    // Grant device 1\n            end else if (r[2]) begin // Device 2 requests\n                next_state = C;\n                g[2] = 1;    // Grant device 2\n            end else if (r[3]) begin // Device 3 requests\n                next_state = D;\n                g[3] = 1;    // Grant device 3\n            end\n        end\n        B: begin\n            if (r[1]) begin   // Device 1 still holds grant\n                next_state = B;\n                g[1] = 1;    // Grant device 1\n            end else begin\n                next_state = A; // If no grant from device 1, return to A\n            end\n        end\n        C: begin\n            if (r[2]) begin   // Device 2 still holds grant\n                next_state = C;\n                g[2] = 1;    // Grant device 2\n            end else begin\n                next_state = A; // If no grant from device 2, return to A\n            end\n        end\n        D: begin\n            next_state = A; // Device 3 has the lowest priority, go back to A\n        end\n        default: begin\n            next_state = A; // Default to state A\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset counter to 0\n        end else if (q == 4'b1001) begin\n            q <= 4'b0000; // If q is 9, roll over to 0\n        end else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State declaration\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE1_RECEIVED = 2'b01,\n        BYTE2_RECEIVED = 2'b10,\n        BYTE3_RECEIVED = 2'b11\n    } state_t;\n\n    // Internal state variable\n    reg [1:0] current_state, next_state;\n\n    // FSM state update\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            done <= 0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                done = 0; // done is de-asserted while in IDLE\n                if (in[3]) begin\n                    next_state = BYTE1_RECEIVED; // First byte detected\n                end else begin\n                    next_state = IDLE; // Remain in IDLE\n                end\n            end\n\n            BYTE1_RECEIVED: begin\n                done = 0; // done is de-asserted\n                next_state = BYTE2_RECEIVED; // Move to next state\n            end\n\n            BYTE2_RECEIVED: begin\n                done = 0; // done is de-asserted\n                next_state = BYTE3_RECEIVED; // Move to next state\n            end\n\n            BYTE3_RECEIVED: begin\n                done = 1; // Signal done after receiving 3rd byte\n                next_state = IDLE; // Reset to IDLE for next message\n            end\n\n            default: begin\n                done = 0;\n                next_state = IDLE; // Fallback to IDLE\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    assign out = (sel) ? b : a; // Using a conditional operator to select the output based on sel\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\nassign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND\nassign out_or = in[0] | in[1] | in[2] | in[3];  // 4-input OR\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    reg [2:0] state; // 3-bit register to hold the state\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= 3'b000; // Reset to state 000\n            z <= 0; // Reset output z\n        end else begin\n            case (state)\n                3'b000: begin\n                    if (x) begin\n                        state <= 3'b001; // Next state for x=1\n                    end else begin\n                        state <= 3'b000; // Next state for x=0\n                    end\n                    z <= 0; // Output for state 000\n                end\n                3'b001: begin\n                    if (x) begin\n                        state <= 3'b100; // Next state for x=1\n                    end else begin\n                        state <= 3'b001; // Next state for x=0\n                    end\n                    z <= 0; // Output for state 001\n                end\n                3'b010: begin\n                    if (x) begin\n                        state <= 3'b001; // Next state for x=1\n                    end else begin\n                        state <= 3'b010; // Next state for x=0\n                    end\n                    z <= 0; // Output for state 010\n                end\n                3'b011: begin\n                    if (x) begin\n                        state <= 3'b010; // Next state for x=1\n                    end else begin\n                        state <= 3'b001; // Next state for x=0\n                    end\n                    z <= 1; // Output for state 011\n                end\n                3'b100: begin\n                    if (x) begin\n                        state <= 3'b100; // Next state for x=1\n                    end else begin\n                        state <= 3'b011; // Next state for x=0\n                    end\n                    z <= 1; // Output for state 100\n                end\n                default: begin\n                    state <= 3'b000; // Default (should not reach here in normal operation)\n                    z <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: 312 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        STATE_A, // Reset state\n        STATE_B, // Initial output state\n        STATE_C, // Monitor x (first input)\n        STATE_D, // Monitor x (second input)\n        STATE_E, // Monitor x (third input)\n        STATE_F, // g = 1, monitor y (first check)\n        STATE_G  // g = 0, monitor y (second check)\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] count; // Count y check cycles\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            f <= 0;\n            g <= 0;\n            count <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        f = 0;\n        g = 0;\n        \n        case (state)\n            STATE_A: begin\n                // Stay in A until resetn is de-asserted\n                if (resetn)\n                    next_state = STATE_B;\n            end\n            \n            STATE_B: begin\n                f = 1; // Output f = 1 for 1 cycle\n                next_state = STATE_C;\n            end\n            \n            STATE_C: begin\n                // Monitor x\n                if (x) begin\n                    next_state = STATE_D; // First 1 detected\n                end\n            end\n            \n            STATE_D: begin\n                if (!x) begin\n                    next_state = STATE_E; // 1, 0 sequence detected\n                end else begin\n                    next_state = STATE_C; // Reset tracking\n                end\n            end\n            \n            STATE_E: begin\n                if (x) begin\n                    g = 1; // Set g = 1\n                    next_state = STATE_F; // Transition to monitor y\n                end else begin\n                    next_state = STATE_C; // Reset tracking\n                end\n            end\n            \n            STATE_F: begin\n                g = 1; // Maintain g = 1\n                if (y) begin\n                    next_state = STATE_F; // Stay in g = 1\n                end else begin\n                    count <= 1; // Start counting cycles for g = 0\n                    next_state = STATE_G;\n                end\n            end\n            \n            STATE_G: begin\n                if (y) begin\n                    g = 1; // Reset g to 1\n                    next_state = STATE_F;\n                end else if (count < 2) begin\n                    count <= count + 1; // Count the cycles\n                    next_state = STATE_G;\n                end else begin\n                    g = 0; // Set g = 0 permanently\n                    next_state = STATE_G;\n                end\n            end\n            \n            default: next_state = STATE_A; // Safety case\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;  // Reset to 0x34 when reset is high\n    end else begin\n        q <= d;     // Latch input d into output q on negative edge of clock\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    assign parity = ~(^in);\nendmodule\n", "result": "failed: 99 out of 100 samples.", "passed": false}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    // Output logic\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output is 1 only for state D\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // A\n            2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // B\n            2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // C\n            2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // D\n            default: next_state = 2'b00; // Default case to avoid latches\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = (~(x & ~y)) | y;\n\nendmodule\n", "result": "failed: 36 out of 110 samples.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b001,\n        B = 3'b010,\n        C = 3'b011,\n        D = 3'b100,\n        E = 3'b101,\n        F = 3'b110\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (w) next_state = B; // A --1--> B\n                else next_state = A;    // A --0--> A\n            end\n            B: begin\n                if (w) next_state = C; // B --1--> C\n                else next_state = D;    // B --0--> D\n            end\n            C: begin\n                if (w) next_state = E; // C --1--> E\n                else next_state = D;    // C --0--> D\n            end\n            D: begin\n                if (w) next_state = F; // D --1--> F\n                else next_state = A;    // D --0--> A\n            end\n            E: begin\n                if (w) next_state = E; // E --1--> E\n                else next_state = D;    // E --0--> D\n            end\n            F: begin\n                if (w) next_state = C; // F --1--> C\n                else next_state = D;    // F --0--> D\n            end\n            default: next_state = A; // Default to state A\n        endcase\n    end\n\n    // State Flip-Flops\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset to state A\n        end else begin\n            current_state <= next_state; // Update state\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        if (current_state == E) \n            z = 1; // Output high if in state E\n        else \n            z = 0; // Output low otherwise\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tq <= 16'b0; // Reset all DFFs to 0\n\t\tend else begin\n\t\t\tif (byteena[0]) begin\n\t\t\t\tq[7:0] <= d[7:0]; // Write to lower byte\n\t\t\tend \n\t\t\tif (byteena[1]) begin\n\t\t\t\tq[15:8] <= d[15:8]; // Write to upper byte\n\t\t\tend \n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    reg [7:0] prev_in; // Register to store previous state of in\n\n    always @(posedge clk) begin\n        // Update pedge to reflect the transitions\n        pedge <= (in & ~prev_in); // Detect positive edges (1 when 0->1)\n        prev_in <= in; // Store current state of in for next comparison\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\n    // Define the behavior of p and q based on waveform analysis\n    always @(posedge clock) begin\n        // State update logic based on a\n        if (a == 0) begin\n            p <= p; // Hold state when a = 0\n            q <= 0; // Reset q when a = 0\n        end else begin\n            if (p == 0) begin\n                p <= 1; // Set p when a = 1\n                q <= 0; // Maintain the q state\n            end else begin\n                // Further conditions to maintain the proper sequence\n                p <= 1; // Maintain p high\n                q <= 1; // Set q to 1 as a=1\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 174 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state from data\n        end else begin\n            // Compute next state based on Rule 90\n            for (int i = 0; i < 512; i++) begin\n                if (i == 0) begin\n                    // Left neighbor for q[0] is assumed to be 0\n                    next_q[i] = 0 ^ q[i + 1]; // q[-1] is treated as 0\n                end else if (i == 511) begin\n                    // Right neighbor for q[511] is assumed to be 0\n                    next_q[i] = q[i - 1] ^ 0; // q[512] is treated as 0\n                end else begin\n                    next_q[i] = q[i - 1] ^ q[i + 1]; // Apply Rule 90\n                end\n            end\n            q <= next_q; // Update the state to the next state\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\nassign z = (A == B);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    // Compute out_both\n    assign out_both[98] = in[98] & in[99]; // Both 1s for in[98] and in[99]\n    // Loop for other indexes\n    genvar i;\n    generate\n        for (i = 0; i < 98; i = i + 1) begin: both_logic\n            assign out_both[i] = in[i] & in[i + 1];\n        end\n    endgenerate\n\n    // Compute out_any\n    assign out_any[99:1] = in[99:1] | in[98:0]; // Any being 1 for in[i] or in[i+1]\n    \n    // Compute out_different\n    assign out_different[99] = in[99] ^ in[0]; // Wrap-around for in[99] and in[0]\n    generate\n        for (i = 0; i < 99; i = i + 1) begin: different_logic\n            assign out_different[i] = in[i] ^ in[i + 1];\n        end\n    endgenerate\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\nalways @(*) begin\n\tif (ena) begin\n\t\tq = d; // When ena is high, q follows d\n\tend\n\t// When ena is low, q holds its previous value\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Use the 'sel' value to extract the correct 4 bits from 'in'\n    assign out = in[sel * 4 +: 4]; // Select 4 bits starting from sel*4\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Set all bits to '1' for unused cases\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\nassign out_or_bitwise = a | b;          // Bitwise OR\nassign out_or_logical = |(a | b);       // Logical OR (1 if either is non-zero)\nassign out_not = {~b, ~a};              // Concatenate NOT of b (upper half) and NOT of a (lower half)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\n// Output logic\nassign out = state[3]; // Output is 1 only when in state D\n\nalways @(*) begin\n    case (state)\n        4'b0001: // State A\n            next_state = (in) ? 4'b0010 : 4'b0001; // A -> B if in=1 else stay at A\n        4'b0010: // State B\n            next_state = (in) ? 4'b0010 : 4'b0100; // B -> B if in=1 else go to C\n        4'b0100: // State C\n            next_state = (in) ? 4'b1000 : 4'b0001; // C -> D if in=1 else go to A\n        4'b1000: // State D\n            next_state = (in) ? 4'b0010 : 4'b0100; // D -> B if in=1 else go to C\n        default: \n            next_state = 4'b0001; // Default to state A\n    endcase\nend\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @(*) begin\n    // Start with assuming a is the minimum\n    min = a;\n\n    // Compare with b\n    if (b < min)\n        min = b;\n\n    // Compare with c\n    if (c < min)\n        min = c;\n\n    // Compare with d\n    if (d < min)\n        min = d;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = (c == 0 && d == 0) || (a && b) || (b && c);\nendmodule\n", "result": "failed: 103 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00, // Reset state\n        B = 2'b01, // Counting state\n        C = 2'b10  // Output state after counting\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] count; // To count the number of 1's in w\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        z = 0; // Default output\n\n        case (state)\n            A: begin\n                if (s) begin\n                    next_state = B; // Transition to state B when s = 1\n                    count = 0; // Reset the count\n                end\n            end\n\n            B: begin\n                // Increment the count if w = 1\n                if (w) begin\n                    count = count + 1;\n                end\n                \n                // Transition to output state after 3 cycles\n                if (count >= 2) begin\n                    next_state = C; // Move to state C next\n                end\n            end\n\n            C: begin\n                // Check the count to determine z\n                if (count == 2) begin\n                    z = 1; // Set z to 1 if exactly 2 ones\n                end else begin\n                    z = 0; // Otherwise z = 0\n                end\n                next_state = B; // Go back to state B to check w again\n                count = 0; // Reset count for the next 3 cycles\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: 300 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out = {{24{in[7]}}, in}; // Replicate the sign bit (in[7]) 24 times and concatenate with input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Define the D flip-flops\n    reg [3:0] shift_reg; // 4-bit register\n    \n    // Combinational logic to output the last bit of the shift register\n    assign out = shift_reg[3]; // Output is the last flip-flop's output\n\n    // Flip-flop behavior on clock edge with reset logic\n    always @(posedge clk) begin\n        if (~resetn) begin\n            shift_reg <= 4'b0000; // Reset all to 0\n        end else begin\n            shift_reg <= {shift_reg[2:0], in}; // Shift right by 1 and load in\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\nalways @(*) begin\n    casez(in) // casez allows us to ignore 'z' states\n        4'b1???: pos = 2'b11;  // If the first bit (bit 3) is high\n        4'b01??: pos = 2'b10;  // If the second bit (bit 2) is high\n        4'b001?: pos = 2'b01;  // If the third bit (bit 1) is high\n        4'b0001: pos = 2'b00;  // If the fourth bit (bit 0) is high\n        default: pos = 2'b00;  // If all are low, output is 0\n    endcase\nend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State definition\n    parameter OFF = 1'b0, ON = 1'b1;\n    reg state;\n\n    // Asynchronous reset and state transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF; // Reset state to OFF\n        end else begin\n            case(state)\n                OFF: begin\n                    if (j == 1'b1) begin\n                        state <= ON; // Transition to ON\n                    end\n                    // Remains in OFF if j == 0\n                end\n                ON: begin\n                    if (k == 1'b1) begin\n                        state <= OFF; // Transition to OFF\n                    end\n                    // Remains in ON if k == 0\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            OFF: out = 1'b0; // Output is 0 in OFF state\n            ON: out = 1'b1;  // Output is 1 in ON state\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n\tassign out = 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n    // Always output logic high\n    assign one = 1'b1;  // Assigning logic high (1)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    \n    integer i;\n    \n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Internal signal to hold state of the flip-flop\n    logic d;\n\n    // Always block for the D flip-flop, sensitive to the rising edge of clk\n    always_ff @(posedge clk) begin\n        // The input 'd' is determined by the XOR of 'in' and current 'out'\n        d <= in ^ out; // XOR operation\n    end\n\n    // Assign the output of the flip-flop to 'out'\n    assign out = d;\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset the register to zero\n        end else if (load) begin\n            q <= data;   // Load the input data into the register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, inserting 0 in MSB\n        end \n        // Else part where nothing happens, keeps the current value of q\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    assign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b0; // Reset output to 0 when areset is high\n\t\tend else begin\n\t\t\tq <= d; // Capture the input d on the rising edge of clk\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\nassign out_and = &in;      // Perform reduction AND on in\nassign out_or  = |in;      // Perform reduction OR on in\nassign out_xor = ^in;      // Perform reduction XOR on in\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\n    assign sum = a ^ b;  // sum is the XOR of a and b\n    assign cout = a & b; // carry-out is the AND of a and b\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Set to 0 when not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Set to 0 when arrived\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // State declaration\n    typedef enum logic [0:0] {\n        OFF = 1'b0,  // State OFF\n        ON  = 1'b1   // State ON\n    } state_t;\n\n    // State variables\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= OFF;  // On reset, go to OFF\n        end else begin\n            current_state <= next_state;  // Update to next state\n        end\n    end\n\n    // Combinational logic to determine next state\n    always_comb begin\n        case (current_state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON;  // Go to ON if j=1\n                end else begin\n                    next_state = OFF;  // Stay in OFF if j=0\n                end\n            end\n            ON: begin\n                if (k) begin\n                    next_state = OFF;  // Go to OFF if k=1\n                end else begin\n                    next_state = ON;  // Stay in ON if k=0\n                end\n            end\n            default: begin\n                next_state = OFF;  // Fallback state\n            end\n        endcase\n    end\n\n    // Output logic based on the state\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 0;  // Reset output\n        end else begin\n            out <= current_state;  // Output follows state\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    // Concatenate all inputs into a single 30-bit vector\n    wire [29:0] concatenated_inputs;\n    assign concatenated_inputs = {a, b, c, d, e, f};\n    \n    // Assign outputs\n    assign w = concatenated_inputs[29:22]; // 8 bits from the 1st part\n    assign x = concatenated_inputs[21:14]; // 8 bits from the 2nd part\n    assign y = concatenated_inputs[13:6];  // 8 bits from the 3rd part\n    assign z = {concatenated_inputs[5:0], 2'b11}; // 6 bits + 2 bits (11)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n    assign q = \n        (a == 0 && (b == 0 && c == 0 && d == 0)) || \n        (a == 0 && (c == 1)) || \n        (a == 0 && (b == 1 && d == 1)) || \n        (a == 1 && (b == 1 && c == 0 && d == 0)) ||\n        (a == 1 && (b == 1 && d == 1)) || \n        (a == 1 && (b == 0 && c == 1 && d == 1));\n\nendmodule\n", "result": "failed: 51 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a & b;  // Logical AND operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [1:0] {\n    B = 1'b0,  // State B\n    A = 1'b1   // State A\n} state_t;\n\n// Current state and next state registers\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= B;  // Reset to state B\n    end else begin\n        current_state <= next_state;  // Move to next state\n    end\nend\n\n// Next state logic\nalways @* begin\n    case (current_state)\n        B: begin\n            if (in == 0) begin\n                next_state = A;  // Transition to A\n            end else begin\n                next_state = B;  // Stay in B\n            end\n        end\n        A: begin\n            if (in == 0) begin\n                next_state = B;  // Transition back to B\n            end else begin\n                next_state = A;  // Stay in A\n            end\n        end\n    endcase\nend\n\n// Output logic based on the current state\nalways @* begin\n    case (current_state)\n        B: out = 1;  // Output is 1 in state B\n        A: out = 0;  // Output is 0 in state A\n    endcase\nend\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    \n    // Intermediate signals\n    wire ab_sum, abc_cout;\n    \n    // Sum calculation\n    assign sum = a ^ b ^ cin;\n\n    // Carry out calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n\tlogic xnor_out;  // Intermediate output for XNOR\n\n\t// XNOR operation\n\tassign xnor_out = ~(in1 ^ in2);  // XNOR can be represented as NOT of XOR\n\n\t// XOR operation\n\tassign out = xnor_out ^ in3;  // XOR the result of XNOR with in3\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    assign mux_in[0] = 0;           // ab = 00\n    assign mux_in[1] = (c == 0 && d == 1) ? 1 : 0; // ab = 01 => 1 if c=0 and d=1\n    assign mux_in[2] = (c == 1 && d == 1) ? 1 : 0; // ab = 11 => 1 if c=1 and d=1\n    assign mux_in[3] = (c == 1 && d == 0) ? 1 : 0; // ab = 10 => 1 if c=1 and d=0\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // Define states using one-hot encoding\n    reg [1:0] state, next_state;\n\n    // State encoding\n    localparam A = 2'b01; // State A\n    localparam B = 2'b10; // State B\n\n    // Sequential logic for state transitions with async reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A; // Reset to state A\n        else \n            state <= next_state; // Transition to next state\n    end\n\n    // Combinational logic to determine next state and output\n    always @(*) begin\n        // Default values\n        next_state = state; // Hold the current state if no conditions are met\n        z = 0;              // Default output\n\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B; // Transition to state B\n                    z = 1;         // Set output z=1\n                end\n                // If x=0, remain in state A and z remains 0\n            end\n            B: begin\n                if (x) begin\n                    z = 0; // Output gets updated to z=0\n                    // Stay in state B\n                end else begin\n                    // Stay in state B and output z=1\n                    z = 1;\n                end\n            end\n            default: begin\n                next_state = A; // Default case to ensure stability\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n    // Internal state register\n    reg internal_state;\n\n    always @(posedge clk) begin\n        // Update the state on the rising edge of clk\n        if (b) begin\n            q <= 1;   // Set q to 1 if b is high\n            internal_state <= 1; // Change internal state based on q\n        end else if (a) begin\n            q <= 0;   // Set q to 0 if a is high and b is not\n            internal_state <= 0; // Change internal state if reset condition\n        end\n        // Maintains output for state based on q\n        state <= internal_state; \n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\n    always_comb begin\n        f = (x[4] & ~x[3] & ~x[2] & ~x[1]) |  // minterm for 8\n            (x[4] & x[3] & ~x[2] & ~x[1]) |  // minterm for 10\n            (x[4] & x[3] & ~x[2] & x[1]) |   // minterm for 12\n            (x[4] & x[3] & ~x[2] & x[1]) |   // minterm for 13\n            (x[2] & x[1] & x[4] & ~x[3]) |   // minterm for 14\n            (~x[4] & ~x[1] & x[2] & ~x[3]) | // minterm for 8\n            (x[1] & x[2] & ~x[4] & ~x[3]) |  // minterm for 9\n            (~x[1] & x[2] & x[3] & ~x[4]);   // minterm for 10\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    typedef enum reg [2:0] {\n        S0 = 3'b000, // idle, reset state\n        S1 = 3'b001, // one 1\n        S2 = 3'b010, // two 1s\n        S3 = 3'b011, // three 1s\n        S4 = 3'b100, // four 1s\n        S5 = 3'b101, // five 1s\n        S6 = 3'b110, // six 1s (flag)\n        S7 = 3'b111  // seven 1s - error state\n    } state_t;\n\n    state_t state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        next_state = state; // Default to stay in place\n        disc = 0; // Default output\n        flag = 0; // Default output\n        err = 0;  // Default output\n\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n            end\n\n            S1: begin\n                if (in)\n                    next_state = S2;\n                else\n                    next_state = S0; // Reset state\n            end\n\n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0; // Reset state\n            end\n\n            S3: begin\n                if (in)\n                    next_state = S4;\n                else\n                    next_state = S0; // Reset state\n            end\n\n            S4: begin\n                if (in)\n                    next_state = S5;\n                else\n                    next_state = S0; // Reset state\n            end\n\n            S5: begin\n                if (in)\n                    next_state = S6;\n                else begin\n                    next_state = S0; // Reset state\n                    disc = 1; // signal discard\n                end\n            end\n\n            S6: begin\n                if (in) begin\n                    next_state = S7; // Transition to error on another 1\n                end else begin\n                    next_state = S0; // Reset state\n                    flag = 1;     // signal frame flag\n                end\n            end\n\n            S7: begin\n                err = 1; // signal error\n                if (!in) \n                    next_state = S0; // Go back to idle on 0\n            end\n\n            default: next_state = S0; // safety net\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n    \n    // State encoding\n    typedef enum reg [1:0] {\n        SEARCH = 2'b00,\n        SHIFT  = 2'b01,\n        COUNT  = 2'b10,\n        DONE_WAIT = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] delay;\n    reg [19:0] counter; // For counting to (delay + 1) * 1000\n    reg [3:0] delay_times; // To hold delay - which counts down\n\n    // Pattern detection\n    reg [3:0] pattern_buf; // Buffer for incoming data bits\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= SEARCH;\n            counting <= 0;\n            done <= 0;\n            count <= 0;\n            pattern_buf <= 0;\n            delay <= 0;\n            counter <= 0;\n            delay_times <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(posedge clk) begin\n        // Shift the data into buffer when searching\n        if (state == SEARCH) begin\n            pattern_buf <= {pattern_buf[2:0], data};\n            // Check for the pattern 1101 (binary)\n            if (pattern_buf == 4'b1101) begin\n                next_state <= SHIFT;\n            end\n        end else if (state == SHIFT) begin\n            // Shift in the next 4 bits\n            pattern_buf <= {pattern_buf[2:0], data}; \n            // Capture delay when 4 bits are received\n            if (pattern_buf[0] != data) begin  // condition to check if we have 4 bits\n                delay <= pattern_buf[3:0]; // capture last 4 bits\n                delay_times <= delay; // initialize delay counter\n                counter <= (delay + 1) * 1000; // setting the total count value\n                next_state <= COUNT; // move to counting state\n                counting <= 1; // start counting\n            end\n        end else if (state == COUNT) begin\n            // Counting down\n            if (counter > 0) begin\n                counter <= counter - 1; // decrement counter\n            end else begin\n                if (delay_times > 0) begin\n                    delay_times <= delay_times - 1; // decrement delay times\n                    count <= delay_times; // update the count output\n                    counter <= 1000; // reset counter for the next second\n                end else begin\n                    done <= 1; // counting is done, signal completion\n                    counting <= 0; // stop counting\n                    next_state <= DONE_WAIT; // move to wait for ack\n                end\n            end\n        end else if (state == DONE_WAIT) begin\n            // Wait for acknowledgment to reset\n            if (ack) begin\n                done <= 0; // reset done signal\n                count <= 0; // reset count output to don't care\n                next_state <= SEARCH; // return to searching state\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Reset state\n\t\tfr3 <= 1'b1;\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;\n\tend else begin\n\t\t// Default state for flow control\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr <= 1'b0;\n\n\t\t// Flow control based on sensor signals (s)\n\t\tif (s[3]) begin\n\t\t\t// Water level above s[3]\n\t\t\tfr1 <= 1'b0; // None\n\t\tend else if (s[2]) begin\n\t\t\t// Water level between s[3] and s[2]\n\t\t\tfr1 <= 1'b1; // fr1\n\t\tend else if (s[1]) begin\n\t\t\t// Water level between s[2] and s[1]\n\t\t\tfr1 <= 1'b1; // fr1\n\t\t\tfr2 <= 1'b1; // fr2\n\t\tend else begin\n\t\t\t// Water level below s[1]\n\t\t\tfr1 <= 1'b1; // fr1\n\t\t\tfr2 <= 1'b1; // fr2\n\t\t\tfr3 <= 1'b1; // fr3\n\t\tend\n\n\t\t// Determine dfr - here assuming a signal or external logic can determine if current level goes up\n\t\t// Placeholder for supplemental flow control\n\t\t// This could be based on previous state or an additional input not mentioned\n\t\tdfr <= // Assign based on logic for monitoring level changes\n\tend\nend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count; // To count the number of data bits received\n\n    // State encoding\n    localparam IDLE  = 3'b000,\n               START = 3'b001,\n               DATA  = 3'b010,\n               STOP  = 3'b011,\n               ERROR = 3'b100;\n\n    // Output logic\n    assign done = (state == STOP && in == 1);\n\n    // FSM\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'b0000;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        next_state = state; // Default next state is current state\n        case (state)\n            IDLE: begin\n                if (in == 0)  // Detected start bit\n                    next_state = START;\n            end\n            \n            START: begin\n                next_state = DATA; // Proceed to data once start bit detected\n                bit_count = 4'b0000; // Reset bit count\n            end\n            \n            DATA: begin\n                if (bit_count < 8) begin\n                    bit_count = bit_count + 4'b0001; // Count data bits\n                end else begin\n                    next_state = STOP; // All 8 bits received\n                end\n            end\n            \n            STOP: begin\n                if (in == 1) begin\n                    next_state = IDLE; // Go back to IDLE if stop bit is correct\n                end else begin\n                    next_state = ERROR; // Stay in ERROR until stop bit arrives\n                end\n            end\n            \n            ERROR: begin\n                if (in == 1) begin\n                    next_state = IDLE; // Valid stop bit detected, go back to IDLE\n                end\n            end\n            \n            default: next_state = IDLE; // Safe default\n        endcase\n    end\nendmodule\n", "result": "failed: 56 out of 905 samples.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    typedef enum reg [1:0] {IDLE, RECEIVE, CHECK_STOP} state_t;\n    state_t current_state, next_state;\n\n    reg [3:0] bit_count; // to count the number of received bits\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            out_byte <= 8'b0;\n            done <= 1'b0;\n            bit_count <= 4'b0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default assignments\n        next_state = current_state;\n        done = 1'b0; // reset done\n        case (current_state)\n            IDLE: begin\n                if (in == 1'b0) begin // Start bit detected\n                    next_state = RECEIVE;\n                    bit_count = 4'b0; // reset bit count\n                end\n            end\n            RECEIVE: begin\n                if (bit_count < 8) begin // Collect data bits\n                    out_byte[bit_count] = in; // Store bit into out_byte\n                    bit_count = bit_count + 1; // Increment count\n                end else begin\n                    next_state = CHECK_STOP; // Move to check stop bit\n                end\n            end\n            CHECK_STOP: begin\n                if (in == 1'b1) begin // Stop bit detected\n                    done = 1'b1; // Assert done\n                    next_state = IDLE; // Move back to idle\n                end else begin\n                    // If stop bit isn't detected, stay in CHECK_STOP\n                    next_state = CHECK_STOP;\n                end\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n\treg [6:0] ghr; // 7-bit global history register\n\treg [1:0] pht[127:0]; // Pattern history table of 128 entries, each 2 bits\n\n\tinteger i;\n\n\t// Initialize PHT in the reset state\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tghr <= 7'b0;\n\t\t\tfor (i = 0; i < 128; i = i + 1) begin\n\t\t\t\tpht[i] <= 2'b10; // Neutral state for saturating counter\n\t\t\tend\n\t\tend else begin\n\t\t\tif (train_valid) begin\n\t\t\t\t// PHT training logic\n\t\t\t\tint index = (train_pc ^ ghr) % 128; // XOR hashed index\n\t\t\t\tif (train_taken) begin\n\t\t\t\t\tif (pht[index] != 2'b11)\n\t\t\t\t\t\tpht[index] <= pht[index] + 1; // Increment saturating counter\n\t\t\t\tend else begin\n\t\t\t\t\tif (pht[index] != 2'b00)\n\t\t\t\t\t\tpht[index] <= pht[index] - 1; // Decrement saturating counter\n\t\t\t\tend\n\n\t\t\t\t// Update GHR on mispredicted training\n\t\t\t\tif (train_mispredicted) begin\n\t\t\t\t\tghr <= train_history; // Recover to historic state\n\t\t\t\tend else begin\n\t\t\t\t\tghr <= {ghr[5:0], train_taken}; // Shift in the taken/not taken\n\t\t\t\tend\n\t\t\tend\n\t\t\tif (predict_valid) begin\n\t\t\t\t// Prediction logic\n\t\t\t\tint index = (predict_pc ^ ghr) % 128; // XOR hashed index\n\t\t\t\tpredict_taken <= pht[index][1]; // MSB for prediction taken\n\t\t\t\tpredict_history <= ghr; // Current state of GHR\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n// Define the state encoding\ntypedef enum reg [2:0] {\n    WALK_LEFT = 3'b000,\n    WALK_RIGHT = 3'b001,\n    FALL = 3'b010,\n    DIGGING = 3'b011,\n    SPLATTER = 3'b100\n} state_t;\n\nstate_t current_state, next_state;\nreg [4:0] fall_counter; // 5-bit counter for counting falls\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= WALK_LEFT;\n        fall_counter <= 0;\n    end else begin\n        current_state <= next_state;\n        if (current_state == FALL)\n            fall_counter <= fall_counter + 1;\n        else\n            fall_counter <= 0; // Reset counter when not falling\n    end\nend\n\nalways @(*) begin\n    // Default values for outputs\n    walk_left = 0;\n    walk_right = 0;\n    aaah = 0;\n    digging = 0;\n    \n    case (current_state)\n        WALK_LEFT: begin\n            walk_left = 1;\n            if (ground == 0) next_state = FALL; // Start falling\n            else if (bump_right) next_state = WALK_RIGHT; // Change direction\n            else if (dig) next_state = DIGGING; // Start digging\n            else next_state = WALK_LEFT; // Stay in WALK_LEFT\n        end\n        WALK_RIGHT: begin\n            walk_right = 1;\n            if (ground == 0) next_state = FALL; // Start falling\n            else if (bump_left) next_state = WALK_LEFT; // Change direction\n            else if (dig) next_state = DIGGING; // Start digging\n            else next_state = WALK_RIGHT; // Stay in WALK_RIGHT\n        end\n        FALL: begin\n            aaah = 1; // Indicate falling\n            if (ground) begin\n                if (fall_counter > 20) \n                    next_state = SPLATTER; // Move to splatter if falling too long\n                else \n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT; // Resume walking\n            end else begin\n                next_state = FALL; // Continue falling\n            end\n        end\n        DIGGING: begin\n            digging = 1;\n            if (ground == 0) next_state = FALL; // Fall if ground is gone\n            else next_state = DIGGING; // Continue digging\n        end\n        SPLATTER: begin\n            walk_left = 0;   // No walking\n            walk_right = 0;  // No walking\n            aaah = 0;        // Not falling\n            digging = 0;     // Not digging\n            next_state = SPLATTER; // Stay in splatter state\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        SHIFT = 2'b01,\n        COUNT = 2'b10,\n        DONE = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] shift_count;  // to count shift cycles\n\n    // Sequential state transition\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_count <= 0;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            // Manage shift count\n            if (state == SHIFT) begin\n                if (shift_count < 4) shift_count <= shift_count + 1;\n                else shift_count <= 0;\n            end else begin\n                shift_count <= 0; // reset when not in SHIFT state\n            end\n        end\n    end\n\n    // Combinatorial next state logic\n    always @(*) begin\n        // Default outputs\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n        \n        case (state)\n            IDLE: begin\n                if (data == 1) begin // Assuming data is shifting in\n                    next_state = (prev_data == 1) ? (prev_prev_data == 0 ? SHIFT : IDLE) : IDLE;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            SHIFT: begin\n                shift_ena = 1;\n                if (shift_count == 3) begin // 4 shifts completed\n                    next_state = COUNT;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            \n            COUNT: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = DONE;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            \n            DONE: begin\n                done = 1;\n                if (ack) begin // Wait for acknowledgment\n                    next_state = IDLE; // Return to idle\n                end else begin\n                    next_state = DONE;\n                end\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    integer i, j;\n    reg [255:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial state\n        end else begin\n            // Update the state\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    // Calculate the number of alive neighbors\n                    integer alive_neighbors;\n                    alive_neighbors = 0;\n                    integer x, y;\n                    \n                    // Checking all relative positions of neighbors\n                    for (x = -1; x <= 1; x = x + 1) begin\n                        for (y = -1; y <= 1; y = y + 1) begin\n                            if (x == 0 && y == 0) continue; // Skip the cell itself\n                            alive_neighbors = alive_neighbors + q[((i + x + 16) % 16) * 16 + ((j + y + 16) % 16)];\n                        end\n                    end\n\n                    // Determine the next state based on neighbor count\n                    case ({q[i*16 + j], alive_neighbors})\n                        5'b10000: next_q[i*16 + j] = 0; // Alive with 0 neighbors\n                        5'b10001: next_q[i*16 + j] = 0; // Alive with 1 neighbor\n                        5'b10010: next_q[i*16 + j] = 0; // Alive with 2 neighbors\n                        5'b10011: next_q[i*16 + j] = 1; // Alive with 3 neighbors\n                        5'b10000: next_q[i*16 + j] = 0; // Alive with 4+ neighbors\n                        5'b00000: next_q[i*16 + j] = 0; // Dead with 0 neighbors\n                        5'b00001: next_q[i*16 + j] = 0; // Dead with 1 neighbor\n                        5'b00010: next_q[i*16 + j] = 0; // Dead with 2 neighbors\n                        5'b00011: next_q[i*16 + j] = 1; // Dead with 3 neighbors\n                        default: next_q[i*16 + j] = 0; // Dead with 4+ neighbors\n                    endcase\n                end\n            end\n            // Update the grid state\n            q <= next_q;\n        end\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        WALK_LEFT  = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING    = 2'b10,\n        DIGGING    = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential Logic for State Transition\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Combinational Logic for Next State and Outputs\n    always @(*) begin\n        // Default outputs\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case(state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                    digging = 1;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            WALK_RIGHT: begin\n                walk_right = 1;\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                    digging = 1;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            FALLING: begin\n                aaah = 1; // Falling sound\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end\n            end\n            \n            DIGGING: begin\n                digging = 1; // Digging action\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1;\n                end\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\t\n\t// Internal registers to count seconds, minutes, and hours\n\treg [5:0] second_count = 6'd0;\n\treg [5:0] minute_count = 6'd0;\n\treg [3:0] hour_count = 4'd0;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\t// Reset all counters and pm\n\t\t\thh <= 8'b0000_1100; // Set to 12 in BCD\n\t\t\tmm <= 8'b0000_0000; // Set to 00 in BCD\n\t\t\tss <= 8'b0000_0000; // Set to 00 in BCD\n\t\t\tpm <= 1'b0;         // Set to AM\n\t\t\tsecond_count <= 6'd0;\n\t\t\tminute_count <= 6'd0;\n\t\t\thour_count <= 4'd0;\n\t\tend else if (ena) begin\n\t\t\tsecond_count <= second_count + 1;\n\t\t\tif (second_count == 6'd59) begin\n\t\t\t\tsecond_count <= 6'd0;\n\t\t\t\tss <= ss + 1;\n\t\t\t\tif (ss == 8'b0101_1000) begin // If ss == 60 in BCD\n\t\t\t\t\tss <= 8'b0000_0000; // Reset seconds to BCD 00\n\t\t\t\t\tminute_count <= minute_count + 1;\n\t\t\t\t\tif (minute_count == 6'd59) begin\n\t\t\t\t\t\tminute_count <= 6'd0;\n\t\t\t\t\t\tmm <= mm + 1;\n\t\t\t\t\t\tif (mm == 8'b0101_1000) begin // If mm == 60 in BCD\n\t\t\t\t\t\t\tmm <= 8'b0000_0000; // Reset minutes to BCD 00\n\t\t\t\t\t\t\thour_count <= hour_count + 1;\n\t\t\t\t\t\t\tif (hour_count == 4'd11) begin\n\t\t\t\t\t\t\t\tpm <= ~pm; // Toggle PM/AM on 12\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tif (hour_count == 4'd12) begin\n\t\t\t\t\t\t\t\thour_count <= 4'd0; // Wrap back to 1\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\t// Updating output in BCD format\n\t\t\thh <= (hour_count < 4'd10) ? {4'd0, hour_count} : {4'd0, hour_count + 4'd1}; // Adjust for BCD\n\t\t\tmm <= (minute_count < 4'd10) ? {4'd0, minute_count} : {4'd0, minute_count}; // BCD already\n\t\t\tss <= (second_count < 4'd10) ? {4'd0, second_count} : {4'd0, second_count}; // BCD already\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Synchronous state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= WALK_LEFT; // Reset to walk left\n        else \n            current_state <= next_state; // Update to next state\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) \n                    next_state = FALLING; // Falling if no ground\n                else if (bump_right) \n                    next_state = WALK_RIGHT; // Bump right switches to walk right\n                else \n                    next_state = WALK_LEFT; // Remain walking left\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) \n                    next_state = FALLING; // Falling if no ground\n                else if (bump_left) \n                    next_state = WALK_LEFT; // Bump left switches to walk left\n                else \n                    next_state = WALK_RIGHT; // Remain walking right\n            end\n            \n            FALLING: begin\n                if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT; // Resume direction when grounded\n                else \n                    next_state = FALLING; // Stay falling\n            end\n            \n            default: next_state = WALK_LEFT; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                aaah = 0;\n            end\n            \n            WALK_RIGHT: begin\n                walk_right = 1;\n                aaah = 0;\n            end\n            \n            FALLING: begin\n                aaah = 1; // Output \"aaah!\" when falling\n            end\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0; // Reset the counter\n        end else begin\n            // Ones place\n            if (q[3:0] == 4'b1001) begin\n                q[3:0] <= 4'b0000; // Reset ones digit\n            end else begin\n                q[3:0] <= q[3:0] + 1; // Increment ones digit\n            end\n            \n            // Tens place\n            if (q[3:0] == 4'b0000 && q[7:4] == 4'b1001) begin\n                q[7:4] <= 4'b0000; // Reset tens digit\n            end else if (q[3:0] == 4'b0000) begin\n                q[7:4] <= q[7:4] + 1; // Increment tens digit\n            end\n            \n            // Hundreds place\n            if (q[7:4] == 4'b0000 && q[11:8] == 4'b1001) begin\n                q[11:8] <= 4'b0000; // Reset hundreds digit\n            end else if (q[7:4] == 4'b0000) begin\n                q[11:8] <= q[11:8] + 1; // Increment hundreds digit\n            end\n            \n            // Thousands place\n            if (q[11:8] == 4'b0000 && q[15:12] == 4'b1001) begin\n                q[15:12] <= 4'b0000; // Reset thousands digit\n            end else if (q[11:8] == 4'b0000) begin\n                q[15:12] <= q[15:12] + 1; // Increment thousands digit\n            end\n        end\n    end\n\n    assign ena[1] = 1'b1; // Enable for ones digit\n    assign ena[2] = (q[3:0] == 4'b1001); // Enable for tens digit\n    assign ena[3] = (q[7:4] == 4'b1001); // Enable for hundreds digit\n\nendmodule\n", "result": "failed: 39804 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\n    assign out = (sel == 0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n    \nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0; // State A\n        3'b001: Y2 = 0; // State B\n        3'b010: Y2 = (w == 0) ? 1 : 0; // State C\n        3'b011: Y2 = (w == 0) ? 1 : 0; // State D\n        3'b100: Y2 = (w == 0) ? 1 : 0; // State E\n        3'b101: Y2 = 0; // State F\n        default: Y2 = 0; // Default case\n    endcase\nend\n\nendmodule\n", "result": "failed: 55 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n    \n    always @(*) begin\n        if (ring) begin   // If there's an incoming call (ringing)\n            if (vibrate_mode) begin   // Check if vibrate mode is on\n                ringer = 0;  // Turn off ringer\n                motor = 1;   // Turn on motor\n            end else begin   // Vibrate mode is off\n                ringer = 1;  // Turn on ringer\n                motor = 0;   // Turn off motor\n            end\n        end else begin   // No incoming call\n            ringer = 0;  // Turn off ringer\n            motor = 0;   // Turn off motor\n        end\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Using an assign statement for output\nassign out_assign = a & b;\n\n// Using a combinational always block for output\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n    assign zero = 0;  // Assigning a constant LOW value to the output\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    // Initialize q\n    initial begin\n        q = 0;\n    end\n\n    // Sequential logic\n    always @(posedge clk) begin\n        if (a == 1) \n            q <= 1;  // Set q to 1 when a is 1\n        else \n            q <= 0;  // Reset q to 0 when a is 0\n    end\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // State declarations\n    typedef enum reg [1:0] {\n        S_WAIT = 2'b00, // Waiting for input\n        S_INVERT = 2'b01, // Inverting the input bit\n        S_ADD = 2'b10 // Handle adding carry\n    } state_t;\n\n    state_t state, next_state;\n    reg [1:0] carry; // To handle carry for addition\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= S_WAIT; // Reset to the waiting state\n            carry <= 2'b00; // Clear carry\n            z <= 0; // Clear output\n        end else begin\n            state <= next_state; // Update state to next state\n        end\n    end\n\n    always @(*) begin\n        // Default output\n        z = 0;\n        case (state)\n            S_WAIT: begin\n                // Wait for input\n                if (carry == 2'b00) begin\n                    next_state = S_INVERT; // Move to inversion state\n                end else {\n                    next_state = S_WAIT;  // Stay in wait\n                end\n            end\n            \n            S_INVERT: begin\n                // Output the inverted bit\n                z = ~x;\n                carry = 1; // Indicate we need to add 1 later\n                next_state = S_ADD; // Move to add state\n            end\n            \n            S_ADD: begin\n                // Add carry logic\n                if (carry == 1) begin\n                    z = z + 1; // Add 1 to inverted output\n                    carry = 0; // Reset carry\n                end\n                next_state = S_WAIT; // After addition, back to waiting\n            end\n            \n            default: begin\n                next_state = S_WAIT; // Default case to avoid latches\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // State register\n    state_t current_state, next_state;\n\n    // Asynchronous reset and state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= A;  // Reset to state A\n        end else begin\n            current_state <= next_state;  // Transition to next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Safe default, should not occur\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Safe default, error case\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\n// Reverse the byte order\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\talways_ff @(posedge clk) begin\n\t\tif (r) begin\n\t\t\tq <= 0; // Reset output to 0 if r is high\n\t\tend else begin\n\t\t\tq <= d; // Capture the value of d on clock's rising edge\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = (x ^ y) & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the shift register\n        end else if (ena) begin\n            case(amount)\n                2'b00: q <= q << 1; // Shift left by 1 bit\n                2'b01: q <= q << 8; // Shift left by 8 bits\n                2'b10: q <= {q[62:0], q[63]}; // Arithmetic right shift by 1 bit\n                2'b11: q <= {q[55:0], q[63], q[63], q[63], q[63]}; // Arithmetic right shift by 8 bits\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: 3104 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00,  // Initial State\n        S1 = 2'b01,  // After receiving '1'\n        S2 = 2'b10   // After receiving '10'\n    } state_t;\n\n    // State variable\n    state_t current_state, next_state;\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: z = 0; // No sequence detected\n            S1: z = 0; // No sequence detected\n            S2: z = 1; // Sequence detected\n            default: z = 0; // Should not happen\n        endcase\n    end\n\n    // State transition\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (x) \n                    next_state = S1; // Move to S1 on '1'\n                else \n                    next_state = S0; // Stay in S0 on '0'\n            end\n            S1: begin\n                if (~x) \n                    next_state = S2; // Move to S2 on '0'\n                else \n                    next_state = S1; // Stay in S1 on '1'\n            end\n            S2: begin\n                if (x) \n                    next_state = S1; // Overlapping, move back to S1\n                else \n                    next_state = S0; // Move to S0 on '0'\n            end\n            default: next_state = S0; // Reset on default\n        endcase\n    end\n\n    // Sequential logic for state update\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0; // Asynchronous reset to S0\n        else \n            current_state <= next_state; // Update state\n    end\n\nendmodule\n", "result": "failed: 40 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\t// State encoding\n\tparameter A = 3'b000;\n\tparameter B = 3'b001;\n\tparameter C = 3'b010;\n\tparameter D = 3'b011;\n\tparameter E = 3'b100;\n\tparameter F = 3'b101;\n\n\treg [2:0] state, next_state;\n\n\t// Combinational logic for next state\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (w == 0) next_state = B;\n\t\t\t\telse next_state = A;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (w == 0) next_state = C;\n\t\t\t\telse next_state = D;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (w == 0) next_state = E;\n\t\t\t\telse next_state = D;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tif (w == 0) next_state = F;\n\t\t\t\telse next_state = A;\n\t\t\t\tz = 0;\n\t\t\tend\n\t\t\tE: begin\n\t\t\t\tnext_state = (w == 0) ? E : D;\n\t\t\t\tz = 1;\n\t\t\tend\n\t\t\tF: begin\n\t\t\t\tnext_state = (w == 0) ? C : D;\n\t\t\t\tz = 1;\n\t\t\tend\n\t\t\tdefault: next_state = A; // Fallback to A for unexpected states\n\t\tendcase\n\tend\n\n\t// Sequential logic for state transitions\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= A; // Reset to initial state\n\t\telse\n\t\t\tstate <= next_state; // Transition to next state\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    // State definitions\n    typedef enum reg [1:0] {WAIT_FOR_START, RECEIVING_BYTES, DONE_RECEIVING} state_t;\n    state_t current_state, next_state;\n    \n    // Byte count\n    reg [1:0] byte_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= WAIT_FOR_START;\n            byte_count <= 0;\n            out_bytes <= 24'b0;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        next_state = current_state; // default next state\n        done = 0;                   // default done signal\n        case (current_state)\n            WAIT_FOR_START: begin\n                if (in[3] == 1) begin\n                    next_state = RECEIVING_BYTES;\n                    byte_count = 0;  // reset byte count\n                end\n            end\n            \n            RECEIVING_BYTES: begin\n                out_bytes[(byte_count+1)*8-1 -: 8] = in; // store incoming byte\n                byte_count = byte_count + 1;\n                if (byte_count == 2) begin // After receiving 3rd byte\n                    next_state = DONE_RECEIVING;\n                end\n            end\n            \n            DONE_RECEIVING: begin\n                done = 1;  // signal done immediately after third byte\n                next_state = WAIT_FOR_START; // return to waiting for new message\n            end\n            \n            default: begin\n                next_state = WAIT_FOR_START; // safety\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    \n    assign Y1 = (y[0] & w); // from A to B on w=1\n    assign Y3 = (y[2] & (w == 0)) | (y[3] & (w == 1)); // from C to D on w=0 and staying in D on w=0, or from F to D on w=0\n \nendmodule\n", "result": "failed: 179 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n// Assign the output vector to the input vector\nassign outv = vec;\n\n// Assign individual bits to their respective outputs\nassign o0 = vec[0]; // Bit 0 of vec to o0\nassign o1 = vec[1]; // Bit 1 of vec to o1\nassign o2 = vec[2]; // Bit 2 of vec to o2\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\talways @(*) begin\n\t\tout = (b & ~c & ~d) | (~a & ~b & c & ~d) | (b & d) | (a & ~b & ~c & d);\n\tend\nendmodule\n", "result": "failed: 128 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n    assign out_hi = in[15:8];  // Extract upper byte\n    assign out_lo = in[7:0];   // Extract lower byte\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a | b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Continuous assignment for XOR\nassign out_assign = a ^ b;\n\n// Combinational always block for XOR\nalways @(*) begin\n\tout_always_comb = a ^ b;\nend\n\n// Clocked always block for flip-flop behavior\nalways @(posedge clk) begin\n\tout_always_ff <= a ^ b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\n\tassign Y2 = (y[6] & ~w) | (y[2] & w) | (y[4] & w);\n\tassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w);\n\nendmodule\n", "result": "failed: 327 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    assign out = in[sel];  // Select the corresponding bit from 'in' using 'sel'\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R; // Load value from R\n\t\tend else if (E) begin\n\t\t\tQ <= w; // Shift value from w\n\t\tend \n\t\t// If neither L nor E is asserted, Q remains unchanged (retains previous state).\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Declare D flip-flop outputs\n    reg [2:0] d_ff_out;\n\n    // Always block for D flip-flops\n    always @(posedge clk) begin\n        d_ff_out[0] <= x ^ d_ff_out[0];             // XOR with the output of FF0\n        d_ff_out[1] <= x & ~d_ff_out[1];           // AND with the complemented output of FF1\n        d_ff_out[2] <= x | ~d_ff_out[2];           // OR with the complemented output of FF2\n    end\n\n    // 3-input XNOR for output z\n    assign z = ~(d_ff_out[0] ^ d_ff_out[1] ^ d_ff_out[2]);\n    \nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (a & (b | c | d));\nendmodule\n", "result": "failed: 49 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    // Next state variable\n    reg [511:0] next_q;\n\n    always @(*) begin\n        // Initialize next_q with all zeroes\n        next_q = 0;\n        \n        // Iterate over each cell control logic\n        for (int i = 0; i < 512; i = i + 1) begin\n            // Define left, center, and right values, adding boundary conditions\n            logic left = (i == 0) ? 1'b0 : q[i - 1];\n            logic center = q[i];\n            logic right = (i == 511) ? 1'b0 : q[i + 1];\n\n            // Rule 110 logic table\n            case ({left, center, right})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n                default: next_q[i] = 1'b0; // Just to handle any undefined case\n            endcase\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial state\n        end else begin\n            q <= next_q; // Update to the next state\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    \n    // Define states using parameter\n    typedef enum reg [1:0] {A, B, C, D} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;  // Reset state is A\n        end else begin\n            current_state <= next_state; // Move to the next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default to A\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A, B, C: out = 0; // Output 0 for states A, B, C\n            D: out = 1;      // Output 1 for state D\n            default: out = 0; // Default output value\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @* begin\n    case (c)\n        4'b0000: q = b; // When c = 0\n        4'b0001: q = e; // When c = 1\n        4'b0010: q = a; // When c = 2\n        4'b0011: q = d; // When c = 3\n        default: q = 4'b1111; // For c >= 4\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\nalways @(*) begin\n\tif (sel) begin\n\t\tout = b; // Output b if sel is 1\n\tend else begin\n\t\tout = a; // Output a if sel is 0\n\tend\nend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n    wire q0, q1, q2;\n\n    top_module inst0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[0]),\n        .Q(q0)\n    );\n\n    top_module inst1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1]),\n        .r_in(r[1]),\n        .Q(q1)\n    );\n\n    top_module inst2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(q2)\n    );\n\n    always @(posedge clk) begin\n        q <= {q2, q1, q0};\n    end\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;          // Reset output to 0\n            prev_in <= 32'b0;      // Optionally reset previous input as well\n        end else begin\n            // Capture changes: out[i] remains 1 until reset if prev_in[i] was 1 and in[i] is now 0\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (prev_in[i] == 1'b1 && in[i] == 1'b0)\n                    out[i] <= 1'b1;   // Set the output bit if the condition is met\n            end\n            prev_in <= in;           // Update previous input\n        end\n    end\nendmodule\n", "result": "failed: 99 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tq <= d; // On the rising edge of clk, assign d to q\n\tend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n// Compute the sum of a and b\nwire [8:0] sum;\nassign sum = {1'b0, a} + {1'b0, b}; // Extend to 9 bits for carry\n\n// Assign the lower 8 bits to s\nassign s = sum[7:0];\n\n// Check for overflow\nassign overflow = (a[7] == b[7]) && (s[7] != a[7]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n// Next State Logic\nassign S_next = state[0] && ~d; // S state, stay on d=0\nassign S1_next = state[0] && d;  // S state, go to S1 on d=1\nassign Count_next = state[8] && done_counting; // Count state to Wait when done_counting is high\nassign Wait_next = state[9] && ack; // Wait state goes to S on ack\n\n// B3_next: Go to B3 if in B2 and shift_ena is asserted\nassign B3_next = state[7]; // Automatically goes to next state B3 when shift_ena is asserted\nassign shift_ena = state[4] || state[5] || state[6] || state[7]; // Active in states B0, B1, B2, B3\n\n// Output Logic\nassign done = state[9]; // done is asserted when in Wait state\nassign counting = state[8]; // counting is asserted when in Count state\n\nendmodule\n", "result": "failed: 2994 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    // Initial state for state\n    always_ff @(posedge clk or posedge areset) begin\n        // Asynchronous reset\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                // Increment, but saturate at 3 (2'b11)\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                // Decrement, but saturate at 0 (2'b00)\n                state <= state - 1;\n            end\n            // If train_valid is high but train_taken is not asserted, state remains unchanged.\n        end\n        // If train_valid is low, state remains unchanged due to nature of always_ff block.\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\nalways @* begin\n    pos = 3'b000; // Default value, in case there are no bits high\n    for (integer i = 0; i < 8; i = i + 1) begin\n        if (in[i] == 1'b1) begin\n            pos = i[2:0]; // Capture the position (limited to 3 bits)\n            break; // Exit once the first high bit is found\n        end\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n    \n    always @* begin\n        // Default the outputs to low\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        // Check the scancode against known values\n        case (scancode)\n            16'hE06B: left = 1;   // Left Arrow\n            16'hE072: down = 1;   // Down Arrow\n            16'hE074: right = 1;  // Right Arrow\n            16'hE075: up = 1;     // Up Arrow\n            default: ;            // No action needed for other values\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n\twire c1, c2, c3; // carry wires between full adders\n\n\t// Full Adder for the least significant bit\n\tassign sum[0] = x[0] ^ y[0]; // Sum bit 0\n\tassign c1 = (x[0] & y[0]);   // Carry out\n\n\t// Full Adder for the second bit\n\tassign sum[1] = x[1] ^ y[1] ^ c1; // Sum bit 1\n\tassign c2 = (x[1] & y[1]) | (c1 & (x[1] ^ y[1])); // Carry out\n\n\t// Full Adder for the third bit\n\tassign sum[2] = x[2] ^ y[2] ^ c2; // Sum bit 2\n\tassign c3 = (x[2] & y[2]) | (c2 & (x[2] ^ y[2])); // Carry out\n\n\t// Full Adder for the most significant bit\n\tassign sum[3] = x[3] ^ y[3] ^ c3; // Sum bit 3\n\tassign sum[4] = (x[3] & y[3]) | (c3 & (x[3] ^ y[3])); // Final carry / overflow bit\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    // Register to hold the current history\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset the predict_history to zero\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            // Load in the training history and the actual result\n            predict_history <= {train_history[30:0], train_taken}; // Concatenating the new branch outcome\n        end else if (predict_valid) begin\n            // Shift in the predicted taken value\n            predict_history <= {predict_history[30:0], predict_taken}; // Shift left and add new value\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n    wire and1_out;  // Intermediate wire for the first AND gate\n    wire and2_out;  // Intermediate wire for the second AND gate\n\n    // First AND gate\n    assign and1_out = a & b;\n\n    // Second AND gate\n    assign and2_out = c & d;\n\n    // OR gate to combine the outputs of the AND gates\n    assign out = and1_out | and2_out;\n\n    // NOT gate for inverted output\n    assign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    always @(posedge clk) begin\n        q <= d; // Assign the value of d to q at the rising edge of clk\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\nreg [7:0] Q; // 8-bit shift register\n\n// Shift Register Logic\nalways @(posedge clk) begin\n\tif (enable) begin\n\t\tQ <= {S, Q[7:1]}; // Shift right\n\tend\nend\n\n// Multiplexer Logic\nalways @(*) begin\n\tcase ({A, B, C}) // Concatenate A, B, and C\n\t\t3'b000: Z = Q[0];\n\t\t3'b001: Z = Q[1];\n\t\t3'b010: Z = Q[2];\n\t\t3'b011: Z = Q[3];\n\t\t3'b100: Z = Q[4];\n\t\t3'b101: Z = Q[5];\n\t\t3'b110: Z = Q[6];\n\t\t3'b111: Z = Q[7];\n\t\tdefault: Z = 1'b0; // Default case (optional)\n\tendcase\nend\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n    // Heater logic: On when mode is heating (1) and it is too cold\n    assign heater = (mode == 1 && too_cold);\n\n    // Air Conditioner logic: On when mode is cooling (0) and it is too hot\n    assign aircon = (mode == 0 && too_hot);\n\n    // Fan logic: On when the heater or aircon is on or if fan_on is requested\n    assign fan = heater || aircon || fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n    // Sum of Products (SOP)\n    assign out_sop = ( ~a &  b &  c &  d ) | ( ~a &  b &  c & ~d ) | ( a &  b &  c &  d );\n\n    // Product of Sums (POS)\n    assign out_pos = ( a | b | c | d ) & \n                     ( a | b | c | ~d ) & \n                     ( a | ~b | c | d ) & \n                     ( a | ~b | c | ~d ) & \n                     ( a | ~b | ~c | d ) & \n                     ( ~a | b | c | d ) & \n                     ( ~a | b | ~c | d ) & \n                     ( ~a | ~b | c | d ) & \n                     ( ~a | ~b | ~c | d );\n\nendmodule\n", "result": "failed: 45 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset to 1\n        end else begin\n            // Perform the shifting and tapping\n            q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])}; // Next MSB produced by XOR of tapped bits\n        end\n    end\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (b & d) | (b & c) | (c & d);\nendmodule\n", "result": "failed: 24 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n    assign p1y = ~(p1a & p1b & p1c & p1d); // First 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d); // Second 4-input NAND gate\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n    integer i; // Loop variable\n    always @* begin\n        out = 0; // Initialize output to zero\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Count the number of '1's\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\n    // Calculate out_both\n    assign out_both[0] = in[1] & in[0]; // Both in[1] and in[0]\n    assign out_both[1] = in[2] & in[1]; // Both in[2] and in[1]\n    assign out_both[2] = in[3] & in[2]; // Both in[3] and in[2]\n\n    // Calculate out_any\n    assign out_any[1] = in[1] | in[2]; // Any of in[2] and in[1]\n    assign out_any[2] = in[2] | in[3]; // Any of in[3] and in[2]\n    assign out_any[3] = in[0] | in[3]; // Any of in[0] and in[3]\n\n    // Calculate out_different\n    assign out_different[0] = in[0] ^ in[3]; // Different from in[3]\n    assign out_different[1] = in[1] ^ in[0]; // Different from in[0]\n    assign out_different[2] = in[2] ^ in[1]; // Different from in[1]\n    assign out_different[3] = in[3] ^ in[2]; // Different from in[2]\n\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    always @* begin\n        case (a)\n            3'b000: q = 16'h1232; // 0\n            3'b001: q = 16'haee0; // 1\n            3'b010: q = 16'h27d4; // 2\n            3'b011: q = 16'h5a0e; // 3\n            3'b100: q = 16'h2066; // 4\n            3'b101: q = 16'h64ce; // 5\n            3'b110: q = 16'hc526; // 6\n            3'b111: q = 16'h2f19; // 7\n            default: q = 16'h0000; // default case (not shown in waveform)\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 4'b0000; // Reset the counter to 0\n\tend else if (slowena) begin\n\t\tif (q == 4'b1001) begin\n\t\t\tq <= 4'b0000; // Roll over to 0 after reaching 9\n\t\tend else begin\n\t\t\tq <= q + 1; // Increment the counter\n\t\tend\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Logic to handle the AND operation with inverted in2\n    assign out = in1 & ~in2;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in; // Directly assign input to output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    reg state; // Current state\n\n    // State encoding\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // State Transition Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_B; // Reset to state B\n        end else begin\n            case (state)\n                STATE_A: begin\n                    if (in == 0)\n                        state <= STATE_B; // 0 input: move to state B\n                    else\n                        state <= STATE_A; // 1 input: remain in state A\n                end\n                STATE_B: begin\n                    if (in == 0)\n                        state <= STATE_A; // 0 input: move to state A\n                    else\n                        state <= STATE_B; // 1 input: remain in state B\n                end\n            endcase\n        end\n    end\n\n    // Output Logic\n    always @(state) begin\n        out = state; // Output is the current state\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\treg d_rising;  // Register to hold value on the rising edge\n\treg d_falling; // Register to hold value on the falling edge\n\n\t// Capture the value of d on the rising edge\n\talways @(posedge clk) begin\n\t\td_rising <= d;\n\tend\n\t\n\t// Capture the value of d on the falling edge\n\talways @(negedge clk) begin\n\t\td_falling <= d; \n\tend\n\t\n\t// Output should reflect the most recent value of d\n\talways @* begin\n\t\tq = d_falling; // Default to the value from the falling edge\n\tend\n\nendmodule\n", "result": "failed: 41 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a ~^ b; // XNOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\t// Internal wires to hold outputs of submodules\n\twire a1_out, b1_out, a2_out, b2_out;\n\twire or_out, and_out;\n\n\t// Module A implementation\n\twire a_mod1_output, a_mod2_output;\n\twire b_mod1_output, b_mod2_output;\n\n\t// Module A: z = (x ^ y) & x\n\tassign a_mod1_output = (x ^ y) & x; // A1\n\tassign a_mod2_output = (x ^ y) & x; // A2\n\n\t// Module B example output derived from the table\n\t// Assuming Module B's output according to conditions deduced from waveform\n\tassign b_mod1_output = (x == 0 && y == 0) || (x == 1 && y == 1); // B1\n\tassign b_mod2_output = (x == 0 && y == 0) || (x == 1 && y == 1); // B2\n\n\t// OR gate combining outputs of A1 and B1\n\tassign or_out = a_mod1_output | b_mod1_output;\n\n\t// AND gate combining outputs of A2 and B2\n\tassign and_out = a_mod2_output & b_mod2_output;\n\n\t// XOR gate for final output\n\tassign z = or_out ^ and_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into q\n            q <= data;\n        end else begin\n            // Rotate based on ena\n            case (ena)\n                2'b01: begin\n                    // Rotate right by one bit\n                    q <= {q[0], q[99:1]};\n                end\n                2'b10: begin\n                    // Rotate left by one bit\n                    q <= {q[98:0], q[99]};\n                end\n                default: begin\n                    // Do not rotate\n                    q <= q;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'b0; // Reset the counter to 0\n        end else begin\n            if (q == 999) begin\n                q <= 10'b0; // Roll over to 0 when reaching 999\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n    assign out = ~in; // Assign the NOT operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    // Next state logic\n    assign next_state[0] = state[1] & ~in | state[3] & ~in | state[4] & ~in | state[5] & ~in | state[0] & ~in; // S0\n    assign next_state[1] = state[0] & in; // S0 -> S1\n    assign next_state[2] = state[1] & in; // S1 -> S2\n    assign next_state[3] = state[2] & in; // S2 -> S3\n    assign next_state[4] = state[3] & in; // S3 -> S4\n    assign next_state[5] = state[4] & in; // S4 -> S5\n    assign next_state[6] = state[5] & in; // S5 -> S6\n    assign next_state[7] = state[6] & in; // S6 -> S7\n    assign next_state[8] = state[5] & ~in; // S5 -> S8\n    assign next_state[9] = state[6] & ~in; // S6 -> S9\n\n    // Output logic\n    assign out1 = state[7] | state[8] | state[9]; // out1 high if in state S7, S8, or S9\n    assign out2 = state[7]; // out2 high only if in state S7\n\nendmodule\n", "result": "failed: 713 out of 1424 samples.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (j == 0 && k == 0) begin\n\t\tQ <= Q;              // Qold\n\tend else if (j == 0 && k == 1) begin\n\t\tQ <= 0;              // Reset to 0\n\tend else if (j == 1 && k == 0) begin\n\t\tQ <= 1;              // Set to 1\n\tend else if (j == 1 && k == 1) begin\n\t\tQ <= ~Q;             // Toggle Q\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[0] + in[1] + in[2]; // Adding the bits directly to get population count\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    \n    assign out[24] = (a == a);\n    assign out[23] = (a == b);\n    assign out[22] = (a == c);\n    assign out[21] = (a == d);\n    assign out[20] = (a == e);\n    \n    assign out[19] = (b == a);\n    assign out[18] = (b == b);\n    assign out[17] = (b == c);\n    assign out[16] = (b == d);\n    assign out[15] = (b == e);\n    \n    assign out[14] = (c == a);\n    assign out[13] = (c == b);\n    assign out[12] = (c == c);\n    assign out[11] = (c == d);\n    assign out[10] = (c == e);\n    \n    assign out[9]  = (d == a);\n    assign out[8]  = (d == b);\n    assign out[7]  = (d == c);\n    assign out[6]  = (d == d);\n    assign out[5]  = (d == e);\n    \n    assign out[4]  = (e == a);\n    assign out[3]  = (e == b);\n    assign out[2]  = (e == c);\n    assign out[1]  = (e == d);\n    assign out[0]  = (e == e);\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n    // State encoding\n    localparam STATE_LEFT = 1'b0;  // walking left\n    localparam STATE_RIGHT = 1'b1; // walking right\n\n    // Current state register\n    reg state, next_state;\n\n    // Always block for state transitions\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= STATE_LEFT; // Reset to walking left\n        end else begin\n            state <= next_state; // Update with the next state\n        end\n    end\n\n    // Combinational logic for next state\n    always @* begin\n        case (state)\n            STATE_LEFT: begin\n                if (bump_right || bump_left) begin\n                    next_state = STATE_RIGHT; // Bumped on the left or right, switch to right\n                end else begin\n                    next_state = STATE_LEFT; // Continue walking left\n                end\n            end\n            STATE_RIGHT: begin\n                if (bump_left || bump_right) begin\n                    next_state = STATE_LEFT; // Bumped on the left or right, switch to left\n                end else begin\n                    next_state = STATE_RIGHT; // Continue walking right\n                end\n            end\n            default: begin\n                next_state = STATE_LEFT; // Default case\n            end\n        endcase\n    end\n\n    // Output logic based on current state\n    always @* begin\n        case (state)\n            STATE_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            STATE_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 0; // Default values\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\n    assign q = a & b; // q is 1 only when both a and b are 1\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Internal wires for AND gates\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n    wire and4_out;\n\n    // First AND gate for p1y\n    assign and1_out = p1a & p1b & p1c;\n\n    // Second AND gate for p1y\n    assign and2_out = p1d & p1e & p1f;\n\n    // OR gate for p1y\n    assign p1y = and1_out | and2_out;\n\n    // First AND gate for p2y\n    assign and3_out = p2a & p2b;\n\n    // Second AND gate for p2y\n    assign and4_out = p2c & p2d;\n\n    // OR gate for p2y\n    assign p2y = and3_out | and4_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\t// Next state logic based on current state `y` and input `x`\n\tcase (y)\n\t\t3'b000: begin\n\t\t\tif (x) begin\n\t\t\t\tY0 <= 0; // Y[0] will be 0 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend else begin\n\t\t\t\tY0 <= 0; // Y[0] will be 0 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend\n\t\tend\n\t\t3'b001: begin\n\t\t\tif (x) begin\n\t\t\t\tY0 <= 0; // Y[0] will be 0 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend else begin\n\t\t\t\tY0 <= 1; // Y[0] will be 1 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend\n\t\tend\n\t\t3'b010: begin\n\t\t\tif (x) begin\n\t\t\t\tY0 <= 0; // Y[0] will be 0 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend else begin\n\t\t\t\tY0 <= 0; // Y[0] will remain 0 for next state\n\t\t\t\tz <= 0;  // Output z will be 0\n\t\t\tend\n\t\tend\n\t\t3'b011: begin\n\t\t\tif (x) begin\n\t\t\t\tY0 <= 1; // Y[0] will transition to state\n\t\t\t\tz <= 1;  // Output z will be 1\n\t\t\tend else begin\n\t\t\t\tY0 <= 0; // Y[0] will transition to state\n\t\t\t\tz <= 1;  // Output z will be 1\n\t\t\tend\n\t\tend\n\t\t3'b100: begin\n\t\t\tif (x) begin\n\t\t\t\tY0 <= 0; // Y[0] will transition to state\n\t\t\t\tz <= 1;  // Output z will be 1\n\t\t\tend else begin\n\t\t\t\tY0 <= 1; // Y[0] will remain state\n\t\t\t\tz <= 1;  // Output z will be 1\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tY0 <= 0; // Default state case\n\t\t\tz <= 0;  // Default output\n\t\tend\n\tendcase\nend\n\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t// Implementing NOR logic\n\tassign out = ~(in1 | in2); // NOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\nassign w = a;  // connect input a to output w\nassign x = b;  // connect input b to output x\nassign y = b;  // connect input b to output y\nassign z = c;  // connect input c to output z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 0;  // Asynchronous reset\n        end else begin\n            q <= d;  // On rising edge, set q to d\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\nalways @(*) begin\n\tcase(sel)\n\t\t3'b000: out = data0; // sel == 0\n\t\t3'b001: out = data1; // sel == 1\n\t\t3'b010: out = data2; // sel == 2\n\t\t3'b011: out = data3; // sel == 3\n\t\t3'b100: out = data4; // sel == 4\n\t\t3'b101: out = data5; // sel == 5\n\t\tdefault: out = 4'b0000; // if sel > 5\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] counter; // 10-bit counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load counter with data\n            tc <= 0; // Reset terminal count upon loading new value\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement counter\n        end\n        \n        // Check if counter has reached zero\n        if (counter == 0) begin\n            tc <= 1; // Assert terminal count if counter is zero\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n    // State encoding\n    reg [2:0] state, next_state;\n    \n    localparam S0 = 3'd0, // No bits matched\n               S1 = 3'd1, // Last bit matched: '1'\n               S2 = 3'd2, // Last two bits matched: '11'\n               S3 = 3'd3, // Last three bits matched: '110'\n               S4 = 3'd4; // Sequence matched: '1101'\n\n    // Sequential state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0; // Reset output\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (data) next_state = S1; // '1'\n                else next_state = S0; // stay in S0\n            end\n            S1: begin\n                if (data) next_state = S2; // '1'\n                else next_state = S0; // '0' goes back to S0\n            end\n            S2: begin\n                if (data) next_state = S2; // stay in S2 ('1')\n                else next_state = S3; // '0' goes to S3\n            end\n            S3: begin\n                if (data) next_state = S4; // '1' found, sequence complete\n                else next_state = S0; // '0' goes back to S0\n            end\n            S4: begin\n                next_state = S4; // Stay in S4 when the sequence is matched\n            end\n            default: next_state = S0; // safety net\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            start_shifting <= 0;\n        end else if (state == S4) begin\n            start_shifting <= 1; // Set when the sequence is matched\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (reset) \n\t\tq <= 8'b0; // Resetting all outputs to zero if reset is high\n\telse \n\t\tq <= d; // Otherwise, transmitting input d to output q\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    reg [7:0] prev_in; // Register to hold the previous value of in\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev_in); // Detect transitions: (current = 1) AND (previous = 0)\n        prev_in <= in; // Update previous value\n    end\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;  // Reset to 1 when reset is active\n    end else begin\n        if (q == 4'b1010) begin  // If q is 10 (decimal)\n            q <= 4'b0001;  // Reset to 1 (next count)\n        end else begin\n            q <= q + 1;  // Count up\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'b100; // Set to 4 (100 in binary) when a is 1\n        end else begin\n            if (q == 3'b110) // 6\n                q <= 3'b000; // Reset to 0 on the next clock when it was 6\n            else\n                q <= q + 1; // Else increment q by 1\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset to non-zero state\n    end else begin\n        // Calculate feedback based on tap positions (5 and 3)\n        q[0] <= q[4] ^ q[2]; // Next state for q[0]\n        q[4:1] <= q[3:0];    // Shift the register\n    end\nend\n\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Default the result_is_zero flag\n\t\tresult_is_zero = 0;\n\t\t\n\t\t// Calculate the output based on the operation\n\t\tif (do_sub)\n\t\t\tout = a - b; // Subtract if do_sub is 1\n\t\telse\n\t\t\tout = a + b; // Add if do_sub is 0\n\n\t\t// Check if the result is zero\n\t\tif (out == 0)\n\t\t\tresult_is_zero = 1; // Set the flag if output is zero\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        f = 0; // default value\n\n        // Implement the logic based on the K-map\n        if ((x[3] == 1 && x[4] == 1) || // x[3:4] = 11 \n            (x[3] == 0 && x[4] == 1 && x[1] == 1 && x[2] == 0) || // x[3:4] = 01\n            (x[3] == 1 && x[4] == 0 && x[1] == 1 && x[2] == 0) || // x[3:4] = 10\n            (x[3] == 1 && x[4] == 1 && x[1] == 0 && x[2] == 0) || // x[3:4] = 11\n            (x[3] == 1 && x[4] == 1 && x[1] == 0 && x[2] == 1)   // x[3:4] = 00\n           ) \n        begin\n            f = 1; // if any condition matches, set f to 1\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @(*) begin\n    // Initialize outputs\n    valid = 0;  // Default is invalid\n    out = 4'b0000;  // Default output is 0\n\n    case (code)\n        8'h45: begin // Key '0'\n            valid = 1;\n            out = 4'd0;\n        end\n        8'h16: begin // Key '1'\n            valid = 1;\n            out = 4'd1;\n        end\n        8'h1e: begin // Key '2'\n            valid = 1;\n            out = 4'd2;\n        end\n        8'h26: begin // Key '3'\n            valid = 1;\n            out = 4'd3;\n        end\n        8'h25: begin // Key '4'\n            valid = 1;\n            out = 4'd4;\n        end\n        8'h2e: begin // Key '5'\n            valid = 1;\n            out = 4'd5;\n        end\n        8'h36: begin // Key '6'\n            valid = 1;\n            out = 4'd6;\n        end\n        8'h3d: begin // Key '7'\n            valid = 1;\n            out = 4'd7;\n        end\n        8'h3e: begin // Key '8'\n            valid = 1;\n            out = 4'd8;\n        end\n        8'h46: begin // Key '9'\n            valid = 1;\n            out = 4'd9;\n        end\n        default: begin // No valid key detected\n            valid = 0;\n            out = 4'b0000; // Ensures output is zero when invalid\n        end\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\n\tassign out = {in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]};\n\nendmodule\n", "result": "failed: 203 out of 218 samples.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    \n    always @* begin\n        out = (b == 0 && c == 0) || (b == 1 && c == 1) || (a == 1) || (c == 1);\n    end\nendmodule\n", "result": "failed: 59 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift left and insert data at LSB\n            q <= {q[2:0], data};\n        end else if (count_ena) begin\n            // Decrement the value\n            q <= q - 1;\n        end\n        // If both are enabled, you can define which one takes priority. \n        // Currently, shift_ena takes precedence here as it is checked first.\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\nassign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n    reg [1:0] counter; // 2-bit counter for counting 4 clock cycles\n\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 0; // Reset the counter\n            shift_ena <= 1; // Enable shift_ena\n        end else begin\n            if (counter < 3) begin\n                counter <= counter + 1; // Increment counter\n                shift_ena <= 1; // Keep shift_ena enabled\n            end else if (counter == 3) begin\n                counter <= counter + 1; // Increment to complete 4 cycles\n                shift_ena <= 0; // Disable shift_ena after 4 cycles\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset the counter to 0\n        end else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n// Continuous assignment with assign statement\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Procedural assignment with if statement\nalways @(*) begin\n    if (sel_b1 && sel_b2) \n        out_always = b;\n    else \n        out_always = a;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    assign out = (b ~^ c) | (b);\nendmodule\n", "result": "failed: 81 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\n// Synchronous state transition\nalways @(posedge clk or negedge resetn) begin\n    if (!resetn) \n        current_state <= A;  // Reset to state A\n    else \n        current_state <= next_state; // Transition to next state\nend\n\n// Combinational logic for state transitions\nalways @(*) begin\n    // Default next state\n    next_state = current_state;\n\n    case (current_state)\n        A: begin\n            if (r[1]) \n                next_state = B; // Device 1's request\n            else if (r[2]) \n                next_state = C; // Device 2's request\n            else if (r[3]) \n                next_state = D; // Device 3's request\n        end\n        \n        B: begin\n            if (!r[1]) \n                next_state = A; // Return to A if device 1's request is cleared\n            // If r[1] is still active, remain in B\n        end\n        \n        C: begin\n            if (!r[2]) \n                next_state = A; // Return to A if device 2's request is cleared\n            // If r[2] is still active, remain in C\n        end\n        \n        D: begin\n            // In state D, we only return to state A\n            next_state = A;  // No transitions from D except to A\n        end\n    endcase\nend\n\n// Grant signals logic based on current state\nalways @(*) begin\n    // Default outputs\n    g = 3'b000;\n\n    case (current_state)\n        B: g[1] = 1; // Grant for device 1\n        C: g[2] = 1; // Grant for device 2\n        D: g[3] = 1; // Grant for device 3\n        default: g = 3'b000; // No grants in state A\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000; // Reset the counter to 0 on active high reset\n    end else if (q == 4'b1001) begin\n        q <= 4'b0000; // Wrap around from 9 to 0\n    end else begin\n        q <= q + 1; // Increment the counter\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    typedef enum reg [2:0] {IDLE, RECEIVE_1, RECEIVE_2, RECEIVE_3} state_t;\n    state_t current_state, next_state;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n            if (next_state == RECEIVE_3) // Signal done when transitioning to RECEIVE_3\n                done <= 1;\n            else\n                done <= 0; // Ensure done is low otherwise\n        end\n    end\n\n    always @* begin\n        case (current_state)\n            IDLE: begin\n                if (in[3] == 1'b1) \n                    next_state = RECEIVE_1;\n                else \n                    next_state = IDLE;\n            end\n            \n            RECEIVE_1: begin\n                next_state = RECEIVE_2;\n            end\n            \n            RECEIVE_2: begin\n                next_state = RECEIVE_3;\n            end\n            \n            RECEIVE_3: begin\n                next_state = IDLE; // After receiving the third byte, go back to IDLE\n            end\n            \n            default: next_state = IDLE; // Default state to avoid latches\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\nassign out = sel ? b : a; // Use of ternary operator to select input based on sel\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    assign out_and = in[3] & in[2] & in[1] & in[0]; // 4-input AND\n    assign out_or  = in[3] | in[2] | in[1] | in[0]; // 4-input OR\n    assign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0]; // 4-input XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n\treg [2:0] y; // 3-bit state register\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\ty <= 3'b000; // Reset to state 000\n\t\tend else begin\n\t\t\tcase (y)\n\t\t\t\t3'b000: y <= (x) ? 3'b001 : 3'b000; // Stay or go to 001\n\t\t\t\t3'b001: y <= (x) ? 3'b100 : 3'b001; // Go to 100 or stay\n\t\t\t\t3'b010: y <= (x) ? 3'b001 : 3'b010; // Go to 001 or stay\n\t\t\t\t3'b011: y <= (x) ? 3'b010 : 3'b001; // Go to 010 or go to 001\n\t\t\t\t3'b100: y <= (x) ? 3'b100 : 3'b011; // Stay or go to 011\n\t\t\t\tdefault: y <= 3'b000; // Default case, shouldn't normally happen\n\t\t\tendcase\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (y)\n\t\t\t3'b000, 3'b001, 3'b010: z = 0; // Output 0 for these states\n\t\t\t3'b011, 3'b100: z = 1; // Output 1 for these states\n\t\t\tdefault: z = 0; // Default case, shouldn't normally happen\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_D1 = 3'b100,\n        STATE_D2 = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [1:0] y_counter; // Counter for y timing\n\n    // FSM state transition\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_state <= STATE_A;\n            f <= 0;\n            g <= 0;\n            y_counter <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        next_state = current_state;\n        f = 0; // default value for f\n        g = 0; // default value for g\n        case (current_state)\n            STATE_A: begin\n                if (!resetn) begin\n                    next_state = STATE_A;\n                end else begin\n                    next_state = STATE_B; // transition to B on clock edge\n                end\n            end\n            STATE_B: begin\n                f = 1; // output f high for one clock cycle\n                next_state = STATE_C; // move to state C\n            end\n            STATE_C: begin\n                if (x == 1) begin\n                    next_state = STATE_D1; // move to D1 if x is 1\n                end else begin\n                    next_state = STATE_C; // stay if x is not 1\n                end\n            end\n            STATE_D1: begin\n                if (x == 0) begin\n                    next_state = STATE_D2; // move to D2 if x is 0\n                end else begin\n                    next_state = STATE_C; // go back to C if x is not 0\n                end\n            end\n            STATE_D2: begin\n                g = 1; // g is set high\n                y_counter = 0; // reset counter\n                next_state = STATE_D; // move to D to monitor y\n            end\n            STATE_D: begin\n                if (y == 1) begin\n                    g = 1; // maintain g high\n                end else begin\n                    y_counter = y_counter + 1; // increment the counter if y is not 1\n                    if (y_counter == 2) begin\n                        g = 0; // set g to 0 if y is not 1 within 2 cycles\n                        next_state = STATE_D; // stay in D\n                    end\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    always @(negedge clk) begin\n        if (reset) begin\n            q <= 8'h34;  // Reset q to 0x34 if reset is active high\n        end else begin\n            q <= d;      // On negative edge, assign d to q\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\n// Combinational Logic for Next State\nalways @(*) begin\n    case (state)\n        2'b00: // State A\n            if (in == 0)\n                next_state = 2'b00; // Stay in A\n            else\n                next_state = 2'b01; // Go to B\n        2'b01: // State B\n            if (in == 0)\n                next_state = 2'b10; // Go to C\n            else\n                next_state = 2'b01; // Stay in B\n        2'b10: // State C\n            if (in == 0)\n                next_state = 2'b00; // Go to A\n            else\n                next_state = 2'b11; // Go to D\n        2'b11: // State D\n            if (in == 0)\n                next_state = 2'b10; // Go to C\n            else\n                next_state = 2'b01; // Go to B\n        default:\n            next_state = 2'b00; // Default case, stay in A\n    endcase\nend\n\n// Output Logic based on current state\nassign out = (state == 2'b11) ? 1 : 0; // Out is 1 only in state D\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x & y) | (~x & ~y);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n// State definitions\ntypedef enum reg [2:0] {\n    A = 3'b000,\n    B = 3'b001,\n    C = 3'b010,\n    D = 3'b011,\n    E = 3'b100,\n    F = 3'b101\n} state_t;\n\n// State variable\nreg state_t current_state, next_state;\n\n// State Flip-Flops\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= A; // reset to state A\n    end else begin\n        current_state <= next_state; // update to next state\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        A: begin\n            if (w) \n                next_state = B;\n            else \n                next_state = A;\n        end\n        B: begin\n            if (w) \n                next_state = C;\n            else \n                next_state = D;\n        end\n        C: begin\n            if (w) \n                next_state = E;\n            else \n                next_state = D;\n        end\n        D: begin\n            if (w) \n                next_state = F;\n            else \n                next_state = A;\n        end\n        E: begin\n            if (w) \n                next_state = E;\n            else \n                next_state = D;\n        end\n        F: begin\n            if (w) \n                next_state = C;\n            else \n                next_state = D;\n        end\n        default: next_state = A; // default case for safety\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        A, B, C, D, F: z = 0; // states that produce zero output\n        E: z = 1; // state E produces one output\n        default: z = 0; // default case for safety\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // reset all flip-flops to 0\n        end else begin\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8]; // update upper byte\n            end\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0]; // update lower byte\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n    reg [7:0] in_prev; // Register to hold the previous state of `in`\n\n    // Always block triggered by the clock signal\n    always @(posedge clk) begin\n        // Check for transitions and update pedge\n        pedge <= 8'b00000000; // Reset pedge on every clock cycle\n        for (int i = 0; i < 8; i = i + 1) begin\n            if (in_prev[i] == 1'b0 && in[i] == 1'b1) begin\n                pedge[i] <= 1'b1; // Set bit in pedge if transition from 0 to 1\n            end\n        end\n        in_prev <= in; // Update previous state\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\nalways @(posedge clock) begin\n    if (a) begin\n        p <= 1;\n    end else begin\n        p <= 0;\n    end\nend\n\nalways @(negedge clock) begin\n    if (a) begin\n        q <= 1;\n    end else begin\n        q <= 0;\n    end\nend\n\nendmodule\n", "result": "failed: 112 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    integer i;\n    reg [511:0] next_q; // Temporary register to hold the next state\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial state\n        end else begin\n            // Calculate the next state of each cell\n            for (i = 0; i < 512; i = i + 1) begin\n                if (i == 0)\n                    next_q[i] = 0 ^ q[i] ^ q[i+1]; // Left neighbor is 0\n                else if (i == 511)\n                    next_q[i] = q[i-1] ^ q[i] ^ 0; // Right neighbor is 0\n                else \n                    next_q[i] = q[i-1] ^ q[i] ^ q[i+1]; // Normal case\n            end\n            q <= next_q; // Update the state\n        end\n    end\nendmodule\n", "result": "failed: 7058 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n\tassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    \n    // Calculate out_both\n    genvar i;\n    generate \n        for (i = 0; i < 99; i = i + 1) begin : both_logic\n            assign out_both[i] = in[i+1] & in[i];\n        end\n    endgenerate\n    \n    // Calculate out_any\n    generate \n        for (i = 1; i < 100; i = i + 1) begin : any_logic\n            assign out_any[i] = in[i-1] | in[i];\n        end\n    endgenerate\n    \n    // Calculate out_different\n    assign out_different[0] = in[0] != in[99];\n    generate \n        for (i = 1; i < 100; i = i + 1) begin : different_logic\n            assign out_different[i] = in[i] != in[i-1];\n        end\n    endgenerate\n\nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n    \nalways @* begin\n    if (ena) \n        q = d;      // Update q with d when ena is high\n    // Else case is implicitly handled as q retains its last value\nend\n\nendmodule \n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting index for the selected input.\n    // Each input is 4 bits wide.\n    // The selected 4 bits can be found at index sel * 4.\n    assign out = in[sel * 4 +: 4]; // Use the concatenation operator to select 4 bits starting from `sel * 4`.\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n    always_comb begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // when sel is 9 to 15\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n    \n    // Logical OR of a and b\n    assign out_or_logical = |a | |b;\n    \n    // Inverse of b (upper half) and inverse of a (lower half)\n    assign out_not = {~b, ~a};\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n    // Default next state to 0\n    next_state = 4'b0000;  \n    \n    // Next state logic\n    next_state[0] = state[0] & ~in | state[2] & in; // A state conditions\n    next_state[1] = state[0] & in | state[1];      // B state conditions\n    next_state[2] = state[1] & ~in | state[3] & in; // C state conditions\n    next_state[3] = state[2] & in | state[3] & ~in; // D state conditions\nend\n\n// Output logic\nassign out = state[3];  // Output is 1 only when in state D\n\nendmodule\n", "result": "failed: 453 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @* begin\n    // Compare a and b to find the minimum\n    if (a < b) \n        min = a;\n    else \n        min = b;\n\n    // Compare with c to find the minimum\n    if (c < min) \n        min = c;\n\n    // Compare with d to find the minimum\n    if (d < min) \n        min = d;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n    assign out_and = a & b;          // AND operation\n    assign out_or = a | b;           // OR operation\n    assign out_xor = a ^ b;          // XOR operation\n    assign out_nand = ~(a & b);      // NAND operation\n    assign out_nor = ~(a | b);       // NOR operation\n    assign out_xnor = ~(a ^ b);      // XNOR operation\n    assign out_anotb = a & ~b;       // AND NOT operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n    assign out = (~c & ~d) | (~c & d) | (b & d) | (a & b);\n\nendmodule\n", "result": "failed: 114 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n    // State declaration\n    typedef enum reg [1:0] {A, B} state_t;\n    state_t state, next_state;\n    reg [1:0] count; // Count for the number of times w = 1\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A; // Reset to state A\n            count <= 0;\n            z <= 0; // Output z is 0 on reset\n        end else begin\n            state <= next_state; // State transitions\n        end\n    end\n\n    always @* begin\n        // Default values\n        next_state = state;\n        z = 0;\n\n        case (state)\n            A: begin\n                // Stay in state A if s = 0, go to state B if s = 1\n                if (s) begin\n                    next_state = B;\n                    count = 0; // Reset count when moving to state B\n                end\n            end\n            \n            B: begin\n                // Count the input w over three cycles\n                if (count < 2'b11) begin // Count should go from 0 to 3\n                    if (w) begin\n                        count = count + 1; // Increment count if w = 1\n                    end \n                    // When count reaches 3, check the counting outcome\n                    if (count == 3) begin\n                        if (count == 2) begin\n                            z = 1; // Set output z if exactly 2 are 1\n                        end\n                        next_state = B; // Stay in B after checking\n                        count = 0; // Reset count after checking\n                    end  \n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 174 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\n    assign out = { {24{in[7]}}, in }; // Replicate the sign bit 24 times and concatenate with the 8-bit input\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n\treg [3:0] shift_reg;  // 4-bit shift register\n\n\talways @(posedge clk) begin\n\t\tif (!resetn) begin\n\t\t\tshift_reg <= 4'b0000;  // Reset to 0 when resetn is low\n\t\tend else begin \n\t\t\tshift_reg <= {shift_reg[2:0], in};  // Shift left and input in the last bit\n\t\tend\n\tend\n\n\tassign out = shift_reg[3];  // Output of the last flip-flop\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n    \n    always @(*) begin\n        case (in)\n            4'b1000: pos = 2'd3; // in[3] is high\n            4'b0100: pos = 2'd2; // in[2] is high\n            4'b0010: pos = 2'd1; // in[1] is high\n            4'b0001: pos = 2'd0; // in[0] is high\n            default: pos = 2'd0; // none are high\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 20 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State encoding\n    parameter OFF = 1'b0;\n    parameter ON = 1'b1;\n    \n    // Current and next state registers\n    reg state, next_state;\n    \n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF; // Reset to OFF state\n        end else begin\n            state <= next_state; // Update state on clock edge\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j == 1'b1) next_state = ON; // Transition to ON\n                else next_state = OFF; // Stay in OFF\n            end\n            ON: begin\n                if (k == 1'b1) next_state = OFF; // Transition to OFF\n                else next_state = ON; // Stay in ON\n            end\n            default: next_state = OFF; // Default case, should not reach here\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0; // Output is 0 when in OFF state\n            ON: out = 1'b1; // Output is 1 when in ON state\n            default: out = 1'b0; // Default case, should not reach here\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n    assign out = 1'b0; // Assign the output to logic low (0)\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n    assign one = 1; // Always drive output to logic high\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\talways @(*) begin\n\t\tout = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], \n\t\t        in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], \n\t\t        in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], \n\t\t        in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], \n\t\t        in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], \n\t\t        in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], \n\t\t        in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], \n\t\t        in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], \n\t\t        in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], \n\t\t        in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], \n\t\t        in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], \n\t\t        in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], \n\t\t        in[98], in[99]};\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    logic xor_result; // Intermediate signal for XOR operation\n\n    // Always block for positive edge-triggered behavior of the flip-flop\n    always_ff @(posedge clk) begin\n        xor_result = in ^ out; // Compute XOR between input and current output\n        out <= xor_result;     // Update flip-flop output\n    end\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset the register to zero\n        end else if (load) begin\n            q <= data; // Load data into the register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right, new bit on left is 0\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    assign f = (x2 & ~x3) | (x3 & x1);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0; // Asynchronous reset sets output to 0\n        end else begin\n            q <= d; // On positive edge of clk, assign d to q\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    assign out_and = &in; // AND operation\n    assign out_or = |in;  // OR operation\n    assign out_xor = ^in; // XOR operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n    // Logic for sum and carry-out\n    assign sum = a ^ b;  // XOR operation for sum\n    assign cout = a & b; // AND operation for carry-out\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;  // Ensure the output is set\n        else\n            shut_off_computer = 1'b0;   // Explicitly reset to avoid latches\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty; // Keep driving based on gas tank\n        else\n            keep_driving = 1'b0; // Set to 0 if arrived to avoid latches\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t\n\t// State encoding\n\ttypedef enum reg [1:0] {\n\t\tOFF = 1'b0,\n\t\tON = 1'b1\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// Synchronous reset and state transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= OFF;\n\t\t\tout <= 0;  // Reset to OFF state\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tout <= current_state; // Output depends on current state\n\t\tend\n\tend\n\t\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tOFF: begin\n\t\t\t\tif (j == 1) begin\n\t\t\t\t\tnext_state = ON;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = OFF;\n\t\t\t\tend\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k == 1) begin\n\t\t\t\t\tnext_state = OFF;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = ON;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = OFF; // Default case to avoid latches\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    wire [29:0] temp; // Temporary storage for concatenated inputs\n    wire [31:0] final_output; // Final output which includes the extra bits\n\n    // Concatenate input vectors\n    assign temp = {a, b, c, d, e, f}; \n\n    // Concatenate the two '1' bits to temp to create a 32-bit signal\n    assign final_output = {temp, 1'b1, 1'b1};\n\n    // Split the 32-bit signal into four 8-bit outputs\n    assign w = final_output[31:24];\n    assign x = final_output[23:16];\n    assign y = final_output[15:8];\n    assign z = final_output[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Implementing the logic based on the identified combinations\n    assign q = (a == 0 && b == 0 && c == 0 && d == 0) || // 0 0 0 0\n               (a == 0 && b == 0 && c == 1 && d == 1) || // 0 0 1 1\n               (a == 1 && b == 0 && c == 0 && d == 1) || // 1 0 0 1\n               (a == 1 && b == 0 && c == 1 && d == 0) || // 1 0 1 0\n               (a == 1 && b == 1 && c == 1 && d == 1);   // 1 1 1 1\n\nendmodule\n", "result": "failed: 25 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a & b; // Implementing the AND operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // State encoding\n    typedef enum reg [1:0] {\n        B = 1'b0,  // State B\n        A = 1'b1   // State A\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Synchronous reset and state transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= B;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        case (current_state)\n            B: begin\n                if (in) begin\n                    next_state = B; // Stay in B\n                end else begin\n                    next_state = A; // Transition to A\n                end\n                out = 1; // Output for state B\n            end\n            A: begin\n                if (in) begin\n                    next_state = A; // Stay in A\n                end else begin\n                    next_state = B; // Transition to B\n                end\n                out = 0; // Output for state A\n            end\n            default: begin\n                next_state = B; // Default state\n                out = 1; // Default output\n            end\n        endcase\n    end\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\n  // Calculate sum\n  assign sum = a ^ b ^ cin;\n  \n  // Calculate carry out\n  assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n    logic xnor_out;  // Intermediate signal to hold the result of XNOR\n\n    // XNOR operation\n    xnor(xnor_out, in1, in2);\n    \n    // XOR operation\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    wire d_inv; // A wire for the NOT operation on d\n\n    // Invert d for selection\n    not(d_inv, d);\n\n    // Assign values to mux_in\n    assign mux_in[0] = 0; // ab = 00\n    assign mux_in[1] = 1; // ab = 01\n    assign mux_in[2] = (c) ? 1 : 0; // ab = 10 where c determines the output\n    assign mux_in[3] = (d) ? 1 : 0; // ab = 11, this can also be based on c or d\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // State Declaration\n    reg [1:0] state;    // using 2 bits for one-hot encoding\n    parameter A = 2'b01; // State A\n    parameter B = 2'b10; // State B\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A; // Reset to state A\n        end else begin\n            case (state)\n                A: begin\n                    if (x) begin\n                        state <= B; // Transition to B on x = 1\n                    end\n                    z <= x; // z = 1 if x = 1, else z = 0 (x = 0)\n                end\n                \n                B: begin\n                    z <= ~x; // If in B, z = 1 if x = 0, else z = 0\n                    // Stay in B regardless of x\n                end\n                \n                default: state <= A; // Default case to ensure safe state\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        // Flip-Flop Logic\n        if (a && !b) begin\n            q <= 1;\n        end\n        else if (!a && b) begin\n            q <= 0;\n        end\n        else begin\n            q <= q;  // maintain the current state\n        end\n    end\n\n    always @(posedge clk) begin\n        // Update state based on q, a, and b\n        if (q) begin\n            state <= a || b; // state is active if either a or b is high when q is high\n        end else begin\n            state <= 0; // if q is low, state is reset\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // Implementing the boolean function based on identified minterms\n    always_comb begin\n        f = (x[1] == 1'b0 && x[3] == 1'b0 && x[2] == 1'b0 && x[4] == 1'b0) || // m0\n            (x[1] == 1'b1 && x[3] == 1'b0 && x[2] == 1'b0 && x[4] == 1'b1) || // m2\n            (x[1] == 1'b1 && x[3] == 1'b1 && x[2] == 1'b0 && x[4] == 1'b0) || // m8\n            (x[1] == 1'b1 && x[3] == 1'b1 && x[2] == 1'b1 && x[4] == 1'b0) || // m10\n            (x[1] == 1'b0 && x[3] == 1'b1 && x[2] == 1'b1 && x[4] == 1'b0);   // m12\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum reg [2:0] {\n\t\tS0 = 3'b000,\n\t\tS1 = 3'b001,\n\t\tS2 = 3'b010,\n\t\tS3 = 3'b011,\n\t\tS4 = 3'b100,\n\t\tS5 = 3'b101,\n\t\tS6 = 3'b110,\n\t\tS7 = 3'b111\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// Sequential logic for state transition\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= S0;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Combinational logic for next state and outputs\n\talways @(*) begin\n\t\t// Default outputs\n\t\tdisc = 0;\n\t\tflag = 0;\n\t\terr = 0;\n\t\t\n\t\tcase (current_state)\n\t\t\tS0: begin\n\t\t\t\tif (in) next_state = S1;\n\t\t\t\telse next_state = S0;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (in) next_state = S2;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (in) next_state = S3;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS3: begin\n\t\t\t\tif (in) next_state = S4;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS4: begin\n\t\t\t\tif (in) next_state = S5;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS5: begin\n\t\t\t\tif (in) next_state = S6;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS6: begin\n\t\t\t\tdisc = 1; // Need to discard\n\t\t\t\tif (in) next_state = S7;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tS7: begin\n\t\t\t\terr = 1; // Error state due to 7+ 1s\n\t\t\t\tif (in) next_state = S7;\n\t\t\t\telse next_state = S0; // Reset on 0\n\t\t\tend\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE,\n        SEARCH1,\n        SEARCH2,\n        SEARCH3,\n        SEARCH4,\n        COUNT,\n        DONE\n    } state_t;\n\n    state_t current_state, next_state;\n\n    reg [3:0] delay;\n    reg [21:0] counter; // Enough bits to count (delay + 1) * 1000\n    reg [3:0] remaining;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            counter <= 0;\n        end else begin\n            current_state <= next_state;\n\n            // Reset done signal when moving to a new state\n            if (next_state != DONE) begin\n                done <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n\n        case (current_state)\n            IDLE: begin\n                if (data == 1) next_state = SEARCH1;\n            end\n            SEARCH1: begin\n                if (data == 1) next_state = SEARCH2;\n                else next_state = IDLE; // Reset if incorrect input\n            end\n            SEARCH2: begin\n                if (data == 0) next_state = SEARCH3;\n                else next_state = IDLE; // Reset if incorrect input\n            end\n            SEARCH3: begin\n                if (data == 1) next_state = SEARCH4;\n                else next_state = IDLE; // Reset if incorrect input\n            end\n            SEARCH4: begin\n                if (data == 0) begin\n                    next_state = COUNT;\n                    delay <= {data, data, data, data}; // Collect delay bits here\n                end else begin\n                    next_state = IDLE; // Reset if incorrect input\n                end\n            end\n            COUNT: begin\n                if (counter == 0) next_state = DONE;\n                else next_state = COUNT; // Continue counting\n            end\n            DONE: begin\n                if (ack) begin\n                    next_state = IDLE; // Wait for ack to reset\n                end\n            end\n        endcase\n    end\n\n    // Counting logic\n    always @(posedge clk) begin\n        if (current_state == COUNT) begin\n            if (counter < (delay + 1) * 1000) begin\n                counter <= counter + 1;\n                counting <= 1;\n                remaining <= (delay - counter / 1000); // Update remaining time\n            end else begin\n                counter <= 0;\n                counting <= 0;\n            end\n        end else begin\n            counter <= 0; // Clear counter if not in counting state\n            counting <= 0;\n        end\n    end\n    \n    assign count = (current_state == COUNT) ? remaining : 4'bxxxx; // Don't care when not counting\n\nendmodule\n", "result": "failed: 234332 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Active-high synchronous reset\n\t\tfr3 <= 1'b1;  // below s1 implies maximum flow\n\t\tfr2 <= 1'b1;\n\t\tfr1 <= 1'b1;\n\t\tdfr <= 1'b1;  // Supplemental flow valve open\n\tend else begin\n\t\t// Default all outputs to 0\n\t\tfr3 <= 1'b0;\n\t\tfr2 <= 1'b0;\n\t\tfr1 <= 1'b0;\n\t\tdfr <= 1'b0;\n\n\t\t// Determine output based on sensor states\n\t\tif (s[3]) begin\n\t\t\t// Above s[3]\n\t\t\t// No flow, all outputs are low (already initialized)\n\t\tend else if (s[2]) begin\n\t\t\t// Between s[3] and s[2]\n\t\t\tfr1 <= 1'b1; // Activate fr1\n\t\tend else if (s[1]) begin\n\t\t\t// Between s[2] and s[1]\n\t\t\tfr1 <= 1'b1; // Activate fr1\n\t\t\tfr2 <= 1'b1; // Activate fr2\n\t\tend else begin\n\t\t\t// Below s[1]\n\t\t\tfr1 <= 1'b1; // Activate fr1\n\t\t\tfr2 <= 1'b1; // Activate fr2\n\t\t\tfr3 <= 1'b1; // Activate fr3\n\t\t\tdfr <= 1'b1; // Supplemental flow valve open\n\t\tend\n\tend\nend\n\nendmodule\n", "result": "failed: 605 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\ttypedef enum reg [2:0] {\n\t\tIDLE,\n\t\tSTART,\n\t\tDATA,\n\t\tSTOP_CHECK,\n\t\tERROR\n\t} state_t;\n\n\tstate_t state, next_state;\n\treg [3:0] bit_count; // To count data bits received\n\t\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tdone = 0;\n\t\t\t\tif (in == 0) // Start bit detected\n\t\t\t\t\tnext_state = START;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA; // Move to data state\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 8) // Finished receiving data bits\n\t\t\t\t\tnext_state = STOP_CHECK;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DATA; // Stay in data state\n\t\t\tend\n\t\t\tSTOP_CHECK: begin\n\t\t\t\tif (in == 1) begin // Stop bit detected\n\t\t\t\t\tdone = 1; // Byte correctly received\n\t\t\t\t\tnext_state = IDLE; // Return to IDLE\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STOP_CHECK; // Wait for stop bit\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = IDLE; // Reset state on unexpected condition\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// State update logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbit_count <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tcase (state)\n\t\t\t\tIDLE: bit_count <= 0; // Reset count in IDLE\n\t\t\t\tSTART: begin\n\t\t\t\t\t// Do nothing, just transitioned from IDLE to DATA\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tbit_count <= bit_count + 1; // Increment bit count\n\t\t\t\tend\n\t\t\t\tSTOP_CHECK: begin\n\t\t\t\t\t// Do nothing on stop check\n\t\t\t\tend\n\t\t\t\tdefault: begin\n\t\t\t\t\t// Unknown state handler\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    reg [3:0] state;\n    reg [3:0] next_state;\n    reg [2:0] bit_count;\n    \n    // Define states\n    parameter IDLE = 4'b0000, \n              START_BIT = 4'b0001, \n              DATA_BITS = 4'b0010, \n              STOP_BIT = 4'b0011, \n              DONE = 4'b0100;\n\n    // State transition logic\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'b0;\n            done <= 1'b0;\n            bit_count <= 3'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (state)\n            IDLE: begin\n                done = 1'b0;\n                if (in == 1'b0) // when we detect a start bit\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            end\n\n            START_BIT: begin\n                if (in == 1'b0) // stay in start bit until we detect the first 0\n                    next_state = DATA_BITS;\n                else\n                    next_state = IDLE;\n            end\n\n            DATA_BITS: begin\n                if (bit_count < 3'd7) // continue receiving data bits\n                    next_state = DATA_BITS;\n                else\n                    next_state = STOP_BIT;\n            end\n            \n            STOP_BIT: begin\n                if (in == 1'b1) begin // if stop bit is received\n                    done = 1'b1;\n                    next_state = DONE;\n                end else\n                    next_state = IDLE; // wait until we find a valid stop bit\n            end\n            \n            DONE: begin\n                done = 1'b1;\n                next_state = IDLE; // go back to IDLE after done output\n            end\n\n            default: next_state = IDLE; // default state\n        endcase\n    end\n\n    // Data capture logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            bit_count <= 3'b0;\n            out_byte <= 8'b0;\n        end else begin\n            case (state)\n                START_BIT: begin\n                    // Reset bit count on start bit\n                    bit_count <= 3'b0;\n                end\n                \n                DATA_BITS: begin\n                    out_byte[bit_count] <= in; // capture the bit\n                    bit_count <= bit_count + 1'b1; // increment bit_count\n                end\n                \n                STOP_BIT: begin\n                    // In STOP_BIT state, don't capture anything\n                end\n                \n                DONE: begin\n                    // In DONE state, out_byte is valid\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    reg [1:0] PHT [127:0];  // 128 entries, 2 bits each for saturating counters\n    reg [6:0] global_history; // 7-bit global history register\n\n    wire [6:0] index;\n    assign index = predict_pc ^ global_history; // Create XOR hashed index for PHT\n\n    // Initialize the saturating counters to weakly not taken (00)\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b00; // Reset all counters to 00\n            end\n            global_history <= 7'b0000000; // Reset global history\n            predict_taken <= 0;\n            predict_history <= 0;\n        end \n        else begin\n            // Prediction Logic\n            if (predict_valid) begin\n                // Predict the outcome based on the PHT entry\n                predict_taken <= (PHT[index] >= 2'b10);  // Predict taken if counter is 2 or 3\n                predict_history <= global_history; // output the current global history\n            end\n            \n            // Training Logic\n            if (train_valid) begin\n                // Update the PHT based on the training outcome\n                if (train_mispredicted) begin\n                    // Restore the global history to the given state\n                    global_history <= train_history; \n                end\n                \n                // Update the PHT entry for the current PC\n                if (train_taken) begin\n                    if (PHT[train_pc ^ train_history] < 2'b11) begin\n                        PHT[train_pc ^ train_history] <= PHT[train_pc ^ train_history] + 1; // Increment counter\n                    end\n                end else begin\n                    if (PHT[train_pc ^ train_history] > 2'b00) begin\n                        PHT[train_pc ^ train_history] <= PHT[train_pc ^ train_history] - 1; // Decrement counter\n                    end\n                end\n                \n                // Update the global history for the training\n                global_history <= {global_history[5:0], train_taken}; // Shift in the new observation\n            end\n            \n            // Predict Taken - handle after any training on the next clock\n            if (predict_valid && !train_valid) begin\n                // Prediction State stays unchanged until the next clock\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n// State Parameters\nparameter [1:0] \n    WALK_LEFT = 2'b00,\n    WALK_RIGHT = 2'b01,\n    FALLING = 2'b10,\n    DIGGING = 2'b11,\n    SPLATTERED = 2'b12;\n\n// State Variables\nreg [1:0] current_state, next_state;\nreg [4:0] fall_counter; // Counter for fall duration\n\n// Sequential Logic for State Transition and Fall Counter\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= WALK_LEFT; // Reset state to walk left\n        fall_counter <= 0; // Reset fall counter\n    end else begin\n        current_state <= next_state;\n\n        if (current_state == FALLING) begin\n            fall_counter <= fall_counter + 1; // Increment fall duration\n        end else if (ground) begin\n            fall_counter <= 0; // Reset counter on solid ground\n        end\n    end\nend\n\n// Combinational Logic for Next State and Outputs\nalways @(*) begin\n    // Default outputs\n    walk_left = 0;\n    walk_right = 0;\n    aaah = 0;\n    digging = 0;\n\n    // Determine next state and outputs based on current state and inputs\n    case (current_state)\n        WALK_LEFT: begin\n            if (!ground) begin\n                next_state = FALLING;\n                aaah = 1; // falling sound\n            end else if (dig) begin\n                next_state = DIGGING;\n                digging = 1; // Start digging\n            end else if (bump_right) begin\n                next_state = WALK_RIGHT;\n                walk_right = 1; // Change direction\n            end else begin\n                next_state = WALK_LEFT;\n                walk_left = 1; // Continue walking left\n            end\n        end\n\n        WALK_RIGHT: begin\n            if (!ground) begin\n                next_state = FALLING;\n                aaah = 1; // falling sound\n            end else if (dig) begin\n                next_state = DIGGING;\n                digging = 1; // Start digging\n            end else if (bump_left) begin\n                next_state = WALK_LEFT;\n                walk_left = 1; // Change direction\n            end else begin\n                next_state = WALK_RIGHT;\n                walk_right = 1; // Continue walking right\n            end\n        end\n\n        FALLING: begin\n            aaah = 1; // Falling sound\n            if (ground) begin\n                if (fall_counter > 20) begin\n                    next_state = SPLATTERED; // Splatter when falling too long\n                end else begin\n                    // Resume previous direction with no output for direction\n                    if (current_state == WALK_LEFT) begin\n                        next_state = WALK_LEFT;\n                        walk_left = 1; // Resuming left walk\n                    end else begin\n                        next_state = WALK_RIGHT;\n                        walk_right = 1; // Resuming right walk\n                    end\n                end\n            end else begin\n                next_state = FALLING; // Continue falling\n            end\n        end\n\n        DIGGING: begin\n            digging = 1; // Continue digging\n            if (!ground) begin\n                next_state = FALLING; // Start falling if ground is gone\n                aaah = 1; // falling sound\n            end else begin\n                next_state = DIGGING; // Continue digging\n            end\n        end\n\n        SPLATTERED: begin\n            // All outputs are already zero by default\n            next_state = SPLATTERED; // Stay in splattered state\n        end\n\n        default: begin\n            next_state = WALK_LEFT; // Default to walking left\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE,\n        SHIFT,\n        COUNT,\n        DONE,\n        ACK\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] shift_count;  // To count the shift enable pulses\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            shift_count <= 0;\n        end else begin\n            current_state <= next_state;\n            // Manage shift_ena and counting signals\n            case (next_state)\n                SHIFT: begin\n                    if (shift_count < 4) begin\n                        shift_ena <= 1;\n                        shift_count <= shift_count + 1;\n                    end else begin\n                        shift_ena <= 0;\n                    end\n                end\n                COUNT: begin\n                    counting <= 1;\n                end\n                DONE: begin\n                    done <= 1;\n                    counting <= 0;\n                end\n                ACK: begin\n                    done <= 0;  // Clear done once acknowledged\n                end\n                default: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    always @* begin\n        // Default next state\n        next_state = current_state;\n        shift_count = shift_count;\n\n        case (current_state)\n            IDLE: begin\n                if (data == 1 && shift_count == 0) begin\n                    shift_count = 1; // Start recognizing the pattern 1101\n                    next_state = SHIFT;\n                end\n            end\n            SHIFT: begin\n                if (shift_count < 4) begin\n                    next_state = SHIFT;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            COUNT: begin\n                if (done_counting) begin\n                    next_state = DONE;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            DONE: begin\n                if (ack) begin\n                    next_state = ACK;\n                end else begin\n                    next_state = DONE;\n                end\n            end\n            ACK: begin\n                next_state = IDLE; // Move back to idle after Acknowledgment\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 4430 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the initial state\n            q <= data;\n        end else begin\n            reg [255:0] next_q;\n\n            // Calculate the next state\n            for (int row = 0; row < 16; row++) begin\n                for (int col = 0; col < 16; col++) begin\n                    // Calculate the index in the 256-bit vector\n                    int idx = row * 16 + col;\n\n                    // Count alive neighbors\n                    int count = 0;\n                    for (int r_offset = -1; r_offset <= 1; r_offset++) begin\n                        for (int c_offset = -1; c_offset <= 1; c_offset++) begin\n                            if (r_offset == 0 && c_offset == 0) begin\n                                continue; // Skip the cell itself\n                            end\n                            // Calculate wrapped indices\n                            int neighbor_row = (row + r_offset + 16) % 16;\n                            int neighbor_col = (col + c_offset + 16) % 16;\n                            int neighbor_idx = neighbor_row * 16 + neighbor_col;\n\n                            // Count neighbor if it's alive\n                            count = count + q[neighbor_idx];\n                        end\n                    end\n\n                    // Apply the rules to determine the next state\n                    next_q[idx] = (q[idx] == 1 && count == 2) || count == 3;\n                end\n            end\n            \n            // Update the state\n            q <= next_q;\n        end\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // State encoding\n    typedef enum {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALL,\n        DIGGING\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT; // Reset to walking left\n        end else begin\n            current_state <= next_state; // Transition to next state\n        end\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default assignments\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALL; // Transition to falling if no ground\n                end else if (bump_right) begin\n                    walk_right = 1;\n                    next_state = WALK_RIGHT; // Switch to walking right\n                end else if (dig) begin\n                    digging = 1;\n                    next_state = DIGGING; // Begin digging\n                end else begin\n                    walk_left = 1; // Stay walking left\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALL; // Transition to falling if no ground\n                end else if (bump_left) begin\n                    walk_left = 1;\n                    next_state = WALK_LEFT; // Switch to walking left\n                end else if (dig) begin\n                    digging = 1;\n                    next_state = DIGGING; // Begin digging\n                end else begin\n                    walk_right = 1; // Stay walking right\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            FALL: begin\n                aaah = 1; // Indicates falling\n                if (ground) begin\n                    // Return to walking based on last direction (implicitly remembered)\n                    next_state = (current_state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALL; // Stay falling\n                end\n            end\n\n            DIGGING: begin\n                digging = 1; // Indicates digging\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALL; // Transition to falling if no ground\n                end else begin\n                    next_state = DIGGING; // Stay digging until ground goes away\n                end\n            end\n\n            default: next_state = WALK_LEFT; // Default state\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    // States to track time in BCD\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'b00001100; // 12 in BCD\n            mm <= 8'b00000000; // 0 in BCD\n            ss <= 8'b00000000; // 0 in BCD\n            pm <= 1'b0; // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b00111001) begin // 59 in BCD\n                ss <= 8'b00000000; // Reset seconds\n                // Increment minutes\n                if (mm == 8'b00111001) begin // 59 in BCD\n                    mm <= 8'b00000000; // Reset minutes\n                    // Increment hours\n                    if (hh == 8'b00001100) begin // 12 in BCD\n                        hh <= 8'b00000001; // Reset to 1\n                        pm <= ~pm; // Toggle AM/PM\n                    end else begin\n                        hh <= hh + 1; // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 1; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 1; // Increment seconds\n            end\n        end\n    end\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n// Define states\nparameter WALK_LEFT = 2'd0;\nparameter WALK_RIGHT = 2'd1;\nparameter FALLING = 2'd2;\n\n// Current state and next state\nreg [1:0] current_state, next_state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n        current_state <= WALK_LEFT; // Reset to walking left\n    else \n        current_state <= next_state; // Keep next state\nend\n\nalways @(*) begin\n    // Default outputs\n    walk_left = 0;\n    walk_right = 0;\n    aaah = 0;\n\n    case (current_state)\n        WALK_LEFT: begin\n            if (!ground) begin\n                next_state = FALLING; // Transition to falling\n                aaah = 1; // Say \"aaah!\"\n            end else if (bump_right) begin\n                next_state = WALK_RIGHT; // Switch direction\n            end else begin\n                next_state = WALK_LEFT; // Remain in same state\n                walk_left = 1; // Walking left\n            end\n        end\n        \n        WALK_RIGHT: begin\n            if (!ground) begin\n                next_state = FALLING; // Transition to falling\n                aaah = 1; // Say \"aaah!\"\n            end else if (bump_left) begin\n                next_state = WALK_LEFT; // Switch direction\n            end else begin\n                next_state = WALK_RIGHT; // Remain in same state\n                walk_right = 1; // Walking right\n            end\n        end\n        \n        FALLING: begin\n            if (ground) begin\n                if (walk_left) \n                    next_state = WALK_LEFT; // Resume walking left\n                else if (walk_right) \n                    next_state = WALK_RIGHT; // Resume walking right\n            end else begin\n                next_state = FALLING; // Remain in same falling state\n            end\n            aaah = 1; // Still falling, say \"aaah!\"\n        end\n        \n        default: next_state = WALK_LEFT; // In case of any invalid state, walk left\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    // Declare the BCD digit signals\n    reg [3:0] ones = 0;\n    reg [3:0] tens = 0;\n    reg [3:0] hundreds = 0;\n    reg [3:0] thousands = 0;\n\n    // Enable signals for the tens, hundreds, and thousands digits\n    assign ena[1] = (ones == 4'd9);\n    assign ena[2] = (tens == 4'd9) && ena[1]; // Only enabled if tens should increment\n    assign ena[3] = (hundreds == 4'd9) && ena[2]; // Only enabled if hundreds should increment\n\n    // Sequential block for counting with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            ones <= 0;\n            tens <= 0;\n            hundreds <= 0;\n            thousands <= 0;\n        end else begin\n            // Increment ones digit\n            if (ones == 4'd9) begin\n                ones <= 0; // Reset ones\n                if (tens < 4'd9) begin\n                    tens <= tens + 1; // Increment tens\n                end else begin\n                    tens <= 0; // Reset tens if it exceeds 9\n                    if (hundreds < 4'd9) begin\n                        hundreds <= hundreds + 1; // Increment hundreds\n                    end else begin\n                        hundreds <= 0; // Reset hundreds if it exceeds 9\n                        if (thousands < 4'd9) begin\n                            thousands <= thousands + 1; // Increment thousands\n                        end else begin\n                            thousands <= 0; // Reset thousands if it exceeds 9\n                        end\n                    end\n                end\n            end else begin\n                ones <= ones + 1; // Increment ones\n            end\n        end\n    end\n\n    // Updating the output register with the current count values\n    always @(posedge clk) begin\n        q <= {thousands, hundreds, tens, ones}; // Concatenate to form the full count value\n    end\n\nendmodule\n", "result": "failed: 39776 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\nassign out = (sel == 0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n    always @(*) begin\n        case (y)\n            3'b000: Y2 = 0; // State A\n            3'b001: Y2 = 0; // State B\n            3'b010: Y2 = (w == 0) ? 1 : 0; // State C\n            3'b011: Y2 = (w == 0) ? 1 : 0; // State D\n            3'b100: Y2 = 1; // State E\n            3'b101: Y2 = 0; // State F\n            default: Y2 = 0; // Default case\n        endcase\n    end\nendmodule\n", "result": "failed: 48 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\nalways @(*) begin\n    // Default output states\n    ringer = 0;\n    motor = 0;\n\n    // Only act on ring signal\n    if (ring) begin\n        if (vibrate_mode) begin\n            motor = 1;  // Turn on motor when in vibrate mode\n        end else begin\n            ringer = 1; // Turn on ringer otherwise\n        end\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Continuous assignment for AND operation\nassign out_assign = a & b;\n\n// Combinational always block for AND operation\nalways @(*) begin\n    out_alwaysblock = a & b;  // Update the output based on inputs a and b\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\n    assign zero = 1'b0; // Setting the output zero to a constant LOW\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (a == 0)\n            q <= 1;\n        else if (a == 1)\n            q <= 0;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // States\n    typedef enum reg [1:0] {\n        IDLE,\n        INVERT,\n        ADD_ONE,\n        OUTPUT\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [31:0] data;  // assuming a maximum of 32 bits for the input number\n    reg [5:0] bit_count; // count for the number of bits processed\n    reg carry;          // carry for addition\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= IDLE;\n            data <= 0;\n            bit_count <= 0;\n            carry <= 1'b0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default outputs and next state\n        next_state = current_state;\n        z = 0;  // Default output\n\n        case (current_state)\n            IDLE: begin\n                if (!areset) begin\n                    next_state = INVERT;\n                    bit_count = 0;\n                end\n            end\n\n            INVERT: begin\n                // Invert the bit\n                data[bit_count] = ~x;\n                bit_count = bit_count + 1;\n\n                if (bit_count == 31) begin // Assuming maximum 32 bits\n                    next_state = ADD_ONE;\n                end\n            end\n\n            ADD_ONE: begin\n                // Add 1 to the least significant bit of inverted data\n                carry = 1'b1; // Start carry for addition\n                for (int i = 0; i < 32; i++) begin\n                    if (carry) begin\n                        {carry, data[i]} = data[i] + 1;\n                        carry = (data[i] == 0) ? 1'b1 : 1'b0; // Check if overflow occurred\n                    end\n                end\n                next_state = OUTPUT;\n            end\n\n            OUTPUT: begin\n                z = data[0]; // The output z is the least significant bit of the 2's complement.\n                if (areset) begin\n                    next_state = IDLE; // Go back to IDLE state when reset is asserted\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default case\n        endcase\n    end\n\n    // State Register with Asynchronous Reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= A;\n        else \n            current_state <= next_state;\n    end\n\n    // Output Logic\n    assign out = (current_state == D) ? 1 : 0;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\n    assign out[31:24] = in[07:00]; // 1st byte becomes 4th\n    assign out[23:16] = in[15:08]; // 2nd byte stays 2nd\n    assign out[15:08] = in[23:16]; // 3rd byte becomes 2nd\n    assign out[07:00] = in[31:24]; // 4th byte becomes 1st\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n\talways_ff @(posedge clk) begin\n\t\tif (r) begin\n\t\t\tq <= 0;  // Reset q to 0 when r is high\n\t\tend else begin\n\t\t\tq <= d;  // Capture the value of d\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    \n\tassign z = (x ^ y) & x; // Calculate z based on the given boolean function \n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data; // Load data into the shift register\n\t\tend else if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[62:0], 1'b0};           // Shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'b00000000};    // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {q[63], q[63:1]};          // Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {q[63], q[63:8]};          // Arithmetic shift right by 8 bits\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 1164 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // Define states using parameters\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // Seen '1'\n        S2 = 2'b10  // Seen '10'\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Always block for state transition\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) begin\n            current_state <= S0; // Reset to initial state\n            z <= 1'b0;           // Assert output z to 0\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Always block for next state logic and output\n    always @(*) begin\n        // Default values\n        next_state = current_state; // Hold current state by default\n        z = 1'b0;                   // Default output is 0\n\n        case (current_state)\n            S0: begin\n                if (x) begin\n                    next_state = S1; // If x is 1, go to S1\n                end\n            end\n            \n            S1: begin\n                if (!x) begin\n                    next_state = S2; // If x is 0, go to S2\n                end\n                // If x is 1, stay in S1 (potential for new '1' sequence)\n            end\n            \n            S2: begin\n                if (x) begin\n                    z = 1'b1; // Output z = 1 when we see '1' after '10'\n                    next_state = S1; // Go to S1 (potential for overlapping sequence)\n                end else begin\n                    next_state = S0; // If x is 0, reset to S0\n                end\n            end\n            \n            default: begin\n                next_state = S0; // Default to initial state\n            end\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    parameter A = 3'b000;\n    parameter B = 3'b001;\n    parameter C = 3'b010;\n    parameter D = 3'b011;\n    parameter E = 3'b100;\n    parameter F = 3'b101;\n\n    reg [2:0] state, next_state;\n\n    // Sequential block for state transitions\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            state <= A;  // Start at state A on reset\n        else \n            state <= next_state; // Transition to next state\n    end\n\n    // Combinational block for determining the next state\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w == 0) \n                    next_state = B;\n                else \n                    next_state = A;\n            end\n            B: begin\n                if (w == 0) \n                    next_state = C;\n                else \n                    next_state = D;\n            end\n            C: begin\n                if (w == 0) \n                    next_state = E;\n                else \n                    next_state = D;\n            end\n            D: begin\n                if (w == 0) \n                    next_state = F;\n                else \n                    next_state = A;\n            end\n            E: begin\n                if (w == 0) \n                    next_state = E;\n                else \n                    next_state = D;\n            end\n            F: begin\n                if (w == 0) \n                    next_state = C;\n                else \n                    next_state = D;\n            end\n            default: next_state = A; // Default case\n        endcase\n    end\n\n    // Output logic for z\n    always @(*) begin\n        case (state)\n            E: z = 1; // Output is 1 when in state E\n            F: z = 1; // Output is also 1 when in state F\n            default: z = 0; // Output is 0 otherwise\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n\t// State encoding\n\tlocalparam IDLE = 2'b00, RECEIVING = 2'b01, DONE = 2'b10;\n\treg [1:0] state, next_state;\n\n\t// Byte storage\n\treg [23:0] byte_storage;\n\treg [1:0] byte_count; // To count received bytes\n\n\t// Sequential logic for state transitions\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tbyte_count <= 0;\n\t\t\tbyte_storage <= 0;\n\t\t\tout_bytes <= 0;\n\t\t\tdone <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\t// Combinational logic for next state and output\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tdone = 0; // Done is low in IDLE\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tnext_state = RECEIVING;\n\t\t\t\t\tbyte_count = 0;\n\t\t\t\t\tbyte_storage = 0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE; // Stay in IDLE\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tRECEIVING: begin\n\t\t\t\tdone = 0; // Done is low in RECEIVING\n\t\t\t\tbyte_storage = (byte_storage << 8) | in; // Shift in the new byte\n\t\t\t\tbyte_count = byte_count + 1; // Increment the byte count\n\n\t\t\t\tif (byte_count == 2) begin // Received 3 bytes (count starts from 0)\n\t\t\t\t\tnext_state = DONE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = RECEIVING; // Continue receiving\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tDONE: begin\n\t\t\t\tdone = 1; // Signal done\n\t\t\t\tout_bytes = byte_storage; // Output the collected bytes\n\t\t\t\tnext_state = IDLE; // Return to IDLE for next message\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tnext_state = IDLE; // Default state\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    assign Y1 = y[0] & w | y[1]; // Y1 is high if in A with w=1 or in B\n    assign Y3 = y[3] | (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w); // Y3 is high if in D or transitioning from B, C, or E to D\nendmodule\n", "result": "failed: 313 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n// Assign the 3-bit output to be the same as the input\nassign outv = vec;\n\n// Assign each individual bit output\nassign o2 = vec[2]; // Most significant bit\nassign o1 = vec[1]; // Middle bit\nassign o0 = vec[0]; // Least significant bit\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        out = ( (!c & d) || \n                ( !a & !b & c) ||\n                ( a & !b & !d) || \n                ( a & b & !c) ||\n                ( !a & b & d) \n               ) ? 1 : 0;\n    end\nendmodule\n", "result": "failed: 129 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\n    assign out_hi = in[15:8];  // Assign upper byte\n    assign out_lo = in[7:0];   // Assign lower byte\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\nassign out = ~(a | b);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Continuous assignment for XOR gate\nassign out_assign = a ^ b;\n\n// Combinational always block for XOR operation\nalways @* begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block for delayed output\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\n// Next-state logic\nassign Y2 = y[1] & ~w; // Y2 is active when in state A and w is 0\nassign Y4 = (y[2] | y[3] | y[5] | y[6]) & w; // Y4 is active in state B, C, E, and F when w is 1\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    assign out = in[sel];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R; // Load the value R into Q when L is high\n\t\tend\n\t\telse if (E) begin\n\t\t\tQ <= w; // Shift the value w into Q when E is high\n\t\tend\n\t\t// If neither L nor E is high, Q retains its previous value\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg q0, q1, q2;  // D Flip-Flop outputs\n\n    // D Flip-Flop assignments on the rising edge of clk\n    always @(posedge clk) begin\n        q0 <= x ^ q0;   // D Flip-Flop 0\n        q1 <= x & ~q1;  // D Flip-Flop 1\n        q2 <= x | ~q2;  // D Flip-Flop 2\n    end\n\n    // Ensure the outputs are combination logic for the XNOR\n    assign z = ~(q0 ^ q1 ^ q2);  // Z is the output of a three-input XNOR\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (b & (c | d)) | (a & (c | d));\nendmodule\n", "result": "failed: 35 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load input state when 'load' is high\n        end else begin\n            // Advance to the next state based on the Rule 110\n            reg [511:0] next_q;\n            integer i;\n\n            for (i = 0; i < 512; i = i + 1) begin\n                // neighbor states initialization\n                wire left = (i == 0) ? 1'b0 : q[i-1];\n                wire center = q[i];\n                wire right = (i == 511) ? 1'b0 : q[i+1];\n\n                // Rule 110 logic\n                case ({left, center, right})\n                    3'b111: next_q[i] = 1'b0;\n                    3'b110: next_q[i] = 1'b1;\n                    3'b101: next_q[i] = 1'b1;\n                    3'b100: next_q[i] = 1'b0;\n                    3'b011: next_q[i] = 1'b1;\n                    3'b010: next_q[i] = 1'b1;\n                    3'b001: next_q[i] = 1'b1;\n                    3'b000: next_q[i] = 1'b0;\n                    default: next_q[i] = 1'b0; // Should never happen, but a safe default\n                endcase\n            end\n            \n            q <= next_q; // Update with the next state\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [1:0] {\n\tA = 2'b00,\n\tB = 2'b01,\n\tC = 2'b10,\n\tD = 2'b11\n} state_t;\n\n// State variable\nstate_t current_state, next_state;\n\n// Synchronous reset and state transition logic\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tcurrent_state <= A; // Reset to state A\n\tend else begin\n\t\tcurrent_state <= next_state; // Update to next state\n\tend\nend\n\n// Next state logic\nalways @(*) begin\n\tcase (current_state)\n\t\tA: begin\n\t\t\tif (in)\n\t\t\t\tnext_state = B;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tB: begin\n\t\t\tif (in)\n\t\t\t\tnext_state = B;\n\t\t\telse\n\t\t\t\tnext_state = C;\n\t\tend\n\t\tC: begin\n\t\t\tif (in)\n\t\t\t\tnext_state = D;\n\t\t\telse\n\t\t\t\tnext_state = A;\n\t\tend\n\t\tD: begin\n\t\t\tif (in)\n\t\t\t\tnext_state = B;\n\t\t\telse\n\t\t\t\tnext_state = C;\n\t\tend\n\t\tdefault: next_state = A; // Default case to handle unexpected states\n\tendcase\nend\n\n// Output logic\nalways @(*) begin\n\tcase (current_state)\n\t\tA, B, C: out = 0; // Output is 0 in states A, B, and C\n\t\tD: out = 1;       // Output is 1 in state D\n\tendcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n    \n    always @(*) begin\n        case (c)\n            0: q = b;\n            1: q = e;\n            2: q = a;\n            3: q = d;\n            4, 5, 6, 7, 8: q = f; // for 4 to 8, f is assumed as 4'd15\n            default: q = f; // Assign f for other conditions where c >= 4\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tif (sel) begin\n\t\t\tout = b;\n\t\tend else begin\n\t\t\tout = a;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": " \n\n    // Internal signal to hold output from the multiplexer\n    wire mux_out;\n    \n    // 2-to-1 multiplexer implementation\n    assign mux_out = (L) ? r_in : q_in;\n\n    // Always block to create flip-flop behavior\n    always @(posedge clk) begin\n        Q <= mux_out;  // Flip-flop updates its output on the rising edge of clk\n    end\n\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n    reg [31:0] prev_in; // Register to hold the previous state of 'in'\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;       // Clear output if reset is active\n            prev_in <= 32'b0;   // Clear previous input state\n        end else begin\n            // Capture transitions\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (prev_in[i] == 1 && in[i] == 0) begin\n                    out[i] <= 1; // Capture the drop from 1 to 0\n                end\n            end\n            prev_in <= in; // Update previous state to current\n        end\n    end\n\nendmodule\n", "result": "failed: 99 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        q <= d; // Capture the input d into output q on the rising edge of clk\n    end\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\n    wire [8:0] sum; // 9 bits to accommodate overflow\n    assign sum = {1'b0, a} + {1'b0, b}; // Add a and b, zero-extend to 9 bits\n    assign s = sum[7:0]; // s is the lower 8 bits of the sum\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]); // Check for overflow condition\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n// Next state logic\nassign B3_next = state[8] & 1'b1;   // State B3 transitions to itself whenever shift_ena is high\nassign S_next = (state[0] & ~d);    // From S, stay in S if d=0\nassign S1_next = (state[1] & d) | (state[2] & ~d); // S1 goes to S if d=0 and stays in S1 if d=1\nassign Count_next = state[8];       // If in B3 and shift_ena is high, go to Count\nassign Wait_next = (state[9] & done) & ack; // Wait goes back to S if ack=1\n\n// Output logic\nassign done = state[9]; // done output is high when in Wait state\nassign counting = state[8]; // counting output is high when in Count state\nassign shift_ena = state[4] | state[5] | state[6] | state[7]; // Any of B0 to B3 leads to shift_ena high\n\nendmodule\n", "result": "failed: 3048 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n// Define a register to hold the counter value\nlogic [1:0] counter;\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        counter <= 2'b01;  // Reset the counter to 01\n    end else if (train_valid) begin\n        if (train_taken) begin\n            // Increment the counter, saturating at 3\n            if (counter < 2'b11) \n                counter <= counter + 1;\n        end else begin\n            // Decrement the counter, saturating at 0\n            if (counter > 2'b00)\n                counter <= counter - 1;\n        end\n    end\nend\n\n// Assign the counter value to the output state\nassign state = counter;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @(*) begin\n        pos = 3'b000; // Default value if no bits are high\n        if (in[0]) pos = 3'd0; \n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @* begin\n    // Default values\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode\n    case (scancode)\n        16'hE06B: left = 1;   // Left arrow\n        16'hE072: down = 1;   // Down arrow\n        16'hE074: right = 1;  // Right arrow\n        16'hE075: up = 1;     // Up arrow\n        default: ;            // Do nothing for any other scancode\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    wire [3:0] carry;  // Intermediate carry wires\n\n    // Full adder for the least significant bit\n    assign sum[0] = x[0] ^ y[0]; // sum for LSB\n    assign carry[0] = (x[0] & y[0]); // carry-out for LSB\n\n    // Full adder for bit 1\n    assign sum[1] = x[1] ^ y[1] ^ carry[0]; // sum for next bit\n    assign carry[1] = (x[1] & y[1]) | (carry[0] & (x[1] ^ y[1])); // carry-out\n\n    // Full adder for bit 2\n    assign sum[2] = x[2] ^ y[2] ^ carry[1]; // sum for next bit\n    assign carry[2] = (x[2] & y[2]) | (carry[1] & (x[2] ^ y[2])); // carry-out\n\n    // Full adder for the most significant bit\n    assign sum[3] = x[3] ^ y[3] ^ carry[2]; // sum for MSB\n    assign carry[3] = (x[3] & y[3]) | (carry[2] & (x[3] ^ y[3])); // carry-out\n\n    // The final sum output includes the carry-out as the 4th bit\n    assign sum[4] = carry[3]; // Overflow bit\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Resetting history to zero\n        end else if (train_mispredicted) begin\n            // On misprediction, load new history\n            predict_history <= {train_history[30:0], train_taken}; // Shift in the taken result\n        end else if (predict_valid) begin\n            // On valid prediction, shift in the predicted direction\n            predict_history <= {predict_history[30:0], predict_taken}; // Shift left and insert predict_taken\n        end\n        // Else, do nothing (retain current state)\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\twire and_output1;\n\twire and_output2;\n\n\t// First layer - AND gates\n\tassign and_output1 = a & b; // AND gate for inputs a and b\n\tassign and_output2 = c & d; // AND gate for inputs c and d\n\t\n\t// Second layer - OR gate\n\tassign out = and_output1 | and_output2; // OR gate for the outputs of the two AND gates\n\n\t// Invert the output using NOT operation\n\tassign out_n = ~out; // Inverted output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\nalways @(posedge clk) begin\n    q <= d; // Capture the value of d at the rising edge of clk\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\n    // 8-bit shift register\n    reg [7:0] Q; // Shift register storage\n\n    // Shift register behavior\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]}; // Shift in the new bit at MSB position\n        end\n    end\n\n    // Output selection using the inputs A, B, C\n    always @(*) begin\n        case ({A, B, C}) // Create the address by concatenating A, B, and C\n            3'b000: Z = Q[0]; // When ABC is 000, output Q[0]\n            3'b001: Z = Q[1]; // When ABC is 001, output Q[1]\n            3'b010: Z = Q[2]; // When ABC is 010, output Q[2]\n            3'b011: Z = Q[3]; // When ABC is 011, output Q[3]\n            3'b100: Z = Q[4]; // When ABC is 100, output Q[4]\n            3'b101: Z = Q[5]; // When ABC is 101, output Q[5]\n            3'b110: Z = Q[6]; // When ABC is 110, output Q[6]\n            3'b111: Z = Q[7]; // When ABC is 111, output Q[7]\n            default: Z = 1'b0; // Default case (should not occur)\n        endcase\n    end\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    assign heater = mode && too_cold;       // Heater on when in heating mode and too cold\n    assign aircon = ~mode && too_hot;       // Air conditioner on when in cooling mode and too hot\n    assign fan = heater || aircon || fan_on; // Fan on if heater or aircon are on, or fan_on is true\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n// SOP Logic\nassign out_sop = (a & b & c & d) | (a & b & c & ~d) | (~a & ~b & c & ~d);\n\n// POS Logic\nassign out_pos = (~(a | b | c | d)) & (~(a | b | c | ~d)) & (~(a | b | ~c | d)) & \n                 (~(a | ~b | c | d)) & (~(a | b | c | ~d)) & \n                 (~(a | ~b | ~c | d)) & (~(a & ~b & c & d)) & \n                 (~(a & b & ~c & d));\n\nendmodule\n", "result": "failed: 36 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // On reset, set q to 1\n        end else begin\n            // Calculate feedback from taps\n            // Tapped bits are q[31], q[21], q[1], q[0]\n            // New leftmost bit is the XOR of these tapped bits\n            reg feedback;\n            feedback = q[31] ^ q[21] ^ q[1] ^ q[0];\n            // Shift right and insert feedback at the leftmost position\n            q <= {feedback, q[31:1]};\n        end\n    end\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (b & (d | (c & !d))) | (a & (b | (c & d))) | (a & b & c) | (a & b & d);\nendmodule\n", "result": "failed: 25 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n// Implementing the first 4-input NAND gate\nassign p1y = ~(p1a & p1b & p1c & p1d);\n\n// Implementing the second 4-input NAND gate\nassign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    integer i; // Variable for loop iteration\n    always @* begin\n        out = 0; // Initialize output\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Count number of '1's\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\n    // Calculate out_both\n    assign out_both[2] = in[2] & in[3]; // check in[3] and in[2]\n    assign out_both[1] = in[1] & in[2]; // check in[2] and in[1]\n    assign out_both[0] = in[0] & in[1]; // check in[1] and in[0]\n\n    // Calculate out_any\n    assign out_any[3] = in[2] | in[3]; // check in[3] and in[2]\n    assign out_any[2] = in[1] | in[2]; // check in[2] and in[1]\n    assign out_any[1] = in[0] | in[1]; // check in[1] and in[0]\n\n    // Calculate out_different\n    assign out_different[0] = in[0] ^ in[3]; // wrap around comparison\n    assign out_different[1] = in[1] ^ in[0];\n    assign out_different[2] = in[2] ^ in[1];\n    assign out_different[3] = in[3] ^ in[2];\n\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    always @* begin\n        case (a)\n            3'b000: q = 16'h1232; // a = 0\n            3'b001: q = 16'haee0; // a = 1\n            3'b010: q = 16'h27d4; // a = 2\n            3'b011: q = 16'h5a0e; // a = 3\n            3'b100: q = 16'h2066; // a = 4\n            3'b101: q = 16'h64ce; // a = 5\n            3'b110: q = 16'hc526; // a = 6\n            3'b111: q = 16'h2f19; // a = 7\n            default: q = 16'h0000; // default case (if needed)\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset to 0\n        end else if (slowena) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000; // Wrap around from 9 to 0\n            end else begin\n                q <= q + 1; // Increment counter\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Intermediate signal to hold the inverted value of in2\n    logic in2_inv;\n\n    // Invert in2\n    assign in2_inv = ~in2;\n\n    // AND gate with in1 and inverted in2\n    assign out = in1 & in2_inv;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in;  // Assign the input directly to the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    parameter A = 1'b0, B = 1'b1;\n    reg state, next_state;\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n            default: out = 1'bx; // Unreachable state\n        endcase\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in) \n                    next_state = A; // Remain in A if input is 1\n                else \n                    next_state = B; // Transition to B if input is 0\n            end\n            B: begin\n                if (in) \n                    next_state = B; // Remain in B if input is 1\n                else \n                    next_state = A; // Transition to A if input is 0\n            end\n            default: next_state = B; // Default case, should not happen\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= B; // Reset state to B if areset is high\n        else \n            state <= next_state; // Update state to next_state\n    end\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n  \n    always @(posedge clk) begin\n        q <= d; // Capture d on the rising edge\n    end\n    \n    always @(negedge clk) begin\n        q <= d; // Capture d on the falling edge\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = (a == b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;  // Implementing the function z = (x XOR y) AND x\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x == 1'b0 && y == 1'b0) ? 1'b1 : // (0,0) -> 1\n               (x == 1'b1 && y == 1'b0) ? 1'b0 : // (1,0) -> 0\n               (x == 1'b0 && y == 1'b1) ? 1'b0 : // (0,1) -> 0\n               (x == 1'b1 && y == 1'b1) ? 1'b1 : // (1,1) -> 1\n               1'b0; // Default case\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire zA1, zA2, zB1, zB2; // Intermediate signals\n\n    // Instantiate Module A\n    A a1 (.x(x), .y(y), .z(zA1));\n    A a2 (.x(x), .y(y), .z(zA2));\n\n    // Instantiate Module B\n    B b1 (.x(x), .y(y), .z(zB1));\n    B b2 (.x(x), .y(y), .z(zB2));\n\n    // OR gate for the outputs of the first module A and B\n    wire OR_result;\n    assign OR_result = zA1 | zB1;\n\n    // AND gate for the outputs of the second module A and B\n    wire AND_result;\n    assign AND_result = zA2 & zB2;\n\n    // XOR gate for the final output\n    assign z = OR_result ^ AND_result;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the new data into q\n            q <= data;\n        end else begin\n            // Perform rotation based on ena value\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]};  // Rotate left\n                default: ;  // Do nothing for 00 and 11\n            endcase\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 10'd0; // Reset counter to 0\n        end else begin\n            if (q == 10'd999) begin\n                q <= 10'd0; // Roll over to 0 after 999\n            end else begin\n                q <= q + 10'd1; // Increment counter\n            end\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n    assign out = ~in; // Assign out to the NOT of in\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    // Determine the next state based on current state and input\n    assign next_state = (state[0] ? (in ? 10'b0000000000 : 10'b0000000001) : // S0\n                         state[1] ? (in ? 10'b0000000010 : 10'b0000000000) : // S1\n                         state[2] ? (in ? 10'b0000000011 : 10'b0000000000) : // S2\n                         state[3] ? (in ? 10'b0000000100 : 10'b0000000000) : // S3\n                         state[4] ? (in ? 10'b0000000101 : 10'b0000000000) : // S4\n                         state[5] ? (in ? 10'b0000001000 : 10'b0000000110) : // S5\n                         state[6] ? (in ? 10'b0000010000 : 10'b0000000111) : // S6\n                         state[7] ? (in ? 10'b0000000111 : 10'b0000000000) : // S7: self-loop on 1\n                         state[8] ? (in ? 10'b0000000001 : 10'b0000000000) : // S8\n                         state[9] ? (in ? 10'b0000000001 : 10'b0000000000) : // S9\n                         10'b0000000000);  // Default to S0\n    \n    // Define outputs based on current state\n    assign out1 = state[7] || state[8] || state[9]; // out1 is high for states S7, S8, S9\n    assign out2 = state[7]; // out2 is high only when in state S7\n\nendmodule\n", "result": "failed: 1368 out of 1424 samples.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    // Check the inputs J and K to determine the output Q\n    if (j == 0 && k == 0) begin\n        Q <= Q; // Remain unchanged\n    end else if (j == 0 && k == 1) begin\n        Q <= 0; // Reset to 0\n    end else if (j == 1 && k == 0) begin\n        Q <= 1; // Set to 1\n    end else if (j == 1 && k == 1) begin\n        Q <= ~Q; // Toggle\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\nassign out = in[0] + in[1] + in[2];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\nassign out[24] = (a == a);\nassign out[23] = (a == b);\nassign out[22] = (a == c);\nassign out[21] = (a == d);\nassign out[20] = (a == e);\nassign out[19] = (b == a);\nassign out[18] = (b == b);\nassign out[17] = (b == c);\nassign out[16] = (b == d);\nassign out[15] = (b == e);\nassign out[14] = (c == a);\nassign out[13] = (c == b);\nassign out[12] = (c == c);\nassign out[11] = (c == d);\nassign out[10] = (c == e);\nassign out[9]  = (d == a);\nassign out[8]  = (d == b);\nassign out[7]  = (d == c);\nassign out[6]  = (d == d);\nassign out[5]  = (d == e);\nassign out[4]  = (e == a);\nassign out[3]  = (e == b);\nassign out[2]  = (e == c);\nassign out[1]  = (e == d);\nassign out[0]  = (e == e);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n\t// State encoding\n\tparameter LEFT = 1'b0, RIGHT = 1'b1;\n\treg current_state, next_state;\n\n\t// State transition logic\n\talways @* begin\n\t\tcase (current_state)\n\t\t\tLEFT: begin\n\t\t\t\tif (bump_right)\n\t\t\t\t\tnext_state = RIGHT; // Bumped on the right, go right\n\t\t\t\telse\n\t\t\t\t\tnext_state = LEFT;  // Stay left otherwise\n\t\t\tend\n            \n\t\t\tRIGHT: begin\n\t\t\t\tif (bump_left)\n\t\t\t\t\tnext_state = LEFT; // Bumped on the left, go left\n\t\t\t\telse\n\t\t\t\t\tnext_state = RIGHT; // Stay right otherwise\n\t\t\tend\n            \n\t\t\tdefault: next_state = LEFT; // Default to left\n\t\tendcase\n\tend\n\n\t// State update logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurrent_state <= LEFT; // Asynchronous reset to LEFT\n\t\tend else begin\n\t\t\tcurrent_state <= next_state; // Transition to next state\n\t\tend\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\twalk_left = (current_state == LEFT);\n\t\twalk_right = (current_state == RIGHT);\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\n    assign q = a & b;  // Implementing the AND operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n// Intermediate wires for the AND gate outputs\nwire and1_out; // Output of the first 3-input AND gate\nwire and2_out; // Output of the second 3-input AND gate\nwire and3_out; // Output of the first 2-input AND gate\nwire and4_out; // Output of the second 2-input AND gate\n\n// 3-input AND gates for p1y\nassign and1_out = p1a & p1b & p1c;  // AND gate 1\nassign and2_out = p1d & p1e & p1f;  // AND gate 2\nassign p1y = and1_out | and2_out;    // OR gate for p1y\n\n// 2-input AND gates for p2y\nassign and3_out = p2a & p2b;        // AND gate 3\nassign and4_out = p2c & p2d;        // AND gate 4\nassign p2y = and3_out | and4_out;    // OR gate for p2y\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n    \nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x) begin\n                Y0 <= 1'b1; // Next state 001\n                z <= 0; // Output is 0\n            end else begin\n                Y0 <= 1'b0; // Next state 000\n                z <= 0; // Output is 0\n            end\n        end\n        3'b001: begin\n            if (x) begin\n                Y0 <= 1'b0; // Next state 100\n                z <= 0; // Output is 0\n            end else begin\n                Y0 <= 1'b1; // Next state 001\n                z <= 0; // Output is 0\n            end\n        end\n        3'b010: begin\n            if (x) begin\n                Y0 <= 1'b1; // Next state 001\n                z <= 0; // Output is 0\n            end else begin\n                Y0 <= 1'b0; // Next state 010\n                z <= 0; // Output is 0\n            end\n        end\n        3'b011: begin\n            if (x) begin\n                Y0 <= 1'b0; // Next state 010\n                z <= 1; // Output is 1\n            end else begin\n                Y0 <= 1'b1; // Next state 001\n                z <= 1; // Output is 1\n            end\n        end\n        3'b100: begin\n            if (x) begin\n                Y0 <= 1'b0; // Next state 100\n                z <= 1; // Output is 1\n            end else begin\n                Y0 <= 1'b1; // Next state 011\n                z <= 1; // Output is 1\n            end\n        end\n        default: begin\n            Y0 <= 1'b0; // Default case for safety\n            z <= 0; // Default output for safety\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\n    assign out = ~(in1 | in2); // NOR operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\n    assign w = a; // Connect input a to output w\n    assign x = b; // Connect input b to output x\n    assign y = b; // Connect input b to output y\n    assign z = c; // Connect input c to output z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\n    // Always block to handle the asynchronous reset and clock behavior\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 0;  // Asynchronous reset\n        end else begin\n            q <= d;  // Capture the value of d at the rising edge of clk\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n    \n    always @(*) begin\n        case (sel)\n            3'b000: out = data0; // sel = 0\n            3'b001: out = data1; // sel = 1\n            3'b010: out = data2; // sel = 2\n            3'b011: out = data3; // sel = 3\n            3'b100: out = data4; // sel = 4\n            3'b101: out = data5; // sel = 5\n            default: out = 4'b0000; // sel out of bounds (6 and above)\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the new value into the counter\n            tc <= 0; // Reset terminal count when a new value is loaded\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement the counter\n            if (counter == 1) begin\n                tc <= 1; // Assert tc when counter reaches 0\n            end\n        end\n    end\n\n    // Assert tc when counter reaches 0 and keep it asserted\n    always @(posedge clk) begin\n        if (counter == 0) begin\n            tc <= 1; // Keep tc asserted if counter is zero\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n    // State encoding\n    parameter S0 = 3'b000; // No bits matched\n    parameter S1 = 3'b001; // First '1' matched\n    parameter S2 = 3'b010; // '11' matched\n    parameter S3 = 3'b011; // '110' matched\n    parameter S4 = 3'b100; // '1101' matched\n\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            state <= S0; // Reset to initial state\n            start_shifting <= 0; // Reset output\n        end else begin\n            state <= next_state; // Transition to the next state\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (data) next_state = S1; // Detect '1'\n                else next_state = S0; // Stay in S0\n            end\n            S1: begin\n                if (data) next_state = S2; // Detect '11'\n                else next_state = S0; // Reset on '0'\n            end\n            S2: begin\n                if (data) next_state = S3; // Detect '110'\n                else next_state = S0; // Reset on '0'\n            end\n            S3: begin\n                if (data) next_state = S1; // Detect trailing '1' (overlap)\n                else next_state = S4; // Completed '1101' sequence\n            end\n            S4: begin\n                next_state = S4; // Stay in S4, sequence found\n            end\n            default: next_state = S0; // Safety default\n        endcase\n    end\n\n    // Output logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            start_shifting <= 0; // Reset output\n        end else begin\n            start_shifting <= (state == S4) ? 1 : 0; // Set output if in S4\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b0; // Reset all flip-flops to zero\n\t\tend else begin\n\t\t\tq <= d;    // Capture the current input\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\nreg [7:0] prev_in; // Register to hold the previous state of the input\n\nalways @(posedge clk) begin\n\t// Detect rising edges and update the output\n\tanyedge <= (in & ~prev_in); // Detect where in has rising edge\n\tprev_in <= in; // Update previous state\nend\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // reset to 1\n    end else begin\n        if (q == 4'b1010) begin\n            q <= 4'b0001; // roll over to 1\n        end else begin\n            q <= q + 1; // increment\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (a) begin\n\t\t// If a is high, continue holding the current value of q\n\t\tq <= q; \n\tend else begin\n\t\t// If a is low, increment q and wrap around if exceeds 7\n\t\tif (q == 3'b111) \n\t\t\tq <= 3'b000; // reset to 0 if q exceeds 7 (3'b111)\n\t\telse \n\t\t\tq <= q + 1'b1; // increment q\n\tend\nend\n\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 5'b00001;  // Reset state to 1 (00001)\n        end else begin\n            q <= {q[3:0], (q[4] ^ q[2])}; // Shift and update MSB with feedback\n        end\n    end\nendmodule\n", "result": "failed: 4276 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\nalways @(*) begin\n    // Reset the result_is_zero\n    result_is_zero = 0;\n\n    // Compute out based on do_sub\n    if (do_sub == 0) begin\n        out = a + b;\n    end else begin\n        out = a - b;\n    end\n\n    // Check if the output is zero\n    if (out == 8'b0) begin\n        result_is_zero = 1;\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    assign f = (x[3] & (x[1] | x[2])) | (x[4] & x[3]);\nendmodule\n", "result": "failed: 10 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\talways @(*) begin\n\t\tvalid = 0; // Default: not valid\n\t\tout = 4'b0000; // Default output\n\n\t\tcase (code)\n\t\t\t8'h45: begin\n\t\t\t\tout = 4'b0000; // 0\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h16: begin\n\t\t\t\tout = 4'b0001; // 1\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h1e: begin\n\t\t\t\tout = 4'b0010; // 2\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h26: begin\n\t\t\t\tout = 4'b0011; // 3\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h25: begin\n\t\t\t\tout = 4'b0100; // 4\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h2e: begin\n\t\t\t\tout = 4'b0101; // 5\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h36: begin\n\t\t\t\tout = 4'b0110; // 6\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h3d: begin\n\t\t\t\tout = 4'b0111; // 7\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h3e: begin\n\t\t\t\tout = 4'b1000; // 8\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\t8'h46: begin\n\t\t\t\tout = 4'b1001; // 9\n\t\t\t\tvalid = 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tout = 4'b0000; // If no valid code, output 0\n\t\t\t\tvalid = 0; // Ensure valid is not set\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase ({c,d})\n\t\t\t2'b00: out = 1; // don't care\n\t\t\t2'b01: out = 0; \n\t\t\t2'b11: out = 1; \n\t\t\t2'b10: out = b; \n\t\t\tdefault: out = 0; // default case\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 68 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\n// Initialization block if desired (not typically done in a clocked always block)\n// Always block triggered by clk\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift operation: Shift left and insert data at LSB\n        q <= {q[2:0], data}; // Shift left 3 bits and insert new data\n    end else if (count_ena) begin\n        // Count operation: Decrement the register value\n        q <= q - 1; // Decrement register value\n    end\n    // If both are enabled, do nothing or choose shift or count as a priority\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\nassign out = in; // Continuous assignment to make the output behave like a wire\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    reg [2:0] count;  // 3 bits is enough to count from 0 to 4\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1'b1;  // assert shift_ena\n            count <= 3'd0;      // initialize counter to 0\n        end else if (count < 3'd3) begin\n            // Counter increment\n            count <= count + 1;\n        end else begin\n            shift_ena <= 1'b0;  // de-assert shift_ena after 4 cycles\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0\n\t\tend else begin\n\t\t\tq <= q + 1; // Increment the counter\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n// Continuous assignment for out_assign based on select signals\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Procedural assignment for out_always based on select signals\nalways @(*) begin\n    if (sel_b1 && sel_b2)\n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\tassign out = (~a & ~b & c) | (a & ~c) | (a & b);\nendmodule\n", "result": "failed: 99 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    // State Encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Table - Next State Logic\n    always @* begin\n        case (current_state)\n            A: begin\n                if (r[1]) next_state = B; // Grant to device 1\n                else if (r[2]) next_state = C; // Grant to device 2\n                else if (r[3]) next_state = D; // Grant to device 3\n                else next_state = A; // Stay in A\n            end\n            B: begin\n                if (r[1]) next_state = B; // Stay in B\n                else next_state = A; // Return to A\n            end\n            C: begin\n                if (r[2]) next_state = C; // Stay in C\n                else next_state = A; // Return to A\n            end\n            D: begin\n                if (r[3]) next_state = D; // Stay in D\n                else next_state = A; // Return to A\n            end\n            default: next_state = A; // Safety\n        endcase\n    end\n\n    // State Flip-Flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Grant Logic\n    always @* begin\n        g = 3'b000; // Default grant signals to 0\n        case (current_state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000; // Stay with no grants\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n// On each rising edge of the clock\nalways @(posedge clk) begin\n    // If reset is active high, reset q to 0\n    if (reset) begin\n        q <= 4'b0000; // Reset q to 0\n    end else begin\n        // If q is 9, reset to 0; else increment by 1\n        if (q == 4'b1001) begin\n            q <= 4'b0000; // Wrap around to 0\n        end else begin\n            q <= q + 1; // Increment q\n        end\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State Declaration\n    typedef enum reg [1:0] {\n        WAIT_FOR_START = 2'b00,\n        RECEIVE_BYTE1  = 2'b01,\n        RECEIVE_BYTE2  = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= WAIT_FOR_START;\n            done <= 0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Combinational logic for next state determination and output\n    always @(*) begin\n        // Default assignments\n        done = 0;\n        next_state = current_state;\n        \n        case (current_state)\n            WAIT_FOR_START: begin\n                if (in[3] == 1) begin\n                    next_state = RECEIVE_BYTE1;\n                end\n            end\n            \n            RECEIVE_BYTE1: begin\n                next_state = RECEIVE_BYTE2;\n            end\n            \n            RECEIVE_BYTE2: begin\n                done = 1; // Signal done for the transition cycle\n                next_state = WAIT_FOR_START; // Return to waiting for next message\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\tassign out = (sel == 0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n// Calculate the outputs based on the inputs\nassign out_and = in[3] & in[2] & in[1] & in[0]; // 4-input AND\nassign out_or  = in[3] | in[2] | in[1] | in[0]; // 4-input OR\nassign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0]; // 4-input XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam S0 = 3'b000,\n               S1 = 3'b001,\n               S2 = 3'b010,\n               S3 = 3'b011,\n               S4 = 3'b100;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0; // Reset to state 000\n        end else begin\n            state <= next_state; // Transition to the next state\n        end\n    end\n\n    // Combinational logic for next state and output\n    always @* begin\n        case (state)\n            S0: begin\n                next_state = (x == 0) ? S0 : S1; // 000\n                z = 0;\n            end\n            S1: begin\n                next_state = (x == 0) ? S1 : S4; // 001\n                z = 0;\n            end\n            S2: begin\n                next_state = (x == 0) ? S2 : S1; // 010\n                z = 0;\n            end\n            S3: begin\n                next_state = (x == 0) ? S1 : S2; // 011\n                z = 1;\n            end\n            S4: begin\n                next_state = (x == 0) ? S3 : S4; // 100\n                z = 1;\n            end\n            default: begin\n                next_state = S0; // Default to state 000\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    // Define the states\n    typedef enum reg [2:0] {A, F, X1, X2, G, G_active, G_inactive} state_t;\n    state_t state, next_state;\n    reg [1:0] x_counter; // To count the occurrences of x values for the sequence\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= A;\n            f <= 0;\n            g <= 0;\n            x_counter <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        // Default values\n        next_state = state;\n        f = 0; // Default f = 0 unless in state F\n        g = (state == G_active) ? 1 : 0; // g follows directly from the state\n\n        case (state)\n            A: begin\n                // Remain in state A while reset is active\n                next_state = F; // Move to F after reset\n            end\n            \n            F: begin\n                f = 1; // Assert f for one clock cycle\n                next_state = X1; // Go to first x check\n            end\n            \n            X1: begin\n                if (x) begin\n                    x_counter = 1; // 1 in x -> count it\n                    next_state = X2; // Expect 0 next\n                end else begin\n                    x_counter = 0; // Reset counter\n                    next_state = X1; // Retry same state\n                end\n            end\n            \n            X2: begin\n                if (!x) begin\n                    next_state = G; // If 0 in x, go to g check\n                end else begin\n                    x_counter = 0; // Reset counter\n                    next_state = X1; // Wrong sequence\n                end\n            end\n            \n            G: begin\n                next_state = (y) ? G_active : G_inactive; // Decide depending on y \n            end\n            \n            G_active: begin\n                if (!y) begin\n                    // Remain in G_active as long as y is 1\n                    next_state = G_active;\n                end else begin\n                    // y is 1, keep g = 1\n                    next_state = G_active; \n                end\n            end\n            \n            G_inactive: begin\n                // Once inactive g = 0 and stay in inactive state till reset\n                next_state = G_inactive;\n            end\n            \n            default: next_state = A; // For safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(negedge clk) begin\n        if (reset) begin\n            q <= 8'h34;  // Reset output to 0x34\n        end else begin\n            q <= d;      // Capture input d on the negative edge of clk\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n    // Determine next state based on current state and input\n    case (state)\n        2'b00: // A\n            if (in == 0)\n                next_state = 2'b00; // Stay in A\n            else\n                next_state = 2'b01; // Go to B\n        2'b01: // B\n            if (in == 0)\n                next_state = 2'b10; // Go to C\n            else\n                next_state = 2'b01; // Stay in B\n        2'b10: // C\n            if (in == 0)\n                next_state = 2'b00; // Go to A\n            else\n                next_state = 2'b11; // Go to D\n        2'b11: // D\n            if (in == 0)\n                next_state = 2'b10; // Go to C\n            else\n                next_state = 2'b01; // Go to B\n        default: next_state = 2'b00; // Default case (optional, for safety)\n    endcase\nend\n\n// Determine output based on current state\nassign out = (state == 2'b11) ? 1'b1 : 1'b0; // out=1 for D, otherwise 0\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    always @* begin\n        case({x, y})\n            2'b00: z = 1; // When x = 0, y = 0\n            2'b01: z = 1; // When x = 0, y = 1\n            2'b10: z = 0; // When x = 1, y = 0\n            2'b11: z = 1; // When x = 1, y = 1\n            default: z = 0; // Fallback\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n  \n    // State Encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Flip-Flops\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;  // Reset to state A\n        end else begin\n            current_state <= next_state;  // Update state\n        end\n    end\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A; // Fallback state\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;  // Output is 1 when in state E\n            default: z = 0; // Output is 0 for all other states\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n    reg [15:0] dff; // internal storage for the D flip-flops\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            dff <= 16'b0; // synchronous reset to 0\n        end else begin\n            if (byteena[1]) begin\n                dff[15:8] <= d[15:8]; // write to upper byte\n            end\n            if (byteena[0]) begin\n                dff[7:0] <= d[7:0]; // write to lower byte\n            end\n        end\n    end\n\n    assign q = dff; // output the D flip-flops value\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n\n    reg [7:0] prev_in; // Register to hold the previous state of `in`\n\n    always @(posedge clk) begin\n        // Detect positive edges\n        pedge <= (prev_in == 8'b0) & (in == 8'b1); // Set pedge if transition detected\n        prev_in <= in; // Update previous state\n    end\n\nendmodule\n", "result": "failed: 180 out of 227 samples.", "passed": false}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n    \n    // Sequential logic triggered on the rising edge of the clock\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;  // Set p high when input a is high\n        end else begin\n            p <= 0;  // Reset p when a is low\n        end\n        \n        // Set q based on p\n        if (p) begin\n            q <= 1;  // Set q high when p is high\n        end else begin\n            q <= q;  // Maintain the state of q (i.e., it holds the previous value)\n        end\n    end\n    \nendmodule\n", "result": "failed: 174 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load the initial state\n        end else begin\n            // Compute the next state based on Rule 90\n            reg [511:0] next_q;\n            next_q[0] = 0 ^ q[1];  // Left boundary is considered 0\n            for (int i = 1; i < 511; i = i + 1) begin\n                next_q[i] = q[i-1] ^ q[i+1];  // Regular cells\n            end\n            next_q[511] = q[510] ^ 0;  // Right boundary is considered 0\n            q <= next_q;  // Update state\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\t\n\tassign z = (A == B);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n// Generate out_both\nassign out_both[0] = in[0] & in[1];          // for bits [0] and [1]\ngenvar i;\ngenerate\n    for (i = 1; i <= 98; i = i + 1) begin\n        assign out_both[i] = in[i] & in[i + 1];\n    end\nendgenerate\n\n// Generate out_any\nassign out_any[1] = in[1] | in[0];          // for bits [1] and [0]\ngenerate\n    for (i = 2; i <= 99; i = i + 1) begin\n        assign out_any[i] = in[i] | in[i - 1];\n    end\nendgenerate\n\n// Generate out_different\nassign out_different[0] = in[0] != in[99]; // wrapping case\ngenerate\n    for (i = 1; i <= 99; i = i + 1) begin\n        assign out_different[i] = (in[i] != in[i - 1]);\n    end\nendgenerate\n\nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n    always @* begin\n        if (ena) begin\n            q = d;  // When enable is high, q follows d\n        end\n        // else case is implicitly handled: q retains its previous value\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\n    // Select the 4 bits from input based on sel value\n    assign out = in[(sel * 4) +: 4];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\talways_comb begin\n\t\tcase (sel)\n\t\t\t4'd0:  out = a;\n\t\t\t4'd1:  out = b;\n\t\t\t4'd2:  out = c;\n\t\t\t4'd3:  out = d;\n\t\t\t4'd4:  out = e;\n\t\t\t4'd5:  out = f;\n\t\t\t4'd6:  out = g;\n\t\t\t4'd7:  out = h;\n\t\t\t4'd8:  out = i;\n\t\t\tdefault: out = 16'b1111111111111111; // Unused cases: all '1's\n\t\tendcase\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Compute the bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute the logical OR of a and b\n    assign out_or_logical = |{a, b}; // using concatenation and reduction OR\n\n    // Compute the NOT of both vectors\n    assign out_not = {~b, ~a}; // Upper half for ~b, lower half for ~a\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = (in == 0) ? 4'b0001 : 4'b0010; // State A\n            4'b0010: next_state = (in == 0) ? 4'b0100 : 4'b0010; // State B\n            4'b0100: next_state = (in == 0) ? 4'b0001 : 4'b1000; // State C\n            4'b1000: next_state = (in == 0) ? 4'b0100 : 4'b0010; // State D\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    assign out = state[3]; // Output is high if in state D (4'b1000)\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @(*) begin\n    // Start with the first two numbers\n    if (a < b) \n        min = a;\n    else \n        min = b;\n\n    // Compare with the third number\n    if (c < min)\n        min = c;\n\n    // Compare with the fourth number\n    if (d < min)\n        min = d;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n// Implementing the logic for each output\nassign out_and = a & b;          // AND operation\nassign out_or = a | b;           // OR operation\nassign out_xor = a ^ b;          // XOR operation\nassign out_nand = ~(a & b);      // NAND operation\nassign out_nor = ~(a | b);       // NOR operation\nassign out_xnor = ~(a ^ b);      // XNOR operation\nassign out_anotb = a & ~b;       // AND-NOT operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n\tassign out = (~c & ~d) | (~c & d) | (~c & b) | (c & b) | (c & d);\n\nendmodule\n", "result": "failed: 84 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\treg [1:0] state; // State variable, 2 bits to represent states\n\treg [1:0] count; // Count variable to count w = 1 occurrences\n\treg [1:0] cycle; // Cycle counter for three cycles\n\n\t// State encoding\n\tparameter A = 2'b00, B = 2'b01; // Only two states needed (A and B)\n\n\t// Sequential logic for FSM\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= A; // Go to reset state\n\t\t\tcount <= 0; // Reset count\n\t\t\tcycle <= 0; // Reset cycle\n\t\t\tz <= 0; // Reset output\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tif (s == 1) begin // Move to state B\n\t\t\t\t\t\tstate <= B;\n\t\t\t\t\t\tcount <= 0; // Reset count for new cycle\n\t\t\t\t\t\tcycle <= 0; // Reset cycle counter\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tif (cycle < 2) begin // Check for three cycles (0, 1, 2)\n\t\t\t\t\t\tif (w == 1) count <= count + 1; // Increment count if w = 1\n\t\t\t\t\t\tcycle <= cycle + 1; // Increment cycle counter\n\t\t\t\t\tend else if (cycle == 2) begin\n\t\t\t\t\t\tif (count == 2) z <= 1; // Set z if the count is exactly 2\n\t\t\t\t\t\telse z <= 0; // Otherwise set z to 0\n\t\t\t\t\t\t\n\t\t\t\t\t\tcount <= 0; // Reset count\n\t\t\t\t\t\tcycle <= 0; // Reset cycle for next block\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n", "result": "failed: 354 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out = { {24{in[7]}}, in }; // Replicate the sign bit and concatenate with the input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\n    reg [3:0] shift_reg; // 4-bit register to hold values\n    \n    // On every clock cycle\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000; // Reset the register to 0 when resetn is low\n        end else begin\n            shift_reg <= {shift_reg[2:0], in}; // Shift left and load new input\n        end\n    end\n    \n    assign out = shift_reg[3]; // MSB is the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\nalways @(*) begin\n    casez (in)           // casez allows us to handle don't care conditions\n        4'b1??? : pos = 2'b11; // in[3] is high\n        4'b01?? : pos = 2'b10; // in[2] is high\n        4'b001? : pos = 2'b01; // in[1] is high\n        4'b0001 : pos = 2'b00; // in[0] is high\n        default : pos = 2'b00; // no bits are high\n    endcase\nend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State encoding\n    localparam OFF = 1'b0;\n    localparam ON = 1'b1;\n    \n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF; // Reset state to OFF\n        end else begin\n            state <= next_state; // Update to the next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON; // Transition to ON if j=1\n                end else begin\n                    next_state = OFF; // Remain in OFF if j=0\n                end\n            end\n            ON: begin\n                if (k) begin\n                    next_state = OFF; // Transition to OFF if k=1\n                end else begin\n                    next_state = ON; // Remain in ON if k=0\n                end\n            end\n            default: next_state = OFF; // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        out = state; // Output is equal to the current state\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n    assign out = 1'b0;  // Always drive the output to 0 (logic low)\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n// Assign the output to constant high\nassign one = 1'b1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\n\tinteger i;\n\n\talways @(*) begin\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99 - i];\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Intermediate signal for XOR output\n    logic xor_output;\n\n    // Instantiate the XOR gate\n    assign xor_output = in ^ out;\n\n    // D Flip-Flop behavior\n    always_ff @(posedge clk) begin\n        out <= xor_output; // update the output on the rising edge of clk\n    end\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\t\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tq <= 4'b0000;  // Reset the register to zero\n\tend else if (load) begin\n\t\tq <= data;    // Load data into the register\n\tend else if (ena) begin\n\t\tq <= {1'b0, q[3:1]};  // Shift right\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\nassign f = ( ~x3 & x2 ) | ( x3 & ~x2 & x1 ) | ( x3 & x2 & x1 );\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 8'b0; // reset output to 0\n        end else begin\n            q <= d; // capture the input d on positive edge of clk\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\nassign out_and = &in;       // AND all inputs\nassign out_or = |in;        // OR all inputs\nassign out_xor = ^in;       // XOR all inputs\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\tassign sum = a ^ b;     // XOR operation for sum\n\tassign cout = a & b;    // AND operation for carry-out\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else \n            shut_off_computer = 0; // Reset to 0 when not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty; // Continue driving if gas tank is not empty\n        else \n            keep_driving = 0; // Reset keep_driving to 0 if arrived\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // State encoding\n    typedef enum reg [0:0] {\n        OFF = 1'b0,\n        ON = 1'b1\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            OFF: begin\n                if (j) \n                    next_state = ON;  // Transition to ON\n                else \n                    next_state = OFF; // Stay in OFF\n            end\n            ON: begin\n                if (k) \n                    next_state = OFF; // Transition to OFF\n                else \n                    next_state = ON;  // Stay in ON\n            end\n        endcase\n    end\n\n    // Flip-flop for state storage\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= OFF; // Reset to OFF state\n        else \n            current_state <= next_state; // Transition to next state\n    end\n\n    // Output logic\n    always @(current_state) begin\n        out = current_state; // Output corresponds to the state\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    // Concatenate inputs and add two 1's in LSB positions\n    wire [31:0] concatenated;\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n    \n    // Assign outputs from concatenated result\n    assign w = concatenated[31:24]; // 8 MSBs\n    assign x = concatenated[23:16]; // next 8 bits\n    assign y = concatenated[15:8];  // next 8 bits\n    assign z = concatenated[7:0];   // 8 LSBs\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (~(a | b | c)) | \n               (~a & ~b & d) | \n               (~a & b & ~c & d) | \n               (a & ~b & ~c & ~d) | \n               (a & b & c & d);\n\nendmodule\n", "result": "failed: 46 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a & b; // Perform AND operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // Define state encoding\n    parameter B = 1'b0, A = 1'b1; // B = 0, A = 1\n    reg state, next_state; // Current state, Next state\n\n    // State transition logic (combinational)\n    always @* begin\n        case (state)\n            B: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            A: begin\n                if (in == 0)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            default: next_state = B; // Default state if needed\n        endcase\n    end\n\n    // State update logic (sequential)\n    always @(posedge clk) begin\n        if (reset) \n            state <= B; // Reset to State B\n        else \n            state <= next_state; // Update state to next state\n    end\n\n    // Output logic (Moore machine output)\n    assign out = (state == B) ? 1 : 0; // Output based on state\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // calculating sum using XOR\n    assign sum = a ^ b ^ cin;\n    \n    // calculating carry-out using OR and AND operations\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n    logic xnor_out; // Intermediate wire to hold XNOR output\n\n    // Compute the XNOR of in1 and in2\n    xnor(xnor_out, in1, in2);\n\n    // Compute the XOR of the XNOR output and in3\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    assign mux_in[0] = 0; // ab = 00, output = 0\n    assign mux_in[1] = c; // ab = 01, output = c\n    assign mux_in[2] = c & d; // ab = 11, output = cd\n    assign mux_in[3] = d; // ab = 10, output = d\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // One-hot encoded state representation\n    reg state_A, state_B;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_A <= 1'b1;  // Reset to state A\n            state_B <= 1'b0;\n            z <= 0;\n        end else begin\n            case ({state_A, state_B})\n                2'b10: begin // State A\n                    if (x) begin\n                        state_A <= 1'b0; // Transition to State B\n                        state_B <= 1'b1;\n                        z <= 1; // Output z=1\n                    end else begin\n                        state_A <= 1'b1; // Remain in State A\n                        state_B <= 1'b0;\n                        z <= 0; // Output z=0\n                    end\n                end\n                2'b01: begin // State B\n                    if (x) begin\n                        state_A <= 1'b0; // Remain in State B\n                        state_B <= 1'b1;\n                        z <= 0; // Output z=0\n                    end else begin\n                        state_A <= 1'b0; // Remain in State B\n                        state_B <= 1'b1;\n                        z <= 1; // Output z=1\n                    end\n                end\n                default: begin\n                    state_A <= 1'b0; // Default to State B - shouldn't happen\n                    state_B <= 1'b0; // State A is invalid\n                    z <= 0; // Default output\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\n\t// Initial state\n\tinitial begin\n\t\tq = 0;\n\t\tstate = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\t// Logic to determine the next state of q\n\t\tif (a == 0 && b == 0) begin\n\t\t\tq <= q; // Hold state\n\t\tend else if (a == 0 && b == 1) begin\n\t\t\tq <= 1; // Set state\n\t\tend else if (a == 1 && b == 0) begin\n\t\t\tq <= 0; // Reset state\n\t\tend else if (a == 1 && b == 1) begin\n\t\t\tq <= ~q; // Toggle state\n\t\tend\n\t\tstate <= q; // The state output follows q\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        f = ( ~x[1] & ~x[2] & ~x[3] & ~x[4] ) |  // from (00, 00)\n            ( ~x[1] &  x[2] & ~x[3] &  x[4] ) |  // from (00, 10)\n            ( ~x[1] & ~x[2] &  x[3] & ~x[4] ) |  // from (11, 00)\n            (  x[1] & ~x[2] &  x[3] & ~x[4] ) |  // from (11, 01)\n            (  x[1] &  x[2] &  x[3] &  x[4] ) |  // from (11, 11)\n            (  x[1] & ~x[2] &  x[3] & ~x[4] ) |  // from (10, 00)\n            (  x[1] & ~x[2] &  x[3] &  x[4] ) |  // from (10, 01)\n            ( ~x[1] &  x[2] & ~x[3] &  x[4] );    // from (10, 10)\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    \n    // State encoding\n    typedef enum reg [2:0] {\n        S0 = 3'b000,\n        S1 = 3'b001,\n        S2 = 3'b010,\n        S3 = 3'b011,\n        S4 = 3'b100,\n        S5 = 3'b101,\n        S6 = 3'b110,\n        S_ERROR = 3'b111\n    } state_t;\n\n    state_t current_state, next_state;\n    \n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0; // On reset to state S0\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            current_state <= next_state; // Move to the next state\n        end\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Default output assignments\n        disc = 0;\n        flag = 0;\n        err = 0;\n        \n        case (current_state)\n            S0: begin\n                if (in) \n                    next_state = S1; \n                else \n                    next_state = S0; // stay in S0 on 0\n            end\n            \n            S1: begin\n                if (in) \n                    next_state = S2; \n                else \n                    next_state = S0; // reset on 0\n            end\n            \n            S2: begin\n                if (in) \n                    next_state = S3; \n                else \n                    next_state = S0; // reset on 0\n            end\n            \n            S3: begin\n                if (in) \n                    next_state = S4; \n                else \n                    next_state = S0; // reset on 0\n            end\n            \n            S4: begin\n                if (in) \n                    next_state = S5; \n                else \n                    next_state = S0; // reset on 0\n            end\n            \n            S5: begin\n                if (in) begin\n                    next_state = S6; // 6 ones, prepare to check for flag\n                end else begin\n                    disc = 1; // signal disc on transition to zero\n                    next_state = S0; // reset on 0\n                end\n            end\n            \n            S6: begin\n                if (in) begin\n                    err = 1; // more than 6 ones leads to error\n                    next_state = S_ERROR; \n                end else begin\n                    flag = 1; // signal flag on transition to zero\n                    next_state = S0; // reset on 0\n                end\n            end\n            \n            S_ERROR: begin\n                // Stay in ERROR until reset\n                next_state = S_ERROR; \n            end\n            \n            default: next_state = S0; // Default case for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State Definitions\n    typedef enum reg [1:0] {\n        IDLE,\n        SHIFT,\n        COUNT,\n        DONE\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] delay;\n    reg [9:0] cycle_count; // to count clock cycles for countdown\n    reg [3:0] remaining_time; // to keep track of remaining countdown time\n\n    // Detecting \"1101\" Sequence\n    reg [2:0] seq_detector; // 3 bits to hold the last 3 bits of data and current bit\n    parameter SEQ = 3'b101; // 1101 corresponds to a 3-bit version where we track the last bits\n\n    // Asynchronous reset handling\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            count <= 4'b0000; // Don't care when not counting\n            counting <= 0;\n            done <= 0;\n            delay <= 4'b0000;\n            cycle_count <= 0;\n            remaining_time <= 4'b0000;\n            seq_detector <= 3'b000;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // State Machine\n    always @(*) begin\n        next_state = current_state; // Default to hold state\n        case (current_state)\n            IDLE: begin\n                done = 0; // Not done until we complete counting\n                counting = 0; // Not counting\n                // Shift in the new bit\n                seq_detector = {seq_detector[1:0], data};\n                if (seq_detector == SEQ) begin\n                    next_state = SHIFT; // Move to SHIFT if pattern 1101 is detected\n                end\n            end\n            \n            SHIFT: begin\n                counting = 0;\n                if (cycle_count < 4) begin\n                    remaining_time = {remaining_time[2:0], data}; // Shift in the next bit\n                    cycle_count = cycle_count + 1; // Count number of bits shifted in\n                end else begin\n                    delay = remaining_time; // Set delay after 4 bits shifted\n                    next_state = COUNT; // Move to counting state\n                    cycle_count = 0; // Reset cycle counter\n                end\n            end\n            \n            COUNT: begin\n                counting = 1;\n                if (cycle_count < 1000) begin\n                    cycle_count = cycle_count + 1; // Count the clock cycles\n                end else if (remaining_time > 0) begin\n                    remaining_time = remaining_time - 1; // Decrease countdown\n                    cycle_count = 0; // Reset the cycle counter for the next 1000 cycles\n                end else begin\n                    done = 1; // Done counting\n                    next_state = DONE; // Move to DONE state\n                end\n            end\n            \n            DONE: begin\n                counting = 0; // No longer counting\n                if (ack == 1) begin\n                    next_state = IDLE; // Acknowledge received, reset to IDLE\n                    cycle_count = 0; // Reset both counters\n                    remaining_time = 4'b0000;\n                end\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\nreg [3:1] last_sensors; // to store previous sensor states\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Reset state: no sensors active, all flow rates enabled\n\t\tfr3 <= 1;\n\t\tfr2 <= 1;\n\t\tfr1 <= 1;\n\t\tdfr <= 0;\n\t\tlast_sensors <= 3'b000; // no sensors active\n\tend else begin\n\t\tlast_sensors <= s; // store current sensors read\n\n\t\t// Determine output based on sensor states\n\t\tif (s[3]) begin\n\t\t\t// Above s[3]: no flow\n\t\t\tfr3 <= 0;\n\t\t\tfr2 <= 0;\n\t\t\tfr1 <= 0;\n\t\t\tdfr <= 0;\n\t\tend else if (s[2]) begin\n\t\t\t// Between s[3] and s[2]\n\t\t\tfr3 <= 0; // inactive\n\t\t\tfr2 <= 1; // active\n\t\t\tfr1 <= 1; // active\n\t\t\tdfr <= (last_sensors < s) ? 1 : 0; // can increase flow\n\t\tend else if (s[1]) begin\n\t\t\t// Between s[2] and s[1]\n\t\t\tfr3 <= 0; // inactive\n\t\t\tfr2 <= 0; // inactive\n\t\t\tfr1 <= 1; // active\n\t\t\tdfr <= (last_sensors < s) ? 1 : 0; // can increase flow\n\t\tend else begin\n\t\t\t// Below s[1]: all flow rates active\n\t\t\tfr3 <= 1;\n\t\t\tfr2 <= 1;\n\t\t\tfr1 <= 1;\n\t\t\tdfr <= (last_sensors < s) ? 1 : 0; // can increase flow\n\t\tend\n\tend\nend\n\nendmodule\n", "result": "failed: 1807 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State definitions\n    typedef enum reg [2:0] {\n        IDLE = 3'b000,\n        START_BIT = 3'b001,\n        DATA_BITS = 3'b010,\n        STOP_BIT = 3'b011\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [2:0] bit_count;\n\n    // Sequential logic for state transitioning\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            done <= 0;\n            bit_count <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Combinatorial logic for next state and output\n    always @* begin\n        done = 0; // Reset done signal\n        next_state = current_state; // Default next state\n\n        case (current_state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START_BIT;\n            end\n            \n            START_BIT: begin\n                // Move to data bits after some time (one clock cycle later)\n                bit_count = 0;\n                next_state = DATA_BITS;\n            end\n            \n            DATA_BITS: begin\n                if (bit_count < 7) begin\n                    bit_count = bit_count + 1; // Increment bit counter\n                    next_state = DATA_BITS; // Stay in DATA_BITS\n                end else begin\n                    next_state = STOP_BIT; // After 8 bits, go to STOP_BIT\n                end\n            end\n            \n            STOP_BIT: begin\n                if (in == 1) begin // Stop bit detected\n                    done = 1; // Byte received correctly\n                    next_state = IDLE; // Go back to IDLE\n                end else if (in == 0) begin\n                    next_state = STOP_BIT; // Wait for the correct stop bit\n                end\n            end\n            \n            default: next_state = IDLE; // Safety fallback\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        IDLE = 3'b000, // idle\n        START = 3'b001, // received start bit\n        DATA = 3'b010, // receiving data bits\n        STOP = 3'b011, // received stop bit\n        ERROR = 3'b100 // error or waiting for next start\n    } state_t;\n\n    state_t state, next_state;\n    reg [2:0] bit_count; // 3 bits to count from 0 to 7 for data bits\n\n    // Sequential logic for state transitions and outputs\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_byte <= 8'b0;\n            bit_count <= 3'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state generation\n    always @* begin\n        // Default values\n        done = 0;\n        next_state = state;\n        \n        case (state)\n            IDLE: begin\n                if (in == 0) begin // Start bit detected\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                if (in == 0) begin // Still receiving start bit\n                    next_state = DATA;\n                    bit_count = 0; // Reset bit counter\n                end else begin\n                    next_state = IDLE; // If not low, go back to IDLE\n                end\n            end\n            \n            DATA: begin\n                if (bit_count < 7) begin\n                    out_byte[bit_count] = in; // Capture data bit\n                    bit_count = bit_count + 1;\n                    next_state = DATA; // Stay in DATA state\n                end else begin\n                    out_byte[7] = in; // Capture the last data bit\n                    next_state = STOP; // Move to STOP state\n                end\n            end\n            \n            STOP: begin\n                if (in == 1) begin // Stop bit detected\n                    done = 1; // Assert done signal\n                    next_state = IDLE; // Reset back to IDLE\n                end else begin\n                    next_state = ERROR; // Go to ERROR if stop bit not detected\n                end\n            end\n            \n            ERROR: begin\n                if (in == 1) begin // Saw a stop bit later\n                    next_state = IDLE; // Can reset now\n                end\n            end\n            \n            default: begin\n                next_state = IDLE; // Default state\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    reg [1:0] PHT[127:0]; // Pattern History Table: 128 entries, each 2 bits\n    reg [6:0] GHR; // Global History Register: 7 bits\n\n    // Initialize the PHT entries to 0 (reset state)\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            GHR <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                PHT[i] <= 2'b00; // Initialized to SNT (Strongly Not Taken)\n            end\n        end else begin\n            // Training logic\n            if (train_valid) begin\n                // Hashing for the PHT index\n                integer train_index = (train_pc ^ train_history) % 128;\n                // Update the PHT based on the training outcome\n                if (train_taken) begin\n                    if (PHT[train_index] < 2'b11) // if not in the strongly taken state\n                        PHT[train_index] <= PHT[train_index] + 1;\n                end else begin\n                    if (PHT[train_index] > 2'b00) // if not in the strongly not taken state\n                        PHT[train_index] <= PHT[train_index] - 1;\n                end\n                // Update the GHR with the outcome of the branch\n                if (train_mispredicted) \n                    GHR <= train_history; // Restore to the previous history if mispredicted\n                else \n                    GHR <= {GHR[5:0], train_taken}; // Shift in the new outcome\n            end\n\n            // Prediction logic\n            if (predict_valid) begin\n                // Hashing for the PHT index\n                integer predict_index = (predict_pc ^ GHR) % 128;\n                // Predict the branch direction and update the history\n                predict_taken <= (PHT[predict_index] >= 2'b10); // Strongly Taken or Weakly Taken\n                predict_history <= GHR; // Current state of the GHR\n                // Update GHR for the prediction stage\n                GHR <= {GHR[5:0], predict_taken}; // Update GHR for future predictions\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [2:0] {\n    WALK_LEFT    = 3'b000,\n    WALK_RIGHT   = 3'b001,\n    FALLING      = 3'b010,\n    DIGGING      = 3'b011,\n    SPLATTERED   = 3'b100\n} state_t;\n\nreg [4:0] fall_timer;    // Count falls, 5 bits for a maximum of 31\nstate_t current_state, next_state;\n\n// State Machine\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= WALK_LEFT;\n        fall_timer <= 0;\n    end else begin\n        current_state <= next_state;\n        if (current_state == FALLING) begin\n            fall_timer <= fall_timer + 1; // Increment fall timer\n        end else begin \n            fall_timer <= 0; // Reset timer when not falling\n        end\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    // Defaults\n    next_state = current_state;\n    walk_left = 0; \n    walk_right = 0; \n    aaah = 0; \n    digging = 0;\n\n    case (current_state)\n        WALK_LEFT: begin\n            if (~ground) begin\n                next_state = FALLING; \n                aaah = 1;\n            end else if (dig) begin\n                next_state = DIGGING;\n            end else if (bump_right) begin\n                next_state = WALK_RIGHT;\n            end else begin\n                walk_left = 1;\n            end\n        end\n\n        WALK_RIGHT: begin\n            if (~ground) begin\n                next_state = FALLING; \n                aaah = 1;\n            end else if (dig) begin\n                next_state = DIGGING;\n            end else if (bump_left) begin\n                next_state = WALK_LEFT;\n            end else begin\n                walk_right = 1;\n            end\n        end\n\n        FALLING: begin\n            if (ground) begin\n                if (fall_timer > 20) begin\n                    next_state = SPLATTERED;\n                end else begin\n                    next_state = (bump_right) ? WALK_LEFT : WALK_RIGHT;\n                end\n            end else begin\n                aaah = 1; // Still in the air\n            end\n        end\n\n        DIGGING: begin\n            if (~ground) begin\n                next_state = FALLING; \n                aaah = 1;\n            end else begin\n                digging = 1;\n                // Continue digging, no direction change\n            end\n        end\n\n        SPLATTERED: begin\n            walk_left = 0; \n            walk_right = 0; \n            aaah = 0; \n            digging = 0; // No actions after splattering\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State declaration\n    typedef enum logic [2:0] {\n        IDLE,\n        DETECT1,\n        DETECT2,\n        DETECT3,\n        SHIFT,\n        COUNTING,\n        NOTIFY\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic and Output logic\n    always_comb begin\n        // Default outputs\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (current_state)\n            IDLE: begin\n                if (data == 1) begin\n                    next_state = DETECT1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            DETECT1: begin\n                if (data == 1) begin\n                    next_state = DETECT2;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            DETECT2: begin\n                if (data == 0) begin\n                    next_state = DETECT3;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            DETECT3: begin\n                if (data == 1) begin\n                    next_state = SHIFT;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            \n            SHIFT: begin\n                shift_ena = 1; // Enable shifting\n                if (/* condition to shift 4 cycles */) begin\n                    next_state = COUNTING; // After shifting 4 cycles\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            \n            COUNTING: begin\n                counting = 1; // Indicate counting in progress\n                if (done_counting) begin\n                    next_state = NOTIFY;\n                end else begin\n                    next_state = COUNTING;\n                end\n            end\n            \n            NOTIFY: begin\n                done = 1; // Notify user\n                if (ack) begin\n                    next_state = IDLE; // Go back to idle after ack\n                end else begin\n                    next_state = NOTIFY;\n                end\n            end\n            \n            default: next_state = IDLE; // Safety case\n        endcase\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    integer i, j, n;\n    reg [255:0] next_q; // Register to hold the next state\n    \n    // Function to count the number of alive neighbors\n    function [3:0] count_neighbors;\n        input [255:0] current;\n        input integer row;\n        input integer col;\n        integer r, c;\n        integer alive_count;\n        begin\n            alive_count = 0;\n            for (r = -1; r <= 1; r = r + 1) begin\n                for (c = -1; c <= 1; c = c + 1) begin\n                    if (r != 0 || c != 0) begin\n                        alive_count = alive_count + current[{(row + r + 16) % 16, (col + c + 16) % 16}];\n                    end\n                end\n            end\n            count_neighbors = alive_count;\n        end\n    endfunction\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            next_q = 256'b0; // Reset the next state\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    n = count_neighbors(q, i, j);\n                    case (n)\n                        0: next_q[{i, j}] = 0;\n                        1: next_q[{i, j}] = 0;\n                        2: next_q[{i, j}] = q[{i, j}]; // Remain the same\n                        3: next_q[{i, j}] = 1;\n                        default: next_q[{i, j}] = 0; // 4 or more\n                    endcase\n                end\n            end\n            q <= next_q; // Update the current state to the next state\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    // State definitions\n    typedef enum reg [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10,\n        DIGGING = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Default output parameters\n    initial begin\n        walk_left = 1;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n    end\n\n    // State transition logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT; // Reset to walk left\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                aaah = 0;\n                digging = 0;\n                if (!ground) begin\n                    next_state = FALLING; // Fall\n                    aaah = 1;\n                end else if (dig) begin\n                    next_state = DIGGING; // Start digging\n                    digging = 1;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT; // Switch to walking right\n                end else begin\n                    next_state = WALK_LEFT; // Continue walking left\n                end\n                walk_left = 1;\n                walk_right = 0;\n            end\n\n            WALK_RIGHT: begin\n                aaah = 0;\n                digging = 0;\n                if (!ground) begin\n                    next_state = FALLING; // Fall\n                    aaah = 1;\n                end else if (dig) begin\n                    next_state = DIGGING; // Start digging\n                    digging = 1;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT; // Switch to walking left\n                end else begin\n                    next_state = WALK_RIGHT; // Continue walking right\n                end\n                walk_left = 0;\n                walk_right = 1;\n            end\n\n            FALLING: begin\n                aaah = 1; // Always aaah when falling\n                digging = 0;\n                if (ground) begin\n                    if (current_state == FALLING) begin\n                        // Resume walking in original direction\n                        if (walk_left) begin\n                            next_state = WALK_LEFT;\n                        end else begin\n                            next_state = WALK_RIGHT;\n                        end\n                    end\n                end else begin\n                    next_state = FALLING; // Stay in falling\n                end\n                walk_left = 0;\n                walk_right = 0;\n            end\n            \n            DIGGING: begin\n                aaah = 0;\n                digging = 1;\n                if (!ground) begin\n                    next_state = FALLING; // Fall\n                    aaah = 1;\n                end else begin\n                    next_state = DIGGING; // Continue digging\n                end\n                walk_left = 0;\n                walk_right = 0;\n            end\n\n            default: next_state = WALK_LEFT; // Reset state\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n    \n    initial begin\n        hh = 8'b00001000; // Start at 12:00 AM\n        mm = 8'b00000000;\n        ss = 8'b00000000;\n        pm = 0; // AM\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'b00001000; // 12 in BCD\n            mm <= 8'b00000000; // 0 in BCD\n            ss <= 8'b00000000; // 0 in BCD\n            pm <= 0; // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'd59) begin\n                ss <= 8'd0; // Reset seconds to 0\n                if (mm == 8'd59) begin\n                    mm <= 8'd0; // Reset minutes to 0\n                    if (hh == 8'd12) begin\n                        hh <= 8'd1; // Reset hours to 1\n                        pm <= ~pm; // Toggle PM/AM\n                    end else begin\n                        hh <= hh + 8'd1; // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 8'd1; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 8'd1; // Increment seconds\n            end\n        end\n    end\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum reg [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            \n            FALLING: begin\n                if (ground) begin\n                    if (current_state == WALK_LEFT)\n                        next_state = WALK_LEFT;\n                    else // current_state == WALK_RIGHT\n                        next_state = WALK_RIGHT;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            \n            default: begin\n                next_state = WALK_LEFT;\n            end\n        endcase\n    end\n\n    // State Register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT; // reset to walk left\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output Logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                aaah = 0;\n            end\n            \n            WALK_RIGHT: begin\n                walk_right = 1;\n                aaah = 0;\n            end\n            \n            FALLING: begin\n                aaah = 1; // falling state\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 16'b0;  // Reset all digits to 0\n\t\tend else begin\n\t\t\t// Increment the ones place\n\t\t\tif (q[3:0] == 9) begin\n\t\t\t\tq[3:0] <= 0;  // Reset ones place on overflow\n\t\t\t\tq[7:4] <= q[7:4] + 1;  // Increment tens place\n\t\t\tend else begin\n\t\t\t\tq[3:0] <= q[3:0] + 1;  // Increment ones place\n\t\t\tend\n\n\t\t\t// Tens place overflow check\n\t\t\tif (q[7:4] == 9 && q[3:0] == 9) begin\n\t\t\t\tq[7:4] <= 0; // Reset tens place on overflow\n\t\t\t\tq[11:8] <= q[11:8] + 1; // Increment hundreds place\n\t\t\tend\n\n\t\t\t// Hundreds place overflow check\n\t\t\tif (q[11:8] == 9 && q[7:4] == 9 && q[3:0] == 9) begin\n\t\t\t\tq[11:8] <= 0; // Reset hundreds place on overflow\n\t\t\t\tq[15:12] <= q[15:12] + 1; // Increment thousands place\n\t\t\tend\n\n\t\t\t// Check thousands place overflow\n\t\t\tif (q[15:12] == 9 && q[11:8] == 9 && q[7:4] == 9 && q[3:0] == 9) begin\n\t\t\t\tq[15:12] <= 0; // Reset thousands place on overflow\n\t\t\tend\n\t\tend\n\tend\n\n\t// Enable signals\n\tassign ena[1] = (q[3:0] == 9);      // Enable tens digit when ones reach 9\n\tassign ena[2] = (q[7:4] == 9) && (q[3:0] == 9); // Enable hundreds when tens reach 9 and ones are 9\n\tassign ena[3] = (q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9); // Enable thousands when hundreds, tens, and ones are 9\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\tassign out = sel ? b : a;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(*) begin\n\tcase (y)\n\t\t3'b000: Y2 = (w == 0) ? 0 : 0; // State A\n\t\t3'b001: Y2 = (w == 0) ? 0 : 1; // State B\n\t\t3'b010: Y2 = 1;                 // State C\n\t\t3'b011: Y2 = (w == 0) ? 1 : 0; // State D\n\t\t3'b100: Y2 = 1;                 // State E\n\t\t3'b101: Y2 = 1;                 // State F\n\t\tdefault: Y2 = 0;                // Default case (not used)\n\tendcase\nend\n\nendmodule\n", "result": "failed: 20 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\nassign motor = (vibrate_mode == 1) ? 1 : 0;   // If vibrate mode is enabled, turn on motor\nassign ringer = (vibrate_mode == 0) ? 1 : 0;  // If not in vibrate mode, turn on ringer\n\nendmodule\n", "result": "failed: 11 out of 19 samples.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Assign statement for AND gate\nassign out_assign = a & b;\n\n// Combinational always block for AND gate\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\n    assign zero = 0; // Assign the output to LOW (0)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (a == 0) \n            q <= 1; // Set q to 1 if a is 0\n        else \n            q <= 0; // Reset q to 0 if a is 1\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // State definitions\n    typedef enum {IDLE, INVERT_BITS, ADD_ONE, OUTPUT} state_t;\n    state_t current_state, next_state;\n    \n    // Internal signals\n    reg [1:0] carry; // This will hold the carry for the addition\n    reg inverted_bit;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= IDLE;\n            z <= 0;\n            carry <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Define the next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (!areset) \n                    next_state = INVERT_BITS;\n                else \n                    next_state = IDLE;\n            end\n            \n            INVERT_BITS: begin\n                inverted_bit = ~x; // invert the bits\n                carry = 0; // reset carry\n                next_state = ADD_ONE; // go to add one state\n            end\n            \n            ADD_ONE: begin\n                if (carry == 1) begin\n                    z = inverted_bit; // output the current inverted bit with carry\n                end else begin\n                    carry = 1; // signal to add one\n                end\n                next_state = OUTPUT; // move to output state\n            end\n            \n            OUTPUT: begin\n                z = inverted_bit + carry; // send out the result\n                next_state = INVERT_BITS; // loop back if more bits are coming\n            end\n            \n            default: next_state = IDLE; // Safety default\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic (state transition)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= A;  // Reset to state A\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Combinational logic (next state logic)\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default case for safety\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\nassign out[31:24] = in[7:0];   // Byte 3 becomes the first byte\nassign out[23:16] = in[15:8];  // Byte 2 becomes the second byte\nassign out[15:8]  = in[23:16]; // Byte 1 becomes the third byte\nassign out[7:0]   = in[31:24]; // Byte 0 becomes the last byte\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n    always_ff @(posedge clk) begin\n        if (r) \n            q <= 0; // Active high reset\n        else \n            q <= d; // Capture the input data\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x; // z is assigned the result of (x XOR y) AND x\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into q\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1;  // Shift left by 1\n                2'b01: q <= q << 8;  // Shift left by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic right shift by 1\n                2'b11: q <= {q[63], q[63:8]}; // Arithmetic right shift by 8\n                default: q <= q; // Default case for safety, retain current value\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 1164 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // Last input was '1'\n        S2 = 2'b10  // Last inputs were '10'\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n                z = 0; // No sequence detected\n            end\n            \n            S1: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S2;\n                z = 0; // No sequence detected\n            end\n            \n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1; // Sequence \"101\" detected\n                end else begin\n                    next_state = S0;\n                    z = 0; // No sequence detected\n                end\n            end\n            \n            default: begin\n                next_state = S0; \n                z = 0; // Safety\n            end\n        endcase\n    end\n\n    // State update logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) begin\n            current_state <= S0; // Asynchronous reset\n            z <= 0;\n        end else begin\n            current_state <= next_state; // Update state\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            E, F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w == 0) ? B : A;\n            B: next_state = (w == 0) ? C : D;\n            C: next_state = (w == 0) ? E : D;\n            D: next_state = (w == 0) ? F : A;\n            E: next_state = (w == 0) ? E : D;\n            F: next_state = (w == 0) ? C : D;\n            default: next_state = A; // default state\n        endcase\n    end\n    \n    // State Register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset to state A\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    // State definitions\n    typedef enum logic [1:0] {\n        IDLE       = 2'b00,\n        RECEIVE1   = 2'b01,\n        RECEIVE2   = 2'b10,\n        RECEIVE3   = 2'b11\n    } state_t;\n\n    // State variable\n    state_t current_state, next_state;\n\n    // Sequential logic for state transitions\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Combinational logic for next state and output\n    always_comb begin\n        // Default assignments\n        next_state = current_state;\n        done = 1'b0;\n        out_bytes = 24'b0;  // Default output\n\n        case (current_state)\n            IDLE: begin\n                if (in[3]) begin  // Transition if input byte indicates start\n                    next_state = RECEIVE1;\n                end\n            end\n            \n            RECEIVE1: begin\n                out_bytes[23:16] = in;  // Store first byte\n                next_state = RECEIVE2;\n            end\n            \n            RECEIVE2: begin\n                out_bytes[15:8] = in;  // Store second byte\n                next_state = RECEIVE3;\n            end\n            \n            RECEIVE3: begin\n                out_bytes[7:0] = in;  // Store third byte\n                done = 1'b1;         // Signal that message is done\n                next_state = IDLE;   // Go back to IDLE after complete message\n            end\n\n            default: next_state = IDLE; // Safety net\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\n// Y1 is asserted when the state is A (y[0]) and w is 1 (transition to B)\nassign Y1 = (y[0] == 1'b1 && w == 1'b1);\n\n// Y3 is asserted when we can transition to state D,\n// 1. from state B (y[1]) with w == 0,\n// 2. from state C (y[2]) with w == 0,\n// 3. from state D (y[3]) itself with w == 0\nassign Y3 = ((y[1] == 1'b1 && w == 1'b0) || \n             (y[2] == 1'b1 && w == 1'b0) || \n             (y[3] == 1'b1 && w == 1'b0));\n\nendmodule\n", "result": "failed: 95 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n// Assign the 3-bit input vector to the output vector\nassign outv = vec;   \n\n// Assign individual bits to corresponding outputs\nassign o0 = vec[0];  // Bit 0\nassign o1 = vec[1];  // Bit 1\nassign o2 = vec[2];  // Bit 2\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n    out = (b & ~d) | (a & c) | (b & d);\nend\n\nendmodule\n", "result": "failed: 121 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\tassign out_lo = in[7:0]; // Extract lower 8 bits\n\tassign out_hi = in[15:8]; // Extract upper 8 bits\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = ~(a | b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Using assign statement for out_assign\nassign out_assign = a ^ b;\n\n// Combinational always block for out_always_comb\nalways @* begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block for out_always_ff\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b; // Use non-blocking assignment for flip-flop\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\nassign Y2 = y[1] & ~w; // Logic for y[2]\nassign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w); // Logic for y[4]\n\nendmodule\n", "result": "failed: 27 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    assign out = in[sel]; // Assigning the selected bit to the output\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\t// Load the value from R into Q\n\t\t\tQ <= R;\n\t\tend else if (E) begin\n\t\t\t// Shift the register, take `w` as the new input\n\t\t\tQ <= w;\n\t\tend else begin\n\t\t\t// Retain the current value of Q\n\t\t\tQ <= Q;\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    // Define the D flip-flops\n    reg ff1, ff2, ff3;\n    \n    wire ff1_n = ~ff1; // Complement of ff1\n    wire ff2_n = ~ff2; // Complement of ff2\n    wire ff3_n = ~ff3; // Complement of ff3\n    \n    // Intermediate wires for gate outputs\n    wire y1, y2, y3;\n    \n    // Logic for the gates\n    assign y1 = x ^ ff1; // XOR gate\n    assign y2 = x & ff2_n; // AND gate\n    assign y3 = x | ff3_n; // OR gate\n    \n    // Flip-flop logic\n    always @(posedge clk) begin\n        ff1 <= y1;\n        ff2 <= y2;\n        ff3 <= y3;\n    end\n\n    // Output z: XNOR of the flip-flops' outputs\n    assign z = ~(ff1 ^ ff2 ^ ff3); // XNOR implemented using complement of XOR\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\nassign q = (b == 1'b1) || ((a == 1'b0) && (c || d)) || ((a == 1'b1) && (b == 1'b0) && (c)); \n\nendmodule\n", "result": "failed: 8 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load state from data\n        end else begin\n            // Calculate next state\n            next_q[0] = 0; // q[-1] is off\n            for (integer i = 0; i < 511; i = i + 1) begin\n                // Using immediate neighbors: left (q[i-1]), center (q[i]), right (q[i+1])\n                next_q[i + 1] = (q[i] == 1'b1 && q[i + 1] == 1'b1) ? 1'b0 :\n                                (q[i] == 1'b1 && q[i + 1] == 1'b0) ? 1'b1 :\n                                (q[i] == 1'b1 && q[i - 1] == 1'b0) ? 1'b1 :\n                                (q[i] == 1'b0 && q[i + 1] == 1'b0 && q[i - 1] == 1'b0) ? 1'b0 :\n                                (q[i] == 1'b0 && q[i + 1] == 1'b1) ? 1'b1 :\n                                (q[i] == 1'b0 && q[i - 1] == 1'b1) ? 1'b1 : \n                                1'b1; // Handles all other cases\n            end\n            next_q[511] = 0; // q[512] is off\n            \n            // Update state to the next state\n            q <= next_q;\n        end\n    end\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n// Define state encoding\ntypedef enum logic [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\n// State variable\nstate_t current_state, next_state;\n\n// Define the synchronous process\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) \n        current_state <= A; // Reset to state A\n    else \n        current_state <= next_state; // Move to next state\nend\n\n// Combinational logic for next state and output\nalways_comb begin\n    // Default values\n    out = 0;\n    next_state = current_state; // Stay in the current state by default\n\n    case (current_state)\n        A: begin\n            if (in) \n                next_state = B; // Input 1 transitions to B\n            // Keep next_state as A if in == 0\n        end\n        B: begin\n            if (in) \n                next_state = B; // Stay in B\n            else \n                next_state = C; // Input 0 transitions to C\n        end\n        C: begin\n            if (in) \n                next_state = D; // Input 1 transitions to D\n            else \n                next_state = A; // Input 0 transitions to A\n        end\n        D: begin\n            if (in) \n                next_state = B; // Input 1 transitions to B\n            else \n                next_state = C; // Input 0 transitions to C\n        end\n    endcase\n\n    // Output logic based on current state\n    case (current_state)\n        A, B, C: out = 0; // States A, B, C output 0\n        D: out = 1;       // State D outputs 1\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @* begin\n    case(c)\n        4'b0000: q = b; // when c = 0\n        4'b0001: q = e; // when c = 1\n        4'b0010: q = a; // when c = 2\n        4'b0011: q = d; // when c = 3\n        4'b0100: q = e; // when c = 4 (same output as conditions above may vary)\n        4'b0101: q = e; // when c = 5\n        4'b0110: q = e; // when c = 6\n        4'b0111: q = e; // when c = 7\n        4'b1000: q = a;  // when c = 8\n        4'b1001: q = b;  // when c = 9\n        4'b1010: q = c;  // when c = 10\n        4'b1011: q = d;  // when c = 11\n        4'b1100: q = e;  // when c = 12\n        4'b1101: q = f;  // when c = 13\n        4'b1110: q = e;  // when c = 14\n        4'b1111: q = f;  // when c = 15\n        default: q = 4'b0000; // when c is unknown\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tout = (sel) ? b : a; // If sel is 1, choose b; if sel is 0, choose a\n\tend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    wire q1, q2, q3;\n\n    // Instantiate the top_module thrice\n    top_module u1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[0]),\n        .Q(q1)\n    );\n\n    top_module u2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1]),\n        .r_in(r[1]),\n        .Q(q2)\n    );\n\n    top_module u3 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(q3)\n    );\n\n    always @(posedge clk) begin\n        if (L) begin\n            q <= r;\n        end else begin\n            q <= {q2 ^ q3, q1, q3};\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n\n// Temporary variable to hold previous state\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;        // Reset output to 0\n        prev_in <= 32'b0;    // Reset previous input to 0\n    end else begin\n        // Capture transition from 1 to 0\n        out <= out | (~in & prev_in);\n        prev_in <= in;       // Update previous input to current input\n    end\nend\n\nendmodule\n", "result": "failed: 91 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\n// On the positive edge of the clock, transfer the data from d to q\nalways @(posedge clk) begin\n    q <= d; // Non-blocking assignment to update q with the value of d\nend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire [8:0] sum; // 9 bits to hold overflow, if any\n\n    assign sum = {1'b0, a} + {1'b0, b}; // Extend to 9 bits for overflow detection\n    assign s = sum[7:0]; // Assign the lower 8 bits as the result\n\n    // Overflow condition checks\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]); // Overflow occurs if signs of a and b are the same but differ in s\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // Next State Logic\n    assign B3_next = state[7] && (1'b1); // B3 always goes to the next state on shift_ena\n    assign S_next = state[0] && (d == 0) ? state[0] : (d == 1) ? 1'b1 : 1'b0;\n    assign S1_next = state[1] && (d == 0) ? 1'b1 : (d == 1) ? 1'b0 : 1'b0;\n    assign Count_next = state[8] && (done_counting ? 1'b0 : 1'b1); // count stays in count while done_counting is low\n    assign Wait_next = state[9] && (done == 1'b1 && ack == 1'b1 ? 1'b0 : 1'b1); // wait goes back to state S showing ack\n\n    // Output Logic\n    assign done = state[9]; // done is high when in Wait\n    assign counting = state[8]; // counting is high when in Count\n    assign shift_ena = (state[4] || state[5] || state[6] || state[7]); // shift_ena high in states B0, B1, B2, B3\n\nendmodule\n", "result": "failed: 3046 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n\n// Sequential always block to handle clock and reset\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01; // Reset to weakly not-taken\n    end else if (train_valid) begin\n        if (train_taken) begin\n            // Increment condition\n            if (state < 2'b11)\n                state <= state + 1'b1;\n        end else begin\n            // Decrement condition\n            if (state > 2'b00)\n                state <= state - 1'b1;\n        end\n    end\n    // If train_valid is 0, maintain the current state\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @(*) begin\n        pos = 3'b0; // Default case (no bits are high)\n\n        // Loop through bits 0 to 7\n        if (in[0]) pos = 3'd0;\n        else if (in[1]) pos = 3'd1;\n        else if (in[2]) pos = 3'd2;\n        else if (in[3]) pos = 3'd3;\n        else if (in[4]) pos = 3'd4;\n        else if (in[5]) pos = 3'd5;\n        else if (in[6]) pos = 3'd6;\n        else if (in[7]) pos = 3'd7;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n    // Initialize outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check the scancode for each arrow key\n    case (scancode)\n        16'hE06B: left = 1;  // left arrow\n        16'hE072: down = 1;  // down arrow\n        16'hE074: right = 1; // right arrow\n        16'hE075: up = 1;    // up arrow\n        default: begin\n            // All outputs are already set to 0 by initialization\n        end\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n\twire [3:0] carry; // intermediate carry bits\n\n\t// Instantiate the first full adder\n\tfull_adder fa0 (\n\t\t.a(x[0]),\n\t\t.b(y[0]),\n\t\t.cin(1'b0),    // no carry-in for the least significant bit\n\t\t.sum(sum[0]),\n\t\t.cout(carry[0])\n\t);\n\n\t// Instantiate the second full adder\n\tfull_adder fa1 (\n\t\t.a(x[1]),\n\t\t.b(y[1]),\n\t\t.cin(carry[0]), // connect carry from the first adder\n\t\t.sum(sum[1]),\n\t\t.cout(carry[1])\n\t);\n\t\n\t// Instantiate the third full adder\n\tfull_adder fa2 (\n\t\t.a(x[2]),\n\t\t.b(y[2]),\n\t\t.cin(carry[1]), // connect carry from the second adder\n\t\t.sum(sum[2]),\n\t\t.cout(carry[2])\n\t);\n\t\n\t// Instantiate the fourth full adder\n\tfull_adder fa3 (\n\t\t.a(x[3]),\n\t\t.b(y[3]),\n\t\t.cin(carry[2]), // connect carry from the third adder\n\t\t.sum(sum[3]),\n\t\t.cout(carry[3])\n\t);\n\n\t// Assign the final carry-out to the 5th bit of sum\n\tassign sum[4] = carry[3];\n\nendmodule\n\nmodule full_adder (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput sum,\n\toutput cout\n);\n\tassign sum = a ^ b ^ cin; // Sum is obtained using XOR gates\n\tassign cout = (a & b) | (cin & (a ^ b)); // Carry-out is obtained using AND and OR gates\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0; // Reset history on asynchronous reset\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken}; // Load history on misprediction\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken}; // Shift in the new prediction\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\twire and1_out; // Intermediate wire for a AND b\n\twire and2_out; // Intermediate wire for c AND d\n\n\t// First AND gate\n\tassign and1_out = a & b;\n\n\t// Second AND gate\n\tassign and2_out = c & d;\n\n\t// OR gate for the two AND outputs\n\tassign out = and1_out | and2_out;\n\n\t// NOT gate for the output\n\tassign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    always @(posedge clk) begin\n        q <= d; // Capture the value of d on the rising edge of clk\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\n    reg [7:0] Q; // 8-bit shift register\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]}; // Shift operation: S goes to Q[0]\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C}) // Combine A, B, C to select one of Q[0] through Q[7]\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 1'b0; // Safety case\n        endcase\n    end\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n// Heater logic: on if in heating mode and too cold\nassign heater = mode && too_cold;\n\n// Air Conditioner logic: on if in cooling mode and too hot\nassign aircon = ~mode && too_hot;\n\n// Fan logic: on if heater is on, aircon is on, or fan is explicitly requested\nassign fan = heater || aircon || fan_on;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n    assign out_sop = (!a & b & !c & !d) |   // Minterm for 2\n                     (!a & b & c & d) |    // Minterm for 7\n                     (a & b & c & d);      // Minterm for 15\n\n    assign out_pos = (a | b | c | d) & \n                     (a | b | c | !d) & \n                     (!a | b | !c | d) & \n                     (!a | b | !c | !d) & \n                     (!a | b | c | !d) & \n                     (!a | !b | c | !d) & \n                     (!a | !b | !c | d) & \n                     (a | !b | c | !d) & \n                     (a | !b | !c | d);\n\nendmodule\n", "result": "failed: 30 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset state\n        end else begin\n            // Calculate the feedback from the tapped positions\n            q <= {q[31:1], (q[32] ^ q[21] ^ q[1] ^ q[0])}; // Shift right and compute feedback\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (b & ~d) | (~b & d) | a;\nendmodule\n", "result": "failed: 46 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n// Implementing the first 4-input NAND gate\nassign p1y = ~(p1a & p1b & p1c & p1d);\n\n// Implementing the second 4-input NAND gate\nassign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    integer i; // Loop variable\n\n    always @* begin\n        out = 0; // Initialize output\n        \n        // Count the number of '1's in the input vector\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Increment count if in[i] is '1'\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\n    assign out_both[0] = in[1] & in[2]; // Check in[1] and in[2]\n    assign out_both[1] = in[2] & in[3]; // Check in[2] and in[3]\n    assign out_both[2] = in[0] & in[1]; // Check in[0] and in[1]\n\n    assign out_any[1] = in[0] | in[1]; // Check in[0] and in[1]\n    assign out_any[2] = in[1] | in[2]; // Check in[1] and in[2]\n    assign out_any[3] = in[2] | in[3]; // Check in[2] and in[3]\n\n    assign out_different[0] = in[0] ^ in[3]; // Check in[0] and in[3] (wraps around)\n    assign out_different[1] = in[1] ^ in[0]; // Check in[1] and in[0]\n    assign out_different[2] = in[2] ^ in[1]; // Check in[2] and in[1]\n    assign out_different[3] = in[3] ^ in[2]; // Check in[3] and in[2]\n\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (a)\n\t\t\t3'b000: q = 16'h1232;\n\t\t\t3'b001: q = 16'haee0;\n\t\t\t3'b010: q = 16'h27d4;\n\t\t\t3'b011: q = 16'h5a0e;\n\t\t\t3'b100: q = 16'h2066;\n\t\t\t3'b101: q = 16'h64ce;\n\t\t\t3'b110: q = 16'hc526;\n\t\t\t3'b111: q = 16'h2f19;\n\t\t\tdefault: q = 16'h0000; // Default case (should not happen in this setup)\n\t\tendcase\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000;  // Reset the counter to 0\n\t\tend else if (slowena) begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000;  // Roll over to 0 after reaching 9\n\t\t\tend else begin\n\t\t\t\tq <= q + 1;  // Increment the counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    logic not_in2; // Intermediate signal for inversion of in2\n\n    // Invert in2\n    not(not_in2, in2);\n    \n    // AND operation\n    and(out, in1, not_in2);\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\nassign out = in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\tparameter A = 1'b0, B = 1'b1; \n\treg state, next_state;\n\n\t// Asynchronous reset and state transition on clock edge\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= B; // Reset to state B\n\t\tend else begin\n\t\t\tstate <= next_state; // Transition to next state\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = B; // Stay in B\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = A; // Go to A\n\t\t\t\tend\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = A; // Stay in A\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = B; // Go to B\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: next_state = B; // Default to state B\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(*) begin\n\t\tif (state == B) \n\t\t\tout = 1;\n\t\telse \n\t\t\tout = 0;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    // This always block handles the positive edge of the clock\n    always @(posedge clk) begin\n        q <= d; // Capture the input on the rising edge\n    end\n\n    // This always block handles the negative edge of the clock\n    always @(negedge clk) begin\n        q <= d; // Capture the input on the falling edge\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\n// XNOR logic implementation\nassign out = (a & b) | (~a & ~b);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule module_b(\n    input x,\n    input y,\n    output z\n);\n    assign z = (~x & ~y) | (x & y);\nendmodule\n\nmodule top_module(\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out;\n    wire b1_out, b2_out;\n    wire or_out, and_out;\n\n    // Instantiate module A\n    module_a A1 (.x(x), .y(y), .z(a1_out));\n    module_a A2 (.x(x), .y(y), .z(a2_out));\n\n    // Instantiate module B\n    module_b B1 (.x(x), .y(y), .z(b1_out));\n    module_b B2 (.x(x), .y(y), .z(b2_out));\n\n    // Logic for final output\n    assign or_out = a1_out | b1_out;\n    assign and_out = a2_out & b2_out;\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the register if load is high\n            q <= data;\n        end else begin\n            // Perform rotations based on ena\n            case (ena)\n                2'b01: begin\n                    // Rotate right by one bit\n                    q <= {q[0], q[99:1]}; // Shift right and wrap around\n                end\n                2'b10: begin\n                    // Rotate left by one bit\n                    q <= {q[98:0], q[99]}; // Shift left and wrap around\n                end\n                default: begin\n                    // Do not change q (for 2'b00 and 2'b11)\n                    q <= q;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n\t// Always block to implement synchronous reset and counting\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 10'b0; // Reset the counter to 0\n\t\tend else if (q < 999) begin\n\t\t\tq <= q + 1; // Increment the counter\n\t\tend else begin\n\t\t\tq <= 10'b0; // Wrap around to 0 after reaching 999\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n    assign out = ~in; // Output is the negation of the input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\nalways @(*) begin\n    // Default outputs\n    next_state = 10'b0000000000; // Reset\n\n    // Output initialization\n    out1 = 0;\n    out2 = 0;\n\n    // State transition\n    case (1'b1) // Using one-hot encoding\n        state[0]: begin // S0\n            if (in) next_state = 10'b0000000001; // Move to S1\n            else next_state = 10'b0000000000; // Stay at S0\n        end\n        state[1]: begin // S1\n            if (in) next_state = 10'b0000000010; // Move to S2\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[2]: begin // S2\n            if (in) next_state = 10'b0000000100; // Move to S3\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[3]: begin // S3\n            if (in) next_state = 10'b0000001000; // Move to S4\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[4]: begin // S4\n            if (in) next_state = 10'b0000010000; // Move to S5\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[5]: begin // S5\n            if (in) next_state = 10'b0000100000; // Move to S6\n            else next_state = 10'b0000100000; // Move to S8\n        end\n        state[6]: begin // S6\n            if (in) next_state = 10'b0000010000; // Move to S7\n            else next_state = 10'b0000000000; // Move to S9\n        end\n        state[7]: begin // S7\n            out2 = 1; // Output (0,1)\n            if (in) next_state = 10'b0000000111; // Stay at S7\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[8]: begin // S8\n            out1 = 1; // Output (1,0)\n            if (in) next_state = 10'b0000000001; // Move to S1\n            else next_state = 10'b0000000000; // Move to S0\n        end\n        state[9]: begin // S9\n            out1 = 1; // Output (1,1)\n            if (in) next_state = 10'b0000000001; // Move to S1\n            else next_state = 10'b0000000000; // Move to S0\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;      // Qold (no change)\n            2'b01: Q <= 0;      // Reset to 0\n            2'b10: Q <= 1;      // Set to 1\n            2'b11: Q <= ~Q;     // Toggle Q\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[0] + in[1] + in[2]; // Count the number of '1's in the 3-bit input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\nassign out[24] = (a == a);\nassign out[23] = (a == b);\nassign out[22] = (a == c);\nassign out[21] = (a == d);\nassign out[20] = (a == e);\nassign out[19] = (b == a);\nassign out[18] = (b == b);\nassign out[17] = (b == c);\nassign out[16] = (b == d);\nassign out[15] = (b == e);\nassign out[14] = (c == a);\nassign out[13] = (c == b);\nassign out[12] = (c == c);\nassign out[11] = (c == d);\nassign out[10] = (c == e);\nassign out[9]  = (d == a);\nassign out[8]  = (d == b);\nassign out[7]  = (d == c);\nassign out[6]  = (d == d);\nassign out[5]  = (d == e);\nassign out[4]  = (e == a);\nassign out[3]  = (e == b);\nassign out[2]  = (e == c);\nassign out[1]  = (e == d);\nassign out[0]  = (e == e);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    \n    // State encoding\n    typedef enum logic {S0, S1} state_t;\n    state_t state, next_state;\n    \n    // State update on rising edge of clk or reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= S0; // Reset to walk left\n        else \n            state <= next_state; // Transition to the next state\n    end\n    \n    // Determine the next state based on current state and inputs\n    always_comb begin\n        case (state)\n            S0: begin\n                if (bump_right || bump_left) begin\n                    next_state = S1; // Bumped left or right, switch to walking right\n                end else begin\n                    next_state = S0; // Stay in walking left\n                end\n            end\n            \n            S1: begin\n                if (bump_left || bump_right) begin\n                    next_state = S0; // Bumped left or right, switch to walking left\n                end else begin\n                    next_state = S1; // Stay in walking right\n                end\n            end\n            \n            default: next_state = S0; // Default case\n        endcase\n    end\n    \n    // Assign outputs based on state\n    always_comb begin\n        walk_left = (state == S0);\n        walk_right = (state == S1);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n    assign q = a & b; // q is 1 when a and b are both 1\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\n// Intermediate wires for AND gate outputs\nwire and1_out;\nwire and2_out;\nwire and3_out;\nwire and4_out;\n\n// Define the AND gates for p1y\nassign and1_out = p1a & p1b & p1c; // 3-input AND gate\nassign and2_out = p1d & p1e & p1f; // 3-input AND gate\n\n// Define the OR gate for p1y\nassign p1y = and1_out | and2_out; // OR of the two AND outputs\n\n// Define the AND gates for p2y\nassign and3_out = p2a & p2b; // 2-input AND gate\nassign and4_out = p2c & p2d; // 2-input AND gate\n\n// Define the OR gate for p2y\nassign p2y = and3_out | and4_out; // OR of the two AND outputs\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\n// State transition and output logic\nalways @(posedge clk) begin\n    // Output z based on current state y\n    case (y)\n        3'b000: z <= 0; // From state 000, outputs 0 regardless of x \n        3'b001: z <= 0; // From state 001, outputs 0 regardless of x\n        3'b010: z <= 0; // From state 010, outputs 0 regardless of x\n        3'b011: z <= 1; // From state 011, outputs 1\n        3'b100: z <= 1; // From state 100, outputs 1\n        default: z <= 0; // Default case\n    endcase\n    \n    // State transitions\n    case (y)\n        3'b000: Y0 <= (x ? 1'b1 : 1'b0); // To states 000 (when x=0), or 001 (when x=1)\n        3'b001: Y0 <= (x ? 3'b100 : 3'b001); // x=1 to 100, x=0 stays at 001\n        3'b010: Y0 <= (x ? 3'b001 : 3'b010); // x=0 stays at 010, x=1 goes to 001\n        3'b011: Y0 <= (x ? 3'b010 : 3'b001); // x=0 goes to 001, x=1 goes to 010\n        3'b100: Y0 <= (x ? 3'b100 : 3'b011); // x=0 goes to 011, stays at 100 if x=1\n        default: Y0 <= 3'b000; // Default to state 000\n    endcase\nend\n\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    assign out = ~(in1 | in2);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\nassign w = a;  // a -> w\nassign x = b;  // b -> x\nassign y = b;  // b -> y\nassign z = c;  // c -> z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 1'b0; // Asynchronous reset: Set q to 0\n        end else begin\n            q <= d; // On positive clock edge, set q to d\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0; // Select data0\n        3'b001: out = data1; // Select data1\n        3'b010: out = data2; // Select data2\n        3'b011: out = data3; // Select data3\n        3'b100: out = data4; // Select data4\n        3'b101: out = data5; // Select data5\n        default: out = 4'b0000; // If sel is not in 0-5 range, output 0\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] counter; // 10-bit counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the counter with provided data\n        end else begin\n            if (counter > 0) begin\n                counter <= counter - 1; // Decrement counter\n            end\n        end\n        tc <= (counter == 0); // Assert tc if counter is zero\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n\t// State encoding\n\tparameter S0 = 2'b00, \n\t          S1 = 2'b01, \n\t          S2 = 2'b10, \n\t          S3 = 2'b11, \n\t          S4 = 2'b100; // For S4 output only\n\n\treg [2:0] state, next_state;\n\n\t// Always block to handle state transitions\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) \n\t\t\tstate <= S0; // Reset state\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\t// FSM state transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: if (data) next_state = S1; else next_state = S0;\n\t\t\tS1: if (data) next_state = S2; else next_state = S0;\n\t\t\tS2: if (data) next_state = S3; else next_state = S0;\n\t\t\tS3: if (data) next_state = S4; else next_state = S0;\n\t\t\tS4: next_state = S4; // Stay in S4 once reached.\n\t\t\tdefault: next_state = S0; // Default case\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstart_shifting <= 0; // Reset output\n\t\telse if (state == S4)\n\t\t\tstart_shifting <= 1; // Set output when sequence is found\n\t\telse\n\t\t\tstart_shifting <= start_shifting; // Maintain output\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;  // Set output to zero when reset is high\n    end else begin\n        q <= d;      // Otherwise, set output to input d\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in & ~prev_in); // Detect 0 to 1 transitions\n        prev_in <= in;              // Update previous state\n    end\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001;  // Reset counter to 1\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001;  // Reset counter back to 1 after reaching 10\n    end else begin\n        q <= q + 1;    // Increment the counter\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n\n    initial begin\n        q = 3'b000; // Initialize q to 0\n    end\n\n    always @(posedge clk) begin\n        if (a == 1'b1) begin\n            q <= 3'b100; // If 'a' is high, set q to 4\n        end else begin\n            if (q < 3'b111) begin // Ensure we don't exceed the maximum value of 7\n                q <= q + 1;      // Increment q\n            end else begin\n                q <= 3'b000; // Reset q to 0 if it exceeds\n            end\n        end\n    end\n   \nendmodule\n", "result": "failed: 192 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 5'b00001; // Set LFSR to 1 on reset\n        end else begin\n            q <= {q[3:1], q[4] ^ q[2]}; // Shift left and XOR tap bits (5th and 3rd)\n        end\n    end\nendmodule\n", "result": "failed: 4412 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n\talways @(*) begin\n\t\t// Initialize result_is_zero to 0\n\t\tresult_is_zero = 0;\n\n\t\t// Perform addition or subtraction based on do_sub\n\t\tif (do_sub == 0) \n\t\t\tout = a + b;\n\t\telse \n\t\t\tout = a - b;\n\n\t\t// Check if the result is zero\n\t\tif (out == 0)\n\t\t\tresult_is_zero = 1;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // The function logic from analysis can be written directly.\n    // f = (x[4] & ~x[3] & x[2] & x[1]) | (x[4] & x[3] & ~x[2] & ~x[1]) |\n    //     (x[4] & x[3] & ~x[2] & x[1]) | (x[4] & ~x[3] & ~x[2] & x[1]) |\n    //     (x[4] & ~x[3] & x[2] & x[1]);\n    \n    assign f = (~x[4] & ~x[3] & x[2] & x[1]) | // 0001 - don't care (ignored)\n               (0 & x[4] & ~x[3]) | // 000 record - also don't care \n               (x[4] & x[3] & x[2]) | // Position for active when signals are [11, 01]\n               (x[4] & ~x[3] & x[2]); // Applying column position to get f\n\nendmodule\n", "result": "failed: 14 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @* begin\n    valid = 0; // default valid to 0\n    out = 0;   // default output to 0\n\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1; end // Key 0\n        8'h16: begin out = 4'd1; valid = 1; end // Key 1\n        8'h1e: begin out = 4'd2; valid = 1; end // Key 2\n        8'h26: begin out = 4'd3; valid = 1; end // Key 3\n        8'h25: begin out = 4'd4; valid = 1; end // Key 4\n        8'h2e: begin out = 4'd5; valid = 1; end // Key 5\n        8'h36: begin out = 4'd6; valid = 1; end // Key 6\n        8'h3d: begin out = 4'd7; valid = 1; end // Key 7\n        8'h3e: begin out = 4'd8; valid = 1; end // Key 8\n        8'h46: begin out = 4'd9; valid = 1; end // Key 9\n        default: begin out = 4'd0; valid = 0; end // Invalid key\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\talways @(*) begin\n\t\tout = (c && (b || a)) || (c && !d);\n\tend\nendmodule\n", "result": "failed: 72 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]};  // Shift in data at MSB\n        end else if (count_ena) begin\n            q <= q - 1;           // Decrement the counter\n        end\n    end\n\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in;  // Assign the value of input directly to the output\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n\n    reg [2:0] count; // 3 bits to count from 0 to 4\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 1; // Enable shift_ena\n            count <= 0;     // Reset counter\n        end else if (count < 3'b011) begin // Count from 0 to 3 (4 cycles)\n            count <= count + 1; // Increment counter\n        end else begin\n            shift_ena <= 0; // After 4 cycles, set shift_ena to 0\n        end\n    end\n\n    // Reset the count when shift_ena goes back to 0\n    always @(negedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == 3'b011) begin\n            count <= 0; // Reset the count to allow for future resets\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset to 0\n        end else begin\n            if (q == 4'b1111) begin\n                q <= 4'b0000; // Reset to 0 when count overflows\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n// Continuous assignment for the 2-to-1 mux\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Procedural assignment for alternative 2-to-1 mux\nalways @(*) begin\n    if (sel_b1 && sel_b2) \n        out_always = b; \n    else \n        out_always = a; \nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\n\tassign out = (b) || (b == 0 && c);\n\nendmodule\n", "result": "failed: 26 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state register\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state; // Update state\n    end\n\n    // Combinational logic for state transition\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1] == 1)\n                    next_state = B; // Device 1 requests\n                else if (r[2] == 1)\n                    next_state = C; // Device 2 requests\n                else if (r[3] == 1)\n                    next_state = D; // Device 3 requests\n                else\n                    next_state = A; // Stay in A\n            end\n            B: begin\n                if (r[1] == 1)\n                    next_state = B; // Stay in B\n                else\n                    next_state = A; // Reset to A\n            end\n            C: begin\n                if (r[2] == 1)\n                    next_state = C; // Stay in C\n                else\n                    next_state = A; // Reset to A\n            end\n            D: begin\n                next_state = A; // Assume authorized for device 3; reset to A\n            end\n            default: next_state = A; // Default to state A\n        endcase\n    end\n\n    // Combinational logic for output grants based on current state\n    always @(*) begin\n        g = 3'b000; // Initialize grants to zero\n        case (current_state)\n            A: g = 3'b000; // No grants in state A\n            B: g = 3'b100; // Grant to device 1\n            C: g = 3'b010; // Grant to device 2\n            D: g = 3'b001; // Grant to device 3\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0\n\t\tend else begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000; // Wrap around to 0 when 9 is reached\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\ntypedef enum reg [1:0] {\n    IDLE = 2'b00,\n    RECEIVING = 2'b01\n} state_t;\n\nstate_t state, next_state;\nreg [1:0] byte_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        byte_count <= 0;\n        done <= 0;\n    end else begin\n        state <= next_state;\n        if (state == RECEIVING) begin\n            if (byte_count == 2) begin\n                done <= 1; // Signal done\n                byte_count <= 0; // Reset counter for the next message\n            end else begin\n                done <= 0; // Ensure done is only high for one cycle\n            end\n        end\n    end\nend\n\nalways @* begin\n    case (state)\n        IDLE: begin\n            if (in[3] == 1) begin\n                next_state = RECEIVING;\n                byte_count = 0; // Reset first byte when starting to receive\n            end else begin\n                next_state = IDLE; // Continue to wait\n                byte_count = 0; // No bytes are received\n            end\n        end\n        \n        RECEIVING: begin\n            // Count the bytes received\n            if (byte_count < 2) begin\n                next_state = RECEIVING; // Remain in receiving state\n                byte_count = byte_count + 1; // Increment received byte count\n            end else begin\n                next_state = IDLE; // Transition back to IDLE after 3 bytes\n            end\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\tassign out = (sel == 1'b0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\nassign out_and = in[3] & in[2] & in[1] & in[0]; // 4-input AND\nassign out_or = in[3] | in[2] | in[1] | in[0];  // 4-input OR\nassign out_xor = in[3] ^ in[2] ^ in[1] ^ in[0]; // 4-input XOR\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    reg [2:0] y; // Present state register\n\n    // State transition logic\n    always @(*) begin\n        case (y)\n            3'b000: begin\n                if (x) begin\n                    y_next = 3'b001; // Next state 001\n                end else begin\n                    y_next = 3'b000; // Next state 000\n                end\n                z = 0;\n            end\n            3'b001: begin\n                if (x) begin\n                    y_next = 3'b100; // Next state 100\n                end else begin\n                    y_next = 3'b001; // Next state 001\n                end\n                z = 0;\n            end\n            3'b010: begin\n                if (x) begin\n                    y_next = 3'b001; // Next state 001\n                end else begin\n                    y_next = 3'b010; // Next state 010\n                end\n                z = 0;\n            end\n            3'b011: begin\n                if (x) begin\n                    y_next = 3'b010; // Next state 010\n                end else begin\n                    y_next = 3'b001; // Next state 001\n                end\n                z = 1;\n            end\n            3'b100: begin\n                if (x) begin\n                    y_next = 3'b100; // Next state 100\n                end else begin\n                    y_next = 3'b011; // Next state 011\n                end\n                z = 1;\n            end\n            default: begin\n                y_next = 3'b000; // Default to state 000\n                z = 0;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000; // Reset to state 000\n        end else begin\n            y <= y_next; // Update state to next state\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    // State definitions\n    typedef enum reg [2:0] {\n        state_A, // Waiting for reset de-assertion\n        state_B, // After reset, f=1\n        state_C, // Monitoring x for 1,0,1\n        state_D, // g=1, monitoring y\n        state_E, // Danl=y?\n        state_F  // g=0 (permanently until reset)\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Sequential logic for state transitions\n    always @(posedge clk or negedge resetn) begin\n        if(!resetn)\n            current_state <= state_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        // Defaults\n        next_state = current_state;\n        f = 0; // default output\n        g = 0; // default output\n\n        case (current_state)\n            state_A: begin\n                // Wait state, stay here while reset is active\n                if (!resetn) begin\n                    next_state = state_A; // Stay in A while resetn is low\n                end else begin\n                    next_state = state_B; // Move to B on reset de-asserted\n                end\n            end\n            state_B: begin\n                f = 1; // Set f = 1\n                next_state = state_C; // Transition to state_C\n            end\n            state_C: begin\n                // Observe x for 1,0,1\n                if (x == 1) begin\n                    next_state = state_D; // Go to state_D if 1 detected\n                end else if (x == 0) begin\n                    next_state = state_C; // Stay if 0 detected\n                end else begin\n                    next_state = state_C; // Stay if no condition met\n                end\n            end\n            state_D: begin\n                g = 1; // Set g = 1\n                next_state = state_E; // Transition to state_E\n            end\n            state_E: begin\n                if (y) begin\n                    // If y becomes 1, stay permanently in state_D\n                    next_state = state_D; \n                    g = 1;\n                end else begin\n                    // If y is not 1 within 2 clocks return to state_F\n                    next_state = state_F; \n                end\n            end\n            state_F: begin\n                g = 0; // If we reach here, g must be 0 permanently\n                // Remain here until reset\n            end\n            default: next_state = state_A; // Default case safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(negedge clk) begin\n    if (reset) begin\n        q <= 8'b00110100; // Reset to 0x34\n    end else begin\n        q <= d; // Assign input D to output Q\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Compute parity using XOR reduction\n    assign parity = ~(^in);\nendmodule\n", "result": "failed: 99 out of 100 samples.", "passed": false}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n\t// Default values\n    next_state = state; // Default next state is the current state\n    out = 0;            // Default output is 0\n\n\t// Transition logic for next_state\n\tcase (state)\n\t\t2'b00: begin // State A\n\t\t\tif (in) begin\n\t\t\t\tnext_state = 2'b01; // Go to State B when in=1\n\t\t\tend else begin\n\t\t\t\tnext_state = 2'b00; // Stay in State A when in=0\n\t\t\tend\n\t\tend\n\t\t2'b01: begin // State B\n\t\t\tif (in) begin\n\t\t\t\tnext_state = 2'b01; // Stay in State B when in=1\n\t\t\tend else begin\n\t\t\t\tnext_state = 2'b10; // Go to State C when in=0\n\t\t\tend\n\t\tend\n\t\t2'b10: begin // State C\n\t\t\tif (in) begin\n\t\t\t\tnext_state = 2'b11; // Go to State D when in=1\n\t\t\tend else begin\n\t\t\t\tnext_state = 2'b00; // Go to State A when in=0\n\t\t\tend\n\t\tend\n\t\t2'b11: begin // State D\n\t\t\tif (in) begin\n\t\t\t\tnext_state = 2'b01; // Go to State B when in=1\n\t\t\tend else begin\n\t\t\t\tnext_state = 2'b10; // Go to State C when in=0\n\t\t\tend\n\t\tend\n\tendcase\n\n\t// Output logic for Moore machine\n\tcase (state)\n\t\t2'b00: out = 0; // State A\n\t\t2'b01: out = 0; // State B\n\t\t2'b10: out = 0; // State C\n\t\t2'b11: out = 1; // State D\n\tendcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ~^ y);  // z is 1 when x and y are both same (both 0 or both 1)\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential Block: State Flip-Flops\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A; // reset state\n        end else begin\n            state <= next_state; // state transition\n        end\n    end\n\n    // Combinational Block: State Transition Logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w) next_state = B; // A (0) --1--> B\n                else next_state = A;    // A (0) --0--> A\n            end\n            B: begin\n                if (w) next_state = C; // B (0) --1--> C\n                else next_state = D;    // B (0) --0--> D\n            end\n            C: begin\n                if (w) next_state = E; // C (0) --1--> E\n                else next_state = D;    // C (0) --0--> D\n            end\n            D: begin\n                if (w) next_state = F; // D (0) --1--> F\n                else next_state = A;    // D (0) --0--> A\n            end\n            E: begin\n                if (w) next_state = E; // E (1) --1--> E\n                else next_state = D;    // E (1) --0--> D\n            end\n            F: begin\n                if (w) next_state = C; // F (1) --1--> C\n                else next_state = D;    // F (1) --0--> D\n            end\n            default: next_state = A; // default case to avoid latches\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == E); // z is high when in state E\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Reset all flip-flops to 0\n        end else begin\n            case (byteena)\n                2'b00: ; // Do nothing, no change\n                2'b01: q[7:0] <= d[7:0]; // Load lower byte\n                2'b10: q[15:8] <= d[15:8]; // Load upper byte\n                2'b11: begin\n                    q[7:0] <= d[7:0]; // Load lower byte\n                    q[15:8] <= d[15:8]; // Load upper byte\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    reg [7:0] previous;  // Register to hold the previous state of input\n\n    always @(posedge clk) begin\n        pedge <= (in & ~previous); // Set pedge to 1 where current input is 1 and previous was 0\n        previous <= in;            // Update the previous state to current input\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n    \n\talways @(posedge clock) begin\n\t\tp <= a; // p is assigned the value of a at the rising edge of clock\n\t\tif (a) begin\n\t\t\tq <= p; // q follows p, which is the value of a\n\t\tend\n\tend\n\t\nendmodule\n", "result": "failed: 179 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    reg [511:0] q_next; // Temporary register for next state\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load the initial state\n        end else begin\n            // Compute the next state based on the Rule 90 definition\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                if (i == 0) begin\n                    q_next[i] = 0 ^ q[i+1]; // Left boundary is 0\n                end else if (i == 511) begin\n                    q_next[i] = q[i-1] ^ 0; // Right boundary is 0\n                end else begin\n                    q_next[i] = q[i-1] ^ q[i+1]; // Normal case\n                end\n            end\n            q <= q_next; // Update state\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    // Calculate out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i] & in[i + 1];\n        end\n    endgenerate\n\n    // Calculate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i - 1] | in[i];\n        end\n    endgenerate\n\n    // Calculate out_different\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : gen_out_different\n            assign out_different[i] = (in[i] ^ in[(i + 1) % 100]);\n        end\n    endgenerate\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\n    always @(ena or d) begin\n        if (ena) \n            q <= d; // Assign `d` to `q` when `ena` is high\n        // No else part because `q` retains its previous value when `ena` is low\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Select the appropriate 4 bits from the input based on the value of sel\n    assign out = in[sel * 4 +: 4];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\n    always_comb begin\n        case(sel)\n            4'd0: out = a; // select input a\n            4'd1: out = b; // select input b\n            4'd2: out = c; // select input c\n            4'd3: out = d; // select input d\n            4'd4: out = e; // select input e\n            4'd5: out = f; // select input f\n            4'd6: out = g; // select input g\n            4'd7: out = h; // select input h\n            4'd8: out = i; // select input i\n            default: out = 16'b1111111111111111; // unused selections\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Calculate the bitwise OR of the inputs\n    assign out_or_bitwise = a | b;\n    \n    // Calculate the logical OR of the inputs\n    assign out_or_logical = |(a | b); // logical OR is true if any bit is 1\n\n    // Calculate the NOT of both inputs\n    assign out_not = {~b, ~a}; // {upper_half, lower_half}\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n    case (state)\n        4'b0001: // State A\n            if (in) next_state = 4'b0010; // to B\n            else next_state = 4'b0001; // stay in A\n            \n        4'b0010: // State B\n            if (in) next_state = 4'b0010; // stay in B\n            else next_state = 4'b0100; // to C\n            \n        4'b0100: // State C\n            if (in) next_state = 4'b1000; // to D\n            else next_state = 4'b0001; // to A\n            \n        4'b1000: // State D\n            if (in) next_state = 4'b0010; // to B\n            else next_state = 4'b0100; // to C\n            \n        default: next_state = 4'b0001; // default to A\n    endcase\nend\n\nassign out = state[3]; // Output high when in state D (4'b1000)\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @* begin\n    if (a < b)\n        min = a;\n    else\n        min = b;\n\n    if (c < min)\n        min = c;\n\n    if (d < min)\n        min = d;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\nassign out_and = a & b;           // AND operation\nassign out_or = a | b;            // OR operation\nassign out_xor = a ^ b;           // XOR operation\nassign out_nand = ~(a & b);       // NAND operation\nassign out_nor = ~(a | b);        // NOR operation\nassign out_xnor = ~(a ^ b);       // XNOR operation\nassign out_anotb = a & ~b;        // AND NOT operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n\tassign out = (~c) | (b & d) | ((~b) & (~d)); // Derived output logic\n\nendmodule\n", "result": "failed: 108 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    // State definitions\n    typedef enum logic [1:0] {\n        A = 2'b00, // State A\n        B = 2'b01  // State B\n    } state_t;\n\n    // Register to hold the current and next states\n    state_t current_state, next_state;\n    \n    // Count of 'w' = 1 occurrences\n    integer count_w;\n\n    // Sequential logic for state transitions\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;\n            count_w <= 0;\n            z <= 0;\n        end else begin\n            current_state <= next_state;\n            // Process z based on counting after three cycles in B\n            if (current_state == B && count_w == 2) begin\n                z <= 1;\n            end else begin\n                z <= 0;\n            end\n        end\n    end\n\n    // Combinational logic to determine next state and count\n    always_ff @(current_state or s or w) begin\n        case (current_state)\n            A: begin\n                if (s) begin\n                    next_state = B;\n                    count_w = 0; // reset the count when moving to state B\n                end else begin\n                    next_state = A; // stay in A\n                end\n            end\n            \n            B: begin\n                // Update count based on w\n                count_w = count_w + w;\n                if (count_w == 3) begin\n                    next_state = B; // remain in B for next evaluation\n                end else begin\n                    next_state = B; // still evaluating\n                end\n            end\n            \n            default: begin\n                next_state = A; // Default to state A (reset)\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out = { {24{in[7]}}, in }; // Concatenate 24 copies of in[7] followed by in\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    reg [3:0] shift_reg; // 4-bit shift register\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000; // Reset all bits to 0\n        end else begin\n            shift_reg <= {shift_reg[2:0], in}; // Shift left and input new data\n        end\n    end\n\n    assign out = shift_reg[3]; // Output the last bit of the shift register\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n    \nalways @(*) begin\n    if (in[3]) // Check MSB first\n        pos = 2'b11; // Position of bit 3\n    else if (in[2])\n        pos = 2'b10; // Position of bit 2\n    else if (in[1])\n        pos = 2'b01; // Position of bit 1\n    else if (in[0])\n        pos = 2'b00; // Position of bit 0\n    else\n        pos = 2'b00; // If nothing is high, output should be zero\nend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    reg state; // state variable (0 = OFF, 1 = ON)\n\n    // State updating process\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // Reset to OFF state\n        end else begin\n            case (state)\n                0: begin // OFF state\n                    if (j == 1) begin\n                        state <= 1; // Transition to ON\n                    end\n                    // If j == 0, stay in OFF\n                end\n                1: begin // ON state\n                    if (k == 1) begin\n                        state <= 0; // Transition to OFF\n                    end\n                    // If k == 0, stay in ON\n                end\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(state) begin\n        out = state; // Output depends on the current state\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n  \n\tassign out = 0; // Continuously drive the output to logic low (0)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n    assign one = 1; // Continuously assign logic high to the output.\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    integer i;\n\n    always @* begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    logic xor_out; // Temporary wire to hold the XOR output\n\n    // Calculate the XOR output\n    assign xor_out = in ^ out;\n\n    // D flip-flop behavior\n    always_ff @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset to zero\n        end else if (load) begin\n            q <= data; // Load data into shift register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right and set MSB to zero\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\nassign f = ( ~x3 & x2 ) | ( x3 & x1 ) | ( x3 & x2 );\n\nendmodule\n", "result": "failed: 2 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b00000000; // Reset output to 0\n    end else begin\n        q <= d; // Assign input to output on clock edge\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    // Compute the logical AND for all inputs\n    assign out_and = &in;  // & is the reduction AND operator\n    \n    // Compute the logical OR for all inputs\n    assign out_or = |in;   // | is the reduction OR operator\n\n    // Compute the logical XOR for all inputs\n    assign out_xor = ^in;  // ^ is the reduction XOR operator\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\n\tassign sum = a ^ b;  // XOR operation for sum\n\tassign cout = a & b; // AND operation for carry-out\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Reset if not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty; \n        else \n            keep_driving = 0; // Stop driving if arrived\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n// State Encoding\ntypedef enum logic [1:0] {\n    OFF = 1'b0,\n    ON = 1'b1\n} state_t;\n\nstate_t current_state, next_state;\n\n// State Transition Process\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= OFF;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next State Logic\nalways_comb begin\n    case (current_state)\n        OFF: begin\n            if (j) begin\n                next_state = ON;\n            end else begin\n                next_state = OFF;\n            end\n        end\n        ON: begin\n            if (k) begin\n                next_state = OFF;\n            end else begin\n                next_state = ON;\n            end\n        end\n        default: next_state = OFF; // default case to handle unforeseen states\n    endcase\nend\n\n// Output Logic\nalways_comb begin\n    case (current_state)\n        OFF: out = 1'b0;\n        ON: out = 1'b1;\n        default: out = 1'b0; // default case to handle unforeseen states\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    wire [31:0] concatenated_result;\n\n    // Concatenate the six input vectors and append two 1's\n    assign concatenated_result = {a, b, c, d, e, f, 2'b11};\n\n    // Split the concatenated result into output vectors\n    assign w = concatenated_result[31:24];\n    assign x = concatenated_result[23:16];\n    assign y = concatenated_result[15:8];\n    assign z = concatenated_result[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    \n    assign q = (a == 0 && b == 0 && c == 0 && d == 0) ? 1 :\n               (a == 0 && b == 1 && c == 0 && d == 0) ? 0 :\n               (a == 0 && b == 0 && c == 1 && d == 1) ? 1 :\n               (a == 1 && b == 0 && c == 0 && d == 1) ? 1 :\n               (a == 0 && b == 1 && c == 1 && d == 0) ? 1 :\n               (a == 1 && b == 1 && c == 1 && d == 0) ? 0 :\n               (a == 1 && b == 0 && c == 1 && d == 0) ? 1 :\n               (a == 0 && b == 1 && c == 0 && d == 1) ? 0 :\n               (a == 1 && b == 0 && c == 1 && d == 1) ? 0 :\n               (a == 1 && b == 1 && c == 1 && d == 1) ? 1 : 0;\n\nendmodule\n", "result": "failed: 18 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = a & b; // Perform the AND operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n\t// State encoding\n\ttypedef enum logic [0:0] {\n\t\tB = 1'b0, // State B\n\t\tA = 1'b1  // State A\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\n\t// State transition logic\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= B; // On reset, go to State B\n\t\tend else begin\n\t\t\tcurrent_state <= next_state; // Update state on clock edge\n\t\tend\n\tend\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tB: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = B; // Stay in B\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = A; // Go to A\n\t\t\t\tend\n\t\t\tend\n\t\t\tA: begin\n\t\t\t\tif (in) begin\n\t\t\t\t\tnext_state = A; // Stay in A\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = B; // Go to B\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Output logic based on the current state\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout <= 1; // State B output\n\t\tend else begin\n\t\t\tcase (current_state)\n\t\t\t\tB: out <= 1; // Output for state B\n\t\t\t\tA: out <= 0; // Output for state A\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // Calculate the sum using XOR operations\n    assign sum = a ^ b ^ cin;\n    \n    // Calculate the carry out using AND and OR operations\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n    // Intermediate signal to store XNOR output\n    logic xnor_output;\n\n    // Implementing XNOR logic\n    assign xnor_output = ~(in1 ^ in2);\n\n    // Implementing XOR logic using the output of the XNOR gate and in3\n    assign out = xnor_output ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    // Connection to the 4-to-1 multiplexer inputs\n    assign mux_in[0] = 0; // When cd = 00, output is 0\n    assign mux_in[1] = 1; // When cd = 01, output is 1\n    assign mux_in[2] = (c == 1) ? 1 : 0; // When cd = 11, output is 1\n    assign mux_in[3] = (c == 1) ? 1 : 0; // When cd = 10, output is 1\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // State encoding\n    reg [1:0] state, next_state;\n    \n    // State definitions\n    parameter A = 2'b01, B = 2'b10;\n\n    // Sequential logic for state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A; // Reset state to A\n        end else begin\n            state <= next_state; // Transition to next state\n        end\n    end\n\n    // Combinational logic to determine next state and output\n    always @(*) begin\n        case (state)\n            A: begin\n                z = (x == 1) ? 1 : 0; // Output based on input when in state A\n                next_state = (x == 1) ? B : A; // Transition to B if x == 1\n            end\n            B: begin\n                z = (x == 0) ? 1 : 0; // Output based on input when in state B\n                next_state = B; // Stay in B regardless of x\n            end\n            default: begin\n                z = 0; // Default output\n                next_state = A; // Default state\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\n// State encoding appropriately based on analysis\nalways @(posedge clk) begin\n    // Update the flip-flop to hold the state\n    state <= (state & ~(a & b)) | (a & ~b); // From inferred waveforms\n    \n    // Update the output q based on the memory state\n    if (state) begin\n        q <= a & b; // q logic based on inputs and state\n    end else begin\n        q <= 0; // Reset q when state is inactive\n    end\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    assign f = ( !x[4] && !x[3] && !x[1] && !x[2]) || // 00 -> 00\n                ( !x[4] && !x[3] &&  x[1] && !x[2]) || // 00 -> 10\n                (  x[3] &&  x[4] && !x[1] && !x[2]) || // 11 -> 00\n                (  x[3] &&  x[4] && !x[1] &&  x[2]) || // 11 -> 01\n                (  x[3] &&  x[4] &&  x[1] &&  x[2]) || // 11 -> 11\n                (  x[3] && !x[4] && !x[1] && !x[2]) || // 10 -> 00\n                (  x[3] && !x[4] && !x[1] &&  x[2]) || // 10 -> 01\n                (  x[3] && !x[4] &&  x[1] && !x[2]) ;  // 10 -> 10\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S0 = 3'b000, // Initial state\n        S1 = 3'b001, // 1 one\n        S2 = 3'b010, // 2 ones\n        S3 = 3'b011, // 3 ones\n        S4 = 3'b100, // 4 ones\n        S5 = 3'b101, // 5 ones\n        S6 = 3'b110, // 6 ones (flag)\n        S7 = 3'b111  // 7 ones or more (error)\n    } state_t;\n\n    state_t state, next_state;\n\n    // Sequential logic: State transition\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinational logic: Next state logic and output logic\n    always @* begin\n        next_state = state; // Default to stay in current state\n        disc = 0;\n        flag = 0;\n        err = 0; \n\n        case (state)\n            S0: begin\n                if (in) next_state = S1;  // Received a '1'\n            end\n            S1: begin\n                if (in) next_state = S2;  // Received another '1'\n                else next_state = S0;      // Reset on '0'\n            end\n            S2: begin\n                if (in) next_state = S3;  // Received another '1'\n                else next_state = S0;      // Reset on '0'\n            end\n            S3: begin\n                if (in) next_state = S4;  // Received another '1'\n                else next_state = S0;      // Reset on '0'\n            end\n            S4: begin\n                if (in) next_state = S5;  // Received another '1'\n                else next_state = S0;      // Reset on '0'\n            end\n            S5: begin\n                if (in) next_state = S6;  // Received another '1'\n                else begin\n                    disc = 1;              // 5 consecutive '1's, need to discard next\n                    next_state = S0;      // Reset on '0'\n                end\n            end\n            S6: begin\n                if (in) next_state = S7;  // Received another '1' => Error\n                else begin\n                    flag = 1;              // Recognized flag\n                    next_state = S0;      // Reset on '0'\n                end\n            end\n            S7: begin\n                err = 1;                  // Error state due to too many '1's\n                if (!in) next_state = S0; // Reset on '0'\n            end\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n// Define states\ntypedef enum logic [1:0] {\n    SEARCHING,  // 00 - searching for pattern\n    DELAYING,   // 01 - received pattern, shifting delay\n    COUNTING,   // 10 - counting down\n    DONE        // 11 - finished counting\n} state_t;\n\nstate_t state, next_state;\n\nreg [3:0] delay;\nreg [11:0] cycle_counter; // Will count up to (delay + 1) * 1000\n\n// Pattern detect shift register\nreg [3:0] pattern_shift;\n\n// State transition\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= SEARCHING;\n        count <= 4'bxxxx; // Don't care\n        counting <= 1'b0;\n        done <= 1'b0;\n        cycle_counter <= 12'd0;\n        pattern_shift <= 4'b0000;\n        delay <= 4'b0000;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways_comb begin\n    next_state = state;\n\n    case (state)\n        SEARCHING: begin\n            done = 1'b0;\n            counting = 1'b0;\n            pattern_shift = {pattern_shift[2:0], data};  // Shift in new bit\n            if (pattern_shift == 4'b1101) begin\n                next_state = DELAYING;\n                delay = 4'b0000; // Reset delay for new input\n            end\n        end\n        DELAYING: begin\n            if (delay < 4'd15) begin // Only accept 4 bits\n                delay = {delay[2:0], data}; // Shift in 4 bits\n                if (delay[3] == 1 && data == 0) begin \n                    next_state = COUNTING;\n                    cycle_counter = (delay + 1) * 1000; // Load cycle counter\n                    counting = 1'b1;\n                end\n            end\n        end\n        COUNTING: begin\n            done = 1'b0;\n            if (cycle_counter > 0) begin\n                cycle_counter = cycle_counter - 1;\n                if (cycle_counter[9:0] == 10'd999) begin\n                    count = delay; // Set count to delay\n                end\n            end else begin\n                next_state = DONE; // Transition to done state\n            end\n        end\n        DONE: begin\n            counting = 1'b0;\n            done = 1'b1;\n            count = 4'bxxxx; // Don't care\n            if (ack) begin\n                next_state = SEARCHING; // Acknowledge and reset\n            end\n        end\n    endcase\nend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n    reg [3:1] prev_s;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the state machine\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n            prev_s <= 0; // No sensors asserted\n        end else begin\n            // Update the flow outputs based on the sensor states\n            case (1'b1)\n                (s[3]) : begin // Above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                    prev_s <= s; // Update previous sensor state\n                end\n                (s[2] && !s[3]) : begin // Between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (prev_s[1] == 0) ? 1 : 0; // Increase flow if moved up\n                    prev_s <= s; \n                end\n                (s[1] && !s[2]) : begin // Between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (prev_s[2] == 0) ? 1 : 0; // Increase flow if moved up\n                    prev_s <= s; \n                end\n                (!s[1]) : begin // Below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 0; // dfr is not necessary here\n                    prev_s <= s; \n                end\n                default: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                    prev_s <= s; \n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 1346 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    reg [3:0] state; // FSM state register\n    reg [3:0] bit_count; // Count of received bits\n\n    // Define state encoding\n    localparam IDLE         = 4'd0,\n               START_BIT    = 4'd1,\n               RECEIVING     = 4'd2,\n               STOP_BIT      = 4'd3,\n               DONE          = 4'd4;\n\n    // State transition\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n            done <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    // Wait for start bit (0)\n                    if (in == 0) begin\n                        state <= START_BIT;\n                    end\n                    done <= 0; // Reset done signal\n                end\n                START_BIT: begin\n                    // Proceed to receiving bits after start bit\n                    state <= RECEIVING;\n                    bit_count <= 4'd0; // Reset bit counter\n                end\n                RECEIVING: begin\n                    // Count the number of bits received\n                    if (in == 1'b0) begin // Make sure we're not receiving wrong data\n                        bit_count <= bit_count + 1;\n                        if (bit_count == 4'd7) begin\n                            state <= STOP_BIT; // After 8 bits, go to stop bit state\n                        end\n                    end\n                end\n                STOP_BIT: begin\n                    // Waiting for stop bit (1)\n                    if (in == 1) begin\n                        state <= DONE; // If we get a correct stop bit, we are done\n                    end else begin\n                        state <= RECEIVING; // If not, revert to receiving state\n                    end\n                end\n                DONE: begin\n                    done <= 1; // Set done signal high\n                    if (in == 0) begin\n                        state <= START_BIT; // Restart the process upon detecting a start bit\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    // State definition\n    typedef enum reg [2:0] {\n        IDLE, // waiting for start bit\n        START, // detected start bit\n        DATA, // receiving data bits\n        STOP, // waiting for stop bit\n        DONE // valid byte received\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] bit_count; // for receiving 8 bits\n\n    // Synchronous reset and state transition\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'b0;\n            done <= 0;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state;\n        done = 0; // default done signal\n        case (state)\n            IDLE: begin\n                if (in == 0) begin // start bit detected\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                next_state = DATA;\n                bit_count = 0; // Reset bit counter\n            end\n            \n            DATA: begin\n                if (bit_count < 8) begin\n                    next_state = DATA;\n                end else begin\n                    next_state = STOP;\n                end\n            end\n            \n            STOP: begin\n                if (in == 1) begin // stop bit detected\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                done = 1; // assert done when we are in DONE state\n                next_state = IDLE; // Return to IDLE to wait for next byte\n            end\n            \n            default: next_state = IDLE; // safety state\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state == DATA) begin\n            out_byte[bit_count] <= in; // Shift in data bits\n            bit_count <= bit_count + 1;\n        end\n    end\n      \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    reg [6:0] ghr; // Global History Register\n    reg [1:0] pht [127:0]; // Pattern History Table\n\n    wire [6:0] index; // PHT index\n    wire [6:0] ghr_plus_train;\n  \n    // Calculate the index using XOR of GHR and lower bits of PC\n    assign index = ghr ^ predict_pc[6:0];\n\n    // GHR update behavior\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            ghr <= 7'b0; // Reset GHR\n            // Reset PHT to 0 or any initial state if needed\n            integer i;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b00; // Initialize PHT counters\n            end\n        end else begin\n            // Handle training first if both predictions and training are valid\n            if (train_valid) begin\n                // Update the PHT based on training outcome\n                case(pht[index]) // 2-bit saturating counter behavior\n                    2'b00: if (train_taken) pht[index] <= 2'b01;\n                    2'b01: if (train_taken) pht[index] <= 2'b10; else pht[index] <= 2'b00;\n                    2'b10: if (train_taken) pht[index] <= 2'b11; else pht[index] <= 2'b01;\n                    2'b11: if (~train_taken) pht[index] <= 2'b10;\n                endcase\n                \n                // Update GHR based on training\n                ghr <= train_history;\n                \n                // Reset GHR to the state after mispredict if needed\n                if (train_mispredicted) \n                    ghr <= train_history; // In case of a misprediction revert changes\n            end\n            \n            // Prediction Logic (if valid)\n            if (predict_valid) begin\n                // Provide prediction based on PHT before any potential updates\n                case(pht[index]) // Using the state before updates\n                    2'b00, 2'b01: predict_taken <= 0; // Predict not taken\n                    2'b10, 2'b11: predict_taken <= 1; // Predict taken\n                endcase\n                \n                // Output current GHR after potential updates\n                predict_history <= ghr;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n// State definitions\ntypedef enum logic [2:0] {\n    STATE_WALK_LEFT,\n    STATE_WALK_RIGHT,\n    STATE_FALL,\n    STATE_DIG,\n    STATE_SPLAT\n} State;\n\nState current_state, next_state;\nreg [4:0] fall_counter; // 5 bits to count up to 20\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= STATE_WALK_LEFT;\n        fall_counter <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\nalways @(*) begin\n    // Default outputs\n    walk_left = 0;\n    walk_right = 0;\n    aaah = 0;\n    digging = 0;\n    \n    // Output and state logic\n    case (current_state)\n        STATE_WALK_LEFT: begin\n            walk_left = 1;\n            if (bump_right)\n                next_state = STATE_WALK_RIGHT;\n            else if (!ground) begin\n                next_state = STATE_FALL;\n                aaah = 1;\n            end else if (dig) begin\n                next_state = STATE_DIG;\n                digging = 1;\n            end else begin\n                next_state = STATE_WALK_LEFT;\n            end\n        end\n\n        STATE_WALK_RIGHT: begin\n            walk_right = 1;\n            if (bump_left)\n                next_state = STATE_WALK_LEFT;\n            else if (!ground) begin\n                next_state = STATE_FALL;\n                aaah = 1;\n            end else if (dig) begin\n                next_state = STATE_DIG;\n                digging = 1;\n            end else begin\n                next_state = STATE_WALK_RIGHT;\n            end\n        end\n\n        STATE_FALL: begin\n            aaah = 1;\n            fall_counter = fall_counter + 1;\n            if (fall_counter > 20)\n                next_state = STATE_SPLAT; // Splat condition\n            else if (ground) begin\n                fall_counter = 0;\n                if (current_state == STATE_WALK_LEFT)\n                    next_state = STATE_WALK_LEFT;\n                else\n                    next_state = STATE_WALK_RIGHT;\n            end else begin\n                next_state = STATE_FALL;\n            end\n        end\n\n        STATE_DIG: begin\n            digging = 1;\n            if (!ground)\n                next_state = STATE_FALL; // Fall when the ground is lost\n            else \n                next_state = STATE_DIG; // Continue digging\n        end\n\n        STATE_SPLAT: begin\n            walk_left = 0;\n            walk_right = 0;\n            aaah = 0;\n            digging = 0; // all outputs are 0\n            // Remain in the splat state\n            next_state = STATE_SPLAT;\n        end\n        \n        default: next_state = STATE_WALK_LEFT; // Default to walking left\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        SHIFT = 2'b01,\n        COUNT = 2'b10,\n        DONE = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] shift_counter; // Count cycles in SHIFT state\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Output and next state logic\n    always @(*) begin\n        // Default output\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n        next_state = current_state; // Default to no state change\n\n        case (current_state)\n            IDLE: begin\n                // Check for pattern 1101 (assuming 4 bits are captured over several clock cycles)\n                if (data == 1) begin\n                    // Assuming we have proper state logic to detect...\n                    // Example placeholder logic:\n                    if ( /* detected sequence logic */ ) begin\n                        next_state = SHIFT;\n                    end\n                end\n            end\n\n            SHIFT: begin\n                shift_ena = 1; // Enable shifting\n                shift_counter = shift_counter + 1; // Increment shift counter\n                if (shift_counter == 4) begin\n                    next_state = COUNT;\n                    shift_counter = 0; // Reset shift counter\n                end\n            end\n\n            COUNT: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = DONE;\n                end\n            end\n\n            DONE: begin\n                done = 1; // Notify that timing is done\n                if (ack) begin\n                    next_state = IDLE; // Reset to search for next sequence\n                end\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\tinteger i, j;\n\treg [255:0] next_q; // Temporary storage for the next state\n\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data; // Load the initial state\n\t\tend else begin\n\t\t\t// Calculate the next state\n\t\t\tfor (i = 0; i < 16; i = i + 1) begin\n\t\t\t\tfor (j = 0; j < 16; j = j + 1) begin\n\t\t\t\t\t// Count the number of alive neighbours\n\t\t\t\t\tint count = 0;\n\t\t\t\t\t\n\t\t\t\t\t// Check all 8 neighbours, with wrapping\n\t\t\t\t\tfor (int ni = -1; ni <= 1; ni = ni + 1) begin\n\t\t\t\t\t\tfor (int nj = -1; nj <= 1; nj = nj + 1) begin\n\t\t\t\t\t\t\tif (ni == 0 && nj == 0) continue; // skip the cell itself\n\t\t\t\t\t\t\tint neighbour_i = (i + ni + 16) % 16;\n\t\t\t\t\t\t\tint neighbour_j = (j + nj + 16) % 16;\n\t\t\t\t\t\t\tcount += q[neighbour_i*16 + neighbour_j]; // Access the cell\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\n\t\t\t\t\t// Apply the Game of Life rules\n\t\t\t\t\tif (q[i*16 + j] == 1) begin\n\t\t\t\t\t\t// Cell is alive\n\t\t\t\t\t\tnext_q[i*16 + j] = (count == 2 || count == 3) ? 1 : 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\t// Cell is dead\n\t\t\t\t\t\tnext_q[i*16 + j] = (count == 3) ? 1 : 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tq <= next_q; // Update the state of the game\n\t\tend\n\tend\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    typedef enum reg [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10,\n        DIGGING = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @* begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (state == FALLING) begin\n                        next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                    end else begin\n                        next_state = FALLING;\n                    end\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Reset to walk left\n        else\n            state <= next_state;\n    end\n\n    // Output logic\n    always @* begin\n        // Defaults\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                aaah = 0;\n                digging = 0;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n                aaah = 0;\n                digging = 0;\n            end\n            FALLING: begin\n                aaah = 1;\n            end\n            DIGGING: begin\n                digging = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    // Initialize counter registers\n    initial begin\n        hh = 8'd12; // Start at 12\n        mm = 8'd0;  // Minutes start at 0\n        ss = 8'd0;  // Seconds start at 0\n        pm = 0;     // Start in AM\n    end\n\n    // Sequential logic for clock operation\n    always @(posedge clk) begin\n        if (reset) begin\n            hh <= 8'd12; // Reset hour to 12\n            mm <= 8'd0;  // Reset minutes to 0\n            ss <= 8'd0;  // Reset seconds to 0\n            pm <= 0;     // Reset to AM\n        end\n        else if (ena) begin\n            if (ss == 59) begin\n                ss <= 0; // Reset seconds\n                if (mm == 59) begin\n                    mm <= 0; // Reset minutes\n                    if (hh == 12) begin\n                        hh <= 1; // Reset hours to 1\n                        pm <= ~pm; // Toggle AM/PM\n                    end else begin\n                        hh <= hh + 1; // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 1; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 1; // Increment seconds\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n// State encoding\ntypedef enum logic [1:0] {\n\tWALK_LEFT = 2'b00,\n\tWALK_RIGHT = 2'b01,\n\tFALLING = 2'b10\n} state_t;\n\nstate_t current_state, next_state;\n\n// State D flip-flop\nalways_ff @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tcurrent_state <= WALK_LEFT; // Reset state\n\tend else begin\n\t\tcurrent_state <= next_state; // Transition to next state\n\tend\nend\n\n// Next state logic\nalways_comb begin\n\t// Default assignments\n\tnext_state = current_state;\n\twalk_left = 0;\n\twalk_right = 0;\n\taaah = 0;\n\t\n\tcase (current_state)\n\t\tWALK_LEFT: begin\n\t\t\tif (!ground) begin\n\t\t\t\tnext_state = FALLING;\n\t\t\t\taaah = 1; // Falling state\n\t\t\tend else if (bump_right) begin\n\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend else begin\n\t\t\t\twalk_left = 1; // Continue walking left\n\t\t\tend\n\t\tend\n\t\t\n\t\tWALK_RIGHT: begin\n\t\t\tif (!ground) begin\n\t\t\t\tnext_state = FALLING;\n\t\t\t\taaah = 1; // Falling state\n\t\t\tend else if (bump_left) begin\n\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend else begin\n\t\t\t\twalk_right = 1; // Continue walking right\n\t\t\tend\n\t\tend\n\t\t\n\t\tFALLING: begin\n\t\t\tif (ground) begin\n\t\t\t\t// Resume walking in the last walking direction\n\t\t\t\tif (current_state == WALK_LEFT) begin\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\t\twalk_left = 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\t\twalk_right = 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t// Do not change state on bumps while in falling\n\t\tend\n\t\t\n\t\tdefault: begin\n\t\t\tnext_state = WALK_LEFT; // Fallback state\n\t\tend\n\tendcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;\n            ena <= 3'b000; // No enable signals active\n        end else begin\n            ena <= 3'b000; // Reset enable signals\n            if (q[3:0] < 4'd9) begin\n                q[3:0] <= q[3:0] + 1; // Increment ones place\n            end else begin\n                q[3:0] <= 4'b0000;    // Reset ones place\n                ena[1] <= 1'b1;       // Enable tens digit increment\n                if (q[7:4] < 4'd9) begin\n                    q[7:4] <= q[7:4] + 1; // Increment tens place\n                end else begin\n                    q[7:4] <= 4'b0000;  // Reset tens place\n                    ena[2] <= 1'b1;     // Enable hundreds digit increment\n                    if (q[11:8] < 4'd9) begin\n                        q[11:8] <= q[11:8] + 1; // Increment hundreds place\n                    end else begin\n                        q[11:8] <= 4'b0000; // Reset hundreds place\n                        ena[3] <= 1'b1;    // Enable thousands digit increment\n                        if (q[15:12] < 4'd9) begin\n                            q[15:12] <= q[15:12] + 1; // Increment thousands place\n                        end else begin\n                            q[15:12] <= 4'b0000; // Reset thousands place after reaching '9'\n                        end\n                    end\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\n    assign out = (sel == 1'b0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n    \nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0; // State A\n        3'b001: Y2 = 0; // State B\n        3'b010: Y2 = (w == 0) ? 1 : 0; // State C\n        3'b011: Y2 = (w == 0) ? 1 : 0; // State D\n        3'b100: Y2 = (w == 0) ? 1 : 0; // State E\n        3'b101: Y2 = 0; // State F\n        default: Y2 = 0; // Default case to avoid latches\n    endcase\nend\n\nendmodule\n", "result": "failed: 55 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\n    assign motor = vibrate_mode;                     // Motor is ON if vibrate_mode is ON\n    assign ringer = ring && ~vibrate_mode;           // Ringer is ON if ringing and not vibrate_mode\n\nendmodule\n", "result": "failed: 4 out of 19 samples.", "passed": false}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\n// Continuous assignment for out_assign using an assign statement\nassign out_assign = a & b;\n\n// Combinational logic for out_alwaysblock using an always block\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n    \n    assign zero = 1'b0; // Continuously assign zero to the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (a == 1) begin\n            q <= 0;  // When a is high, reset q to 0.\n        end else begin\n            q <= 1;  // When a is low, set q to 1.\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n    reg [31:0] result; // Result storage for 2's complement (32 bits for arbitrary length support)\n    reg carry; // Carry for adding '1'\n    integer bit_count; // To keep track of how many bits have been processed\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            result <= 0; // Reset result\n            carry <= 0;  // Reset carry\n            bit_count <= 0; // Reset bit count\n            z <= 0; // Reset output\n        end else begin\n            if (bit_count == 0) begin\n                // First bit is processed\n                result <= ~x; // Take the complement of the first bit\n                carry <= 1; // Prepare to add 1 at the next clock pulse\n                bit_count <= bit_count + 1; // Move to the next bit\n            end else begin\n                // Process subsequent bits\n                result <= (result << 1) | (~x); // Shift result left and insert the inverted new bit\n                if (carry) begin\n                    if (result[31] == 1) begin\n                        result <= result + 1; // Add carry\n                    end\n                    carry <= 0; // Reset the carry after adding\n                end\n                bit_count <= bit_count + 1; // Increment bit count\n            end\n            z <= result[0]; // Assign the LSB of the result to output, which is the final 2's complement result\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State Encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 1'b0) ? A : B;\n            B: next_state = (in == 1'b0) ? C : B;\n            C: next_state = (in == 1'b0) ? A : D;\n            D: next_state = (in == 1'b0) ? C : B;\n            default: next_state = A; // default case for safety \n        endcase\n    end\n\n    // State Register with Asynchronous Reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            A, B, C: out = 0;\n            D: out = 1;\n            default: out = 0; // default case for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\n    assign out[31:24] = in[ 7: 0];  // Byte 0 to byte 3\n    assign out[23:16] = in[15: 8];  // Byte 1 to byte 2\n    assign out[15: 8] = in[23:16];  // Byte 2 to byte 1\n    assign out[ 7: 0] = in[31:24];  // Byte 3 to byte 0\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\n    always_ff @(posedge clk or posedge r) begin\n        if (r) begin\n            q <= 0; // Asynchronous reset\n        end else begin\n            q <= d; // Capture D on clock edge\n        end\n    end\n\nendmodule\n", "result": "failed: 16 out of 100 samples.", "passed": false}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\t\n\tassign z = (x ^ y) & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into the shift register\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: begin\n                    // Shift left by 1 bit\n                    q <= {q[62:0], 1'b0};\n                end\n                2'b01: begin\n                    // Shift left by 8 bits\n                    q <= {q[55:0], 8'b0};\n                end\n                2'b10: begin\n                    // Shift right by 1 bit (arithmetic)\n                    q <= {q[63], q[63:1]};\n                end\n                2'b11: begin\n                    // Shift right by 8 bits (arithmetic)\n                    q <= {q[63], q[63:8]};\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: 1164 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00, // Initial state\n        S1 = 2'b01, // '1' detected\n        S2 = 2'b10  // '10' detected\n    } state_type;\n\n    state_type current_state, next_state;\n\n    // Asynchronous reset and edge-triggered clock\n    always @ (posedge clk or negedge aresetn) begin\n        if (!aresetn) begin\n            current_state <= S0;\n            z <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic and output logic\n    always @ (*) begin\n        // Default next state and output\n        next_state = current_state;\n        z = 0; // Default output\n\n        case (current_state)\n            S0: begin\n                if (x) begin\n                    next_state = S1; // move to state S1\n                end\n            end\n            S1: begin\n                if (~x) begin\n                    next_state = S2; // move to state S2\n                end else begin\n                    next_state = S1; // remain in S1\n                end\n            end\n            S2: begin\n                if (x) begin\n                    z = 1; // output is high when we transition to state S0\n                    next_state = S0; // return to initial state\n                end else begin\n                    next_state = S2; // remain in state S2\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 41 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101} state_t;\n    state_t state, next_state;\n\n    // Output logic\n    always @(*) begin\n        // Default output\n        z = 1'b0; \n        case (state)\n            E: z = 1'b1; // Output is 1 in state E\n            default: z = 1'b0; // All other states have output 0\n        endcase\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = (w == 0) ? B : A;\n            B: next_state = (w == 0) ? C : D;\n            C: next_state = (w == 0) ? E : D;\n            D: next_state = (w == 0) ? F : A;\n            E: next_state = (w == 0) ? E : D;\n            F: next_state = (w == 0) ? C : D;\n            default: next_state = A; // Default to state A on errors\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A; // Reset to initial state A\n        end else begin\n            state <= next_state; // Transition to next state\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        RECEIVE1 = 2'b01,\n        RECEIVE2 = 2'b10,\n        RECEIVE3 = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n    reg [23:0] buffer;  // Buffer to hold the 3 bytes of the message\n    reg [1:0] byte_count; // Counter for received bytes\n\n    // State Transition\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_bytes <= 24'b0;\n            buffer <= 24'b0;\n            byte_count <= 2'b0;\n            done <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (done) begin\n                out_bytes <= buffer; // Assign buffer to out_bytes when done\n            end\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        done = 1'b0;  // Default done to low\n        case (state)\n            IDLE: begin\n                if (in[3]) begin\n                    next_state = RECEIVE1;\n                    byte_count = 2'b0; // reset byte count\n                } else begin\n                    next_state = IDLE; // stay in IDLE\n                end\n            end\n\n            RECEIVE1: begin\n                buffer[23:16] = in; // Store first byte\n                byte_count = byte_count + 1;\n                next_state = RECEIVE2;\n            end\n\n            RECEIVE2: begin\n                buffer[15:8] = in; // Store second byte\n                byte_count = byte_count + 1;\n                next_state = RECEIVE3;\n            end\n\n            RECEIVE3: begin\n                buffer[7:0] = in; // Store third byte\n                done = 1'b1; // Assert done\n                next_state = IDLE; // Go back to IDLE after receiving the third byte\n            end\n\n            default: next_state = IDLE; // Default to IDLE for safety\n        endcase\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\nassign Y1 = (y[0] & w) | (y[4] & ~w);  // Y1 logic\nassign Y3 = (~w & (y[1] | y[2]));      // Y3 logic\n\nendmodule\n", "result": "failed: 127 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\n// Assign the input vector to output vector\nassign outv = vec;\n\n// Assign individual bits of vec to outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\nalways @(*) begin\n\tout = ( (c==0 && d==1) || (b==0 && c==1) || (b==1 && c==1) || (a==0 && c==1) || (a==1 && d==0) );\nend\n\nendmodule\n", "result": "failed: 131 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\n\tassign out_hi = in[15:8]; // Assigning the upper byte\n\tassign out_lo = in[7:0];  // Assigning the lower byte\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = ~(a | b); // NOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Continuous assignment for XOR\nassign out_assign = a ^ b;\n\n// Combinational always block using 'always @*'\nalways @* begin\n    out_always_comb = a ^ b; // Assign XOR result to out_always_comb\nend\n\n// Clocked always block for flip-flop behavior\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b; // Assign XOR result to out_always_ff on clock edge\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\n    assign Y2 = (y[2] & ~w) | (y[4] & ~w); // Output Y2\n    assign Y4 = (y[2] & w) | (y[3] & (w | !w)); // Output Y4\n\nendmodule\n", "result": "failed: 285 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    assign out = in[sel]; // select the appropriate bit based on sel\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n  \n\talways @(posedge clk) begin\n\t\tif (L) begin\n\t\t\tQ <= R; // Load operation\n\t\tend else if (E) begin\n\t\t\tQ <= w; // Shift operation\n\t\tend\n\t\t// else case is implicitly handled: Q retains its value\n\tend\n  \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\n\treg q1, q2, q3; // State registers for the D flip-flops\n\n\t// Next state logic\n\twire d1 = x ^ q1;      // XOR gate\n\twire d2 = x & ~q2;     // AND gate\n\twire d3 = x | ~q3;     // OR gate\n\n\t// Flip-flop behavior\n\talways @(posedge clk) begin\n\t\tq1 <= d1;\n\t\tq2 <= d2;\n\t\tq3 <= d3;\n\tend\n\n\t// Output logic for the XNOR gate\n\tassign z = ~(q1 ^ q2 ^ q3); // 3-input XNOR\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (~a & (b | c)) | (a & d);\nendmodule\n", "result": "failed: 31 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\t// Load the new state from data\n\t\tq <= data;\n\tend else begin\n\t\t// Temporary variable to store next state\n\t\treg [511:0] next_q;\n\t\tinteger i;\n\t\t\n\t\tfor (i = 0; i < 512; i = i + 1) begin\n\t\t\t// Get left, center, right states with boundary conditions\n\t\t\twire left = (i == 0) ? 0 : q[i-1];  // Boundary condition 0 for left of q[0]\n\t\t\twire center = q[i];\n\t\t\twire right = (i == 511) ? 0 : q[i+1]; // Boundary condition 0 for right of q[511]\n\t\t\t\n\t\t\t// Apply Rule 110\n\t\t\tcase ({left, center, right})\n\t\t\t\t3'b111: next_q[i] = 0;\n\t\t\t\t3'b110: next_q[i] = 1;\n\t\t\t\t3'b101: next_q[i] = 1;\n\t\t\t\t3'b100: next_q[i] = 0;\n\t\t\t\t3'b011: next_q[i] = 1;\n\t\t\t\t3'b010: next_q[i] = 1;\n\t\t\t\t3'b001: next_q[i] = 1;\n\t\t\t\t3'b000: next_q[i] = 0;\n\t\t\tendcase\n\t\tend\n\t\t// Update q with the next state\n\t\tq <= next_q;\n\tend\nend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\n// Synchronous reset and state transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        current_state <= A; // Reset state to A\n    else \n        current_state <= next_state; // Move to next state\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // Default case\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        A, B, C: out = 0; // Output is 0 in states A, B, C\n        D: out = 1;     // Output is 1 in state D\n        default: out = 0; // Default case\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\nalways @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        4'd4: q = 4'b1111; // Representing 'f'\n        4'd5: q = 4'b1111; // Representing 'f'\n        4'd6: q = 4'b1111; // Representing 'f'\n        4'd7: q = 4'b1111; // Representing 'f'\n        4'd8: q = 4'b1111; // Representing 'f'\n        4'd9: q = 4'b1111; // Representing 'f'\n        default: q = 4'b1111; // Constant output for values greater than 9\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\nalways @(*) begin\n    if (sel)\n        out = b;  // Output `b` when sel is high\n    else\n        out = a;  // Output `a` when sel is low\nend\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n    wire Q0, Q1, Q2;\n\n    // Instantiate three top_module instances\n    top_module inst0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[0]),\n        .Q(Q0)\n    );\n\n    top_module inst1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1]),\n        .r_in(r[1]),\n        .Q(Q1)\n    );\n\n    top_module inst2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(Q2)\n    );\n\n    always @(posedge clk) begin\n        if (L) begin\n            q <= r; // Load r when L is high\n        end else begin\n            q <= {Q0 ^ Q1, Q1, Q2}; // Update q based on feedback from the top_module instances\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0; // Reset out to 0\n        end else begin\n            // Check for the transition from 1 to 0\n            for (integer i = 0; i < 32; i = i + 1) begin\n                if (prev_in[i] == 1'b1 && in[i] == 1'b0) begin\n                    out[i] <= 1'b1; // Capture the transition\n                end\n            end\n        end\n        prev_in <= in; // Update prev_in to current in for next clock cycle\n    end\nendmodule\n", "result": "failed: 8 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    q <= d;  // Capture the input data d on the positive edge of clk\nend\n\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire [7:0] sum; // Wire to hold the sum of a and b\n    assign sum = a + b; // Perform addition\n    \n    // Overflow logic\n    assign overflow = ((a[7] == 0) && (b[7] == 0) && (sum[7] == 1)) || // Positive overflow\n                      ((a[7] == 1) && (b[7] == 1) && (sum[7] == 0)); // Negative overflow\n    \n    assign s = sum; // Assign the sum to output s\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // Determine the next state for B3\n    wire B3 = state[3]; // B3 is represented by state[3]\n    assign B3_next = B3; // Remain in B3 if this state is active with shift_ena = 1 \n\n    // Determine the next state for S\n    wire S = state[0]; // S is represented by state[0]\n    assign S_next = S && !d; // Stay in S when d = 0 \n\n    // Determine the next state for S1\n    wire S1 = state[1]; // S1 is represented by state[1]\n    assign S1_next = S1 && d; // Transition to S1 on d = 1 \n\n    // Determine the next state for Count\n    wire Count = state[7]; // Count is represented by state[7]\n    assign Count_next = Count && !done_counting; // Continue counting while done_counting is false\n\n    // Determine the next state for Wait\n    wire Wait = state[9]; // Wait is represented by state[9]\n    assign Wait_next = Wait && ack; // Transition back to S on ack = 1 \n\n    // Output logic\n    assign done = Wait && done_counting; // done is active when in Wait state and done_counting is true\n    assign counting = Count; // counting is active when in Count state\n    assign shift_ena = (state[4] || state[5] || state[6] || state[3]); // Active in any B0 to B3 state\n\nendmodule\n", "result": "failed: 3050 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    // Internal counter registry\n    logic [1:0] counter;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            counter <= 2'b01; // Reset to weakly not-taken value\n        end else if (train_valid) begin\n            if (train_taken) begin\n                // Increment but saturate at 3\n                if (counter < 2'b11) \n                    counter <= counter + 1;\n            end else begin\n                // Decrement but not below 0\n                if (counter > 2'b00)\n                    counter <= counter - 1;\n            end\n        end\n    end\n\n    // Assign the counter value to output state\n    assign state = counter;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    \n    integer i;\n    \n    always @(*) begin\n        pos = 3'b000; // Default to no bits set\n        for (i = 0; i < 8; i = i + 1) begin\n            if (in[i] == 1'b1) begin\n                pos = i[2:0]; // Set position to the index of the first 1\n                break; // Exit the loop after finding the first bit that is high\n            end\n        end\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n    // Default outputs to zero\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check for the specific scancode values\n    case (scancode)\n        16'hE06B: left = 1;    // Left arrow\n        16'hE072: down = 1;    // Down arrow\n        16'hE074: right = 1;   // Right arrow\n        16'hE075: up = 1;      // Up arrow\n        default: ;              // Do nothing, outputs remain low\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\n    wire c1, c2, c3; // carry wires\n\n    // Full adder for the least significant bit\n    wire s0 = x[0] ^ y[0] ^ 1'b0;\n    assign c1 = (x[0] & y[0]) | (1'b0 & (x[0] ^ y[0]));\n\n    // Full adder for the second bit\n    wire s1 = x[1] ^ y[1] ^ c1;\n    assign c2 = (x[1] & y[1]) | (c1 & (x[1] ^ y[1]));\n\n    // Full adder for the third bit\n    wire s2 = x[2] ^ y[2] ^ c2;\n    assign c3 = (x[2] & y[2]) | (c2 & (x[2] ^ y[2]));\n\n    // Full adder for the most significant bit\n    wire s3 = x[3] ^ y[3] ^ c3;\n    assign sum[4] = (x[3] & y[3]) | (c3 & (x[3] ^ y[3]));\n\n    // Combining the results into sum\n    assign sum = {sum[4], s3, s2, s1, s0};\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\n    // Shift register for storing the branch history\n    logic [31:0] history_reg;\n\n    always_ff @(posedge clk or posedge areset) begin\n        // Asynchronous reset\n        if (areset) begin\n            history_reg <= 32'b0;  // Reset history to zero\n        end else if (train_mispredicted) begin\n            // Load new history on misprediction\n            history_reg <= {train_history[30:0], train_taken}; // Concatenate train_history and train_taken\n        end else if (predict_valid) begin\n            // Shift in the new prediction\n            history_reg <= {history_reg[30:0], predict_taken}; // Shift the history and add new prediction\n        end\n    end\n\n    // Assign the output\n    assign predict_history = history_reg;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\t// Intermediate wires\n\twire and_out1;\n\twire and_out2;\n\n\t// First layer: Two AND gates\n\tassign and_out1 = a & b; // AND gate for a and b\n\tassign and_out2 = c & d; // AND gate for c and d\n\t\n\t// Second layer: One OR gate\n\tassign out = and_out1 | and_out2; // OR the outputs of the AND gates\n\t\n\t// Inversion output\n\tassign out_n = ~out; // NOT the out to get out_n\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n\t// Always block triggered on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tq <= d; // On the positive edge of clk, assign d to q\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    // Define an 8-bit shift register\n    reg [7:0] Q; // 8-bit shift register\n\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]}; // Shift left and inject S into Q[0]\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C}) // Case for selecting Z based on ABC\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n            default: Z = 0; // Default case (for safety)\n        endcase\n    end\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\n    assign heater = (mode == 1 && too_cold == 1) ? 1 : 0;\n    assign aircon = (mode == 0 && too_hot == 1) ? 1 : 0;\n    assign fan = (heater || aircon || fan_on) ? 1 : 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n\tassign out_sop = (~a & b & c) | (~a & b & d) | (a & b & c & d);\n\tassign out_pos = (a | b | c) & (a | b | ~d) & (a | ~c | ~d) & (~a | b | c | d);\n\nendmodule\n", "result": "failed: 84 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Set to reset value\n    end else begin\n        // XOR the tapped bits for feedback calculation\n        // Tapped at positions 32 (q[31]), 22 (q[21]), 2 (q[1]), 1 (q[0])\n        // The feedback bit is XOR of these tapped bits\n        q[0] <= q[31] ^ q[21] ^ q[1] ^ q[0];   // Feedback calculation\n        q[31:1] <= q[30:0];                    // Shift right\n    end\nend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\n\tassign q = (b & d) | (c & (b | d));\n\nendmodule\n", "result": "failed: 24 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // First 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\n\tinteger i;\n\n\talways @(*) begin\n\t\tout = 0; // Initialize count to zero\n\t\tfor (i = 0; i < 255; i = i + 1) begin\n\t\t\tout = out + in[i]; // Sum the number of '1's\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\tassign out_both[0] = in[0] & in[1]; // in[0] and in[1]\n\tassign out_both[1] = in[1] & in[2]; // in[1] and in[2]\n\tassign out_both[2] = in[2] & in[3]; // in[2] and in[3]\n\n\tassign out_any[1] = in[0] | in[1]; // in[0] or in[1]\n\tassign out_any[2] = in[1] | in[2]; // in[1] or in[2]\n\tassign out_any[3] = in[2] | in[3]; // in[2] or in[3]\n\n\tassign out_different[0] = in[0] ^ in[3]; // in[0] different from in[3]\n\tassign out_different[1] = in[1] ^ in[0]; // in[1] different from in[0]\n\tassign out_different[2] = in[2] ^ in[1]; // in[2] different from in[1]\n\tassign out_different[3] = in[3] ^ in[2]; // in[3] different from in[2]\nendmodule\n", "result": "failed: 160 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;  // for a=0\n            3'b001: q = 16'hAEE0;  // for a=1\n            3'b010: q = 16'h27D4;  // for a=2\n            3'b011: q = 16'h5A0E;  // for a=3\n            3'b100: q = 16'h2066;  // for a=4\n            3'b101: q = 16'h64CE;  // for a=5\n            3'b110: q = 16'hC526;  // for a=6\n            3'b111: q = 16'h2F19;  // for a=7\n            default: q = 16'h0000; // default case (not strictly necessary for a 3-bit input)\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset counter to 0\n\t\tend else if (slowena) begin\n\t\t\tif (q == 4'b1001) begin\n\t\t\t\tq <= 4'b0000; // Wrap around if it reaches 10\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Invert in2\n    logic in2_inv;\n    \n    assign in2_inv = ~in2;  // Step 1: Inverting in2\n    \n    // AND operation\n    assign out = in1 & in2_inv;  // Step 2: AND between in1 and inverted in2\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in; // Assign the input value directly to the output\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n// State encoding\ntypedef enum reg {A, B} state_t; // Defining states as an enumerated type\nstate_t current_state, next_state;\n\n// Asynchronous reset and state transition logic\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= B; // Reset to state B\n    end else begin\n        current_state <= next_state; // Transition to next state\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        A: begin\n            if (in == 0)\n                next_state = B; // A --0--> B\n            else\n                next_state = A; // A --1--> A\n        end\n        B: begin\n            if (in == 0)\n                next_state = A; // B --0--> A\n            else\n                next_state = B; // B --1--> B\n        end\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        A: out = 0; // Output is 0 in state A\n        B: out = 1; // Output is 1 in state B\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\t\n\talways @(posedge clk) begin\n\t\tq <= d; // Capture 'd' on the rising edge\n\tend\n\t\n\talways @(negedge clk) begin\n\t\tq <= d; // Capture 'd' on the falling edge\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    assign out = ~(a ^ b); // XNOR operation using bitwise XOR followed by NOT\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x; // A: z = (x XOR y) AND x\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output z\n);\n    assign z = x & y; // B: z = x AND y\nendmodule\n\nmodule top_module (\n    input x,\n    input y,\n    output z\n);\n    wire a1_out, a2_out, b1_out, b2_out;\n    wire or_out, and_out;\n\n    A a1 (\n        .x(x),\n        .y(y),\n        .z(a1_out)\n    );\n\n    A a2 (\n        .x(x),\n        .y(y),\n        .z(a2_out)\n    );\n\n    B b1 (\n        .x(x),\n        .y(y),\n        .z(b1_out)\n    );\n\n    B b2 (\n        .x(x),\n        .y(y),\n        .z(b2_out)\n    );\n\n    assign or_out = a1_out | b1_out; // Output from OR gate\n    assign and_out = a2_out & b2_out; // Output from AND gate\n    assign z = or_out ^ and_out; // Final output as XOR of or_out and and_out\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data when load is high\n        end else begin\n            case (ena)\n                2'b01: begin\n                    // Rotate right by one bit\n                    q <= {q[0], q[99:1]};\n                end\n                2'b10: begin\n                    // Rotate left by one bit\n                    q <= {q[98:0], q[99]};\n                end\n                default: begin\n                    // No rotation\n                    q <= q;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 10'b0; // Reset counter to 0\n\t\tend else begin\n\t\t\tif (q < 10'd999) begin\n\t\t\t\tq <= q + 1; // Increment counter\n\t\t\tend else begin\n\t\t\t\tq <= 10'b0; // Reset counter to 0 when it reaches 999\n\t\t\tend\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\nassign out = ~in; // use bitwise NOT to assign the negation of input to output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    always @(*) begin\n        // Default next state to S0\n        next_state = 10'b0000000001; // S0\n        \n        case (1'b1)\n            state[0]: // S0\n                next_state = in ? 10'b0000000010 : 10'b0000000001; // S1 or S0\n            state[1]: // S1\n                next_state = in ? 10'b0000000100 : 10'b0000000001; // S2 or S0\n            state[2]: // S2\n                next_state = in ? 10'b0000001000 : 10'b0000000001; // S3 or S0\n            state[3]: // S3\n                next_state = in ? 10'b0000010000 : 10'b0000000001; // S4 or S0\n            state[4]: // S4\n                next_state = in ? 10'b0000100000 : 10'b0000000001; // S5 or S0\n            state[5]: // S5\n                next_state = in ? 10'b0000000110 : 10'b0000100000; // S6 or S8\n            state[6]: // S6\n                next_state = in ? 10'b0000001000 : 10'b0000000001; // S7 or S9\n            state[7]: // S7\n                next_state = in ? 10'b0000000110 : 10'b0000000001; // S7 or S0\n            state[8]: // S8\n                next_state = in ? 10'b0000000001 : 10'b0000000010; // S1 or S0\n            state[9]: // S9\n                next_state = in ? 10'b0000000010 : 10'b0000000001; // S1 or S0\n        endcase\n    end\n\n    // Output Logic\n    assign out1 = state[7] | state[8] | state[9]; // 1 for S7, S8, S9\n    assign out2 = state[7]; // 1 only for S7\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (j == 0 && k == 0) begin\n\t\t\t// 0 0: Q remains Qold\n\t\t\tQ <= Q;  // No change\n\t\tend else if (j == 0 && k == 1) begin\n\t\t\t// 0 1: Q becomes 0\n\t\t\tQ <= 0;\n\t\tend else if (j == 1 && k == 0) begin\n\t\t\t// 1 0: Q becomes 1\n\t\t\tQ <= 1;\n\t\tend else if (j == 1 && k == 1) begin\n\t\t\t// 1 1: Q toggles\n\t\t\tQ <= ~Q;\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[0] + in[1] + in[2];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\nassign out[24] = ~(a ^ a); // Compare a with a\nassign out[23] = ~(a ^ b); // Compare a with b\nassign out[22] = ~(a ^ c); // Compare a with c\nassign out[21] = ~(a ^ d); // Compare a with d\nassign out[20] = ~(a ^ e); // Compare a with e\nassign out[19] = ~(b ^ a); // Compare b with a\nassign out[18] = ~(b ^ b); // Compare b with b\nassign out[17] = ~(b ^ c); // Compare b with c\nassign out[16] = ~(b ^ d); // Compare b with d\nassign out[15] = ~(b ^ e); // Compare b with e\nassign out[14] = ~(c ^ a); // Compare c with a\nassign out[13] = ~(c ^ b); // Compare c with b\nassign out[12] = ~(c ^ c); // Compare c with c\nassign out[11] = ~(c ^ d); // Compare c with d\nassign out[10] = ~(c ^ e); // Compare c with e\nassign out[9]  = ~(d ^ a); // Compare d with a\nassign out[8]  = ~(d ^ b); // Compare d with b\nassign out[7]  = ~(d ^ c); // Compare d with c\nassign out[6]  = ~(d ^ d); // Compare d with d\nassign out[5]  = ~(d ^ e); // Compare d with e\nassign out[4]  = ~(e ^ a); // Compare e with a\nassign out[3]  = ~(e ^ b); // Compare e with b\nassign out[2]  = ~(e ^ c); // Compare e with c\nassign out[1]  = ~(e ^ d); // Compare e with d\nassign out[0]  = ~(e ^ e); // Compare e with e\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S0 = 2'b00,  // walking left\n        S1 = 2'b01   // walking right\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                // Walking left\n                if (bump_right) begin\n                    next_state = S1;  // switch to walking right if bumped on the right\n                end else begin\n                    next_state = S0;  // continue walking left\n                end\n            end\n            \n            S1: begin\n                // Walking right\n                if (bump_left) begin\n                    next_state = S0;  // switch to walking left if bumped on the left\n                end else begin\n                    next_state = S1;  // continue walking right\n                end\n            end\n            \n            default: next_state = S0; // default case for safety\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= S0;  // Reset to walking left\n        end else begin\n            current_state <= next_state; // Update state on clock\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            S1: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\tassign q = a & b; // Logical AND operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Intermediate wires for the AND gates\n    wire p1_and1, p1_and2; // For p1y\n    wire p2_and1, p2_and2; // For p2y\n\n    // 3-input AND gates for p1y\n    assign p1_and1 = p1a & p1b & p1c; // AND(p1a, p1b, p1c)\n    assign p1_and2 = p1d & p1e & p1f; // AND(p1d, p1e, p1f)\n    \n    // OR gates for p1y\n    assign p1y = p1_and1 | p1_and2; // OR(p1_and1, p1_and2)\n\n    // 2-input AND gates for p2y\n    assign p2_and1 = p2a & p2b; // AND(p2a, p2b)\n    assign p2_and2 = p2c & p2d; // AND(p2c, p2d)\n\n    // OR gates for p2y\n    assign p2y = p2_and1 | p2_and2; // OR(p2_and1, p2_and2)\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\n// State register to hold the current state\nreg [2:0] Y;\n\n// Sequential logic for state updates\nalways @(posedge clk) begin\n    case (y)\n        3'b000: Y <= (x == 0) ? 3'b000 : 3'b001; // y = 000 -> Y = 000 or 001\n        3'b001: Y <= (x == 0) ? 3'b001 : 3'b100; // y = 001 -> Y = 001 or 100\n        3'b010: Y <= (x == 0) ? 3'b010 : 3'b001; // y = 010 -> Y = 010 or 001\n        3'b011: Y <= (x == 0) ? 3'b001 : 3'b010; // y = 011 -> Y = 001 or 010\n        3'b100: Y <= (x == 0) ? 3'b011 : 3'b100; // y = 100 -> Y = 011 or 100\n        default: Y <= 3'b000; // Reset to 000\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    // Assign output z based on the current state y\n    z = (y == 3'b011) || ((y == 3'b100) && (x == 1));\n    \n    // Assign Y0 from the next state bits\n    Y0 = Y[0]; // Y0 corresponds to the LSB of the next state\nend\n\nendmodule\n", "result": "failed: 60 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    assign out = ~(in1 | in2); // NOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\nassign w = a; // Connect input a to output w\nassign x = b; // Connect input b to output x\nassign y = b; // Connect input b to output y\nassign z = c; // Connect input c to output z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\talways_ff @(posedge clk or posedge ar) begin\n\t\tif (ar) \n\t\t\tq <= 0; // Set output to 0 on asynchronous reset\n\t\telse \n\t\t\tq <= d; // Capture d value on clock rising edge\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase(sel)\n\t\t\t3'b000: out = data0;\n\t\t\t3'b001: out = data1;\n\t\t\t3'b010: out = data2;\n\t\t\t3'b011: out = data3;\n\t\t\t3'b100: out = data4;\n\t\t\t3'b101: out = data5;\n\t\t\tdefault: out = 4'b0000; // If sel is 6 or 7 (beyond the 0-5 range)\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] counter; // Internal counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the new value into the counter\n            tc <= 0;         // Reset the terminal count signal\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement counter\n            if (counter == 1) begin\n                tc <= 0; // Will set tc to 0 right before it reaches 0\n            end\n        end\n\n        // When the counter reaches 0\n        if (counter == 0) begin\n            tc <= 1; // Assert the tc signal\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S0 = 3'd0,\n        S1 = 3'd1,\n        S2 = 3'd2,\n        S3 = 3'd3,\n        S4 = 3'd4\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= S0;\n            start_shifting <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (data) next_state = S1; // '1' detected\n                else next_state = S0; // Stay in S0\n            end\n            S1: begin\n                if (data) next_state = S2; // Another '1' detected\n                else next_state = S0; // '0' detected, return to S0\n            end\n            S2: begin\n                if (data) next_state = S2; // Stay on '1'\n                else next_state = S3; // '0' detected\n            end\n            S3: begin\n                if (data) next_state = S4; // '1' detected, complete sequence\n                else next_state = S0; // '0' detected, return to S0\n            end\n            S4: begin\n                next_state = S4; // Stay in S4\n            end\n            default: next_state = S0; // Fallback to S0\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (current_state == S4) begin\n            start_shifting <= 1; // Set start_shifting high when sequence detected\n        end else begin\n            start_shifting <= 0; // Reset start_shifting in other states\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'd0;  // Set output to zero when reset is high\n    end else begin\n        q <= d;     // Transfer the input data to output on clock edge\n    end\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n\n\treg [7:0] prev_in; // register to hold the previous state of the input\n\n\talways @(posedge clk) begin\n\t\t// Detect transitions from 0 to 1\n\t\tanyedge <= (in & ~prev_in); // Set bits in anyedge where in is 1 and prev_in is 0\n\t\tprev_in <= in; // Update prev_in to the current state of in\n\tend\n\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n// Initialize the counter\nalways @(posedge clk) begin\n    if (reset) begin\n        // If reset is active, set counter to 1\n        q <= 4'b0001;\n    end else begin\n        // Increment the counter unless it's already 10\n        if (q < 4'b1010) begin // 10 in binary is 1010\n            q <= q + 1;\n        end\n    end\nend\n\nendmodule\n", "result": "failed: 314 out of 439 samples.", "passed": false}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    // Initialization of q to 0\n    always @(posedge clk) begin\n        if (a) begin\n            // If a is 1, retain the value of q\n            q <= q; // This can also be omitted\n        end else begin\n            // If a is 0, increment q (wrap around using modulo 8)\n            q <= (q + 1) % 8;\n        end\n    end\n\n    // Initial value for simulation purposes only\n    initial begin\n        q = 3'b000; // Start with q equals 0\n    end\n\nendmodule\n", "result": "failed: 222 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tq <= 5'b00001; // Reset to 1\n\tend else begin\n\t\t// Compute the next state based on taps at positions 5 and 3\n\t\tq <= {q[3:1], q[4] ^ q[2]}; // Shift right and insert the new bit\n\tend\nend\n\nendmodule\n", "result": "failed: 4412 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\n    always @(*) begin\n        // Initialize result_is_zero\n        result_is_zero = 0;\n        \n        case (do_sub)\n            0: out = a + b;  // Perform addition\n            1: out = a - b;  // Perform subtraction\n            default: out = 8'b0; // Default case, set output to 0\n        endcase\n\n        // Set result_is_zero if out is 0\n        if (out == 8'b0)\n            result_is_zero = 1;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    assign f = (x[3] & x[4]) | \n               (~x[3] & x[4] & x[1] & x[2]) | \n               (x[3] & ~x[4] & (x[1] | x[2]));\n\nendmodule\n", "result": "failed: 5 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\nalways @(*) begin\n    // Default values\n    out = 4'b0000; \n    valid = 1'b0;\n    \n    // Check scan codes\n    case (code)\n        8'h45: begin out = 4'b0000; valid = 1'b1; end // 0\n        8'h16: begin out = 4'b0001; valid = 1'b1; end // 1\n        8'h1e: begin out = 4'b0010; valid = 1'b1; end // 2\n        8'h26: begin out = 4'b0011; valid = 1'b1; end // 3\n        8'h25: begin out = 4'b0100; valid = 1'b1; end // 4\n        8'h2e: begin out = 4'b0101; valid = 1'b1; end // 5\n        8'h36: begin out = 4'b0110; valid = 1'b1; end // 6\n        8'h3d: begin out = 4'b0111; valid = 1'b1; end // 7\n        8'h3e: begin out = 4'b1000; valid = 1'b1; end // 8\n        8'h46: begin out = 4'b1001; valid = 1'b1; end // 9\n        default: begin out = 4'b0000; valid = 1'b0; end // Unrecognized\n    endcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\tassign out[0] = in[7];\n\tassign out[1] = in[6];\n\tassign out[2] = in[5];\n\tassign out[3] = in[4];\n\tassign out[4] = in[3];\n\tassign out[5] = in[2];\n\tassign out[6] = in[1];\n\tassign out[7] = in[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    \nalways @(*) begin\n    out = (b & c) || (b & d) || (c & d) || (a & b) || (a & c);\nend\n\nendmodule\n", "result": "failed: 76 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data into the register MSB first\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Decrement the register\n            q <= q - 1;\n        end\n    end\n\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    assign out = in; // Wire assignment - output follows input\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    reg [1:0] count; // 2-bit counter to count cycles\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;      // Reset the counter to 0\n            shift_ena <= 1;  // Assert shift_ena\n        end else if (count < 3) begin  // Count till we reach 3\n            count <= count + 1; // Increment the counter\n            shift_ena <= 1; // Keep shift_ena asserted\n        end else begin\n            shift_ena <= 0; // Deassert shift_ena after 4 cycles\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\t\n\t// Always block triggered on the rising edge of clk\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0\n\t\tend else begin\n\t\t\tq <= q + 1;   // Increment the counter\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\n// Continuous assignment for out_assign\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Procedural assignment for out_always\nalways @(*) begin\n    if (sel_b1 && sel_b2) \n        out_always = b; \n    else \n        out_always = a; \nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\tassign out = b | c; // Output is true if either b or c are true\nendmodule\n", "result": "failed: 26 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @ (posedge clk or negedge resetn) begin\n        if (!resetn) \n            current_state <= A;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1]) next_state = B; // Grant for device 1\n                else if (r[2]) next_state = C; // Grant for device 2\n                else if (r[3]) next_state = D; // Grant for device 3\n                else next_state = A; // Stay in A if no requests\n            end\n            B: begin\n                if (r[1]) next_state = B; // Stay in B if device 1 is still requesting\n                else next_state = A; // Device 1 is not requesting, go back to A\n            end\n            C: begin\n                if (r[2]) next_state = C; // Stay in C if device 2 is still requesting\n                else next_state = A; // Device 2 is not requesting, go back to A\n            end\n            D: begin\n                next_state = A; // Return to A from D\n            end\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output\n        case (current_state)\n            B: g[1] = 1; // Grant for device 1\n            C: g[2] = 1; // Grant for device 2\n            D: g[3] = 1; // Grant for device 3\n            default: g = 3'b000; // No grants\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;  // Reset the counter to 0\n        end else begin\n            if (q < 4'd9) begin\n                q <= q + 1;  // Increment the counter\n            end else begin\n                q <= 4'b0000;  // Wrap around to 0\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        BYTE1 = 2'b01,\n        BYTE2 = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(*) begin\n        // Default next state settings\n        next_state = current_state;\n        done = 0; // Default done signal is low\n\n        case (current_state)\n            IDLE: begin\n                if (in[3] == 1) \n                    next_state = BYTE1; // Move to BYTE1 if in[3] is 1\n            end\n            BYTE1: begin\n                next_state = BYTE2; // Move to BYTE2 after receiving first byte\n            end\n            BYTE2: begin\n                done = 1;          // Indicate done after receiving the third byte\n                next_state = IDLE; // Move back to IDLE\n            end\n        endcase\n    end\n\n    // State update logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE; // Reset to IDLE on high reset signal\n            done <= 0; // Ensure done is low on reset\n        end else begin\n            current_state <= next_state; // Update current state to next state\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\nassign out = (sel == 0) ? a : b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    assign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND\n    assign out_or  = in[0] | in[1] | in[2] | in[3]; // 4-input OR\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3]; // 4-input XOR\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\t// State definition\n\treg [2:0] current_state, next_state;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\t3'b000: next_state = (x) ? 3'b001 : 3'b000; z = 1'b0;\n\t\t\t3'b001: next_state = (x) ? 3'b100 : 3'b001; z = 1'b0;\n\t\t\t3'b010: next_state = (x) ? 3'b001 : 3'b010; z = 1'b0;\n\t\t\t3'b011: next_state = (x) ? 3'b010 : 3'b001; z = 1'b1;\n\t\t\t3'b100: next_state = (x) ? 3'b100 : 3'b011; z = 1'b1;\n\t\t\tdefault: next_state = 3'b000; z = 1'b0; // Default case for safety\n\t\tendcase\n\tend\n\n\t// State update logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= 3'b000; // Reset to state 000\n\t\tend else begin\n\t\t\tcurrent_state <= next_state; // Update to the next state\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\n    // State Encoding\n    typedef enum logic [2:0] {\n        S_A,  // Reset State\n        S_B,  // f = 1 State\n        S_C,  // x=1,0,1 State\n        S_D,  // g = 1, monitor y\n        S_E   // g = 0 State\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [1:0] cycle_count;  // To count the cycles for y input\n\n    // Sequential logic for FSM state transition\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_state <= S_A;\n            f <= 0;\n            g <= 0;\n            cycle_count <= 0;\n        end\n        else begin\n            current_state <= next_state;\n            // Only update f when transitioning to S_B\n            if (current_state == S_B) begin\n                f <= 1;\n            end\n            else begin\n                f <= 0; // f goes back to 0 afterwards\n            end\n        end\n    end\n\n    // Combinational logic for next state and output\n    always_comb begin\n        // Default values\n        next_state = current_state;\n        g = (current_state == S_D); // g is set to 1 if we are in S_D\n\n        case (current_state)\n            S_A: begin\n                next_state = S_B; // Move to State B after reset\n                g = 0; // g is 0 in reset state\n            end\n            S_B: begin\n                next_state = (x && (cycle_count == 0)) ? S_C : S_B; // Move to State C if x=1\n                cycle_count = 0;\n            end\n            S_C: begin\n                if (cycle_count < 2) begin\n                    cycle_count = (x == 1) ? cycle_count + 1 : 0; \n                    if (cycle_count == 2) begin // Sequence 1,0,1 detected\n                        next_state = S_D; // Move to State D\n                        g = 1; // Set g to 1\n                    end\n                end\n                else begin\n                    next_state = S_E; // If sequence not valid then move to state E\n                end\n            end\n            S_D: begin\n                if (y == 1) begin\n                    // If y is 1, stay in S_D\n                    next_state = S_D; \n                end\n                else begin\n                    cycle_count = cycle_count + 1;\n                    if (cycle_count >= 2) begin\n                        next_state = S_E;  // Move to State E if y not detected within two cycles\n                    end\n                end\n            end\n            S_E: begin\n                g = 0; // Set g to 0\n                if (!resetn) begin\n                    next_state = S_A; // Return to State A on reset\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(negedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 8'b00110100;  // Load with 0x34\n\t\tend else begin\n\t\t\tq <= d;            // Store input data on negative edge of clock\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n\tassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n    // Default values\n    next_state = state; // Hold current state by default\n    out = 0;            // Default output\n\n    case (state)\n        2'b00: begin // State A\n            if (in == 0) begin\n                next_state = 2'b00; // Next state = A\n            end else begin\n                next_state = 2'b01; // Next state = B\n            end\n            out = 0; // Output for state A\n        end\n        \n        2'b01: begin // State B\n            if (in == 0) begin\n                next_state = 2'b10; // Next state = C\n            end else begin\n                next_state = 2'b01; // Next state = B\n            end\n            out = 0; // Output for state B\n        end\n        \n        2'b10: begin // State C\n            if (in == 0) begin\n                next_state = 2'b00; // Next state = A\n            end else begin\n                next_state = 2'b11; // Next state = D\n            end\n            out = 0; // Output for state C\n        end\n        \n        2'b11: begin // State D\n            if (in == 0) begin\n                next_state = 2'b10; // Next state = C\n            end else begin\n                next_state = 2'b01; // Next state = B\n            end\n            out = 1; // Output for state D\n        end\n        \n        default: begin\n            next_state = 2'b00; // Default to state A if unknown\n            out = 0;\n        end\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\nalways @* begin\n    case ({x, y})\n        2'b00: z = 1; // both x and y are 0\n        2'b01: z = 0; // x is 0, y is 1\n        2'b10: z = 0; // x is 1, y is 0\n        2'b11: z = 1; // both x and y are 1\n        default: z = 1'bx; // undefined state\n    endcase\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // State definition\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    // Current state and next state variables\n    state_t current_state, next_state;\n\n    // State flip-flops\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Go to state A on reset\n        end else begin\n            current_state <= next_state; // Update state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1; // Output 1 when in state E\n            F: z = 1; // Output 1 when in state F\n            default: z = 0; // Output 0 for all other states\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0; // Reset all DFFs to 0\n        end else begin\n            if (byteena[1]) begin // Enable upper byte\n                q[15:8] <= d[15:8]; // Write upper byte\n            end\n            if (byteena[0]) begin // Enable lower byte\n                q[7:0] <= d[7:0]; // Write lower byte\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Internal register to hold previous input values\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Check for positive edge detection\n        pedge <= (in & ~prev_in); // Set output to 1 if there is a rising edge\n        // Update previous input with current input for the next cycle\n        prev_in <= in;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\n// Always block triggered on the rising edge of the clock\nalways @(posedge clock) begin\n\tp <= a; // p takes the value of a on the clock's rising edge\nend\n\n// Always block that handles q\nalways @(posedge clock) begin\n\tif (a) begin\n\t\tq <= 1;  // If a is 1, set q to 1\n\tend else begin\n\t\tq <= q; // If a is 0, retain the previous value of q\n\tend\nend\n\nendmodule\n", "result": "failed: 168 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    reg [511:0] next_q;  // Register to hold the next state\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            next_q[0] = 0 ^ q[0] ^ q[1]; // q[-1] is 0\n            for (int i = 1; i < 511; i = i + 1) begin\n                next_q[i] = q[i-1] ^ q[i] ^ q[i+1];\n            end\n            next_q[511] = q[510] ^ q[511] ^ 0; // q[512] is 0\n            q <= next_q; // Update state\n        end\n    end\nendmodule\n", "result": "failed: 7058 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n    assign z = (A == B);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\n    genvar i;\n\n    // Compute out_both\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : b\n            assign out_both[i] = in[i + 1] & in[i];  // in[i+1] and in[i]\n        end\n    endgenerate\n\n    // Compute out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : a\n            assign out_any[i] = in[i - 1] | in[i];  // in[i] and in[i-1]\n        end\n    endgenerate\n\n    // Compute out_different\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : d\n            assign out_different[i] = in[i] ^ in[(i + 1) % 100]; // in[i] differs from in[i+1], wrapping around\n        end\n    endgenerate\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\nalways @* begin\n    if (ena) begin\n        q = d;  // When enable is high, latch the input\n    end\n    // Implicitly, if ena is low, there's no assignment, q retains its value\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting index for the selected 4 bits\n    assign out = in[(sel * 4) +: 4]; // Selects 4 bits starting from (sel * 4)\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'b1111111111111111; // for sel = 9 to 15\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\n    // Bitwise OR operation\n    assign out_or_bitwise = a | b;\n\n    // Logical OR operation\n    assign out_or_logical = (|a) || (|b);\n\n    // NOT operation\n    assign out_not = {~b, ~a}; // Upper half is NOT of b and lower half is NOT of a\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\nalways @(*) begin\n    next_state = 4'b0000; // Initialize next_state\n    case (1'b1) // One-hot encoding\n        state[0]: begin // State A\n            next_state[0] = ~in; // If in=0 stay in A, if in=1 go to B\n            next_state[1] = in;\n        end\n        state[1]: begin // State B\n            next_state[1] = state[1]; // stay in B if in=1\n            next_state[2] = ~in; // go to C if in=0\n        end\n        state[2]: begin // State C\n            next_state[0] = ~in; // go to A if in=0\n            next_state[3] = in;  // go to D if in=1\n        end\n        state[3]: begin // State D\n            next_state[2] = ~in; // go to C if in=0\n            next_state[1] = in;  // go to B if in=1\n        end\n    endcase\nend\n\nassign out = state[3]; // Output is high only when in state D\n\nendmodule\n", "result": "failed: 247 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\nalways @(*) begin\n    min = a; // Assume a is the minimum\n    \n    if (b < min) \n        min = b; // Update min if b is smaller\n    if (c < min) \n        min = c; // Update min if c is smaller\n    if (d < min) \n        min = d; // Update min if d is smaller\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\n    assign out_and = a & b;               // AND operation\n    assign out_or = a | b;                // OR operation\n    assign out_xor = a ^ b;               // XOR operation\n    assign out_nand = ~(a & b);           // NAND operation\n    assign out_nor = ~(a | b);            // NOR operation\n    assign out_xnor = ~(a ^ b);           // XNOR operation\n    assign out_anotb = a & ~b;            // AND-NOT operation (AND a with NOT b)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\n\tassign out = (~c) | (b & d) | (a & (~c)) | (a & b);\n\nendmodule\n", "result": "failed: 114 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\n    // State definition\n    typedef enum logic [1:0] {\n        A, // State A\n        B  // State B\n    } state_t;\n\n    state_t current_state, next_state;\n    \n    // Count of w = 1 in last three cycles\n    reg [2:0] count; // can count from 0 to 3\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (current_state == B) begin\n            // Shift old counts\n            count <= {count[1:0], w}; // Shift in new w value\n\n            // Check the count after third cycle\n            if (count[2] + count[1] + count[0] == 2)\n                z <= 1; // Set z to 1 if two w's are 1\n            else\n                z <= 0; // Otherwise z is 0\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            A: begin\n                if (s == 1) \n                    next_state = B; \n                else \n                    next_state = A; \n            end\n            B: begin\n                next_state = B; // Remain in B while counting\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 502 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    assign out = { {24{in[7]}}, in }; // Replicate the sign bit 24 times and concatenate with the original 8-bit number\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Declare flip-flops to hold the shift register state\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Reset all flip-flops to 0\n            shift_reg <= 4'b0000;\n        end else begin\n            // Shift the register: D3 <- D2, D2 <- D1, D1 <- D0, D0 <- in\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    // Output is the most significant bit (D3)\n    assign out = shift_reg[3];\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\nalways @* begin\n    case (1'b1)  // Case statement that checks each bit for '1'\n        in[3]: pos = 2'b11; // if in[3] is high\n        in[2]: pos = 2'b10; // if in[2] is high\n        in[1]: pos = 2'b01; // if in[1] is high\n        in[0]: pos = 2'b00; // if in[0] is high\n        default: pos = 2'b00; // if none are high\n    endcase\nend\n\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    typedef enum logic {OFF, ON} state_t;\n    state_t current_state, next_state;\n\n    // State Transition Logic \n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= OFF; // Reset to OFF state\n        end else begin\n            current_state <= next_state; // Transition to the next state\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        case (current_state)\n            OFF: begin\n                if (j) \n                    next_state = ON; // Transition to ON state\n                else \n                    next_state = OFF; // Remain in OFF\n            end\n            ON: begin\n                if (k) \n                    next_state = OFF; // Transition to OFF state\n                else \n                    next_state = ON; // Remain in ON\n            end\n        endcase\n    end\n\n    // Output Logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            out <= 0; // Set output to 0 on reset\n        end else begin\n            out <= (current_state == ON) ? 1 : 0; // Output based on current state\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\n\tassign out = 1'b0; // Always drive the output to logic low (0)\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\n\tassign one = 1'b1; // Drive the output 'one' to logic high (1).\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n\n\tinteger i;\n\n\talways @(*) begin\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tout[i] = in[99 - i];\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Temporary variable to hold the value of the XOR operation\n    logic d;\n\n    // Instantiate the XOR gate\n    assign d = in ^ out;\n\n    // D flip-flop behavior\n    always_ff @(posedge clk) begin\n        out <= d; // Update output on the rising edge of the clock\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000; // Reset the shift register to zero\n        end else if (load) begin\n            q <= data; // Load the data into the shift register\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Shift right\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    assign f = (x2) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\nendmodule\n", "result": "failed: 2 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 8'b00000000; // Reset all outputs to 0\n\t\tend else begin\n\t\t\tq <= d; // On clock edge, update outputs with inputs\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\n    assign out_and = &in;    // AND operation across all inputs\n    assign out_or = |in;     // OR operation across all inputs\n    assign out_xor = ^in;    // XOR operation across all inputs\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n    assign sum = a ^ b;  // Sum is the XOR of a and b\n    assign cout = a & b; // Carry-out is the AND of a and b\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\n    always @(*) begin\n        shut_off_computer = 0; // Default assignment\n        if (cpu_overheated)\n            shut_off_computer = 1;\n    end\n\n    always @(*) begin\n        keep_driving = 0; // Default assignment\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // Define state encoding\n    typedef enum reg {OFF = 1'b0, ON = 1'b1} state_t; \n    state_t current_state, next_state;\n\n    // Output logic based on current state\n    assign out = current_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= OFF; // Reset to OFF state\n        end else begin\n            current_state <= next_state; // Transition to next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            OFF: begin\n                if (j) \n                    next_state = ON; // Transition to ON if j=1\n                else \n                    next_state = OFF; // Stay in OFF if j=0\n            end\n            ON: begin\n                if (k) \n                    next_state = OFF; // Transition to OFF if k=1\n                else \n                    next_state = ON; // Stay in ON if k=0\n            end\n            default: \n                next_state = OFF; // Default state\n        endcase\n    end\nendmodule\n", "result": "failed: 21 out of 241 samples.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\n    // Concate all inputs and append two 1's at the end\n    wire [31:0] concatenated;\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign outputs\n    assign w = concatenated[31:24]; // 8 bits from MSB to w\n    assign x = concatenated[23:16]; // Next 8 bits to x\n    assign y = concatenated[15:8];   // Next 8 bits to y\n    assign z = concatenated[7:0];    // Last 8 bits to z\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (~a & ~b & ~c & ~d) | (~a & b & c & d) | (a & b & ~c & ~d) | (a & ~b & c & ~d) | (~a & b & c & ~d);\nendmodule\n", "result": "failed: 38 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Assign the output as the result of the AND operation on inputs a and b\n    assign out = a & b; // Using bitwise AND operator\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\n    // State encoding\n    parameter A = 1'b0, B = 1'b1;\n    \n    reg current_state, next_state;\n    \n    // Output logic based on the state\n    assign out = (current_state == B) ? 1'b1 : 1'b0;\n\n    // State transition logic\n    always @ (posedge clk) begin\n        if (reset) begin\n            current_state <= B; // Reset to State B\n        end else begin\n            current_state <= next_state; // Transition to next state\n        end\n    end\n    \n    // Next state logic based on current state and input\n    always @ (*) begin\n        case (current_state)\n            B: begin\n                if (in) \n                    next_state = B; // Stay in B\n                else \n                    next_state = A; // Go to A\n            end\n            \n            A: begin\n                if (in) \n                    next_state = A; // Stay in A\n                else \n                    next_state = B; // Go to B\n            end\n            \n            default: next_state = B; // Default case to prevent latches\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    assign sum = a ^ b ^ cin; // Sum is the XOR of all three inputs\n    assign cout = (a & b) | (cin & (a ^ b)); // Carry-out logic\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\n// Declare intermediate wires\nlogic xnor_out;\n\n// Implement the XNOR gate\nassign xnor_out = ~(in1 ^ in2); // XNOR is the negation of XOR\n\n// Implement the XOR gate\nassign out = xnor_out ^ in3; // XOR operation\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    // Define internal wires for multiplexers\n    wire d_mux_out;\n\n    // Use 2-to-1 multiplexers to get the correct mux_in[2] and mux_in[3]\n    assign d_mux_out = (c) ? d : 1'b1; // connective logic\n\n    // assign values to mux_in\n    assign mux_in[0] = 1'b0; // result of cd=00\n    assign mux_in[1] = 1'b0; // result of cd=01\n    assign mux_in[2] = d; // result of cd=10 based on input d\n    assign mux_in[3] = d_mux_out; // result of cd=11 based on d or a\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // State encoding\n    parameter A = 2'b01; // State A\n    parameter B = 2'b10; // State B\n    \n    reg [1:0] state, next_state;\n\n    // State transition on clock edge\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A; // reset to State A\n        end else begin\n            state <= next_state; // update state to next state\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B; // Transition to B\n                    z = 1; // Output z = 1\n                end else begin\n                    next_state = A; // Stay in A\n                    z = 0; // Output z = 0\n                end\n            end\n            B: begin\n                next_state = B; // Stay in B as per input\n                if (x) begin\n                    z = 0; // Output z = 0 when x=1\n                end else begin\n                    z = 1; // Output z = 1 when x=0\n                end\n            end\n            default: begin\n                next_state = A; // Default state in case of error\n                z = 0; // Default output\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\n    always @(posedge clk) begin\n        q <= a; // Capture the value of a on the rising edge of the clk\n    end\n    \n    always @(*) begin\n        // Define the state logic based on a, b, and the current q value\n        if (q == 0 && a == 1 && b == 1) begin\n            state = 1;\n        end else if (q == 1 && a == 0 && b == 1) begin\n            state = 0;\n        end else if (q == 1 && a == 1 && b == 0) begin\n            state = 1;\n        end else begin\n            state = 0; // Default case\n        end\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        f = (x[4] == 0 && x[3] == 0) ||                        // For (0,0)\n            (x[4] == 1 && x[3] == 1 && x[1] == 1) ||        // For (1,1) - group for sake of combination\n            (x[4] == 0 && x[1] == 1 && x[2] == 1) ||        // For (0,1,1)\n            (x[4] == 0 && x[3] == 1 && x[1] == 0) ||        // For (1,0)\n            (x[3] == 1 && x[2] == 1) ||                      // For (1,1)\n            (x[4] == 1 && x[1] == 0);                       // Direct (1,0)\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    // State Definitions\n    parameter S0 = 3'b000; // Initial state\n    parameter S1 = 3'b001; // 0 received\n    parameter S2 = 3'b010; // 1 received (011)\n    parameter S3 = 3'b011; // 11 received (0111)\n    parameter S4 = 3'b100; // 111 received (01111)\n    parameter S5 = 3'b101; // 1111 received (011111)\n    parameter S6 = 3'b110; // 11111 received (0111111)\n    parameter S7 = 3'b111; // 111111 received (0111111)\n    parameter S_err = 3'b1000; // Error state for 1111111\n\n    reg [3:0] state, next_state;\n\n    // Sequential block to update state based on clock\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Combinatorial block for next state logic and output assignments\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n        \n        case (state)\n            S0: begin\n                if (in == 0) next_state = S1; // Starting with 0\n                else next_state = S0;         // Ignore 1\n            end\n            S1: begin\n                if (in == 1) next_state = S2; // 01\n                else next_state = S0;         // Back to initial state\n            end\n            S2: begin\n                if (in == 1) next_state = S3; // 011\n                else next_state = S0;         // Back to initial state\n            end\n            S3: begin\n                if (in == 1) next_state = S4; // 0111\n                else next_state = S0;         // Back to initial state\n            end\n            S4: begin\n                if (in == 1) next_state = S5; // 01111\n                else next_state = S0;         // Back to initial state\n            end\n            S5: begin\n                if (in == 1) next_state = S6; // 011111\n                else next_state = S0;         // Back to initial state\n            end\n            S6: begin\n                if (in == 1) next_state = S7; // 0111111\n                else next_state = S0;         // Back to initial state\n            end\n            S7: begin\n                if (in == 1) next_state = S_err; // 0111111 (err state)\n                else next_state = S0;             // Back to initial state\n                disc = 1;                        // 0111110 seen\n            end\n            S_err: begin\n                err = 1;            // Error state\n                if (in == 0) next_state = S1; // Reset to check for new frame\n                else next_state = S_err;      // Stay in error state\n            end\n            default: next_state = S0;\n        endcase\n\n        // Set outputs for flag\n        if (state == S6 && in == 0) flag = 1;  // 01111110 seen, flag set\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State Declaration\n    typedef enum logic [2:0] {\n        S_IDLE,\n        S_PATTERN_1,\n        S_PATTERN_2,\n        S_PATTERN_3,\n        S_PATTERN_4,\n        S_READ_DELAY,\n        S_COUNTING,\n        S_DONE\n    } state_t;\n\n    state_t state, next_state;\n    reg [3:0] delay; // holds delay value\n    reg [10:0] clock_counter; // counter for clock cycles\n    reg [3:0] current_count; // current count value\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= S_IDLE;\n            counting <= 0;\n            done <= 0;\n            count <= 0;\n            current_count <= 0;\n            clock_counter <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (state == S_COUNTING) begin\n            if (clock_counter < 1000) begin\n                clock_counter <= clock_counter + 1;\n            end else begin\n                current_count <= current_count - 1; // decrement\n                clock_counter <= 0;\n            end\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (state == S_COUNTING && current_count == 0) begin\n            done <= 1; // Timer done\n        end else if (state == S_DONE && ack) begin\n            done <= 0; // Acknowledge done\n            state <= S_IDLE; // Go back to IDLE\n        end\n    end\n\n    always_comb begin\n        next_state = state; // default state\n        case (state)\n            S_IDLE: begin\n                counting <= 0;\n                if (data == 1'b1) next_state = S_PATTERN_1;\n            end\n            S_PATTERN_1: if (data == 1'b1) next_state = S_PATTERN_2; else next_state = S_IDLE;\n            S_PATTERN_2: if (data == 1'b0) next_state = S_PATTERN_3; else next_state = S_IDLE;\n            S_PATTERN_3: if (data == 1'b1) next_state = S_PATTERN_4; else next_state = S_IDLE;\n            S_PATTERN_4: if (data == 1'b0) next_state = S_READ_DELAY; else next_state = S_IDLE;\n            S_READ_DELAY: begin\n                if (delay < 4'b1111) begin // Reading 4 bits for delay\n                    delay = {delay[2:0], data};\n                    if (delay[3]) next_state = S_COUNTING; // If we read 4 bits\n                end else begin\n                    current_count <= delay; // Load delay count\n                    next_state = S_COUNTING;\n                end\n            end\n            S_COUNTING: begin\n                counting <= 1;\n                if (current_count == 0) begin\n                    next_state = S_DONE;\n                end\n            end\n            S_DONE: begin\n                counting <= 0;\n                if (ack) next_state = S_IDLE;\n            end\n        endcase\n\n        count = current_count; // Show current count\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n    reg [3:1] last_s;  // To keep track of the previous sensor state\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // On reset, set all outputs high and no sensors asserted\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n            last_s <= 3'b000;  // No sensors asserted\n        end else begin\n            // Determine the state based on the current sensors\n            case(s)\n                3'b111: begin // Above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                    last_s <= s;\n                end\n                3'b110: begin // Between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= 0; // Previous level check not necessary\n                    last_s <= s;\n                end\n                3'b100: begin // Between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (last_s < s) ? 1 : 0; // Check if we have risen\n                    last_s <= s;\n                end\n                3'b000: begin // Below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                    last_s <= s;\n                end\n                default: begin // Case to handle potential undefined states\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                    last_s <= s;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 1171 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        START = 3'b001,\n        DATA = 3'b010,\n        STOP = 3'b011,\n        WAIT_STOP = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    int bit_count; // Counts the number of received bits\n\n    // Asynchronous reset and state transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        done = 0; // Default done signal is low\n        case (state)\n            IDLE: begin\n                if (in == 0) begin // Start bit detected\n                    next_state = START;\n                end\n            end\n            START: begin\n                next_state = DATA; // Move to data bit state\n                bit_count = 0; // Reset bit counter\n            end\n            DATA: begin\n                if (bit_count < 7) begin\n                    bit_count = bit_count + 1; // Increment bit counter\n                end else begin\n                    next_state = STOP; // Move to stop state after 8 bits\n                end\n            end\n            STOP: begin\n                if (in == 1) begin // Stop bit detected\n                    done = 1; // Signal that data was received\n                    next_state = IDLE; // Return to idle state\n                end else begin\n                    next_state = WAIT_STOP; // Stay in the character state until stop is found\n                end\n            end\n            WAIT_STOP: begin\n                if (in == 1) begin // Stop bit detected\n                    done = 1; // Signal that data was received\n                    next_state = IDLE; // Return to idle state\n                end else begin\n                    // Remain in WAIT_STOP\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    // Define state encoding\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        START = 2'b01,\n        DATA = 2'b10,\n        STOP = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] bit_count; // Counts the received bits\n    reg [7:0] byte_buffer; // Holds the incoming byte\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            done <= 0;\n            bit_count <= 0;\n            out_byte <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == DATA) begin\n                byte_buffer <= {in, byte_buffer[7:1]};\n            end\n            if (current_state == STOP) begin\n                if (in == 1) begin // Stop bit valid\n                    done <= 1;\n                    out_byte <= byte_buffer;\n                end else begin\n                    done <= 0; // Invalid stop bit, do not assert done\n                end\n            end else begin\n                done <= 0; // Reset done for other states\n            end\n        end\n    end\n\n    // State transition logic\n    always @* begin\n        next_state = current_state; // Default to stay in the same state\n        case (current_state)\n            IDLE: begin\n                if (in == 0) next_state = START; // Start bit detected\n            end\n            START: begin\n                next_state = DATA; // Move to DATA state\n                bit_count = 0; // Reset counter in START state\n            end\n            DATA: begin\n                bit_count = bit_count + 1;\n                if (bit_count == 8) begin\n                    next_state = STOP; // Transition to STOP after 8 bits\n                end\n            end\n            STOP: begin\n                if (in == 1) begin\n                    next_state = IDLE; // If stop bit is 1, go back to IDLE\n                end // If stop bit isn't 1, stay in STOP state until valid\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\n    // Global History Register (GHR)\n    reg [6:0] ghr;\n    \n    // Pattern History Table (PHT) - 128 entries, 2 bits each\n    reg [1:0] pht[127:0];\n\n    // Initialize PHT and GHR on reset\n    integer i;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            ghr <= 7'b0;\n            for (i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b00; // Initialize all counters to '00' (weakly not taken)\n            end\n        end else begin\n            // Training logic\n            if (train_valid) begin\n                int index = (train_pc[6:0] ^ ghr) % 128; // Calculate index\n                // Handle training with respect to misprediction\n                if (train_mispredicted) begin\n                    ghr <= train_history; // Rollback to the history register after a misprediction\n                end\n\n                // Update PHT entry\n                if (train_taken) begin\n                    pht[index] <= (pht[index] == 2'b11) ? 2'b11 : pht[index] + 1; // Saturate up\n                end else begin\n                    pht[index] <= (pht[index] == 2'b00) ? 2'b00 : pht[index] - 1; // Saturate down\n                end\n\n                // After updating GHR\n                ghr <= {ghr[5:0], train_taken}; // Shift in the new outcome\n            end\n            \n            // Prediction logic\n            if (predict_valid) begin\n                int predict_index = (predict_pc[6:0] ^ ghr) % 128; // Compute the index\n                // Make prediction based on PHT entry\n                predict_taken <= (pht[predict_index] > 2'b01); // Taken if counter is 2 or higher\n                predict_history <= ghr;\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\n    // Define states\n    typedef enum reg [2:0] {\n        STATE_WALK_LEFT = 3'b000,\n        STATE_WALK_RIGHT = 3'b001,\n        STATE_FALLING = 3'b010,\n        STATE_DIGGING = 3'b011,\n        STATE_SPLATTER = 3'b100\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    reg [4:0] falling_timer; // 5 bits to hold up to 31 cycles for falling\n    \n    // Synchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_WALK_LEFT;\n            falling_timer <= 0;\n        end else if (current_state != STATE_SPLATTER) begin\n            current_state <= next_state;\n            if (current_state == STATE_FALLING) // Increment timer only when falling\n                falling_timer <= falling_timer + 1;\n            else\n                falling_timer <= 0; // Reset timer when not falling\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        // Default values\n        next_state = current_state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (current_state)\n            STATE_WALK_LEFT: begin\n                if (dig && ground) begin\n                    next_state = STATE_DIGGING;\n                    digging = 1;\n                end else if (!ground) begin\n                    next_state = STATE_FALLING;\n                    aaah = 1; // Start falling with aaah\n                end else if (bump_right) begin\n                    next_state = STATE_WALK_RIGHT;\n                end\n                walk_left = 1;\n            end\n            \n            STATE_WALK_RIGHT: begin\n                if (dig && ground) begin\n                    next_state = STATE_DIGGING;\n                    digging = 1;\n                end else if (!ground) begin\n                    next_state = STATE_FALLING;\n                    aaah = 1; // Start falling with aaah\n                end\n                else if (bump_left) begin\n                    next_state = STATE_WALK_LEFT;\n                end\n                walk_right = 1;\n            end\n            \n            STATE_FALLING: begin\n                aaah = 1; // Continuously falling\n                if (ground) begin\n                    if (falling_timer > 20) begin\n                        next_state = STATE_SPLATTER; // Splatter if falling too long\n                    end else begin\n                        // Resume walking in original direction determined by last walking state\n                        if (walk_left) \n                            next_state = STATE_WALK_LEFT;\n                        else if (walk_right)\n                            next_state = STATE_WALK_RIGHT;\n                    end\n                end\n            end\n            \n            STATE_DIGGING: begin\n                if (!ground) begin\n                    next_state = STATE_FALLING;\n                    aaah = 1; // Fall after digging\n                end\n                digging = 1; // Continue digging\n            end\n            \n            STATE_SPLATTER: begin\n                // No transitions from splatter state\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    \n    // State encoding\n    typedef enum logic [2:0] {\n        IDLE,\n        WAIT_FOR_PATTERN_1,\n        WAIT_FOR_PATTERN_2,\n        WAIT_FOR_PATTERN_3,\n        ENABLE_SHIFT,\n        WAIT_COUNT_DONE,\n        NOTIFY_DONE\n    } state_t;\n    \n    state_t current_state, next_state;\n    reg [2:0] shift_count;  // Counter for shift enable (4 bits need to be counted)\n    \n    // State Transition\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_count <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Next State Logic\n    always_comb begin\n        // Default assignments\n        next_state = current_state;  // Stay in current state by default\n        shift_ena = 0;                // Default outputs\n        counting = 0;\n        done = 0;\n\n        case (current_state)\n            IDLE: begin\n                if (data == 1) next_state = WAIT_FOR_PATTERN_1;\n            end\n            \n            WAIT_FOR_PATTERN_1: begin\n                if (data == 1) next_state = WAIT_FOR_PATTERN_2; // 11\n                else if (data == 0) next_state = IDLE; // reset if wrong\n            end\n            \n            WAIT_FOR_PATTERN_2: begin\n                if (data == 0) next_state = WAIT_FOR_PATTERN_3; // 110\n                else next_state = IDLE; // reset if wrong\n            end\n            \n            WAIT_FOR_PATTERN_3: begin\n                if (data == 1) next_state = ENABLE_SHIFT; // 1101\n                else next_state = IDLE; // reset if wrong\n            end\n            \n            ENABLE_SHIFT: begin\n                if (shift_count < 3) begin  // Shift for 4 cycles (0,1,2,3)\n                    shift_ena = 1; \n                    shift_count = shift_count + 1;\n                end else begin\n                    shift_count = 0;\n                    next_state = WAIT_COUNT_DONE;\n                end\n            end\n            \n            WAIT_COUNT_DONE: begin\n                counting = 1; // start counting\n                if (done_counting) next_state = NOTIFY_DONE;\n            end\n            \n            NOTIFY_DONE: begin\n                done = 1; // Notify user that timer is done\n                if (ack) next_state = IDLE; // Wait for ack to reset\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\nendmodule\n", "result": "failed: 1109 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    \n    reg [255:0] next_q; // Temporary next state container\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load initial state\n        end else begin\n            q <= next_q; // Update state to next state\n        end\n    end\n\n    // This block computes the next state\n    always @* begin\n        integer i, j, count;\n        for (i = 0; i < 256; i = i + 1) begin\n            count = 0;\n            // Count the neighbors (8 directions)\n            for (j = -1; j <= 1; j = j + 1) begin\n                for (k = -1; k <= 1; k = k + 1) begin\n                    if (!(j == 0 && k == 0)) begin // Skip the cell itself\n                        // Calculate neighbor index with wrap-around\n                        count = count + q[(i + j * 16 + k) & 255]; // Wrap-around\n                    end\n                end\n            end\n            \n            // Update the next state based on the neighbor count\n            case (count)\n                0, 1, 4: next_q[i] = 0; // 0-1 neighbours or 4+ neighbours\n                2: next_q[i] = q[i]; // 2 neighbours, state unchanged\n                3: next_q[i] = 1; // 3 neighbours, cell becomes alive\n                default: next_q[i] = 0; // Default case\n            endcase\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n  \n    // State encoding\n    typedef enum logic [2:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALLING,\n        DIGGING\n    } state_t;\n\n    state_t state, next_state;\n\n    // Register the state on clock edge\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Reset state\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state; // Default to stay in the current state\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1; // Start falling\n                end else if (dig) begin\n                    next_state = DIGGING;\n                    digging = 1; // Start digging\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                    walk_right = 1; // Walk right\n                end else begin\n                    walk_left = 1; // Continue walking left\n                end\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1; // Start falling\n                end else if (dig) begin\n                    next_state = DIGGING;\n                    digging = 1; // Start digging\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                    walk_left = 1; // Walk left\n                end else begin\n                    walk_right = 1; // Continue walking right\n                end\n            end\n\n            FALLING: begin\n                if (ground) begin\n                    if (state == WALK_LEFT) begin\n                        next_state = WALK_LEFT;\n                        walk_left = 1; // Resume walking left\n                    end else begin\n                        next_state = WALK_RIGHT;\n                        walk_right = 1; // Resume walking right\n                    end\n                end else begin\n                    aaah = 1; // Stay falling\n                end\n            end\n            \n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                    aaah = 1; // Start falling\n                end else begin\n                    digging = 1; // Continue digging\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            hh <= 8'b00001100; // 12 in BCD\n            mm <= 8'b00000000; // 00 in BCD\n            ss <= 8'b00000000; // 00 in BCD\n            pm <= 1'b0; // Start as AM\n        end else if (ena) begin\n            if (ss == 8'b00111001) begin // ss = 59\n                ss <= 8'b00000000; // Reset seconds\n                if (mm == 8'b00111001) begin // mm = 59\n                    mm <= 8'b00000000; // Reset minutes\n                    if (hh == 8'b00001100) begin // hh = 12\n                        hh <= 8'b00000001; // Reset hours to 01\n                        pm <= ~pm; // Toggle AM/PM\n                    end else begin\n                        hh <= hh + 1; // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 1; // Increment minutes\n                end\n            end else begin\n                ss <= ss + 1; // Increment seconds\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\n\ttypedef enum reg [1:0] {WALK_LEFT, WALK_RIGHT, FALL} state_type;\n\tstate_type state, next_state;\n\n\t// Sequential logic for state transitions\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= WALK_LEFT;  // Initial state, walking left\n\t\tend else begin\n\t\t\tstate <= next_state; // Transition to the next state\n\t\tend\n\tend\n\n\t// Combinational logic for next state and outputs\n\talways @* begin\n\t\t// Default outputs\n\t\twalk_left = 0;\n\t\twalk_right = 0;\n\t\taaah = 0; // Default not falling\n\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = FALL; // fall if ground disappears\n\t\t\t\t\taaah = 1; // saying \"aaah!\"\n\t\t\t\tend else if (bump_right) begin\n\t\t\t\t\tnext_state = WALK_RIGHT; // bump right changes direction\n\t\t\t\tend else if (bump_left) begin\n\t\t\t\t\tnext_state = WALK_RIGHT; // bump left changes direction\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = WALK_LEFT; // remain walking left\n\t\t\t\t\twalk_left = 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = FALL; // fall if ground disappears\n\t\t\t\t\taaah = 1; // saying \"aaah!\"\n\t\t\t\tend else if (bump_left) begin\n\t\t\t\t\tnext_state = WALK_LEFT; // bump left changes direction\n\t\t\t\tend else if (bump_right) begin\n\t\t\t\t\tnext_state = WALK_LEFT; // bump right changes direction\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = WALK_RIGHT; // remain walking right\n\t\t\t\t\twalk_right = 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tFALL: begin\n\t\t\t\tif (ground) begin\n\t\t\t\t\tif (state == WALK_LEFT) begin\n\t\t\t\t\t\tnext_state = WALK_LEFT; // Should resume walking left\n\t\t\t\t\t\twalk_left = 1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = WALK_RIGHT; // Should resume walking right\n\t\t\t\t\t\twalk_right = 1;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = FALL; // Remain falling\n\t\t\t\t\taaah = 1; // Still saying \"aaah!\"\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tdefault: begin\n\t\t\t\tnext_state = WALK_LEFT; // Default state\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 16'b0;  // Reset all digits to zero\n        end else begin\n            // Increment the ones digit\n            if (q[3:0] == 4'b1001) begin // Check for 9\n                q[3:0] <= 4'b0000;      // Reset ones digit to 0\n                ena[1] <= 1'b1;         // Enable for tens digit\n                if (q[7:4] == 4'b1001) begin // Check tens\n                    q[7:4] <= 4'b0000;        // Reset tens to 0\n                    ena[2] <= 1'b1;           // Enable for hundreds digit\n                    if (q[11:8] == 4'b1001) begin // Check hundreds\n                        q[11:8] <= 4'b0000;   // Reset hundreds to 0\n                        ena[3] <= 1'b1;       // Enable for thousands digit\n                        if (q[15:12] == 4'b1001) begin // Check thousands\n                            q[15:12] <= 4'b0000; // Reset thousands to 0\n                        end else begin\n                            q[15:12] <= q[15:12] + 1; // Increment thousands\n                        end\n                    end else begin\n                        q[7:4] <= q[7:4] + 1; // Increment tens digit\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1; // Increment tens digit\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1; // Increment ones digit\n                ena <= 3'b000; // Disable upper level increments\n            end\n        end\n    end\n\n    // Default values for enable signals when no carry happens\n    always @(posedge clk) begin\n        if (q[3:0] < 9) begin\n            ena <= 3'b000; // No enable\n        end else begin\n            ena[1] <= (q[3:0] == 4'b1001);\n            ena[2] <= (q[7:4] == 4'b1001);\n            ena[3] <= (q[11:8] == 4'b1001);\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
