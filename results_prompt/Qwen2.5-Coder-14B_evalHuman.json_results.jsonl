{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\nalways @(*) begin\n\tif (sel == 1'b0) begin\n\t\tout <= a;\n\tend else begin\n\t\tout <= b;\n\tend\nend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(*) begin\n    case(y)\n        3'b000: // State A\n            if (w == 0) Y2 = 1'b0; // Next state B\n            else Y2 = 1'b0; // Stay at A\n        3'b001: // State B\n            if (w == 0) Y2 = 1'b0; // Next state C\n            else Y2 = 1'b1; // Next state D\n        3'b010: // State C\n            if (w == 0) Y2 = 1'b1; // Next state E\n            else Y2 = 1'b1; // Next state D\n        3'b011: // State D\n            if (w == 0) Y2 = 1'b1; // Next state F\n            else Y2 = 1'b0; // Next state A\n        3'b100: // State E\n            if (w == 0) Y2 = 1'b1; // Stay at E\n            else Y2 = 1'b0; // Next state D\n        3'b101: // State F\n            if (w == 0) Y2 = 1'b0; // Next state C\n            else Y2 = 1'b0; // Next state D\n        default: Y2 = 1'bX; // Undefined state\n    endcase\nend\n\nendmodule\n", "result": "failed: 40 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = ring & vibrate_mode;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n    // Using an assign statement for out_assign\n    assign out_assign = a & b;\n\n    // Combinational always block for out_alwaysblock\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n    // Always assign 0 to the output\n    assign zero = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    q <= a;\nend\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\t\n\t// Define states\n\ttypedef enum logic [1:0] {INITIAL = 2'b00, FLIP_BITS = 2'b01, ADD_ONE = 2'b10} state_t;\n\t\n\t// State and shift registers\n\tstate_t state, next_state;\n\tlogic [7:0] shift_reg; // Assuming an 8-bit register for demonstration purposes\n\t\n\t// Output signal\n\twire carry_out;\n\t\n\t// State transition logic\n\talways_ff @(posedge clk, posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tstate <= INITIAL;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\t// Next state logic\n\talways_comb\n\tbegin\n\t\tcase(state)\n\t\t\tINITIAL: begin\n\t\t\t\tif (x)\n\t\t\t\t\tnext_state = FLIP_BITS;\n\t\t\t\telse\n\t\t\t\t\tnext_state = INITIAL;\n\t\t\tend\n\t\t\tFLIP_BITS: begin\n\t\t\t\tif (shift_reg == 8'b11111111)\n\t\t\t\t\tnext_state = ADD_ONE;\n\t\t\t\telse\n\t\t\t\t\tnext_state = FLIP_BITS;\n\t\t\tend\n\t\t\tADD_ONE: begin\n\t\t\t\tif (carry_out)\n\t\t\t\t\tnext_state = ADD_ONE;\n\t\t\t\telse\n\t\t\t\t\tnext_state = INITIAL;\n\t\t\tend\n\t\t\tdefault: next_state = INITIAL;\n\t\tendcase\n\tend\n\t\n\t// Shift register logic\n\talways_ff @(posedge clk)\n\tbegin\n\t\tif (state == FLIP_BITS)\n\t\t\tshift_reg <= {shift_reg[6:0], ~x};\n\t\telse if (state == ADD_ONE)\n\t\t\tshift_reg <= {shift_reg[6:0], 1'b0};\n\tend\n\t\n\t// Output logic\n\tassign z = (state == FLIP_BITS) ? ~shift_reg[0] : shift_reg[0];\n\t\n\t// Carry out calculation\n\tassign carry_out = &shift_reg;\nendmodule\n", "result": "failed: 422 out of 436 samples.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case(current_state)\n            A: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = B;\n                out = 0;\n            end\n            B: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 0;\n            end\n            C: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = D;\n                out = 0;\n            end\n            D: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 1;\n            end\n            default: begin\n                next_state = A;\n                out = 0;\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    \n    // Extracting bytes from the input vector\n    wire [7:0] byte0 = in[7:0];  // Least significant byte\n    wire [7:0] byte1 = in[15:8]; // Second byte\n    wire [7:0] byte2 = in[23:16]; // Third byte\n    wire [7:0] byte3 = in[31:24]; // Most significant byte\n    \n    // Reversing the byte order\n    assign out = {byte0, byte1, byte2, byte3}; // Assigning the reversed bytes to the output\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n    // Detect the rising edge of the clock\n    always @(posedge clk) begin\n        // If reset is high, force q to 0\n        if (r)\n            q <= 0;\n        else\n            // Otherwise, set q to the value of d\n            q <= d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\t// Perform XOR operation on inputs x and y\n\twire xor_result = x ^ y;\n\n\t// Perform AND operation between the XOR result and input x\n\tassign z = xor_result & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into the shift register\n            q <= data;\n        end else if (ena) begin\n            case (amount)\n                2'b00: begin\n                    // Shift left by 1 bit\n                    q <= {q[62:0], 1'b0};\n                end\n                2'b01: begin\n                    // Shift left by 8 bits\n                    q <= {q[55:0], 8'b0};\n                end\n                2'b10: begin\n                    // Arithmetic shift right by 1 bit\n                    q <= {{1{q[63]}}, q[63:1]};\n                end\n                2'b11: begin\n                    // Arithmetic shift right by 8 bits\n                    q <= {{8{q[63]}}, q[63:8]};\n                end\n                default: begin\n                    // No shift operation\n                    q <= q;\n                end\n            endcase\n        end else begin\n            // Hold the current state if neither load nor ena is active\n            q <= q;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define the states\n    typedef enum {S0, S1, S2} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always @(posedge clk or negedge aresetn)\n        if (!aresetn)\n            current_state <= S0; // Asynchronous reset to S0\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: if (x == 1'b1)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            S1: if (x == 1'b0)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            S2: if (x == 1'b1)\n                    next_state = S0;\n                else\n                    next_state = S0;\n            default: next_state = S0; // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = 1'b0; // Default output\n        if (current_state == S2 && x == 1'b1)\n            z = 1'b1; // Set z to 1 when transitioning from S2 to S0 due to '1'\n    end\n    \nendmodule\n", "result": "failed: 22 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {A, B, C, D, E, F} state_t;\n    \n    // State register\n    state_t current_state, next_state;\n\n    // Output z based on current state\n    assign z = (current_state == D || current_state == E) ? 1'b1 : 1'b0;\n\n    // Next state logic\n    always_comb begin\n        unique case (current_state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A; // In case of invalid state\n        endcase\n    end\n\n    // State register update on clock edge\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    // State definition\n    parameter IDLE = 0, BYTE1 = 1, BYTE2 = 2, BYTE3 = 3, DONE = 4;\n    \n    // State register\n    reg [2:0] state_reg, state_next;\n    \n    // Byte registers\n    reg [7:0] byte1, byte2, byte3;\n\n    // Next state logic\n    always @(state_reg or in or reset) begin\n        case(state_reg)\n            IDLE: if (!reset && in[3]) state_next = BYTE1; else state_next = IDLE;\n            BYTE1: state_next = BYTE2;\n            BYTE2: state_next = BYTE3;\n            BYTE3: state_next = DONE;\n            DONE: state_next = IDLE;\n            default: state_next = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state_reg <= IDLE;\n            byte1 <= 0;\n            byte2 <= 0;\n            byte3 <= 0;\n            done <= 0;\n        end else begin\n            state_reg <= state_next;\n            case(state_reg)\n                BYTE1: byte1 <= in;\n                BYTE2: byte2 <= in;\n                BYTE3: begin\n                    byte3 <= in;\n                    done <= 1;\n                end\n                DONE: done <= 0;\n                default: ;\n            endcase\n        end\n    end\n\n    // Assign out_bytes\n    assign out_bytes = {byte3, byte2, byte1};\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    // Y1 Logic\n    assign Y1 = (y == 6'b000001 && w) || (y == 6'b001000 && w) || (y == 6'b100000 && !w);\n    \n    // Y3 Logic\n    assign Y3 = (y == 6'b000010 && w) || (y == 6'b000010 && !w) || (y == 6'b000100 && !w) || (y == 6'b010000 && !w) || (y == 6'b100000 && !w);\nendmodule\n", "result": "failed: 228 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n\t// Assign the input vector to the output vector\n\tassign outv = vec;\n\n\t// Assign each bit of the input vector to the respective output\n\tassign o2 = vec[2];\n\tassign o1 = vec[1];\n\tassign o0 = vec[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n\t// Implementing the logic derived from the Karnaugh map\n\tout = (a & ~d) | (~a & d);\nend\nendmodule\n", "result": "failed: 119 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n    // Assign the upper byte to out_hi\n    assign out_hi = in[15:8];\n    // Assign the lower byte to out_lo\n    assign out_lo = in[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\t\n\t// Step 1: Combine the inputs using OR operation\n\twire or_output;\n\tor #1 or_gate(a, b, or_output);\n\t\n\t// Step 2: Negate the OR output to get the NOR output\n\tnot #1 not_gate(or_output, out);\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\n// Using assign statement for out_assign\nassign out_assign = a ^ b;\n\n// Combinational always block for out_always_comb\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block for out_always_ff\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n    // Next state logic for Y2 (State B)\n    assign Y2 = y[1] & ~w;\n    \n    // Next state logic for Y4 (State D)\n    assign Y4 = y[1] & w | y[2] & w | y[3] & w | y[5] & ~w | y[6] & ~w;\nendmodule\n", "result": "failed: 256 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\t// Assign the output to the selected bit in the input vector\n\talways @(*) begin\n\t\tout = in[sel];\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n    // Internal signal to hold the multiplexer output before it goes into the flip-flop\n    reg Q_next;\n\n    // Determine the next state of Q based on control signals L and E\n    always @(posedge clk) begin\n        if (L)\n            Q <= R;  // Load R into Q if L is high\n        else if (E)\n            Q <= w;  // Shift in w if E is high (assuming shifting left)\n        else\n            Q <= Q;  // Hold the current value of Q if no change is required\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Declare the flip-flops\n    reg q1;\n    reg q2;\n    reg q3;\n\n    // Define the outputs of the logic gates as wires\n    wire xor_out;\n    wire and_out;\n    wire or_out;\n\n    // Define the XNOR gate output\n    wire xnout;\n\n    // Implement the XOR gate\n    assign xor_out = x ^ q1;\n\n    // Implement the AND gate\n    assign and_out = x & (~q2);\n\n    // Implement the OR gate\n    assign or_out = x | (~q3);\n\n    // Implement the D flip-flops\n    always @(posedge clk) begin\n        q1 <= xor_out;\n        q2 <= and_out;\n        q3 <= or_out;\n    end\n\n    // Implement the three-input XNOR gate\n    assign xnout = ~(~q1 ^ ~q2 ^ ~q3);\n\n    // Assign the final output\n    assign z = xnout;\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\t\n\twire or_result = b | c | d; // OR of b, c, and d\n\twire and_result = b & c & d; // AND of b, c, and d\n\twire not_and_result = ~and_result; // Invert the AND result\n\t\n\tassign q = (a == 0) ? or_result : not_and_result;\n\t\nendmodule\n", "result": "failed: 30 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    // State update logic\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            begin\n                // Compute next state for each cell\n                for (integer i = 0; i < 512; i = i + 1) begin\n                    integer left, center, right;\n                    \n                    // Boundary conditions\n                    if (i == 0) begin\n                        left = 0; // Fixed boundary condition\n                        center = q[i];\n                        right = q[i+1];\n                    end\n                    else if (i == 511) begin\n                        left = q[i-1];\n                        center = q[i];\n                        right = 0; // Fixed boundary condition\n                    end\n                    else begin\n                        left = q[i-1];\n                        center = q[i];\n                        right = q[i+1];\n                    end\n                    \n                    // Apply Rule 110\n                    case ({left, center, right})\n                        3'b111: q[i] <= 1'b0;\n                        3'b110: q[i] <= 1'b1;\n                        3'b101: q[i] <= 1'b1;\n                        3'b100: q[i] <= 1'b0;\n                        3'b011: q[i] <= 1'b1;\n                        3'b010: q[i] <= 1'b1;\n                        3'b001: q[i] <= 1'b1;\n                        3'b000: q[i] <= 1'b0;\n                    endcase\n                end\n            end\n    end\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t\n\tenum {A, B, C, D} state, next_state;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase(state)\n\t\t\tA: begin\n\t\t\t\tnext_state = (in == 1'b0) ? A : B;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tnext_state = (in == 1'b0) ? C : B;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tnext_state = (in == 1'b0) ? A : D;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tnext_state = (in == 1'b0) ? C : B;\n\t\t\t\tout = 1'b1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = A;\n\t\t\t\tout = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase (c)\n\t\t\t4'b0000: q = b; // c = 0\n\t\t\t4'b0001: q = e; // c = 1\n\t\t\t4'b0010: q = a; // c = 2\n\t\t\t4'b0011: q = d; // c = 3\n\t\t\tdefault: q = 4'b1111; // c >= 4, set q to 'f'\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n    \n    // Use an always block for proper handling of reg type output\n    always @(*) begin\n        if (sel)\n            out <= b;\n        else\n            out <= a;\n    end\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    // Internal signal to hold the next state of Q\n    reg next_Q;\n\n    // Define the next state logic\n    always @(*) begin\n        if (L)\n            next_Q = r_in;\n        else\n            next_Q = q_in ^ Q;\n    end\n\n    // Flip-flop to store the state\n    always @(posedge clk) begin\n        Q <= next_Q;\n    end\n\nendmodule\n", "result": "failed: 49 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    // Register to hold the previous value of 'in'\n    reg [31:0] prev_in;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the output and previous state\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            // Store the current input as the previous input for the next cycle\n            prev_in <= in;\n\n            // Detect transitions from 1 to 0 and update the output\n            out <= (prev_in & (~in)) & out | (prev_in & (~in));\n        end\n    end\nendmodule\n", "result": "failed: 227 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        // Update all 8 flip-flops on the rising edge of the clock\n        q <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    // Perform the addition\n    assign {overflow, s} = a + b;\n\nendmodule\n", "result": "failed: 55 out of 116 samples.", "passed": false}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // State encoding\n    localparam S = 10'b0000000001;\n    localparam S1 = 10'b0000000010;\n    localparam S11 = 10'b0000000100;\n    localparam S110 = 10'b0000001000;\n    localparam B0 = 10'b0000010000;\n    localparam B1 = 10'b0000100000;\n    localparam B2 = 10'b0001000000;\n    localparam B3 = 10'b0010000000;\n    localparam Count = 10'b0100000000;\n    localparam Wait = 10'b1000000000;\n\n    // Next state logic\n    wire [9:0] next_state;\n    assign next_state = (state == S) ? (d ? S1 : S) :\n                        (state == S1) ? (d ? S1 : S1) :\n                        (state == S11) ? (d ? S11 : S110) :\n                        (state == S110) ? (d ? B0 : S) :\n                        (state == B0) ? B1 :\n                        (state == B1) ? B2 :\n                        (state == B2) ? B3 :\n                        (state == B3) ? Count :\n                        (state == Count) ? (done_counting ? Wait : Count) :\n                        (state == Wait) ? (ack ? S : Wait) : 10'b0;\n\n    // Assign next state bits\n    assign B3_next = &next_state & B3;\n    assign S_next = &next_state & S;\n    assign S1_next = &next_state & S1;\n    assign Count_next = &next_state & Count;\n    assign Wait_next = &next_state & Wait;\n\n    // Output logic\n    assign shift_ena = |{B0, B1, B2, B3};\n    assign counting = Count;\n    assign done = Wait;\n\nendmodule\n", "result": "failed: 3199 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            state <= 2'b01; // Weakly not-taken\n        else if (train_valid)\n        begin\n            if (train_taken)\n                state <= state == 2'b11 ? 2'b11 : state + 1; // Increment, saturate at 3\n            else\n                state <= state == 2'b00 ? 2'b00 : state - 1; // Decrement, saturate at 0\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @(*) begin\n        // Initialize pos to 0\n        pos = 3'b0;\n        \n        // Check each bit from LSB to MSB\n        if (in[0]) pos = 3'b000; // Bit 0\n        else if (in[1]) pos = 3'b001; // Bit 1\n        else if (in[2]) pos = 3'b010; // Bit 2\n        else if (in[3]) pos = 3'b011; // Bit 3\n        else if (in[4]) pos = 3'b100; // Bit 4\n        else if (in[5]) pos = 3'b101; // Bit 5\n        else if (in[6]) pos = 3'b110; // Bit 6\n        else if (in[7]) pos = 3'b111; // Bit 7\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n    always @(*) begin\n        // Initialize all outputs to low\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Check the scancode against each arrow key scancode\n        case(scancode)\n            16'hE06B: left = 1; // Left arrow\n            16'hE072: down = 1; // Down arrow\n            16'hE074: right = 1; // Right arrow\n            16'hE075: up = 1; // Up arrow\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n\t// Declare intermediate signals for carries\n\twire c1, c2, c3, c4;\n\t\n\t// Full Adder for the least significant bit\n\tfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n\t\n\t// Full Adders for the remaining bits\n\tfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n\tfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n\tfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n\t\n\t// Overflow is detected as XOR of initial carry (0) and final carry (c4)\n\tassign sum[4] = c4 ^ 1'b0;\nendmodule\n\n// Define the full_adder module if not already defined\nmodule full_adder (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput reg sum,\n\toutput reg cout\n);\n\talways @(*) begin\n\t\tsum = a ^ b ^ cin;\n\t\tcout = (a & b) | (cin & (a ^ b));\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    // Internal signal for the next state of the shift register\n    logic [31:0] next_state;\n\n    // Asynchronous reset\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            predict_history <= 32'b0;\n        else\n            predict_history <= next_state;\n\n    // Determine the next state based on conditions\n    always_comb begin\n        // Default behavior: shift left\n        next_state = {predict_history[30:0], predict_history[31]};\n        \n        // Override if train_mispredicted is active\n        if (train_mispredicted)\n            next_state = {train_history, train_taken};\n\n        // Override if predict_valid is active and no misprediction\n        else if (predict_valid)\n            next_state = {predict_history[30:0], predict_taken};\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n    // Intermediate wires\n    wire and_out1;\n    wire and_out2;\n    wire or_out;\n\n    // First AND gate\n    assign and_out1 = a & b;\n\n    // Second AND gate\n    assign and_out2 = c & d;\n\n    // OR gate combining the two AND gates\n    assign or_out = and_out1 | and_out2;\n\n    // Output assignments\n    assign out = or_out;\n    assign out_n = ~or_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    // Monitor the rising edge of the clock\n    always @(posedge clk) begin\n        // Assign the value of 'd' to 'q'\n        q <= d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    \n    reg [7:0] q;\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable)\n            q <= {S, q[7:1]};\n    end\n    \n    // Multiplexer logic to select the appropriate bit\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = q[0];\n            3'b001: Z = q[1];\n            3'b010: Z = q[2];\n            3'b011: Z = q[3];\n            3'b100: Z = q[4];\n            3'b101: Z = q[5];\n            3'b110: Z = q[6];\n            3'b111: Z = q[7];\n            default: Z = 1'b0; // Default case, not necessary but good practice\n        endcase\n    end\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n    // Heater control\n    assign heater = (mode && too_cold);\n\n    // Air Conditioner control\n    assign aircon = (!mode && too_hot);\n\n    // Fan control\n    // The fan should be on if heater or aircon is on, or if fan_on is true\n    assign fan = heater | aircon | fan_on;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\n// Sum-of-Products (SOP) Form\nassign out_sop = (~a & b & ~c & ~d) | (a & b & c & d);\n\n// Product-of-Sums (POS) Form\nassign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | b | ~c | d) & (a | b | ~c | ~d) &\n                 (a | b | ~c | ~d) & (a | ~b | c | d) & (a | ~b | c | ~d) & (a | ~b | ~c | d) &\n                 (~a | b | c | d);\n\nendmodule\n", "result": "failed: 67 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\t\n\t// Initialize the state when reset is high\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1; // Initial state\n\t\telse\n\t\t\tq <= {q[30:0], ^{q[31], q[21], q[1], q[0]}}; // Shift and compute new MSB\n\tend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Implementing the logic based on the observed pattern\n    assign q = ~(b & d); // This ensures q is 0 only when both b and d are 0, otherwise q is 1\nendmodule\n", "result": "failed: 85 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\t// Implementing the first 4-input NAND gate\n\twire and_result_p1;\n\tand_result_p1 = ~(p1a & p1b & p1c & p1d); // Calculate the AND result and then apply NOT\n\tp1y = and_result_p1; // Assign the NAND result to p1y\n\n\t// Implementing the second 4-input NAND gate\n\twire and_result_p2;\n\tand_result_p2 = ~(p2a & p2b & p2c & p2d); // Calculate the AND result and then apply NOT\n\tp2y = and_result_p2; // Assign the NAND result to p2y\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n\t\n\t// Define intermediate wires for the reduction process\n\twire [254:0] temp_in;\n\twire [127:0] stage1_out;\n\twire [63:0] stage2_out;\n\twire [31:0] stage3_out;\n\twire [15:0] stage4_out;\n\twire [7:0] stage5_out;\n\n\t// Stage 1: Count '1's in each byte of the input\n\tassign temp_in = {in[254:248], in[247:240], in[239:232], in[231:224], in[223:216], in[215:208], in[207:200], in[199:192], in[191:184], in[183:176], in[175:168], in[167:160], in[159:152], in[151:144], in[143:136], in[135:128], in[127:120], in[119:112], in[111:104], in[103:96], in[95:88], in[87:80], in[79:72], in[71:64], in[63:56], in[55:48], in[47:40], in[39:32], in[31:24], in[23:16], in[15:8], in[7:0]};\n\tassign stage1_out = {temp_in[254:248]&8+temp_in[254:248]&4+temp_in[254:248]&2+temp_in[254:248]&1, temp_in[247:240]&8+temp_in[247:240]&4+temp_in[247:240]&2+temp_in[247:240]&1, temp_in[239:232]&8+temp_in[239:232]&4+temp_in[239:232]&2+temp_in[239:232]&1, temp_in[231:224]&8+temp_in[231:224]&4+temp_in[231:224]&2+temp_in[231:224]&1, temp_in[223:216]&8+temp_in[223:216]&4+temp_in[223:216]&2+temp_in[223:216]&1, temp_in[215:208]&8+temp_in[215:208]&4+temp_in[215:208]&2+temp_in[215:208]&1, temp_in[207:200]&8+temp_in[207:200]&4+temp_in[207:200]&2+temp_in[207:200]&1, temp_in[199:192]&8+temp_in[199:192]&4+temp_in[199:192]&2+temp_in[199:192]&1, temp_in[191:184]&8+temp_in[191:184]&4+temp_in[191:184]&2+temp_in[191:184]&1, temp_in[183:176]&8+temp_in[183:176]&4+temp_in[183:176]&2+temp_in[183:176]&1, temp_in[175:168]&8+temp_in[175:168]&4+temp_in[175:168]&2+temp_in[175:168]&1, temp_in[167:160]&8+temp_in[167:160]&4+temp_in[167:160]&2+temp_in[167:160]&1, temp_in[159:152]&8+temp_in[159:152]&4+temp_in[159:152]&2+temp_in[159:152]&1, temp_in[151:144]&8+temp_in[151:144]&4+temp_in[151:144]&2+temp_in[151:144]&1, temp_in[143:136]&8+temp_in[143:136]&4+temp_in[143:136]&2+temp_in[143:136]&1, temp_in[135:128]&8+temp_in[135:128]&4+temp_in[135:128]&2+temp_in[135:128]&1, temp_in[127:120]&8+temp_in[127:120]&4+temp_in[127:120]&2+temp_in[127:120]&1, temp_in[119:112]&8+temp_in[119:112]&4+temp_in[119:112]&2+temp_in[119:112]&1, temp_in[111:104]&8+temp_in[111:104]&4+temp_in[111:104]&2+temp_in[111:104]&1, temp_in[103:96]&8+temp_in[103:96]&4+temp_in[103:96]&2+temp_in[103:96]&1, temp_in[95:88]&8+temp_in[95:88]&4+temp_in[95:88]&2+temp_in[95:88]&1, temp_in[87:80]&8+temp_in[87:80]&4+temp_in[87:80]&2+temp_in[87:80]&1, temp_in[79:72]&8+temp_in[79:72]&4+temp_in[79:72]&2+temp_in[79:72]&1, temp_in[71:64]&8+temp_in[71:64]&4+temp_in[71:64]&2+temp_in[71:64]&1, temp_in[63:56]&8+temp_in[63:56]&4+temp_in[63:56]&2+temp_in[63:56]&1, temp_in[55:48]&8+temp_in[55:48]&4+temp_in[55:48]&2+temp_in[55:48]&1, temp_in[47:40]&8+temp_in[47:40]&4+temp_in[47:40]&2+temp_in[47:40]&1, temp_in[39:32]&8+temp_in[39:32]&4+temp_in[39:32]&2+temp_in[39:32]&1, temp_in[31:24]&8+temp_in[31:24]&4+temp_in[31:24]&2+temp_in[31:24]&1, temp_in[23:16]&8+temp_in[23:16]&4+temp_in[23:16]&2+temp_in[23:16]&1, temp_in[15:8]&8+temp_in[15:8]&4+temp_in[15:8]&2+temp_in[15:8]&1, temp_in[7:0]&8+temp_in[7:0]&4+temp_in[7:0]&2+temp_in[7:0]&1};\n\n\t// Stage 2: Reduce the counts to half the size\n\tassign stage2_out = stage1_out[127:120]+stage1_out[119:112]+stage1_out[111:104]+stage1_out[103:96]+stage1_out[95:88]+stage1_out[87:80]+stage1_out[79:72]+stage1_out[71:64]+stage1_out[63:56]+stage1_out[55:48]+stage1_out[47:40]+stage1_out[39:32]+stage1_out[31:24]+stage1_out[23:16]+stage1_out[15:8]+stage1_out[7:0];\n\n\t// Stage 3: Further reduce the counts\n\tassign stage3_out = stage2_out[63:56]+stage2_out[55:48]+stage2_out[47:40]+stage2_out[39:32]+stage2_out[31:24]+stage2_out[23:16]+stage2_out[15:8]+stage2_out[7:0];\n\n\t// Stage 4: Continue reducing the counts\n\tassign stage4_out = stage3_out[31:24]+stage3_out[23:16]+stage3_out[15:8]+stage3_out[7:0];\n\n\t// Stage 5: Final reduction to get the output\n\tassign out = stage4_out[15:8]+stage4_out[7:0];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    // out_both calculation\n    assign out_both = {in[3]&in[2], in[2]&in[1], in[1]&in[0]};\n    \n    // out_any calculation\n    assign out_any = {(in[3]|in[0]), (in[2]|in[3]), (in[1]|in[2]), (in[0]|in[1])};\n    \n    // out_different calculation\n    assign out_different = {in[3]^in[0], in[0]^in[1], in[1]^in[2], in[2]^in[3]};\nendmodule\n", "result": "failed: 88 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase(a)\n\t\t\t3'b000: q = 16'h1232;\n\t\t\t3'b001: q = 16'hAEE0;\n\t\t\t3'b010: q = 16'h27D4;\n\t\t\t3'b011: q = 16'h5A0E;\n\t\t\t3'b100: q = 16'h2066;\n\t\t\t3'b101: q = 16'h64CE;\n\t\t\t3'b110: q = 16'hC526;\n\t\t\t3'b111: q = 16'h2F19;\n\t\t\tdefault: q = 16'hXXXX; // Optional: default case for invalid inputs\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\t// Synchronous reset\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0;\n\t\telse if (slowena)\n\t\t\tif (q == 4'b1001) // 9 in binary\n\t\t\t\tq <= 4'b0; // Wrap around to 0\n\t\t\telse\n\t\t\t\tq <= q + 1;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t\n\t// Negate in2\n\tlogic not_in2;\n\tassign not_in2 = ~in2;\n\n\t// Perform AND operation between in1 and not_in2\n\tassign out = in1 & not_in2;\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Directly assign the input to the output\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // State encoding\n    typedef enum logic [1:0] {B = 2'b00, A = 2'b01} state_t;\n    state_t current_state, next_state;\n\n    // Output assignment based on current state\n    assign out = current_state == A ? 1'b0 : 1'b1; // Output is 0 when in state A, 1 when in state B\n    \n    // Next state logic\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            current_state <= B; // Asynchronous reset to state B\n        else\n            current_state <= next_state;\n\n    // Combinatorial logic to determine next state\n    always_comb begin\n        case(current_state)\n            B: next_state = in ? B : A; // Stay in B if input is 1, go to A if input is 0\n            A: next_state = in ? A : B; // Stay in A if input is 1, go to B if input is 0\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    // Register for capturing d on the positive edge of clk\n    reg pos_edge_q;\n    always @(posedge clk) begin\n        pos_edge_q <= d;\n    end\n\n    // Register for capturing d on the negative edge of clk\n    reg neg_edge_q;\n    always @(negedge clk) begin\n        neg_edge_q <= d;\n    end\n\n    // Combining the outputs of the two registers using XOR\n    always @(posedge clk or negedge clk) begin\n        q <= pos_edge_q ^ neg_edge_q;\n    end\nendmodule\n", "result": "failed: 112 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Perform XOR on the inputs\n    wire xor_result = a ^ b;\n    \n    // Apply NOT to the XOR result to get the XNOR output\n    assign out = ~xor_result;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\t// Define internal signals for clarity\n\twire a_out_1, a_out_2, b_out_1, b_out_2, or_out, and_out;\n\n\t// Instantiate module A\n\tmodule_A inst_a1(x, y, a_out_1);\n\tmodule_A inst_a2(x, y, a_out_2);\n\n\t// Instantiate module B\n\tmodule_B inst_b1(x, y, b_out_1);\n\tmodule_B inst_b2(x, y, b_out_2);\n\n\t// Connect outputs of first pair of modules to OR gate\n\tor_gate or_inst(a_out_1, b_out_1, or_out);\n\n\t// Connect outputs of second pair of modules to AND gate\n\tand_gate and_inst(a_out_2, b_out_2, and_out);\n\n\t// Connect outputs of OR and AND gates to XOR gate\n\txor_gate xor_inst(or_out, and_out, z);\n\nendmodule\n\n// Define module A\nmodule module_A(input x, input y, output reg z);\n\talways @(*) begin\n\t\tz = (x ^ y) & x;\n\tend\nendmodule\n\n// Define module B\nmodule module_B(input x, input y, output reg z);\n\talways @(*) begin\n\t\tz = (~x & ~y) | (x & y);\n\tend\nendmodule\n\n// Define OR gate\nmodule or_gate(input a, input b, output reg out);\n\talways @(*) begin\n\t\tout = a | b;\n\tend\nendmodule\n\n// Define AND gate\nmodule and_gate(input a, input b, output reg out);\n\talways @(*) begin\n\t\tout = a & b;\n\tend\nendmodule\n\n// Define XOR gate\nmodule xor_gate(input a, input b, output reg out);\n\talways @(*) begin\n\t\tout = a ^ b;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        // Synchronous load operation\n        if (load) begin\n            q <= data;\n        end else begin\n            // No rotation when ena is 2'b00 or 2'b11\n            if (ena == 2'b00 || ena == 2'b11) begin\n                q <= q;\n            end else if (ena == 2'b01) begin\n                // Right rotation\n                q <= {q[98:0], q[99]};\n            end else if (ena == 2'b10) begin\n                // Left rotation\n                q <= {q[1:0], q[99:2]};\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 3590 out of 4005 samples.", "passed": false}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0; // Reset the counter to 0 if reset is high\n        end else begin\n            if (q == 999) begin\n                q <= 0; // Reset to 0 when counter reaches 999\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Assign the negated value of 'in' to 'out'\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n    // State transition logic\n    assign next_state = ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000000001) ? \n                        (in ? 10'b0000000010 : 10'b0000000001) : // S0\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000000010) ?\n                        (in ? 10'b0000000100 : 10'b0000000001) : // S1\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000000100) ?\n                        (in ? 10'b0000001000 : 10'b0000000001) : // S2\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000001000) ?\n                        (in ? 10'b0000010000 : 10'b0000000001) : // S3\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000010000) ?\n                        (in ? 10'b0000100000 : 10'b0000000001) : // S4\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0000100000) ?\n                        (in ? 10'b0001000000 : 10'b0010000000) : // S5\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0001000000) ?\n                        (in ? 10'b0010000000 : 10'b0100000000) : // S6\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0010000000) ?\n                        (in ? 10'b0100000000 : 10'b0000000001) : // S7\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0010000000) ?\n                        (in ? 10'b0000000001 : 10'b0000000001) : // S8\n                       ({state[9], state[8], state[7], state[6], state[5], state[4], state[3], state[2], state[1], state[0]} == 10'b0100000000) ?\n                        (in ? 10'b0000000001 : 10'b0000000001) : // S9\n                       10'b0000000001; // Default to S0\n\n    // Output logic\n    assign out1 = state[8];\n    assign out2 = state[7];\n\nendmodule\n", "result": "failed: 1091 out of 1424 samples.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n    // Edge-triggered JK flip-flop\n    always @(posedge clk) begin\n        case ({j, k}) // Concatenate J and K to form a 2-bit signal\n            2'b00: Q <= Q; // No change, keep the old value\n            2'b01: Q <= 1'b0; // Reset\n            2'b10: Q <= 1'b1; // Set\n            2'b11: Q <= ~Q; // Toggle\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t3'b000: out = 2'b00;\n\t\t\t3'b001, 3'b010, 3'b100: out = 2'b01;\n\t\t\t3'b011, 3'b101, 3'b110: out = 2'b10;\n\t\t\tdefault: out = 2'b11;\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    // Assigning outputs based on the comparison logic\n    assign out[24] = ~a ^ a;   // Self-comparison for 'a'\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n\n    assign out[19] = ~b ^ a;   // Self-comparison for 'b' is already covered by out[23]\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n\n    assign out[14] = ~c ^ a;   // Self-comparison for 'c' is already covered by out[22]\n    assign out[13] = ~c ^ b;   // Already covered by out[17]\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n\n    assign out[9]  = ~d ^ a;   // Self-comparison for 'd' is already covered by out[21]\n    assign out[8]  = ~d ^ b;   // Already covered by out[16]\n    assign out[7]  = ~d ^ c;   // Already covered by out[11]\n    assign out[6]  = ~d ^ d;\n    assign out[5]  = ~d ^ e;\n\n    assign out[4]  = ~e ^ a;   // Self-comparison for 'e' is already covered by out[20]\n    assign out[3]  = ~e ^ b;   // Already covered by out[15]\n    assign out[2]  = ~e ^ c;   // Already covered by out[10]\n    assign out[1]  = ~e ^ d;   // Already covered by out[5]\n    assign out[0]  = ~e ^ e;   // Self-comparison for 'e'\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\t\n\treg currentState;\n\n\t// Next state logic\n\talways @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tcurrentState <= 1'b0; // Reset to walk_left\n\t\telse\n\t\tbegin\n\t\t\tif (bump_left)\n\t\t\t\tcurrentState <= ~currentState; // Switch to opposite direction\n\t\t\telse if (bump_right)\n\t\t\t\tcurrentState <= ~currentState;\n\t\tend\n\tend\n\t\n\t// Output logic\n\tassign walk_left = ~currentState;\n\tassign walk_right = currentState;\n\nendmodule\n", "result": "failed: 83 out of 229 samples.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n    assign q = a & b; // Logical AND operation between a and b\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\t// Intermediate signals for AND gate outputs\n\twire and1_output;\n\twire and2_output;\n\twire and3_output;\n\twire and4_output;\n\n\t// AND gate 1: p1a & p1b & p1c\n\tand(and1_output, p1a, p1b, p1c);\n\n\t// AND gate 2: p1d & p1e & p1f\n\tand(and2_output, p1d, p1e, p1f);\n\n\t// AND gate 3: p2a & p2b\n\tand(and3_output, p2a, p2b);\n\n\t// AND gate 4: p2c & p2d\n\tand(and4_output, p2c, p2d);\n\n\t// OR gate for p1y: and1_output | and2_output\n\tor(p1y, and1_output, and2_output);\n\n\t// OR gate for p2y: and3_output | and4_output\n\tor(p2y, and3_output, and4_output);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\t\n\t// Define internal signals for next state\n\treg [2:0] next_state;\n\t\n\t// Determine next state based on current state and input x\n\talways @(*) begin\n\t\tcase(y)\n\t\t\t3'b000: next_state = (x) ? 3'b001 : 3'b000;\n\t\t\t3'b001: next_state = (x) ? 3'b100 : 3'b001;\n\t\t\t3'b010: next_state = (x) ? 3'b001 : 3'b010;\n\t\t\t3'b011: next_state = (x) ? 3'b010 : 3'b001;\n\t\t\t3'b100: next_state = (x) ? 3'b100 : 3'b011;\n\t\t\tdefault: next_state = 3'b000; // Default case\n\t\tendcase\n\tend\n\t\n\t// Update the state on rising edge of the clock\n\talways @(posedge clk) begin\n\t\ty <= next_state;\n\t\tY0 <= next_state[0]; // Assign Y0 as the least significant bit of the next state\n\tend\n\t\n\t// Determine output z based on transition from present state to next state\n\talways @(posedge clk) begin\n\t\tif ((y == 3'b011 && next_state == 3'b010) || (y == 3'b100 && next_state == 3'b100))\n\t\t\tz <= 1'b1;\n\t\telse\n\t\t\tz <= 1'b0;\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Compute the OR of the two inputs\n    wire or_result = in1 | in2;\n    \n    // Negate the OR result to get the NOR output\n    assign out = ~or_result;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\t// Assigning the inputs to the outputs based on the given connections\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    // Asynchronous reset\n    always @(*) begin\n        if (ar) begin\n            q <= 1'b0;  // Reset Q to 0 when AR is high\n        end\n    end\n\n    // Rising edge detection for clock\n    always @(posedge clk) begin\n        if (!ar) begin\n            q <= d;  // Capture D on the rising edge of clk if AR is low\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @(*) begin\n\tcase (sel)\n\t\t3'b000: out = data0; // Select data0 when sel is 0\n\t\t3'b001: out = data1; // Select data1 when sel is 1\n\t\t3'b010: out = data2; // Select data2 when sel is 2\n\t\t3'b011: out = data3; // Select data3 when sel is 3\n\t\t3'b100: out = data4; // Select data4 when sel is 4\n\t\t3'b101: out = data5; // Select data5 when sel is 5\n\t\tdefault: out = 4'b0; // Output 0 for invalid sel values (6 or 7)\n\tendcase\nend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    // Internal counter\n    reg [9:0] counter;\n\n    // Assign the terminal count signal based on the counter value\n    always @(posedge clk) begin\n        if (counter == 0) begin\n            tc <= 1;\n        end else begin\n            tc <= 0;\n        end\n    end\n\n    // Update the counter based on the load signal and clock edge\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data; // Load the new value into the counter\n        end else if (counter > 0) begin\n            counter <= counter - 1; // Decrement the counter\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n    typedef enum logic [2:0] {\n        STATE_IDLE = 3'b000,\n        STATE_1 = 3'b001,\n        STATE_11 = 3'b010,\n        STATE_110 = 3'b011,\n        STATE_FOUND = 3'b100\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge reset)\n        if (reset)\n            current_state <= STATE_IDLE;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            STATE_IDLE: \n                if (data == 1)\n                    next_state = STATE_1;\n                else\n                    next_state = STATE_IDLE;\n            STATE_1: \n                if (data == 1)\n                    next_state = STATE_11;\n                else\n                    next_state = STATE_IDLE;\n            STATE_11: \n                if (data == 1)\n                    next_state = STATE_11;\n                else\n                    next_state = STATE_110;\n            STATE_110: \n                if (data == 1)\n                    next_state = STATE_FOUND;\n                else\n                    next_state = STATE_IDLE;\n            STATE_FOUND: \n                next_state = STATE_FOUND; // Stay in this state indefinitely\n            default: \n                next_state = STATE_IDLE;\n        endcase\n    end\n\n    // Output logic\n    always_ff @(posedge clk, posedge reset)\n        if (reset)\n            start_shifting <= 0;\n        else if (current_state == STATE_FOUND)\n            start_shifting <= 1;\n        else\n            start_shifting <= 0;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    // Always block triggered by the positive edge of clk\n    always @(posedge clk) begin\n        // Synchronous reset condition\n        if (reset) begin\n            q <= 8'b0; // Set all outputs to 0 if reset is high\n        end else begin\n            // Otherwise, assign the inputs to the outputs on the rising edge of clk\n            q <= d;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    // Register to hold the previous state of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Store the current state of 'in' into 'prev_in' for the next cycle\n        prev_in <= in;\n        \n        // Detect rising edges and update 'anyedge'\n        anyedge <= (in & (~prev_in));\n    end\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0001; // Reset to 1 when reset is high\n\t\tend else begin\n\t\t\tif (q < 10) begin\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\t\tend else begin\n\t\t\t\tq <= 4'b0001; // Wrap around to 1 when reaching 10\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    // Internal signal to detect the rising edge of 'a'\n    reg a_rising_edge;\n    \n    always @(posedge clk) begin\n        if (a == 0 && a_rising_edge == 1) begin\n            // Reset counter when 'a' transitions to low and counter is 4\n            if (q == 4) begin\n                q <= 0;\n            end else begin\n                // Increment counter when 'a' is low\n                q <= q + 1;\n            end\n        end else if (a == 1) begin\n            // Hold counter value when 'a' is high\n            q <= q;\n        end\n    end\n    \n    // Detect rising edge of 'a'\n    always @(negedge a) begin\n        a_rising_edge <= 1;\n    end\n    \n    always @(posedge clk) begin\n        a_rising_edge <= 0;\n    end\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\t\tq <= 5'b11000; // Initial state for a 5-bit maximal-length LFSR with taps at 5 and 3\n\t\telse\n\t\t\tq <= {q[3:0], q[4]^q[2]}; // Shift left and compute new LSB using XOR\n\tend\nendmodule\n", "result": "failed: 4442 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(*) begin\n        // Perform addition or subtraction based on do_sub\n        if (do_sub) begin\n            out = a - b;\n        end else begin\n            out = a + b;\n        end\n        \n        // Check if the result is zero\n        result_is_zero = (out == 8'b0);\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\t\n\t// The simplified expression for f based on the K-map is f = x[2]\n\tassign f = x[2];\n\t\nendmodule\n", "result": "failed: 20 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n    // Define the scancode values for keys 0 through 9\n    localparam [7:0] SCANCODE_0 = 8'h45;\n    localparam [7:0] SCANCODE_1 = 8'h16;\n    localparam [7:0] SCANCODE_2 = 8'h1E;\n    localparam [7:0] SCANCODE_3 = 8'h26;\n    localparam [7:0] SCANCODE_4 = 8'h25;\n    localparam [7:0] SCANCODE_5 = 8'h2E;\n    localparam [7:0] SCANCODE_6 = 8'h36;\n    localparam [7:0] SCANCODE_7 = 8'h3D;\n    localparam [7:0] SCANCODE_8 = 8'h3E;\n    localparam [7:0] SCANCODE_9 = 8'h46;\n\n    always @(*) begin\n        // Initialize outputs\n        out = 4'b0;\n        valid = 1'b0;\n\n        // Check for each scancode\n        if (code == SCANCODE_0) begin\n            out = 4'b0000;\n            valid = 1'b1;\n        end else if (code == SCANCODE_1) begin\n            out = 4'b0001;\n            valid = 1'b1;\n        end else if (code == SCANCODE_2) begin\n            out = 4'b0010;\n            valid = 1'b1;\n        end else if (code == SCANCODE_3) begin\n            out = 4'b0011;\n            valid = 1'b1;\n        end else if (code == SCANCODE_4) begin\n            out = 4'b0100;\n            valid = 1'b1;\n        end else if (code == SCANCODE_5) begin\n            out = 4'b0101;\n            valid = 1'b1;\n        end else if (code == SCANCODE_6) begin\n            out = 4'b0110;\n            valid = 1'b1;\n        end else if (code == SCANCODE_7) begin\n            out = 4'b0111;\n            valid = 1'b1;\n        end else if (code == SCANCODE_8) begin\n            out = 4'b1000;\n            valid = 1'b1;\n        end else if (code == SCANCODE_9) begin\n            out = 4'b1001;\n            valid = 1'b1;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    always @(*) begin\n        out[0] = in[7];\n        out[1] = in[6];\n        out[2] = in[5];\n        out[3] = in[4];\n        out[4] = in[3];\n        out[5] = in[2];\n        out[6] = in[1];\n        out[7] = in[0];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\t// Implementing the simplified Boolean expression\n\tassign out = c & d | (~c) & (~d);\n\t\nendmodule\n", "result": "failed: 58 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data into the MSB and shift the rest right\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Decrement the current value\n            if (q == 0) begin\n                // Handle underflow\n                q <= 4'b1111; // Assuming wrap-around behavior\n            end else begin\n                q <= q - 1;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Directly assign the input to the output\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    \n    // Define a counter to count up to 4\n    reg [1:0] count; // Only need 2 bits to count up to 4\n    \n    // Initialize shift_ena\n    reg shift_ena_reg;\n\n    // Clock edge detection\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the counter to 0 and start counting\n            count <= 0;\n            shift_ena_reg <= 1; // Enable shift for the first cycle\n        end else begin\n            // Increment the counter only if it's not already at 4\n            if (count < 3) begin\n                count <= count + 1;\n            end else begin\n                // Counter reached 4, disable shift\n                count <= 0;\n                shift_ena_reg <= 0;\n            end\n        end\n    end\n\n    // Assign shift_ena to the internal register\n    assign shift_ena = shift_ena_reg;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    // Always block to handle the clock and reset\n    always @(posedge clk) begin\n        // Synchronous reset handling\n        if (reset)\n            q <= 4'b0;\n        else\n            q <= q + 1;  // Increment the counter\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n\t// Using assign statement\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n\t// Using procedural if statement\n\talways @(a or b or sel_b1 or sel_b2)\n\tbegin\n\t\tif (sel_b1 & sel_b2)\n\t\t\tout_always <= b;\n\t\telse\n\t\t\tout_always <= a;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n\t\n\t// Define intermediate signals\n\twire not_b;\n\twire not_c;\n\twire term1; // Represents a'b'c'\n\twire term2; // Represents a\n\t\n\t// NOT gates for b and c\n\tnot (not_b, b);\n\tnot (not_c, c);\n\t\n\t// AND gate for a'b'c'\n\tand (term1, a, not_b, not_c);\n\t\n\t// Direct assignment for a\n\tassign term2 = a;\n\t\n\t// OR gate to combine a and a'b'c'\n\tor (out, term1, term2);\n\nendmodule\n", "result": "failed: 86 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\n    // Define states\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // Current state register\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_state <= A;  // Reset to state A\n        end else begin\n            current_state <= next_state;  // Update state on rising edge of clk\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: next_state = D;  // Stay in D if r3 is 1\n            default: next_state = A;  // Default to A\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            B: g = {1'b1, r[2], r[3]};  // Grant to device 1\n            C: g = {r[1], 1'b1, r[3]};  // Grant to device 2\n            D: g = {r[1], r[2], 1'b1};  // Grant to device 3\n            default: g = 3'b0;  // No grants if in state A\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0; // Reset to 0 when reset is high\n        else if (q == 4'b1001) // Check if q is 9 (binary 1001)\n            q <= 4'b0; // Reset to 0\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [1:0] {IDLE, BYTE_1, BYTE_2, BYTE_3} state_t;\n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            IDLE: begin\n                if (in[3])\n                    next_state = BYTE_1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE_1: next_state = BYTE_2;\n            BYTE_2: next_state = BYTE_3;\n            BYTE_3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign done = (state == BYTE_3);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n\tassign out = (sel == 1'b1) ? b : a; // If sel is 1, then out=b, else out=a\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\t\n\t// Implementing 4-input AND gate\n\tassign out_and = in[0] & in[1] & in[2] & in[3];\n\t\n\t// Implementing 4-input OR gate\n\tassign out_or = in[0] | in[1] | in[2] | in[3];\n\t\n\t// Implementing 4-input XOR gate\n\t// Using the property that XOR is associative and commutative\n\t// a ^ b ^ c ^ d = (a ^ b) ^ (c ^ d)\n\twire xor_temp;\n\tassign xor_temp = in[0] ^ in[1];\n\tassign out_xor = xor_temp ^ (in[2] ^ in[3]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define the state variables\n    reg [2:0] state, next_state;\n    \n    // Output logic\n    always @* begin\n        case(state)\n            3'b011, 3'b100: z = 1;\n            default: z = 0;\n        endcase\n    end\n    \n    // Next state logic\n    always @* begin\n        case({state, x})\n            5'b0000: next_state = 3'b000; // x=0\n            5'b0001: next_state = 3'b001; // x=1\n            5'b0010: next_state = 3'b001; // x=0\n            5'b0011: next_state = 3'b100; // x=1\n            5'b0100: next_state = 3'b010; // x=0\n            5'b0101: next_state = 3'b001; // x=1\n            5'b0110: next_state = 3'b011; // x=0\n            5'b0111: next_state = 3'b010; // x=1\n            5'b1000: next_state = 3'b100; // x=0\n            5'b1001: next_state = 3'b100; // x=1\n            default: next_state = 3'b000;\n        endcase\n    end\n    \n    // State register update\n    always @(posedge clk) begin\n        if (reset)\n            state <= 3'b000;\n        else\n            state <= next_state;\n    end\nendmodule\n", "result": "failed: 462 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [2:0] {\n        A, B, C, D, E, F, G\n    } state_t;\n    \n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk or negedge resetn)\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            A: begin\n                if (!resetn)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            B: next_state = C;\n            C: begin\n                if (x == 1'b1)\n                    next_state = D;\n                else\n                    next_state = C;\n            end\n            D: begin\n                if (x == 1'b0)\n                    next_state = E;\n                else\n                    next_state = D;\n            end\n            E: begin\n                if (x == 1'b1)\n                    next_state = F;\n                else\n                    next_state = G;\n            end\n            F: begin\n                if (y == 1'b1)\n                    next_state = F;\n                else\n                    next_state = G;\n            end\n            G: next_state = G;\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        f = 1'b0;\n        g = 1'b0;\n        \n        case(state)\n            B: f = 1'b1;\n            D: g = 1'b1;\n            F: g = 1'b1;\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    // Asynchronous reset to 0x34\n    always @(posedge reset or negedge clk) begin\n        if (reset) begin\n            q <= 8'b00110100; // Binary representation of 0x34\n        end else if (!clk) begin\n            // Negative edge of clk\n            q <= d;\n        end\n    end\n\nendmodule\n", "result": "failed: 46 out of 436 samples.", "passed": false}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Calculate the parity bit by XORing all input bits together\n    assign parity = ^in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        case(state)\n            2'b00: begin // State A\n                if (in == 1'b0) next_state = 2'b00; // Next state is A\n                else next_state = 2'b01; // Next state is B\n                out = 1'b0; // Output is 0\n            end\n            2'b01: begin // State B\n                if (in == 1'b0) next_state = 2'b10; // Next state is C\n                else next_state = 2'b01; // Next state is B\n                out = 1'b0; // Output is 0\n            end\n            2'b10: begin // State C\n                if (in == 1'b0) next_state = 2'b00; // Next state is A\n                else next_state = 2'b11; // Next state is D\n                out = 1'b0; // Output is 0\n            end\n            2'b11: begin // State D\n                if (in == 1'b0) next_state = 2'b10; // Next state is C\n                else next_state = 2'b01; // Next state is B\n                out = 1'b1; // Output is 1\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A\n                out = 1'b0; // Output is 0\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Step 1: XOR x and y\n    wire xor_result;\n    assign xor_result = x ^ y;\n\n    // Step 2: Invert the XOR result\n    wire not_xor_result;\n    assign not_xor_result = ~xor_result;\n\n    // Step 3: AND x and y\n    wire and_result;\n    assign and_result = x & y;\n\n    // Step 4: OR the inverted XOR result and the AND result\n    assign z = not_xor_result | and_result;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    // Define state encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // Current state and next state registers\n    state_t curr_state, next_state;\n\n    // Output signal\n    reg z;\n\n    // State transition logic\n    always_ff @(posedge clk, posedge reset)\n    begin\n        if (reset)\n            curr_state <= A;  // Reset to state A\n        else\n            curr_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb\n    begin\n        unique case (curr_state)\n            A: if (w) next_state = B; else next_state = A;\n            B: if (w) next_state = C; else next_state = D;\n            C: if (w) next_state = E; else next_state = D;\n            D: if (w) next_state = F; else next_state = A;\n            E: if (w) next_state = E; else next_state = D;\n            F: if (w) next_state = C; else next_state = D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always_comb\n    begin\n        unique case (curr_state)\n            A: z = 0;\n            B: z = 0;\n            C: z = 0;\n            D: z = 0;\n            E: z = 1;\n            F: z = 0;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    // Define internal signals for each byte\n    reg [7:0] upper_byte;\n    reg [7:0] lower_byte;\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            upper_byte <= 8'b0;\n            lower_byte <= 8'b0;\n        end else begin\n            if (byteena[1]) begin\n                upper_byte <= d[15:8];\n            end\n            if (byteena[0]) begin\n                lower_byte <= d[7:0];\n            end\n        end\n    end\n\n    // Assign the outputs\n    assign q = {upper_byte, lower_byte};\nendmodule\n", "result": "failed: 1 out of 443 samples.", "passed": false}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Register to hold the previous state of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Store the current 'in' value into 'prev_in' for the next clock cycle\n        prev_in <= in;\n        \n        // Detect positive edge transitions and set 'pedge' accordingly\n        for (integer i = 0; i < 8; i = i + 1) begin\n            if ((in[i] == 1'b1) && (prev_in[i] == 1'b0)) begin\n                pedge[i] <= 1'b1;\n            end else begin\n                pedge[i] <= 1'b0;\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n    always @(posedge clock) begin\n        // Initialize p to 0 when the clock rises\n        if (!a)\n            p <= 0;\n        else\n            p <= 1; // Set p to 1 when a is 1 and the clock rises\n    end\n\n    always @(negedge clock) begin\n        // Set q to 0 when the clock falls\n        q <= 0;\n        // Set q to 1 when a is 1 and the clock falls\n        if (a)\n            q <= 1;\n    end\nendmodule\n", "result": "failed: 112 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        // Load the initial state when load is high\n        if (load)\n            q <= data;\n        else begin\n            // Compute the next state for each cell\n            for (integer i = 0; i < 512; i = i + 1) begin\n                // Boundary conditions\n                if (i == 0) begin\n                    q[i] <= data[i+1];\n                end else if (i == 511) begin\n                    q[i] <= data[i-1];\n                end else begin\n                    q[i] <= data[i-1] ^ data[i+1];\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: 7050 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n\t// Compare each bit of A and B\n\twire eq_bit_0 = (A[0] == B[0]);\n\twire eq_bit_1 = (A[1] == B[1]);\n\n\t// Combine the results using AND operation\n\tassign z = eq_bit_0 & eq_bit_1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    // Part 1: out_both\n    assign out_both = {in[99:1], 1'b0} & in;\n\n    // Part 2: out_any\n    assign out_any = {1'b0, in[99:1]} | in;\n\n    // Part 3: out_different\n    assign out_different = {in[0], in[99:1]} ^ in;\nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n    always @(posedge ena or posedge negedge d) begin\n        if (ena) begin\n            q <= d; // Transparent state: q follows d\n        end\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\t// Calculate the starting index for the selected 4-bit segment\n\twire [9:0] start_index = sel * 4;\n\t\n\t// Extract the 4-bit segment from the input vector\n\tassign out = in[start_index + 3:start_index];\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\nalways_comb begin\n\tcase (sel)\n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = 16'b1; // Set output to all '1's if sel > 8\n\tendcase\nend\nendmodule\n", "result": "failed: 101 out of 220 samples.", "passed": false}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n    \n    // Bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Logical OR\n    assign out_or_logical = (a != 0) || (b != 0);\n\n    // Inverse (NOT)\n    assign out_not[5:3] = ~b; // Inverse of b goes to the upper half\n    assign out_not[2:0] = ~a; // Inverse of a goes to the lower half\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    // State transition logic\n    always @(*) begin\n        case(state)\n            4'b0001: // State A\n                if (in == 1'b0) next_state = 4'b0001; // Next state A\n                else            next_state = 4'b0010; // Next state B\n            4'b0010: // State B\n                if (in == 1'b0) next_case = 4'b0100; // Next state C\n                else            next_state = 4'b0010; // Next state B\n            4'b0100: // State C\n                if (in == 1'b0) next_state = 4'b0001; // Next state A\n                else            next_state = 4'b1000; // Next state D\n            4'b1000: // State D\n                if (in == 1'b0) next_state = 4'b0100; // Next state C\n                else            next_state = 4'b0010; // Next state B\n            default: next_state = 4'b0001; // Default state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n    // Step 1: Compare a and b\n    reg [7:0] temp1;\n    always @(*) begin\n        if(a < b)\n            temp1 = a;\n        else\n            temp1 = b;\n    end\n\n    // Step 2: Compare the result of step 1 with c\n    reg [7:0] temp2;\n    always @(*) begin\n        if(temp1 < c[7:0])\n            temp2 = temp1;\n        else\n            temp2 = c[7:0];\n    end\n\n    // Step 3: Compare the result of step 2 with d\n    always @(*) begin\n        if(temp2 < d[7:0])\n            min = temp2;\n        else\n            min = d[7:0];\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\t\n\t// Implementing AND operation\n\tassign out_and = a & b;\n\t\n\t// Implementing OR operation\n\tassign out_or = a | b;\n\t\n\t// Implementing XOR operation\n\tassign out_xor = a ^ b;\n\t\n\t// Implementing NAND operation\n\tassign out_nand = ~(a & b);\n\t\n\t// Implementing NOR operation\n\tassign out_nor = ~(a | b);\n\t\n\t// Implementing XNOR operation\n\tassign out_xnor = ~(a ^ b);\n\t\n\t// Implementing AND-NOT operation\n\tassign out_anotb = a & (~b);\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n    // Simplified Boolean Expression: out = a' + ac'\n    assign out = ~a | (a & ~c);\nendmodule\n", "result": "failed: 99 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {A, B1, B2, B3, C, D} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always @(posedge clk, posedge reset)\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: if (s) next_state = B1; else next_state = A;\n            B1: next_state = B2;\n            B2: next_state = B3;\n            B3: next_state = C;\n            C: if (w == 1 && current_state == B2) next_state = D;\n               else if (w == 1 && current_state == B1) next_state = C;\n               else next_state = C;\n            D: next_state = A;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk, posedge reset)\n        if (reset)\n            z <= 0;\n        else if (current_state == D)\n            z <= 1;\n        else\n            z <= 0;\n\nendmodule\n", "result": "failed: 174 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Replicate the sign bit (in[7]) 24 times\n    // Concatenate the replicated sign bits with the original 8-bit input\n    assign out = { {24{in[7]}}, in };\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Internal wires for connecting flip-flops\n    wire d1, d2, d3;\n\n    // D Flip-Flop for the first stage\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d1 <= 0;\n        else\n            d1 <= in;\n    end\n\n    // D Flip-Flop for the second stage\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d2 <= 0;\n        else\n            d2 <= d1;\n    end\n\n    // D Flip-Flop for the third stage\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d3 <= 0;\n        else\n            d3 <= d2;\n    end\n\n    // D Flip-Flop for the fourth stage\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            out <= 0;\n        else\n            out <= d3;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n\tif (in[3]) pos = 2'b11; // Highest priority, if in[3] is 1\n\telse if (in[2]) pos = 2'b10;\n\telse if (in[1]) pos = 2'b01;\n\telse if (in[0]) pos = 2'b00;\n\telse pos = 2'b00; // Default case, all inputs are 0\nend\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    parameter OFF = 2'b00;\n    parameter ON = 2'b01;\n\n    reg [1:0] state, next_state;\n\n    always @(posedge clk or posedge areset)\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n\n    always @(*) begin\n        case(state)\n            OFF: \n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            ON: \n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            default: \n                next_state = OFF;\n        endcase\n    end\n\n    always @(*) begin\n        case(state)\n            OFF: out = 0;\n            ON: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\tassign out = 0; // Directly assign the output to 0\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\t// Assigning the output 'one' to logic high (1)\n\tassign one = 1;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        // Initialize output to all zeros\n        out = 0;\n        \n        // Reverse the bits\n        for (int i = 0; i < 100; i++) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Intermediate signal to hold the result of the XOR operation\n    logic xor_result;\n\n    // XOR gate operation\n    assign xor_result = in ^ out;\n\n    // Positive edge triggered D flip-flop\n    always_ff @(posedge clk) begin\n        out <= xor_result;\n    end\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tq <= 4'b0; // Asynchronous reset\n\t\tend else if (load) begin\n\t\t\tq <= data; // Synchronous load\n\t\tend else if (ena) begin\n\t\t\tq <= {1'b0, q[3:1]}; // Synchronous shift right\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\tassign f = ~(x2 ^ x3); // This line implements the logic derived from the truth table.\nendmodule\n", "result": "failed: 12 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    // Asynchronous reset to 0\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            q <= 8'b0;  // Reset all bits to 0 when areset is high\n        else\n            q <= d;     // On the positive edge of clk, load the value of d into q\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\t\n\t// Implementing AND gate\n\tassign out_and = &in;\n\t\n\t// Implementing OR gate\n\tassign out_or = |in;\n\t\n\t// Implementing XOR gate\n\tassign out_xor = ^in;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\tassign sum = a ^ b; // XOR operation for sum\n\tassign cout = a & b; // AND operation for carry-out\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    \n    // Determine whether to shut off the computer based on cpu overheating\n    always @(*) begin\n        if (cpu_overheated) \n            shut_off_computer = 1;\n        else \n            shut_off_computer = 0; // Explicitly set to 0 when not overheated\n    end\n    \n    // Determine whether to keep driving based on arrival and gas tank status\n    always @(*) begin\n        if (~arrived && ~gas_tank_empty) \n            keep_driving = 1;\n        else \n            keep_driving = 0; // Explicitly set to 0 when either condition fails\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    \n    // Enumerate states\n    typedef enum logic [1:0] {\n        OFF = 2'b00,\n        ON = 2'b01\n    } state_t;\n    \n    // Current state register\n    state_t curr_state, next_state;\n\n    // Output assignment\n    assign out = (curr_state == ON) ? 1'b1 : 1'b0;\n\n    // Next state logic\n    always_comb begin\n        if (reset)\n            next_state = OFF;  // Reset to OFF state\n        else if (curr_state == OFF && j)\n            next_state = ON;   // Transition to ON state\n        else if (curr_state == ON && k)\n            next_state = OFF;  // Transition to OFF state\n        else\n            next_state = curr_state;  // Stay in the same state\n    end\n\n    // State register update on clock edge\n    always_ff @(posedge clk) begin\n        curr_state <= next_state;\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\t\n\t// Concatenate all input vectors and add two 1 bits at the end\n\twire [31:0] combined = {a, b, c, d, e, f, 2'b11};\n\t\n\t// Assign segments of the combined signal to outputs\n\tassign w = combined[31:24];\n\tassign x = combined[23:16];\n\tassign y = combined[15:8];\n\tassign z = combined[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Implementing the logic for q\n    assign q = ~a | ~b | ~c | ~d;\nendmodule\n", "result": "failed: 64 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Directly assign the AND result to the output\n    assign out = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // Define the state type\n    typedef enum logic [1:0] {\n        STATE_B = 2'b01,\n        STATE_A = 2'b10\n    } state_t;\n\n    // Declare the state register\n    state_t current_state, next_state;\n\n    // Output assignment based on current state\n    assign out = (current_state == STATE_B) ? 1'b1 : 1'b0;\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            default: next_state = STATE_B; // Just in case\n        endcase\n    end\n\n    // Synchronous state update\n    always_ff @(posedge clk) begin\n        if (reset) // Active-high synchronous reset\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // Calculate the sum using XOR gates\n    assign sum = a ^ b ^ cin;\n    \n    // Calculate the carry-out using AND and OR gates\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\tlogic xnor_out;\n\n\t// Implementing XNOR gate\n\txnor_out = ~(in1 ^ in2); \n\n\t// Implementing XOR gate\n\tout = xnor_out ^ in3;\n\t\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\n    // Define intermediate signals for the 2-to-1 multiplexers\n    reg mux_in_1;\n    reg mux_in_2;\n\n    // Implementing the 2-to-1 multiplexer for mux_in[2] and mux_in[3]\n    always @(posedge c or posedge d) begin\n        case (d)\n            1'b0: mux_in_2 <= 1'b0;  // When d = 0, output 0\n            1'b1: mux_in_2 <= 1'b1;  // When d = 1, output 1\n        endcase\n    end\n\n    // Implementing the 2-to-1 multiplexer for mux_in[0] and mux_in[1]\n    always @(posedge c or posedge d) begin\n        case (d)\n            1'b0: mux_in_1 <= 1'b0;  // When d = 0, output 0\n            1'b1: mux_in_1 <= 1'b0;  // When d = 1, output 0\n        endcase\n    end\n\n    // Assigning the values to the 4-to-1 multiplexer inputs\n    assign mux_in[0] = 1'b0;  // Fixed value for ab = 00\n    assign mux_in[1] = mux_in_1;  // Output of the first 2-to-1 multiplexer\n    assign mux_in[2] = mux_in_2;  // Output of the second 2-to-1 multiplexer\n    assign mux_in[3] = 1'b1;  // Fixed value for ab = 10\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // State definitions\n    localparam [1:0] A = 2'b01;\n    localparam [1:0] B = 2'b10;\n\n    // State register\n    reg [1:0] state_reg, next_state;\n\n    // Output register\n    reg z_reg;\n\n    // Next state logic\n    always @(state_reg or x) begin\n        case(state_reg)\n            A: begin\n                if (x == 0) \n                    next_state = A;\n                else \n                    next_state = B;\n            end\n            B: begin\n                if (x == 0) \n                    next_state = B;\n                else \n                    next_state = B;\n            end\n            default: next_state = A; // Default to state A on reset\n        endcase\n    end\n\n    // Output logic\n    always @(state_reg or x) begin\n        case(state_reg)\n            A: z_reg = x;\n            B: z_reg = ~x;\n            default: z_reg = 0; // Default output\n        endcase\n    end\n\n    // State register update on rising edge of clock, with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state_reg <= A;\n        end else begin\n            state_reg <= next_state;\n        end\n    end\n\n    // Assign output z\n    assign z = z_reg;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nalways @(posedge clk) begin\n    case ({a, b}) // Combining inputs a and b into a 2-bit vector\n        2'b00: state <= state; // No change in state\n        2'b01: state <= 2'd1;  // Transition to state 1\n        2'b10: state <= state; // No change in state\n        2'b11: state <= 2'd0;  // Transition to state 0\n    endcase\nend\n\nassign q = state[0]; // Assigning the least significant bit of state to q\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\t\n\t// Define intermediate signals for clarity\n\tlogic x3_not, x1_x2_not;\n\t\n\t// Calculate the complement of x[3]\n\tassign x3_not = ~x[3];\n\t\n\t// Calculate the AND of x[1]' and x[2]'\n\tassign x1_x2_not = (~x[1]) & (~x[2]);\n\t\n\t// Combine the terms as per the derived Boolean expression\n\tassign f = (x3_not & x[4]) | (x3_not & x1_x2_not);\n\t\nendmodule\n", "result": "failed: 66 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    \n    // State definition\n    typedef enum {INIT, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= INIT;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            INIT: next_state = (in == 1'b1) ? ONE : INIT;\n            ONE: next_state = (in == 1'b1) ? TWO : INIT;\n            TWO: next_state = (in == 1'b1) ? THREE : INIT;\n            THREE: next_state = (in == 1'b1) ? FOUR : INIT;\n            FOUR: next_state = (in == 1'b1) ? FIVE : INIT;\n            FIVE: next_state = (in == 1'b1) ? SIX : INIT;\n            SIX: next_state = (in == 1'b0) ? INIT : SEVEN;\n            SEVEN: next_state = (in == 1'b0) ? INIT : SEVEN;\n            default: next_state = INIT;\n        endcase\n    end\n\n    // Output generation\n    always @(*) begin\n        disc = 0;\n        flag = 0;\n        err = 0;\n\n        case(next_state)\n            SIX: begin\n                if (in == 1'b0) begin\n                    disc = 1;\n                end\n            end\n            SEVEN: begin\n                if (in == 1'b0) begin\n                    flag = 1;\n                end else begin\n                    err = 1;\n                end\n            end\n            default: ;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n\t// State definition\n\ttypedef enum logic [3:0] {\n\t\tSEARCHING,\n\t\tSHIFTING_DELAY,\n\t\tCOUNTING_DOWN,\n\t\tWAITING_ACK\n\t} state_t;\n\n\tstate_t state, next_state;\n\tlogic [3:0] shift_register, delay_counter;\n\tlogic [9:0] cycle_counter;\n\t\n\t// State transition logic\n\talways_ff @(posedge clk, posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= SEARCHING;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\t// Next state logic\n\talways_comb begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tSEARCHING: begin\n\t\t\t\tif (shift_register == 4'b1101)\n\t\t\t\t\tnext_state = SHIFTING_DELAY;\n\t\t\tend\n\t\t\tSHIFTING_DELAY: begin\n\t\t\t\tif (shift_register[3:0] != 4'b1111)\n\t\t\t\t\tnext_state = COUNTING_DOWN;\n\t\t\tend\n\t\t\tCOUNTING_DOWN: begin\n\t\t\t\tif (cycle_counter == 0)\n\t\t\t\t\tnext_state = WAITING_ACK;\n\t\t\tend\n\t\t\tWAITING_ACK: begin\n\t\t\t\tif (ack)\n\t\t\t\t\tnext_state = SEARCHING;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\t// Shift register for detecting the pattern and shifting in the delay\n\talways_ff @(posedge clk) begin\n\t\tif (reset)\n\t\t\tshift_register <= 4'b0000;\n\t\telse\n\t\t\tshift_register <= {shift_register[2:0], data};\n\tend\n\t\n\t// Delay counter to store the shifted in delay\n\talways_ff @(posedge clk) begin\n\t\tif (reset || state == SEARCHING)\n\t\t\tdelay_counter <= 4'b0000;\n\t\telse if (state == SHIFTING_DELAY)\n\t\t\tdelay_counter <= shift_register[3:0];\n\tend\n\t\n\t// Cycle counter for countdown\n\talways_ff @(posedge clk) begin\n\t\tif (reset)\n\t\t\tcycle_counter <= 10'd0;\n\t\telse if (state == COUNTING_DOWN && cycle_counter == 0)\n\t\t\tcycle_counter <= {delay_counter, 2'b00} + 4'b0001; // (delay[3:0] + 1) * 1000 cycles\n\t\telse if (state == COUNTING_DOWN)\n\t\t\tcycle_counter <= cycle_counter - 1;\n\tend\n\t\n\t// Count output\n\tassign count = (state == COUNTING_DOWN) ? cycle_counter[9:6] : 4'b0000;\n\t\n\t// Counting signal\n\tassign counting = (state == COUNTING_DOWN);\n\t\n\t// Done signal\n\tassign done = (state == WAITING_ACK);\nendmodule\n", "result": "failed: 228610 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [2:0] {\n        LOW = 3'b000,\n        MID_LOW = 3'b001,\n        MID_HIGH = 3'b011,\n        HIGH = 3'b111\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= LOW;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        case (current_state)\n            LOW: begin\n                if (&s) // All sensors high (highest level)\n                    next_state = HIGH;\n                else if (s[1])\n                    next_state = MID_LOW;\n                else\n                    next_state = LOW;\n            end\n            MID_LOW: begin\n                if (&s) // All sensors high (highest level)\n                    next_state = HIGH;\n                else if (s[2])\n                    next_state = MID_HIGH;\n                else if (!|s)\n                    next_state = LOW;\n                else\n                    next_state = MID_LOW;\n            end\n            MID_HIGH: begin\n                if (&s) // All sensors high (highest level)\n                    next_state = HIGH;\n                else if (!|s)\n                    next_state = LOW;\n                else\n                    next_state = MID_HIGH;\n            end\n            HIGH: begin\n                if (!|s)\n                    next_state = LOW;\n                else\n                    next_state = HIGH;\n            end\n            default: next_state = LOW; // Default to LOW\n        endcase\n    end\n    \n    // Output generation\n    always_comb begin\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n        \n        case (current_state)\n            LOW: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            MID_LOW: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            MID_HIGH: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n            end\n            HIGH: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n            end\n        endcase\n        \n        // Determine if dfr should be set\n        if ((current_state == LOW && next_state == MID_LOW) ||\n            (current_state == MID_LOW && next_state == MID_HIGH) ||\n            (current_state == MID_HIGH && next_state == HIGH))\n            dfr = 1'b1;\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State definition\n    typedef enum {IDLE, START_BIT, DATA_BITS, STOP_BIT} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: \n                if (!in)\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            START_BIT: \n                next_state = DATA_BITS;\n            DATA_BITS: \n                if (in == 1'b1) begin\n                    if (count < 7)\n                        next_state = DATA_BITS;\n                    else\n                        next_state = STOP_BIT;\n                end else\n                    next_state = IDLE; // Incorrect data bit, go back to IDLE\n            STOP_BIT: \n                if (in)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_BIT; // Incorrect stop bit, stay in STOP_BIT\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    // Data bit counter\n    reg [2:0] count;\n    always @(posedge clk or posedge reset)\n        if (reset)\n            count <= 0;\n        else if (state == DATA_BITS && in == 1'b1)\n            count <= count + 1;\n        else if (state != DATA_BITS)\n            count <= 0;\n\n    // Done signal\n    always @(posedge clk or posedge reset)\n        if (reset)\n            done <= 0;\n        else if (state == STOP_BIT && in)\n            done <= 1;\n        else if (state == IDLE || state == START_BIT)\n            done <= 0;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    // Define states\n    typedef enum {IDLE, DATA_0, DATA_1, DATA_2, DATA_3, DATA_4, DATA_5, DATA_6, DATA_7, STOP} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: \n                if (!in) \n                    next_state = DATA_0;\n                else \n                    next_state = IDLE;\n            DATA_0: \n                next_state = DATA_1;\n            DATA_1: \n                next_state = DATA_2;\n            DATA_2: \n                next_state = DATA_3;\n            DATA_3: \n                next_state = DATA_4;\n            DATA_4: \n                next_state = DATA_5;\n            DATA_5: \n                next_state = DATA_6;\n            DATA_6: \n                next_state = DATA_7;\n            DATA_7: \n                next_state = STOP;\n            STOP: \n                if (in) \n                    next_state = IDLE;\n                else \n                    next_state = STOP;\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out_byte <= 8'b0;\n        else if (current_state == DATA_0) \n            out_byte[0] <= in;\n        else if (current_state == DATA_1) \n            out_byte[1] <= in;\n        else if (current_state == DATA_2) \n            out_byte[2] <= in;\n        else if (current_state == DATA_3) \n            out_byte[3] <= in;\n        else if (current_state == DATA_4) \n            out_byte[4] <= in;\n        else if (current_state == DATA_5) \n            out_byte[5] <= in;\n        else if (current_state == DATA_6) \n            out_byte[6] <= in;\n        else if (current_state == DATA_7) \n            out_byte[7] <= in;\n    end\n\n    // Done signal\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            done <= 0;\n        else if (current_state == STOP && in)\n            done <= 1;\n        else\n            done <= 0;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    \n    // Global History Register\n    reg [6:0] global_history;\n    \n    // Pattern History Table (PHT)\n    reg [1:0] pht_table [0:127];\n    \n    // Initialize PHT entries\n    initial begin\n        for (integer i = 0; i < 128; i = i + 1) begin\n            pht_table[i] = 2'b01; // Initial value of PHT entries\n        end\n    end\n    \n    // Update global history based on predictions\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            global_history <= 7'b0;\n        else if (predict_valid)\n            global_history <= {global_history[5:0], predict_taken};\n    end\n    \n    // Prediction Logic\n    wire [6:0] pht_index = predict_pc ^ global_history;\n    assign predict_taken = pht_table[pht_index] >= 2'b10; // Strongly taken if PHT > 2'b10\n    assign predict_history = global_history;\n    \n    // Training Logic\n    always @(posedge clk) begin\n        if (areset) begin\n            for (integer i = 0; i < 128; i = i + 1) begin\n                pht_table[i] <= 2'b01;\n            end\n        end else if (train_valid) begin\n            if (train_taken) begin\n                case (pht_table[train_pc ^ train_history])\n                    2'b00: pht_table[train_pc ^ train_history] <= 2'b01; // Weakly taken -> Strongly not taken\n                    2'b01: pht_table[train_pc ^ train_history] <= 2'b10; // Weakly not taken -> Strongly taken\n                    2'b10: pht_table[train_pc ^ train_history] <= 2'b11; // Strongly taken -> Stronger taken\n                    2'b11: pht_table[train_pc ^ train_history] <= 2'b11; // Already strongly taken\n                endcase\n            end else begin\n                case (pht_table[train_pc ^ train_history])\n                    2'b00: pht_table[train_pc ^ train_history] <= 2'b00; // Weakly not taken -> Weaker not taken\n                    2'b01: pht_table[train_pc ^ train_history] <= 2'b00; // Weakly taken -> Weaker not taken\n                    2'b10: pht_table[train_pc ^ train_history] <= 2'b01; // Strongly taken -> Weakly taken\n                    2'b11: pht_table[train_pc ^ train_history] <= 2'b01; // Strongly not taken -> Weakly not taken\n                endcase\n            end\n            \n            if (train_mispredicted) begin\n                global_history <= train_history;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 270 out of 1083 samples.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALL = 3'b010,\n        DIG_LEFT = 3'b011,\n        DIG_RIGHT = 3'b100,\n        SPLATTERED = 3'b101\n    } state_t;\n    \n    state_t curr_state, next_state;\n    reg [4:0] fall_counter;\n\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset) begin\n            curr_state <= WALK_LEFT;\n            fall_counter <= 5'b00000;\n        end else begin\n            curr_state <= next_state;\n            if (curr_state == FALL) begin\n                fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 5'b00000;\n            end\n        end\n    end\n    \n    always_comb begin\n        next_state = curr_state;\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        \n        unique case (curr_state)\n            WALK_LEFT: begin\n                if (bump_left) next_state = WALK_RIGHT;\n                else if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right) next_state = WALK_LEFT;\n                else if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG_RIGHT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (next_state == WALK_LEFT) next_state = WALK_LEFT;\n                    else if (next_state == WALK_RIGHT) next_state = WALK_RIGHT;\n                end\n                if (fall_counter > 20) next_state = SPLATTERED;\n            end\n            DIG_LEFT: begin\n                if (ground) next_state = WALK_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (ground) next_state = WALK_RIGHT;\n            end\n            SPLATTERED: begin\n                // Terminal state, do nothing\n            end\n        endcase\n        \n        unique case (curr_state)\n            WALK_LEFT: walk_left = 1'b1;\n            WALK_RIGHT: walk_right = 1'b1;\n            FALL: aaah = 1'b1;\n            DIG_LEFT: begin\n                walk_left = 1'b1;\n                digging = 1'b1;\n            end\n            DIG_RIGHT: begin\n                walk_right = 1'b1;\n                digging = 1'b1;\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\ntypedef enum logic [3:0] {\n\tSEARCH_PATTERN = 4'b0000,\n\tMATCHED_1 = 4'b0001,\n\tMATCHED_11 = 4'b0010,\n\tMATCHED_110 = 4'b0011,\n\tMATCHED_1101 = 4'b0100,\n\tSHIFT_IN_BITS = 4'b0101,\n\tWAIT_FOR_COUNTING = 4'b0110,\n\tNOTIFY_USER = 4'b0111,\n\tACKNOWLEDGE = 4'b1000\n} state_t;\n\nstate_t state, next_state;\n\nalways_ff @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\tstate <= SEARCH_PATTERN;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways_comb begin\n\tnext_state = state;\n\n\tcase(state)\n\t\tSEARCH_PATTERN: begin\n\t\t\tif (data == 1) next_state = MATCHED_1;\n\t\tend\n\t\tMATCHED_1: begin\n\t\t\tif (data == 1) next_state = MATCHED_11;\n\t\t\telse next_state = SEARCH_PATTERN;\n\t\tend\n\t\tMATCHED_11: begin\n\t\t\tif (data == 0) next_state = MATCHED_110;\n\t\t\telse next_state = SEARCH_PATTERN;\n\t\tend\n\t\tMATCHED_110: begin\n\t\t\tif (data == 1) next_state = MATCHED_1101;\n\t\t\telse next_state = SEARCH_PATTERN;\n\t\tend\n\t\tMATCHED_1101: begin\n\t\t\tnext_state = SHIFT_IN_BITS;\n\t\tend\n\t\tSHIFT_IN_BITS: begin\n\t\t\tnext_state = WAIT_FOR_COUNTING;\n\t\tend\n\t\tWAIT_FOR_COUNTING: begin\n\t\t\tif (done_counting) next_state = NOTIFY_USER;\n\t\tend\n\t\tNOTIFY_USER: begin\n\t\t\tif (ack) next_state = ACKNOWLEDGE;\n\t\tend\n\t\tACKNOWLEDGE: begin\n\t\t\tif (ack) next_state = SEARCH_PATTERN;\n\t\tend\n\tendcase\nend\n\nalways_comb begin\n\tshift_ena = 0;\n\tcounting = 0;\n\tdone = 0;\n\n\tcase(state)\n\t\tSHIFT_IN_BITS: shift_ena = 1;\n\t\tWAIT_FOR_COUNTING: counting = 1;\n\t\tNOTIFY_USER: done = 1;\n\tendcase\nend\n\nendmodule\n", "result": "failed: 1474 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n    // Helper function to get the neighbor count for a given cell\n    function integer count_neighbors;\n        input [7:0] x, y;\n        integer sum;\n        begin\n            sum = 0;\n            // Loop through all possible neighbors\n            for (integer i = -1; i <= 1; i=i+1)\n                for (integer j = -1; j <= 1; j=j+1)\n                    if (!(i == 0 && j == 0)) // Exclude the cell itself\n                        sum = sum + q[(y+j+16)%16*16 + (x+i+16)%16];\n            count_neighbors = sum;\n        end\n    endfunction\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            integer new_q[255:0];\n            for (integer i = 0; i < 256; i=i+1) begin\n                integer x = i % 16;\n                integer y = i / 16;\n                integer neighbors = count_neighbors(x, y);\n                case (neighbors)\n                    0, 1: new_q[i] = 0;\n                    2: new_q[i] = q[i];\n                    3: new_q[i] = 1;\n                    default: new_q[i] = 0;\n                endcase\n            end\n            q <= new_q;\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // State definitions\n    typedef enum logic [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALLING = 3'b010,\n        DIGGING = 3'b011,\n        TRANSITION_LEFT = 3'b100,\n        TRANSITION_RIGHT = 3'b101\n    } state_t;\n\n    state_t curr_state, next_state;\n    \n    // State register\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset)\n            curr_state <= WALK_LEFT;\n        else\n            curr_state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        case (curr_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_RIGHT;\n                else if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_left)\n                    next_state = WALK_LEFT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground && (next_state == WALK_LEFT || next_state == WALK_RIGHT))\n                    next_state = next_state;\n                else\n                    next_state = FALLING;\n            end\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (ground && (next_state == WALK_LEFT || next_state == WALK_RIGHT))\n                    next_state = next_state;\n                else\n                    next_state = DIGGING;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n    \n    // Output logic\n    always_comb begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        \n        case (curr_state)\n            WALK_LEFT: begin\n                walk_left = 1'b1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1'b1;\n            end\n            FALLING: begin\n                aaah = 1'b1;\n            end\n            DIGGING: begin\n                digging = 1'b1;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\t// Internal state variables\n\treg [3:0] h; // Hours in BCD (01-12)\n\treg [5:0] m; // Minutes in BCD (00-59)\n\treg [5:0] s; // Seconds in BCD (00-59)\n\n\t// Initialize internal states and pm flag\n\tinitial begin\n\t\th = 4'b0001; // Start at 1\n\t\tm = 6'b000000;\n\t\ts = 6'b000000;\n\t\tpm = 1'b0;   // Start at AM\n\tend\n\n\t// Clock process\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\th <= 4'b0001; // Reset to 1\n\t\t\tm <= 6'b000000;\n\t\t\ts <= 6'b000000;\n\t\t\tpm <= 1'b0;   // Set to AM\n\t\tend else if (ena) begin\n\t\t\ts <= s + 1; // Increment seconds\n\n\t\t\t// Roll-over logic for seconds\n\t\t\tif (s == 6'b001110) begin // 59 in BCD\n\t\t\t\ts <= 6'b000000; // Reset seconds\n\t\t\t\tm <= m + 1;     // Increment minutes\n\t\t\tend\n\n\t\t\t// Roll-over logic for minutes\n\t\t\tif (m == 6'b001110) begin // 59 in BCD\n\t\t\t\tm <= 6'b000000; // Reset minutes\n\t\t\t\th <= h + 1;     // Increment hours\n\t\t\tend\n\n\t\t\t// Roll-over logic for hours\n\t\t\tif (h == 4'b1100) begin // 12 in BCD\n\t\t\t\th <= 4'b0001; // Reset hours back to 1\n\t\t\t\tpm <= ~pm;    // Toggle AM/PM\n\t\t\tend\n\t\tend\n\tend\n\n\t// Output BCD conversion\n\tassign hh = {h[3], h[2], h[1], h[0], 3'b000}; // Convert 4-bit BCD to 8-bit BCD\n\tassign mm = {m[5], m[4], m[3], m[2], m[1], m[0], 2'b00}; // Convert 6-bit BCD to 8-bit BCD\n\tassign ss = {s[5], s[4], s[3], s[2], s[1], s[0], 2'b00}; // Convert 6-bit BCD to 8-bit BCD\nendmodule\n", "result": "failed: 352408 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    // Define states\n    typedef enum logic [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10\n    } state_t;\n\n    state_t curr_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset)\n            curr_state <= WALK_LEFT;\n        else\n            curr_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (curr_state)\n            WALK_LEFT: begin\n                if (bump_right)\n                    next_state = WALK_RIGHT;\n                else if (!ground)\n                    next_state = FALLING;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_left)\n                    next_state = WALK_LEFT;\n                else if (!ground)\n                    next_state = FALLING;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = (curr_state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALLING;\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = (curr_state == WALK_LEFT);\n        walk_right = (curr_state == WALK_RIGHT);\n        aaah = (curr_state == FALLING);\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n    \n    // Internal signals for carry detection\n    wire carry_ones_to_tens;\n    wire carry_tens_to_hundreds;\n    wire carry_hundreds_to_thousands;\n\n    // Detecting carry from ones to tens\n    assign carry_ones_to_tens = &q[3:0]; // Carry if ones is 9 (1001 in binary)\n    \n    // Detecting carry from tens to hundreds\n    assign carry_tens_to_hundreds = &q[7:4]; // Carry if tens is 9 (1001 in binary)\n    \n    // Detecting carry from hundreds to thousands\n    assign carry_hundreds_to_thousands = &q[11:8]; // Carry if hundreds is 9 (1001 in binary)\n\n    // Assigning enable signals based on carry conditions\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            ena <= 0; // Reset all enable signals\n            q <= 0;   // Reset counter to 0\n        end else begin\n            ena[1] <= carry_ones_to_tens; // Enable tens when ones reaches 9\n            ena[2] <= carry_tens_to_hundreds; // Enable hundreds when tens reaches 9\n            ena[3] <= carry_hundreds_to_thousands; // Enable thousands when hundreds reaches 9\n            \n            // Increment the least significant digit\n            if (carry_ones_to_tens) begin\n                q[3:0] <= 0; // Reset ones to 0\n                if (carry_tens_to_hundreds) begin\n                    q[7:4] <= 0; // Reset tens to 0\n                    if (carry_hundreds_to_thousands) begin\n                        q[11:8] <= 0; // Reset hundreds to 0\n                    end else begin\n                        q[11:8] <= q[11:8] + 1; // Increment hundreds\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1; // Increment tens\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1; // Increment ones\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\nalways @(*) begin\n    if (sel == 1'b0)\n        out <= a;\n    else\n        out <= b;\nend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(*) begin\n    // Initialize next state for y[2]\n    Y2 = 1'b0;\n\n    // Case statement to determine the next state for y[2] based on current state (y[3:1]) and input (w)\n    case(y)\n        3'b000: // State A\n            if (w == 1'b0) begin\n                Y2 = 1'b0; // Next state is B -> y[2] = 0\n            end else begin\n                Y2 = 1'b0; // Next state is A -> y[2] = 0\n            end\n        3'b001: // State B\n            if (w == 1'b0) begin\n                Y2 = 1'b0; // Next state is C -> y[2] = 0\n            end else begin\n                Y2 = 1'b1; // Next state is D -> y[2] = 1\n            end\n        3'b010: // State C\n            if (w == 1'b0) begin\n                Y2 = 1'b0; // Next state is E -> y[2] = 0\n            end else begin\n                Y2 = 1'b1; // Next state is D -> y[2] = 1\n            end\n        3'b011: // State D\n            if (w == 1'b0) begin\n                Y2 = 1'b0; // Next state is F -> y[2] = 0\n            end else begin\n                Y2 = 1'b0; // Next state is A -> y[2] = 0\n            end\n        3'b100: // State E\n            if (w == 1'b0) begin\n                Y2 = 1'b0; // Next state is E -> y[2] = 0\n            end else begin\n                Y2 = 1'b1; // Next state is D -> y[2] = 1\n            end\n        3'b101: // State F\n            if (w == 1'b0) begin\n                Y2 = 1'b1; // Next state is C -> y[2] = 1\n            end else begin\n                Y2 = 1'b1; // Next state is D -> y[2] = 1\n            end\n    endcase\nend\n\nendmodule\n", "result": "failed: 8 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n    // Assignments based on the conditions\n    assign ringer = (!vibrate_mode && ring);  // Ringer is on if not in vibrate mode and there is a ring signal\n    assign motor = (vibrate_mode && ring);    // Motor is on if in vibrate mode and there is a ring signal\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n    // Using assign statement\n    assign out_assign = a & b;\n    \n    // Using combinational always block\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\t// Assigning the output to 0 (LOW)\n\tassign zero = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (a == 1'b1)\n\t\t\tq <= 1'b0; // Reset q to 0 if a is 1\n\t\telse\n\t\t\tq <= 1'b1; // Set q to 1 if a is 0\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // State definitions\n    typedef enum logic [2:0] { IDLE, COPY, INVERT, ADD, DONE } state_t;\n    state_t current_state, next_state;\n\n    // Output logic\n    always_comb begin\n        case(current_state)\n            IDLE: z = 1'b0; // No output in idle state\n            COPY: z = x;\n            INVERT: z = ~x;\n            ADD: z = x ^ 1'b1; // Add 1 to the inverted bit\n            DONE: z = 1'bx; // Undefined output in done state\n            default: z = 1'b0;\n        endcase\n    end\n    \n    // Next state logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    always_comb begin\n        case(current_state)\n            IDLE: \n                if (!areset) next_state = COPY;\n                else next_state = IDLE;\n            COPY: \n                if (x == 1'b1) next_state = INVERT;\n                else next_state = ADD;\n            INVERT: \n                next_state = ADD;\n            ADD: \n                next_state = DONE;\n            DONE: \n                next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\t\n\t// Define the states\n\ttypedef enum logic [1:0] {A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11} state_t;\n\t\n\t// Declare the current state and next state\n\tstate_t curr_state, next_state;\n\t\n\t// Output signal declaration\n\tlogic out_signal;\n\t\n\t// Assign the output based on the current state\n\tassign out = (curr_state == D) ? 1'b1 : 1'b0;\n\t\n\t// State register process\n\talways_ff @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tcurr_state <= A; // Reset state to A\n\t\telse\n\t\t\tcurr_state <= next_state; // Update current state on clock edge\n\tend\n\t\n\t// Next state logic process\n\talways_comb\n\tbegin\n\t\tunique case (curr_state)\n\t\t\tA: next_state = (in) ? B : A;\n\t\t\tB: next_state = (in) ? B : C;\n\t\t\tC: next_state = (in) ? D : A;\n\t\t\tD: next_state = (in) ? B : C;\n\t\t\tdefault: next_state = A; // Default case to avoid latches\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Assign each byte to its new position\n    assign out[7:0] = in[24:16]; // Byte 3 -> Byte 0\n    assign out[15:8] = in[15:8]; // Byte 2 -> Byte 1\n    assign out[23:16] = in[8:0]; // Byte 1 -> Byte 2\n    assign out[31:24] = in[31:24]; // Byte 0 -> Byte 3\n\nendmodule\n", "result": "failed: 109 out of 110 samples.", "passed": false}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n    // Use an always block sensitive to changes in clk and r\n    always @(posedge clk or posedge r) begin\n        if (r) begin\n            // Reset condition\n            q <= 1'b0;\n        end else begin\n            // Normal operation - capture input d on rising edge of clk\n            q <= d;\n        end\n    end\nendmodule\n", "result": "failed: 16 out of 100 samples.", "passed": false}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Step 1: Compute the XOR of x and y\n    wire xor_result;\n    assign xor_result = x ^ y;\n\n    // Step 2: Perform AND operation between the XOR result and x\n    assign z = xor_result & x;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: q <= {q[62:0], q[63]}; // Left shift by 1 bit\n\t\t\t2'b01: q <= {q[55:0], 8'b0}; // Left shift by 8 bits\n\t\t\t2'b10: q <= {{63{q[63]}}, q[62:0]}; // Arithmetic right shift by 1 bit\n\t\t\t2'b11: q <= {{56{q[63]}}, q[55:0]}; // Arithmetic right shift by 8 bits\n\t\tendcase\n\tend\nend\n\nendmodule\n", "result": "failed: 3216 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {STATE_0, STATE_1, STATE_2} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always @(posedge clk or negedge aresetn)\n        if (!aresetn) \n            current_state <= STATE_0;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_0: \n                if (x == 1'b1)\n                    next_state = STATE_1;\n                else\n                    next_state = STATE_0;\n            STATE_1: \n                if (x == 1'b0)\n                    next_state = STATE_0;\n                else\n                    next_state = STATE_2;\n            STATE_2: \n                if (x == 1'b0)\n                    next_state = STATE_0;\n                else\n                    next_state = STATE_1;\n            default: \n                next_state = STATE_0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (next_state)\n            STATE_1: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 113 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    // Current state and next state registers\n    state_t curr_state, next_state;\n    \n    // Output signal\n    assign z = (curr_state == E) ? 1'b1 : 1'b0;\n\n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            curr_state <= A;  // Reset condition\n        else\n            curr_state <= next_state;  // Update state on clock edge\n    end\n    \n    // Next state logic\n    always_comb begin\n        case (curr_state)\n            A: next_state = (w == 0) ? B : A;\n            B: next_state = (w == 0) ? C : D;\n            C: next_state = (w == 0) ? E : D;\n            D: next_state = (w == 0) ? F : A;\n            E: next_state = (w == 0) ? E : D;\n            F: next_state = (w == 0) ? C : D;\n            default: next_state = A;  // Default case\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        BYTE_1 = 2'b01,\n        BYTE_2 = 2'b10,\n        BYTE_3 = 2'b11\n    } state_t;\n    \n    // State register\n    state_t state, next_state;\n\n    // Byte registers\n    reg [7:0] byte1, byte2, byte3;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: begin\n                if (in[3])\n                    next_state = BYTE_1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE_1: begin\n                next_state = BYTE_2;\n            end\n            BYTE_2: begin\n                next_state = BYTE_3;\n            end\n            BYTE_3: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Byte collection logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            byte1 <= 8'h00;\n            byte2 <= 8'h00;\n            byte3 <= 8'h00;\n        end else begin\n            case(state)\n                BYTE_1: byte1 <= in;\n                BYTE_2: byte2 <= in;\n                BYTE_3: byte3 <= in;\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out_bytes <= 24'h000000;\n            done <= 1'b0;\n        end else begin\n            if (state == BYTE_3) begin\n                out_bytes <= {byte3, byte2, byte1};\n                done <= 1'b1;\n            end else begin\n                out_bytes <= 24'h000000;\n                done <= 1'b0;\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\t\n\tassign Y1 = (y[0] & w) | (y[4] & ~w);\n\tassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "result": "failed: 103 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Assigning the 3-bit input to the 3-bit output\n    assign outv = vec;\n    \n    // Assigning each bit of the input vector to individual outputs\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\t// Compute individual terms\n\treg ab;\n\treg a_b;\n\treg a_c;\n\treg ab_c;\n\t\n\tassign ab = a & b; // ab\n\tassign a_b = ~a & b; // a'b\n\tassign a_c = ~a & ~c; // a'c'\n\tassign ab_c = a & ~c; // ac'\n\t\n\t// Combine terms\n\talways @(*) begin\n\t\tif (a == 1'b0 && b == 1'b0) begin\n\t\t\tout = 1'b1; // a'b'\n\t\tend else if (a == 1'b1 && b == 1'b0) begin\n\t\t\tout = 1'b1; // ab'\n\t\tend else if (a == 1'b0 && c == 1'b0) begin\n\t\t\tout = 1'b1; // a'c'\n\t\tend else if (a == 1'b1 && c == 1'b0) begin\n\t\t\tout = 1'b1; // ac'\n\t\tend else begin\n\t\t\tout = 1'b0;\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 119 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\t// Assign the upper 8 bits of 'in' to 'out_hi'\n\tassign out_hi = in[15:8];\n\t\n\t// Assign the lower 8 bits of 'in' to 'out_lo'\n\tassign out_lo = in[7:0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = ~(a | b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n    // Using an assign statement for direct XOR logic\n    assign out_assign = a ^ b;\n\n    // Combinational always block for XOR\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Clocked always block for sequential XOR logic\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n    // Calculate Y2\n    assign Y2 = ~(y[1]) & ((y[2] ^ y[3]) | (y[4] & ~y[5] & ~y[6])) & (~y[4] | ~y[5] | y[6]);\n\n    // Calculate Y4\n    assign Y4 = (y[1] & ~w) | (y[2] & w) | (y[3] & ~w) | (y[5] & w) | (y[6] & ~w);\nendmodule\n", "result": "failed: 454 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    // Assign the output based on the selected input bit\n    always @(*) begin\n        out = in[sel];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n    \n    // Internal signal to hold the input to the D flip-flop\n    wire d_in;\n\n    // Multiplexer logic to choose between R, w, and Q\n    always @(*) begin\n        if (L)\n            d_in = R;\n        else if (E)\n            d_in = w;  // Assuming the first stage takes w as input for shift\n        else\n            d_in = Q;  // Hold current state\n    end\n\n    // D flip-flop to store the state\n    always @(posedge clk) begin\n        Q <= d_in;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // Declare internal signals for the outputs of the D flip-flops\n    reg q1, q2, q3;\n\n    // D flip-flop definitions\n    always @(posedge clk) begin\n        q1 <= x ^ q1;  // XOR gate\n        q2 <= x & ~q2; // AND gate with inverted output as second input\n        q3 <= x | ~q3; // OR gate with inverted output as second input\n    end\n\n    // Output Z is the result of a three-input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3); // Three-input XNOR implemented using XOR and NOT\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\t\n\tassign q = d | (~d & c);\n\nendmodule\n", "result": "failed: 26 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    \n    // Function to determine the next state of a cell based on Rule 110\n    function [1:0] next_state;\n        input left, center, right;\n        begin\n            case ({left, center, right})\n                3'b111: next_state = 2'b00; // 111 -> 0\n                3'b110: next_state = 2'b01; // 110 -> 1\n                3'b101: next_state = 2'b01; // 101 -> 1\n                3'b100: next_state = 2'b00; // 100 -> 0\n                3'b011: next_state = 2'b01; // 011 -> 1\n                3'b010: next_state = 2'b01; // 010 -> 1\n                3'b001: next_state = 2'b01; // 001 -> 1\n                default: next_state = 2'b00; // 000 -> 0\n            endcase\n        end\n    endfunction\n\n    // Process the state transition on each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            reg [511:0] new_q;\n            for (int i = 0; i < 512; i = i + 1) begin\n                // Handle edge cases where left and right neighbors are fixed to 0\n                if (i == 0) begin\n                    new_q[i] = next_state(0, q[i], q[i+1]);\n                end else if (i == 511) begin\n                    new_q[i] = next_state(q[i-1], q[i], 0);\n                end else begin\n                    new_q[i] = next_state(q[i-1], q[i], q[i+1]);\n                end\n            end\n            q <= new_q;\n        end\n    end\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // Define the states using parameterized constants\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    // Current state register\n    reg [1:0] current_state;\n\n    // Next state logic\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            current_state <= A;  // Reset to state A\n        else\n            case(current_state)\n                A: current_state <= (in == 1'b0) ? A : B;\n                B: current_state <= (in == 1'b0) ? C : B;\n                C: current_state <= (in == 1'b0) ? A : D;\n                D: current_state <= (in == 1'b0) ? C : B;\n                default: current_state <= A;  // Default to state A\n            endcase\n    end\n\n    // Output logic\n    always @* begin\n        case(current_state)\n            A: out = 1'b0;\n            B: out = 1'b0;\n            C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0;  // Default output to 0\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n    \n    always @(*) begin\n        // Initialize q to an invalid state (or any fixed state)\n        q = 4'bzzzz; // This is a placeholder for initialization; typically, we'd use a known value\n        \n        // Use a case statement to handle different values of c\n        case (c)\n            4'b0000: q = b; // When c is 0, q is set to b\n            4'b0001: q = e; // When c is 1, q is set to e\n            4'b0010: q = a; // When c is 2, q is set to a\n            4'b0011: q = d; // When c is 3, q is set to d\n            default: q = 4'b1111; // For all other values of c, set q to f (4'b1111 represents binary 15, which corresponds to hexadecimal F)\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n    \n    always @(*) begin\n        if (sel == 1'b0)\n            out <= a;\n        else\n            out <= b;\n    end\n\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            // Implementing the logic for the next state\n            case ({q_in, Q})\n                2'b00: Q <= 0;\n                2'b01: Q <= 1;\n                2'b10: Q <= 0;\n                2'b11: Q <= 1;\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 49 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    // Register to hold the previous value of 'in'\n    reg [31:0] prev_in;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            prev_in <= 0;\n        else\n            prev_in <= in;\n    end\n\n    // Detecting the transition from 1 to 0 for each bit\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 0;\n        else begin\n            // Loop through each bit\n            for (integer i = 0; i < 32; i = i + 1) begin\n                // If the current bit is 0 and the previous bit was 1, set the corresponding bit in 'out'\n                if (!in[i] && prev_in[i])\n                    out[i] <= 1;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 150 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tq <= d;\n\tend\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\t// Internal wires for carry\n\twire [7:0] c;\n\n\t// Full adders for each bit\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 0; i < 8; i = i + 1) begin : full_adders\n\t\t\tif (i == 0) begin\n\t\t\t\tassign c[i] = a[i] ^ b[i]; // No carry-in for LSB\n\t\t\tend else begin\n\t\t\t\tassign c[i] = a[i] ^ b[i] ^ c[i-1];\n\t\t\tend\n\t\t\tassign s[i] = c[i] ^ b[i+1];\n\t\tend\n\tendgenerate\n\n\t// Detecting overflow\n\tassign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n    // Next-state logic\n    assign B3_next = &state[9:7]; // Check if state is B3 (10'b0000000100)\n    assign S_next = (state == 10'b0000000001) | (state[9:6] == 4'b0000 && d == 0);\n    assign S1_next = (state == 10'b0000000010) | (state[9:6] == 4'b0000 && d == 1);\n    assign Count_next = (state == 10'b0000000000) ? 0 : (state[9:7] == 3'b100 && done_counting);\n    assign Wait_next = (state[9:8] == 2'b10) ? ack : 0;\n\n    // Output logic\n    assign shift_ena = |state[9:7]; // Check if state is in B0, B1, B2, or B3\n    assign counting = state[9];\n    assign done = state[8];\n\nendmodule\n", "result": "failed: 3231 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk, posedge areset)\n    begin\n        if (areset)\n            state <= 2'b01; // Reset to weakly not-taken (1)\n        else\n        begin\n            if (train_valid)\n            begin\n                if (train_taken)\n                    state <= state + 1; // Increment\n                else\n                    state <= state - 1; // Decrement\n            end\n            // Saturate the counter\n            if (state > 2'b11) // Greater than 3\n                state <= 2'b11;\n            else if (state < 2'b00) // Less than 0\n                state <= 2'b00;\n        end\n    end\nendmodule\n", "result": "failed: 807 out of 1051 samples.", "passed": false}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\talways @(*) begin\n\t\tpos = 3'b111; // Initialize to an invalid value indicating no '1' found yet.\n\t\tfor (int i = 0; i < 8; i = i + 1) begin\n\t\t\tif (in[i]) begin\n\t\t\t\tpos = i;\n\t\t\t\tbreak; // Exit the loop once the first '1' is found.\n\t\t\tend\n\t\tend\n\t\tif (pos == 3'b111) pos = 3'b000; // If no '1' was found, set pos to 0.\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n\t// Initialize all outputs to low\n\tleft = 0;\n\tdown = 0;\n\tright = 0;\n\tup = 0;\n\n\t// Compare scancode with predefined values\n\tcase(scancode)\n\t\t16'hE06B: left = 1; // Left arrow\n\t\t16'hE072: down = 1; // Down arrow\n\t\t16'hE074: right = 1; // Right arrow\n\t\t16'hE075: up = 1; // Up arrow\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    wire [3:0] carry;\n    \n    // Full Adder instantiation\n    // Assuming a full_adder module is available which has the following interface:\n    // full_adder(a, b, cin, s, cout)\n    full_adder fa0(x[0], y[0], 1'b0, sum[0], carry[0]);\n    full_adder fa1(x[1], y[1], carry[0], sum[1], carry[1]);\n    full_adder fa2(x[2], y[2], carry[1], sum[2], carry[2]);\n    full_adder fa3(x[3], y[3], carry[2], sum[3], carry[3]);\n    \n    // Assigning the overflow bit\n    assign sum[4] = carry[3];\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    // Internal signal for the new history to be shifted in\n    logic [31:0] new_history;\n\n    // Asynchronous reset block\n    always_ff @(posedge clk, posedge areset)\n    begin\n        if (areset)\n            predict_history <= 32'b0;\n        else\n        begin\n            // Handle mispredictions first\n            if (train_mispredicted)\n                predict_history <= {train_history, train_taken};\n            // Handle predictions if no misprediction\n            else if (predict_valid)\n                predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n    // Declare intermediate wires for AND gate outputs\n    wire and_out1, and_out2;\n\n    // Implement the first AND gate\n    assign and_out1 = a & b;\n\n    // Implement the second AND gate\n    assign and_out2 = c & d;\n\n    // Implement the OR gate using the outputs of the AND gates\n    assign out = and_out1 | and_out2;\n\n    // Invert the output 'out' to generate 'out_n'\n    assign out_n = ~out;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\t\n\t// Define an always block sensitive to the rising edge of the clock\n\talways @(posedge clk) begin\n\t\t// Assign the value of 'd' to 'q' on the rising edge of the clock\n\t\tq <= d;\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    \n    // Define the internal wires\n    reg [7:0] data_reg;\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable) begin\n            data_reg = {S, data_reg[7:1]};\n        end\n    end\n\n    // Multiplexer logic to select the correct bit based on A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = data_reg[0];\n            3'b001: Z = data_reg[1];\n            3'b010: Z = data_reg[2];\n            3'b011: Z = data_reg[3];\n            3'b100: Z = data_reg[4];\n            3'b101: Z = data_reg[5];\n            3'b110: Z = data_reg[6];\n            3'b111: Z = data_reg[7];\n        endcase\n    end\n\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\t\n\t// Heater Logic\n\tassign heater = (mode & too_cold); // Heater turns on when mode is heating (mode=1) and it's too cold (too_cold=1)\n\t\n\t// Air Conditioner Logic\n\tassign aircon = (!mode & too_hot); // AC turns on when mode is cooling (mode=0) and it's too hot (too_hot=1)\n\t\n\t// Fan Logic\n\t// Fan turns on if either heater or air conditioner is on, or if fan_on is set to 1\n\tassign fan = (heater | aircon | fan_on);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\t\n\t// Sum of Products (SOP) for out_sop\n\tassign out_sop = (~a & ~b & ~c & d) | (~a & b & c & ~d) | (a & b & c & d);\n\t\n\t// Product of Sums (POS) for out_pos\n\tassign out_pos = ~(a | b | c | d) & ~(a | b | c | ~d) & ~(a | ~b | c | ~d) & ~(~a | b | c | ~d);\n\t\nendmodule\n", "result": "failed: 43 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    // Define the taps positions (bit indices)\n    localparam TAP_32 = 31; // Tap position 32 corresponds to index 31\n    localparam TAP_22 = 21; // Tap position 22 corresponds to index 21\n    localparam TAP_2 = 1;   // Tap position 2 corresponds to index 1\n    localparam TAP_1 = 0;   // Tap position 1 corresponds to index 0\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Initialize q to 32'h1 when reset is high\n            q <= 32'h1;\n        end else begin\n            // Compute the new bit to be inserted at the LSB\n            reg new_bit;\n            new_bit = q[TAP_32] ^ q[TAP_22] ^ q[TAP_2] ^ q[TAP_1];\n\n            // Shift the state to the right and insert the new bit at the LSB\n            q <= {q[30:0], new_bit};\n        end\n    end\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (a & b) | (a & c) | (a & d) | (b & c) | (b & d) | (c & d) | (a & b & c) | (a & b & d) | (a & c & d) | (b & c & d) | (a & b & c & d);\nendmodule\n", "result": "failed: 15 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Compute the NAND output for the first set of inputs\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    \n    // Compute the NAND output for the second set of inputs\n    assign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    // Precomputed LUT to count '1's in an 8-bit input\n    reg [3:0] lut [0:255];\n    initial begin\n        for (integer i = 0; i < 256; i = i + 1) begin\n            integer count = 0;\n            integer j;\n            for (j = 0; j < 8; j = j + 1) begin\n                if ((i >> j) & 1) count = count + 1;\n            end\n            lut[i] = count;\n        end\n    end\n\n    // Count '1's in each 8-bit segment\n    reg [7:0] partial_sums [0:31];\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 32; i = i + 1) begin\n            partial_sums[i] = lut[in[8*i+7 -: 8]];\n        end\n    end\n\n    // Parallel reduction to sum all partial sums\n    reg [7:0] reduced_sums [0:3];\n    always @(*) begin\n        reduced_sums[0] = partial_sums[0] + partial_sums[1] + partial_sums[2] + partial_sums[3];\n        reduced_sums[1] = partial_sums[4] + partial_sums[5] + partial_sums[6] + partial_sums[7];\n        reduced_sums[2] = partial_sums[8] + partial_sums[9] + partial_sums[10] + partial_sums[11];\n        reduced_sums[3] = partial_sums[12] + partial_sums[13] + partial_sums[14] + partial_sums[15];\n        reduced_sums[4] = partial_sums[16] + partial_sums[17] + partial_sums[18] + partial_sums[19];\n        reduced_sums[5] = partial_sums[20] + partial_sums[21] + partial_sums[22] + partial_sums[23];\n        reduced_sums[6] = partial_sums[24] + partial_sums[25] + partial_sums[26] + partial_sums[27];\n        reduced_sums[7] = partial_sums[28] + partial_sums[29] + partial_sums[30] + partial_sums[31];\n    end\n\n    // Final reduction to get the total count\n    always @(*) begin\n        out = reduced_sums[0] + reduced_sums[1] + reduced_sums[2] + reduced_sums[3]\n             + reduced_sums[4] + reduced_sums[5] + reduced_sums[6] + reduced_sums[7];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\t// Calculate out_both[2]\n\tassign out_both[2] = in[3] & in[2];\n\n\t// Calculate out_any[3:1]\n\tassign out_any[3] = in[3] | in[0];\n\tassign out_any[2] = in[2] | in[3];\n\tassign out_any[1] = in[1] | in[2];\n\n\t// Calculate out_different[3:0] considering wrap-around\n\tassign out_different[3] = in[3] ^ in[0];\n\tassign out_different[2] = in[2] ^ in[3];\n\tassign out_different[1] = in[1] ^ in[2];\n\tassign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "failed: 213 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    \n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000; // Default case, not necessary but good practice\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0; // Reset the counter to 0\n\t\telse if (slowena) begin\n\t\t\tif (q == 4'b1001) // Check if q is 9 (binary 1001)\n\t\t\t\tq <= 4'b0; // Wrap around to 0\n\t\t\telse\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\tlogic not_in2;\n\n\t// Invert in2\n\tassign not_in2 = ~in2;\n\n\t// Perform AND operation with in1 and inverted in2\n\tassign out = in1 & not_in2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Directly assign the input to the output using 'assign' statement\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // Define the states\n    parameter B = 0;\n    parameter A = 1;\n\n    // Current state register\n    reg [1:0] current_state;\n\n    // Next state logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            current_state <= B; // Reset to state B\n        else\n            case (current_state)\n                B: if (in == 0) current_state <= A; // Transition from B to A on input 0\n                   else         current_state <= B; // Stay in B on input 1\n                A: if (in == 0) current_state <= B; // Transition from A to B on input 0\n                   else         current_state <= A; // Stay in A on input 1\n            endcase\n    end\n\n    // Output logic - Moore machine outputs depend only on the current state\n    always @(*) begin\n        case (current_state)\n            B: out = 1'b1; // Output 1 in state B\n            A: out = 1'b0; // Output 0 in state A\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    // Intermediate signals for positive and negative edge outputs\n    reg pos_edge_q;\n    reg neg_edge_q;\n\n    // Positive edge triggered flip-flop\n    always @(posedge clk) begin\n        pos_edge_q <= d;\n    end\n\n    // Negative edge triggered flip-flop\n    always @(negedge clk) begin\n        neg_edge_q <= d;\n    end\n\n    // Output is the OR of the two intermediate signals\n    assign q = pos_edge_q | neg_edge_q;\n\nendmodule\n", "result": "failed: 47 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\t// Implementing XNOR logic using logical expressions\n\tassign out = (a & b) | (~a & ~b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    \n    // Define submodules A and B\n    wire a1_out, a2_out, b1_out, b2_out;\n    \n    // Instantiate submodules A and B\n    assign a1_out = (x ^ y) & x;  // Module A\n    assign b1_out = (x & y) | (~x & ~y);  // Module B\n    \n    // Connect outputs of A1 and B1 to OR gate\n    wire or_out;\n    assign or_out = a1_out | b1_out;\n\n    // Instantiate another set of A and B modules\n    assign a2_out = (x ^ y) & x;  // Module A\n    assign b2_out = (x & y) | (~x & ~y);  // Module B\n    \n    // Connect outputs of A2 and B2 to AND gate\n    wire and_out;\n    assign and_out = a2_out & b2_out;\n\n    // Connect OR and AND outputs to XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            case (ena)\n                2'b01: // Right rotation\n                    q <= {q[0], q[99:1]};\n                2'b10: // Left rotation\n                    q <= {q[98:0], q[99]};\n                default: // No rotation\n                    q <= q;\n            endcase\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the counter to 0 when reset is high\n            q <= 10'b0;\n        end else begin\n            // Increment the counter unless it has reached 999\n            if (q == 10'd999) begin\n                q <= 10'b0; // Reset to 0 when it reaches 999\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Invert the input signal and assign it to the output\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\t\n\t// Next State Logic\n\tassign next_state = \n\t\t(state == 10'b0000000001 && in) ? 10'b0000000010 : // S0 to S1\n\t\t(state == 10'b0000000010 && !in) ? 10'b0000000001 : // S1 to S0\n\t\t(state == 10'b0000000010 && in)  ? 10'b0000000100 : // S1 to S2\n\t\t(state == 10'b0000000100 && !in) ? 10'b0000000001 : // S2 to S0\n\t\t(state == 10'b0000000100 && in)  ? 10'b0000001000 : // S2 to S3\n\t\t(state == 10'b0000001000 && !in) ? 10'b0000000001 : // S3 to S0\n\t\t(state == 10'b0000001000 && in)  ? 10'b0000010000 : // S3 to S4\n\t\t(state == 10'b0000010000 && !in) ? 10'b0000000001 : // S4 to S0\n\t\t(state == 10'b0000010000 && in)  ? 10'b0000100000 : // S4 to S5\n\t\t(state == 10'b0000100000 && !in) ? 10'b0000000001 : // S5 to S0\n\t\t(state == 10'b0000100000 && in)  ? 10'b0000000010 : // S5 to S6\n\t\t(state == 10'b0000000010 && !in) ? 10'b0000000001 : // S6 to S0\n\t\t(state == 10'b0000000010 && in)  ? 10'b0000000100 : // S6 to S1\n\t\t(state == 10'b0000000100 && !in) ? 10'b0000000001 : // S7 to S0\n\t\t(state == 10'b0000000100 && in)  ? 10'b0000000100 : // S7 to S7\n\t\t(state == 10'b0000001000 && !in) ? 10'b0000000001 : // S8 to S0\n\t\t(state == 10'b0000001000 && in)  ? 10'b0000000010 : // S8 to S1\n\t\t(state == 10'b0000100000 && !in) ? 10'b0000000001 : // S9 to S0\n\t\t(state == 10'b0000100000 && in)  ? 10'b0000000010;  // S9 to S1\n\t// Output Logic\n\tassign {out1, out2} = \n\t\t(state == 10'b0000000100 && in) ? 2'b01 : // S7\n\t\t(state == 10'b0000001000 && !in) ? 2'b10 : // S8\n\t\t(state == 10'b0000001000 && in) ? 2'b10 : // S9\n\t\t2'b00;\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q; // Keep the same as Qold\n            2'b01: Q <= 0; // Set Q to 0\n            2'b10: Q <= 1; // Set Q to 1\n            2'b11: Q <= ~Q; // Toggle Q\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    \n    // Calculate the lower bit of the output\n    assign out[0] = in[0] | in[1] | in[2];\n    \n    // Calculate the higher bit of the output\n    assign out[1] = (in[0] & in[1]) | (in[0] & in[2]) | (in[1] & in[2]);\n    \nendmodule\n", "result": "failed: 92 out of 220 samples.", "passed": false}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\t\n\t// Assigning the output based on the equality check (XOR operation)\n\tassign out[24] = ~(a ^ a); // a == a\n\tassign out[23] = ~(a ^ b); // a == b\n\tassign out[22] = ~(a ^ c); // a == c\n\tassign out[21] = ~(a ^ d); // a == d\n\tassign out[20] = ~(a ^ e); // a == e\n\t\n\tassign out[19] = ~(b ^ a); // b == a\n\tassign out[18] = ~(b ^ b); // b == b\n\tassign out[17] = ~(b ^ c); // b == c\n\tassign out[16] = ~(b ^ d); // b == d\n\tassign out[15] = ~(b ^ e); // b == e\n\t\n\tassign out[14] = ~(c ^ a); // c == a\n\tassign out[13] = ~(c ^ b); // c == b\n\tassign out[12] = ~(c ^ c); // c == c\n\tassign out[11] = ~(c ^ d); // c == d\n\tassign out[10] = ~(c ^ e); // c == e\n\t\n\tassign out[ 9] = ~(d ^ a); // d == a\n\tassign out[ 8] = ~(d ^ b); // d == b\n\tassign out[ 7] = ~(d ^ c); // d == c\n\tassign out[ 6] = ~(d ^ d); // d == d\n\tassign out[ 5] = ~(d ^ e); // d == e\n\t\n\tassign out[ 4] = ~(e ^ a); // e == a\n\tassign out[ 3] = ~(e ^ b); // e == b\n\tassign out[ 2] = ~(e ^ c); // e == c\n\tassign out[ 1] = ~(e ^ d); // e == d\n\tassign out[ 0] = ~(e ^ e); // e == e\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    // Internal state variable\n    reg [1:0] state;\n\n    // Next state logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            state <= 2'b00; // Reset to walking left\n        else\n            case ({bump_right, bump_left})\n                2'b00: state <= state; // No bump, stay in the same state\n                2'b01: state <= ~state; // Bumped on the left, switch direction\n                2'b10: state <= ~state; // Bumped on the right, switch direction\n                default: state <= ~state; // Bumped on both sides, switch direction\n            endcase\n    end\n\n    // Output logic\n    assign walk_left = (state == 2'b00); // Walking left when state is 00\n    assign walk_right = (state == 2'b01); // Walking right when state is 01\nendmodule\n", "result": "failed: 152 out of 229 samples.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\t\n\tassign q = a & b; // Use the AND operator to implement the required functionality\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Calculate the AND gate results for p1y\n    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);\n    \n    // Calculate the AND gate results for p2y\n    assign p2y = (p2a & p2b) | (p2c & p2d);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n    reg [2:0] next_y;\n\n    always @(posedge clk) begin\n        // Update the state register on the rising edge of the clock\n        y <= next_y;\n    end\n\n    always @(*) begin\n        // Determine the next state based on the current state and input x\n        case(y)\n            3'b000: next_y = (x == 1'b0) ? 3'b000 : 3'b001;\n            3'b001: next_y = (x == 1'b0) ? 3'b001 : 3'b100;\n            3'b010: next_y = (x == 1'b0) ? 3'b010 : 3'b001;\n            3'b011: next_y = (x == 1'b0) ? 3'b001 : 3'b010;\n            3'b100: next_y = (x == 1'b0) ? 3'b011 : 3'b100;\n            default: next_y = 3'b000; // Default case to prevent latches\n        endcase\n        \n        // Determine the output z based on the current state\n        case(y)\n            3'b000: z = 1'b0;\n            3'b001: z = 1'b0;\n            3'b010: z = 1'b0;\n            3'b011: z = 1'b1;\n            3'b100: z = 1'b1;\n            default: z = 1'b0; // Default case to prevent latches\n        endcase\n        \n        // Extract Y0 from the state register\n        Y0 = y[0];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t\n\t// Implementing the NOR gate logic\n\tassign out = ~(in1 | in2); \n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\t\n\t// Assigning inputs to outputs as per the problem statement\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    // Process to handle positive edge triggering and asynchronous reset\n    always @(posedge clk) begin\n        if (ar)\n            q <= 1'b0;  // Asynchronous reset to 0\n        else\n            q <= d;     // Positive edge triggered assignment\n    end\nendmodule\n", "result": "failed: 17 out of 100 samples.", "passed": false}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase(sel)\n\t\t\t3'b000: out = data0;\n\t\t\t3'b001: out = data1;\n\t\t\t3'b010: out = data2;\n\t\t\t3'b011: out = data3;\n\t\t\t3'b100: out = data4;\n\t\t\t3'b101: out = data5;\n\t\t\tdefault: out = 4'b0; // For sel values 6 and 7\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load)\n            counter <= data;\n        else if (!counter)\n            tc <= 1'b1;\n        else\n            counter <= counter - 1;\n    end\n\n    assign tc = !counter; // This ensures tc is asserted as soon as counter hits zero\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n    // Define states\n    typedef enum logic [2:0] {\n        S0, S1, S2, S3, FOUND\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            S0: if (data) next_state = S1; else next_state = S0;\n            S1: if (data) next_state = S2; else next_state = S0;\n            S2: if (data) next_state = S3; else next_state = S0;\n            S3: if (data) next_state = S0; else next_state = FOUND;\n            FOUND: next_state = FOUND;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == FOUND)\n            start_shifting <= 1;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Set all outputs to 0 if reset is high\n        else\n            q <= d; // Otherwise, set the outputs to the current inputs\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    // Register to hold the previous value of in\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Store the current value of in into prev_in for the next clock cycle\n        prev_in <= in;\n        \n        // Detect rising edges (0 to 1 transitions)\n        reg [7:0] rising_edge_detected;\n        rising_edge_detected = (in & ~prev_in);\n        \n        // Assign the detected rising edges to anyedge for the next clock cycle\n        anyedge <= rising_edge_detected;\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the counter to 1 when reset is high\n            q <= 4'b0001;\n        end else begin\n            // Increment the counter from 1 to 10\n            if (q == 4'b1010) begin\n                // If the counter reaches 10, reset to 1\n                q <= 4'b0001;\n            end else begin\n                // Otherwise, increment the counter\n                q <= q + 1;\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    // Initialize q to 0\n    initial q = 0;\n\n    always @(posedge clk) begin\n        if (!a) begin\n            if (q == 7) begin\n                q <= 0;  // Reset q to 0 when it reaches 7\n            end else begin\n                q <= q + 1;  // Increment q by 1\n            end\n        end\n    end\nendmodule\n", "result": "failed: 222 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n\n// Initialize the state when reset is high\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset)\n        q <= 5'b00001; // Initialize to 1 (00001 in binary)\n    else\n    begin\n        // Compute the new state for the LFSR\n        // Tap positions are at bit 5 (most significant bit) and bit 3\n        // Perform XOR on the taps and shift left\n        q <= {q[4:1], q[4] ^ q[2]};\n    end\nend\n\nendmodule\n", "result": "failed: 4412 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b; // Addition\n            1: out = a - b; // Subtraction\n        endcase\n        \n        // Check if the result is zero\n        result_is_zero = (out == 8'b0);\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\t\n\t// Simplified terms based on Karnaugh map groups\n\tlogic term1, term2, term3;\n\n\tassign term1 = (x[3] & x[4]);\n\tassign term2 = (~x[3] & ~x[1]);\n\tassign term3 = (~x[3] & x[4] & x[1]);\n\n\t// Output f is true if any of the 1s group conditions are met, and false if any of the 0s group condition is met\n\tassign f = (term1 | term2) & (~term3);\n\nendmodule\n", "result": "failed: 25 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n    always @(*) begin\n        // Initialize outputs to default values\n        out = 4'b0;\n        valid = 1'b0;\n\n        // Check each scancode and set out and valid accordingly\n        case (code)\n            8'h45: begin out = 4'b0000; valid = 1'b1; end\n            8'h16: begin out = 4'b0001; valid = 1'b1; end\n            8'h1e: begin out = 4'b0010; valid = 1'b1; end\n            8'h26: begin out = 4'b0011; valid = 1'b1; end\n            8'h25: begin out = 4'b0100; valid = 1'b1; end\n            8'h2e: begin out = 4'b0101; valid = 1'b1; end\n            8'h36: begin out = 4'b0110; valid = 1'b1; end\n            8'h3d: begin out = 4'b0111; valid = 1'b1; end\n            8'h3e: begin out = 4'b1000; valid = 1'b1; end\n            8'h46: begin out = 4'b1001; valid = 1'b1; end\n            default: begin out = 4'b0; valid = 1'b0; end\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    always @(*) begin\n        out[0] = in[7];\n        out[1] = in[6];\n        out[2] = in[5];\n        out[3] = in[4];\n        out[4] = in[3];\n        out[5] = in[2];\n        out[6] = in[1];\n        out[7] = in[0];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tout = ~b | (c & d); // Simplified expression derived from the Karnaugh map\n\tend\n\nendmodule\n", "result": "failed: 63 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in data at MSB and shift the rest of the bits\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Decrement the current value\n            q <= q - 1;\n        end\n    end\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Assign the input 'in' directly to the output 'out'\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    \n    // Define the states\n    localparam IDLE = 2'b00;\n    localparam SHIFTING_1 = 2'b01;\n    localparam SHIFTING_2 = 2'b10;\n    localparam SHIFTING_3 = 2'b11;\n\n    // Current state and next state registers\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n    \n    // Output signal\n    wire shift_ena_signal;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(current_state)\n            IDLE: \n                if (reset)\n                    next_state = SHIFTING_1;\n                else\n                    next_state = IDLE;\n            SHIFTING_1: \n                next_state = SHIFTING_2;\n            SHIFTING_2: \n                next_state = SHIFTING_3;\n            SHIFTING_3: \n                next_state = IDLE;\n            default: \n                next_state = IDLE;\n        endcase\n    end\n    \n    // Output generation\n    assign shift_ena_signal = (current_state != IDLE);\n    assign shift_ena = shift_ena_signal;\n\nendmodule\n", "result": "failed: 10 out of 200 samples.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    // Detect rising edge of the clock\n    reg clk_d;\n    always @(posedge clk) begin\n        clk_d <= 1'b1; // On every positive edge of clk, set clk_d to 1\n    end\n    \n    // Synchronous reset logic\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0; // If reset is high, reset q to 0\n        end else if (clk_d) begin\n            q <= q + 1; // Otherwise, increment q by 1\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n    // Combinational logic using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n    \n    // Sequential logic using always block\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    // Compute the AND of a, b, and c\n    wire abc;\n    assign abc = a & b & c;\n\n    // Compute the NOT of the AND result\n    assign out = ~abc;\nendmodule\n", "result": "failed: 48 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    \n    // Define state register and next state signals\n    reg [1:0] state_reg;\n    reg [1:0] state_next;\n\n    // State encoding: A=00, B=01, C=10, D=11\n    localparam STATE_A = 2'b00;\n    localparam STATE_B = 2'b01;\n    localparam STATE_C = 2'b10;\n    localparam STATE_D = 2'b11;\n\n    // Determine the next state and outputs\n    always @(*) begin\n        case(state_reg)\n            STATE_A: begin\n                if (r[1]) state_next = STATE_B;\n                else if (r[2]) state_next = STATE_C;\n                else if (r[3]) state_next = STATE_D;\n                else state_next = STATE_A; // Stay in state A if no requests\n            end\n            STATE_B: begin\n                if (g[1] & r[1]) state_next = STATE_B;\n                else if (g[1] & ~r[1]) state_next = STATE_A;\n            end\n            STATE_C: begin\n                if (g[2] & r[2]) state_next = STATE_C;\n                else if (g[2] & ~r[2]) state_next = STATE_A;\n            end\n            STATE_D: begin\n                if (g[3] & r[3]) state_next = STATE_D;\n                else if (g[3] & ~r[3]) state_next = STATE_A;\n            end\n            default: state_next = STATE_A;\n        endcase\n        \n        // Output assignments based on current state\n        case(state_reg)\n            STATE_A: g = 3'b000;\n            STATE_B: g = 3'b100;\n            STATE_C: g = 3'b010;\n            STATE_D: g = 3'b001;\n            default: g = 3'b000;\n        endcase\n    end\n    \n    // Sequential logic to update state register on clock edge\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state_reg <= STATE_A; // Reset to state A\n        end else begin\n            state_reg <= state_next;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 4'b0; // Reset the counter to 0\n        end else begin\n            if (q == 4'b1001) begin // Check if q is 9 (binary 1001)\n                q <= 4'b0; // Reset to 0\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\nendmodule\n", "result": "failed: 185 out of 439 samples.", "passed": false}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [1:0] {\n        IDLE,\n        BYTE_1,\n        BYTE_2,\n        BYTE_3\n    } state_t;\n\n    state_t state, next_state;\n\n    // Register for state storage\n    always_ff @(posedge clk, posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            IDLE: \n                if (in[3])\n                    next_state = BYTE_1;\n                else\n                    next_state = IDLE;\n            BYTE_1: \n                next_state = BYTE_2;\n            BYTE_2: \n                next_state = BYTE_3;\n            BYTE_3: \n                next_state = IDLE;\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    // Output signal generation\n    assign done = (state == BYTE_3 && next_state == IDLE);\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    // Use a ternary operator to select between a and b based on sel\n    assign out = (sel == 1) ? b : a;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\tassign out_and = in[0] & in[1] & in[2] & in[3]; // 4-input AND gate\n\tassign out_or = in[0] | in[1] | in[2] | in[3]; // 4-input OR gate\n\tassign out_xor = ^in; // 4-input XOR gate using the reduction XOR operator\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // Define state variables\n    reg [2:0] current_state;\n    reg [2:0] next_state;\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            3'b000: if (x == 0) next_state = 3'b000; else next_state = 3'b001;\n            3'b001: if (x == 0) next_state = 3'b001; else next_state = 3'b100;\n            3'b010: if (x == 0) next_state = 3'b010; else next_state = 3'b001;\n            3'b011: if (x == 0) next_state = 3'b001; else next_state = 3'b010;\n            3'b100: if (x == 0) next_state = 3'b011; else next_state = 3'b100;\n            default: next_state = 3'b000; // Default case to prevent latches\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            3'b000: z = 0;\n            3'b001: z = 0;\n            3'b010: z = 0;\n            3'b011: z = 1;\n            3'b100: z = 1;\n            default: z = 0; // Default case to prevent latches\n        endcase\n    end\n\n    // State register update\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= 3'b000;\n        else\n            current_state <= next_state;\n    end\nendmodule\n", "result": "failed: 2 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    typedef enum logic [2:0] {\n        A, B, C, D, E, F\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            A: begin\n                if (!resetn) begin\n                    next_state = A;\n                end else begin\n                    next_state = B;\n                end\n            end\n            B: next_state = C;\n            C: begin\n                if (x == 1'b1 && {x, prev_x} == 3'b101) begin\n                    next_state = D;\n                end else begin\n                    next_state = C;\n                end\n            end\n            D: begin\n                if (y == 1'b1) begin\n                    next_state = E;\n                end else begin\n                    next_state = F;\n                end\n            end\n            E: next_state = E;\n            F: next_state = F;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            f <= 1'b0;\n            g <= 1'b0;\n            prev_x <= 1'b0;\n        end else begin\n            case (next_state)\n                B: f <= 1'b1;\n                default: f <= 1'b0;\n            endcase\n            case (current_state)\n                E: g <= 1'b1;\n                F: g <= 1'b0;\n                default: g <= 1'b0;\n            endcase\n            prev_x <= x;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge ~clk) begin\n        if (reset) begin\n            q <= 8'b00110100; // Reset value is 0x34\n        end else begin\n            q <= d; // Load data on non-reset condition\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Compute the XOR of all 8 input bits\n    assign parity = ^in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\t\n\t// Determine the next state based on the current state and input\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t2'b00: if (in == 0) next_state = 2'b00; else next_state = 2'b01;\n\t\t\t2'b01: if (in == 0) next_state = 2'b10; else next_state = 2'b01;\n\t\t\t2'b10: if (in == 0) next_state = 2'b00; else next_state = 2'b11;\n\t\t\t2'b11: if (in == 0) next_state = 2'b10; else next_state = 2'b01;\n\t\tendcase\n\tend\n\t\n\t// Determine the output based on the current state\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t2'b00: out = 1'b0;\n\t\t\t2'b01: out = 1'b0;\n\t\t\t2'b10: out = 1'b0;\n\t\t\t2'b11: out = 1'b1;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Assign z based on the logical AND of the negated inputs x and y\n    assign z = ~(x | y);\nendmodule\n", "result": "failed: 24 out of 110 samples.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {\n        A = 3'b00,\n        B = 3'b01,\n        C = 3'b10,\n        D = 3'b11,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n    \n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge reset)\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        unique case (current_state)\n            A: next_state = (w) ? B : A;\n            B: next_state = (w) ? C : D;\n            C: next_state = (w) ? E : D;\n            D: next_state = (w) ? F : A;\n            E: next_state = (w) ? E : D;\n            F: next_state = (w) ? C : D;\n            default: next_state = A; // In case of invalid state\n        endcase\n    end\n    \n    // Output definition\n    assign z = (current_state == E);\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\nalways @(posedge clk or negedge resetn)\nbegin\n\tif (!resetn)\n\t\tq <= 16'b0;\n\telse\n\tbegin\n\t\tcase (byteena)\n\t\t\t2'b00: q <= q; // No bytes are enabled\n\t\t\t2'b01: q <= {8'b0, d[7:0]}; // Only lower byte is enabled\n\t\t\t2'b10: q <= {d[15:8], 8'b0}; // Only upper byte is enabled\n\t\t\t2'b11: q <= d; // Both bytes are enabled\n\t\tendcase\n\tend\nend\n\nendmodule\n", "result": "failed: 167 out of 443 samples.", "passed": false}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Register to hold the previous value of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Update the previous value of 'in' in every clock cycle\n        prev_in <= in;\n        \n        // Detect positive edge transitions from 0 to 1 for each bit\n        // Set the corresponding bit in 'pedge' if there was a transition\n        pedge <= {in[0] & ~prev_in[0], in[1] & ~prev_in[1], \n                  in[2] & ~prev_in[2], in[3] & ~prev_in[3],\n                  in[4] & ~prev_in[4], in[5] & ~prev_in[5],\n                  in[6] & ~prev_in[6], in[7] & ~prev_in[7]};\n    end\nendmodule\n", "result": "failed: 164 out of 227 samples.", "passed": false}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\t\n\talways @(posedge clock) begin\n\t\tif (a == 1) begin\n\t\t\tp <= q;\n\t\t\tq <= p;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "failed: 235 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    // Initialize q to all zeros at the start\n    initial q = 0;\n\n    always @(posedge clk) begin\n        // Temporary variable to hold the new state\n        reg [511:0] next_q;\n        \n        // Compute the next state for each cell\n        for (int i = 0; i < 512; i = i + 1) begin\n            // Boundary conditions: q[-1] and q[512] are treated as 0\n            if (i == 0) begin\n                next_q[i] = ^{0, q[i], q[i+1]};\n            end else if (i == 511) begin\n                next_q[i] = ^{q[i-1], q[i], 0};\n            end else begin\n                next_q[i] = ^{q[i-1], q[i], q[i+1]};\n            end\n        end\n        \n        // Load the new state if load signal is high\n        if (load)\n            q <= next_q;\n        else\n            q <= q; // Hold the current state\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n\t// Compare each bit of A with the corresponding bit of B\n\tassign z = (A[0] == B[0]) & (A[1] == B[1]);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\tlogic [99:0] temp_out_both;\n\tlogic [99:0] temp_out_any;\n\tlogic [99:0] temp_out_different;\n\n\t// out_both calculation\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 0; i < 99; i++) begin : gen_out_both\n\t\t\tassign temp_out_both[i] = in[i] & in[i+1];\n\t\tend\n\tendgenerate\n\tassign out_both = temp_out_both[98:0];\n\n\t// out_any calculation\n\tgenerate\n\t\tfor (i = 0; i < 99; i++) begin : gen_out_any\n\t\t\tassign temp_out_any[i] = in[i] | in[i+1];\n\t\tend\n\tendgenerate\n\tassign out_any = temp_out_any[99:1];\n\n\t// out_different calculation\n\tgenerate\n\t\tfor (i = 0; i < 99; i++) begin : gen_out_different\n\t\t\tassign temp_out_different[i] = in[i] != in[i+1];\n\t\tend\n\tendgenerate\n\tassign temp_out_different[99] = in[99] != in[0]; // Wrap around for the last bit\n\tassign out_different = temp_out_different;\n\nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n\tlogic q_reg;\n\n\talways @(posedge ena) begin\n\t\tif (ena)\n\t\t\tq_reg <= d;\n\tend\n\n\tassign q = q_reg;\n\nendmodule\n", "result": "failed: 40 out of 100 samples.", "passed": false}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\t// Calculate the starting bit position for the selected 4-bit segment\n\twire [9:0] start_bit = {sel[7:2], 2'b0}; // Concatenate sel[7:2] with two zeros\n\n\t// Extract the 4-bit segment from the input vector\n\tassign out = in[start_bit + 3:start_bit];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n    always_comb begin\n        unique case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'b1; // Set to all '1's if sel is 9 to 15\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of a and b\n    assign out_not[5:3] = ~b;\n    assign out_not[2:0] = ~a;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\t\n\t// State transition logic\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001: // State A\n\t\t\t\tif (in == 0) next_state = 4'b0001; // Stay in A\n\t\t\t\telse next_state = 4'b0010; // Go to B\n\t\t\t4'b0010: // State B\n\t\t\t\tif (in == 0) next_state = 4'b0100; // Go to C\n\t\t\t\telse next_state = 4'b0010; // Stay in B\n\t\t\t4'b0100: // State C\n\t\t\t\tif (in == 0) next_state = 4'b0001; // Go to A\n\t\t\t\telse next_state = 4'b1000; // Go to D\n\t\t\t4'b1000: // State D\n\t\t\t\tif (in == 0) next_state = 4'b0100; // Go to C\n\t\t\t\telse next_state = 4'b0010; // Go to B\n\t\t\tdefault: next_state = 4'b0001; // Default to A\n\t\tendcase\n\tend\n\t\n\t// Output logic\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n    always @(*) begin\n        if (a < b) begin\n            if (a < c) begin\n                if (a < d)\n                    min = a;\n                else\n                    min = d;\n            end else if (c < d)\n                min = c;\n            else\n                min = d;\n        end else if (b < c) begin\n            if (b < d)\n                min = b;\n            else\n                min = d;\n        end else if (c < d)\n            min = c;\n        else\n            min = d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\tassign out_and = a & b; // AND operation\n\tassign out_or = a | b;  // OR operation\n\tassign out_xor = a ^ b; // XOR operation\n\tassign out_nand = ~(a & b); // NAND operation\n\tassign out_nor = ~(a | b);  // NOR operation\n\tassign out_xnor = ~(a ^ b); // XNOR operation, equivalent to a XNOR b\n\tassign out_anotb = a & ~b; // AND with NOT b\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\tassign out = c | d;\nendmodule\n", "result": "failed: 104 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define state variables\n    localparam [1:0] A = 2'b00;\n    localparam [1:0] B = 2'b01;\n    localparam [1:0] C = 2'b10;\n    localparam [1:0] D = 2'b11;\n\n    reg [1:0] current_state, next_state;\n    reg [1:0] w_count;  // Counts occurrences of w = 1 in the last three cycles\n    \n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: if (s) next_state = B; else next_state = A;\n            B: begin\n                w_count <= {w_count[0], w};  // Shift in new value of w and count\n                next_state = C;\n            end\n            C: begin\n                if (w_count == 2'b10)  // Check if w was 1 exactly twice in the last three cycles\n                    next_state = D;\n                else\n                    next_state = B;\n            end\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            z <= 1'b0;\n        else if (current_state == D)\n            z <= 1'b1;\n        else\n            z <= 1'b0;\n    end\n\nendmodule\n", "result": "failed: 174 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\t// Sign extend the 8-bit input to 32 bits\n\tassign out = {24{in[7]}, in};\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    \n    // Internal signals for intermediate outputs\n    wire d1, d2, d3;\n\n    // First D flip-flop\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d1 <= 0;\n        else\n            d1 <= in;\n    end\n\n    // Second D flip-flop\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d2 <= 0;\n        else\n            d2 <= d1;\n    end\n\n    // Third D flip-flop\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            d3 <= 0;\n        else\n            d3 <= d2;\n    end\n\n    // Fourth D flip-flop\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            out <= 0;\n        else\n            out <= d3;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n    always @(*) begin\n        // Initialize pos to 0\n        pos = 2'b00;\n        \n        // Check each bit in order of priority\n        if (in[3]) pos = 2'b10;  // Highest priority\n        else if (in[2]) pos = 2'b01;\n        else if (in[1]) pos = 2'b00;\n        else if (in[0]) pos = 2'b00;\n    end\nendmodule\n", "result": "failed: 63 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\t\n\tparameter OFF = 1'b0; // State 0\n\tparameter ON = 1'b1;  // State 1\n\t\n\treg state; // Current state register\n\t\n\t// Next state logic\n\talways @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset) // Asynchronous reset\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tcase(state)\n\t\t\t\tOFF: if(j) state <= ON; else state <= OFF;\n\t\t\t\tON:  if(k) state <= OFF; else state <= ON;\n\t\t\tendcase\n\tend\n\t\n\t// Output generation\n\tassign out = state;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\t// Directly assigning 0 to the output without any always block\n\tassign out = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\t// Directly assign a logic high to the output\n\tassign one = 1;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        for (integer i = 0; i < 100; i = i + 1) begin\n            out[99 - i] = in[i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Internal signal for the D input of the flip-flop\n    logic d;\n\n    // Assign the D input of the flip-flop to be the result of the XOR operation\n    assign d = in ^ out;\n\n    // Positive edge triggered D flip-flop\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tq <= 4'b0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= {1'b0, q[3:1]};\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\tassign f = (~x3 & x2) | (x3 & ~x2 & x1) | (x3 & x2);\nendmodule\n", "result": "failed: 2 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0; // Reset all outputs to 0 when areset is high\n        else\n            q <= d; // Update outputs with new data on the rising edge of clk\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    \n    // Initialize variables\n    reg xor_temp;\n    integer i;\n\n    // Calculate AND output\n    assign out_and = &in; // This is equivalent to multiplying all bits together\n\n    // Calculate OR output\n    assign out_or = |in; // This is equivalent to adding all bits together\n\n    // Calculate XOR output\n    assign xor_temp = in[0];\n    for (i = 1; i < 100; i = i + 1) begin\n        xor_temp = xor_temp ^ in[i];\n    end\n    assign out_xor = xor_temp;\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n    // Compute the sum using XOR gate\n    assign sum = a ^ b;\n    \n    // Compute the carry-out using AND gate\n    assign cout = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    always @(*) begin\n        // Set shut_off_computer when cpu_overheated\n        if (cpu_overheated) \n            shut_off_computer = 1;\n        else \n            shut_off_computer = 0;\n\n        // Set keep_driving based on arrived and gas_tank_empty\n        if (~arrived) \n            keep_driving = ~gas_tank_empty;\n        else \n            keep_driving = 0;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t// State definition\n\ttypedef enum logic [1:0] {OFF, ON} state_t;\n\tstate_t curr_state, next_state;\n\n\t// State register\n\talways_ff @(posedge clk or posedge reset)\n\t\tif (reset)\n\t\t\tcurr_state <= OFF; // Synchronous reset to OFF\n\t\telse\n\t\t\tcurr_state <= next_state;\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase (curr_state)\n\t\t\tOFF: if (j) next_state = ON; else next_state = OFF;\n\t\t\tON: if (k) next_state = OFF; else next_state = ON;\n\t\t\tdefault: next_state = OFF; // Default to OFF\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (curr_state == ON) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: 21 out of 241 samples.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\t\n\t// Step 1: Concatenate the inputs\n\twire [29:0] combined_input = {a, b, c, d, e, f};\n\t\n\t// Step 2: Append two 1's to the concatenated input\n\twire [31:0] full_output = {combined_input, 2'b11};\n\t\n\t// Step 3: Assign the 32-bit output to the four 8-bit outputs\n\tassign w = full_output[31:24];\n\tassign x = full_output[23:16];\n\tassign y = full_output[15:8];\n\tassign z = full_output[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // q is high if not (b & d & c) and not (d)\n    assign q = ~(b & d & c) & ~(d);\nendmodule\n", "result": "failed: 57 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\t// Assign the output to be the AND of the two inputs\n\tassign out = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t\n\t// Define states\n\tlocalparam B = 2'b00;\n\tlocalparam A = 2'b01;\n\n\t// Declare internal state register\n\treg [1:0] state_reg, state_next;\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate_reg <= B; // Reset to state B\n\t\telse\n\t\t\tstate_reg <= state_next; // Update state on rising edge of clock\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase(state_reg)\n\t\t\tB: state_next = (in == 0) ? A : B; // B -> A if in=0, else stay at B\n\t\t\tA: state_next = (in == 0) ? B : A; // A -> B if in=0, else stay at A\n\t\t\tdefault: state_next = B; // Default to B if in unknown state\n\t\tendcase\n\tend\n\n\t// Output logic based on current state\n\tassign out = (state_reg == B) ? 1'b1 : 1'b0; // Output 1 for state B, else 0\n\nendmodule\n", "result": "failed: 57 out of 230 samples.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // Compute the sum using XOR operation\n    assign sum = a ^ b ^ cin;\n\n    // Compute the carry-out using AND and OR operations\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n    // Step 2: Temporary variable for XNOR output\n    logic xnor_out;\n\n    // Step 3: Perform XNOR operation on in1 and in2\n    assign xnor_out = ~(in1 ^ in2);\n\n    // Step 4: Perform XOR operation between xnor_out and in3\n    assign out = xnor_out ^ in3;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    // Generate mux_in[1] and mux_in[0] using a 2-to-1 multiplexer\n    wire mux_out_1;\n    assign mux_out_1 = d ? 1'b1 : 1'b0;  // d ? 1 : 0\n\n    // Generate mux_in[2] and mux_in[3] using another 2-to-1 multiplexer\n    wire mux_out_2;\n    assign mux_out_2 = c ? 1'b1 : 1'b0;  // c ? 1 : 0\n\n    // Assign the outputs to mux_in\n    always @(*) begin\n        case({c, d})\n            2'b00: mux_in = 4'b0000;  // Output 0 when c = 0, d = 0\n            2'b01: mux_in = 4'b0111;  // Output 1 when c = 0, d = 1\n            2'b10: mux_in = 4'b1011;  // Output 1 when c = 1, d = 0\n            2'b11: mux_in = 4'b1110;  // Output 1 when c = 1, d = 1\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\t\n\t// Define the states using one-hot encoding\n\tlocalparam [1:0] STATE_A = 2'b01;\n\tlocalparam [1:0] STATE_B = 2'b10;\n\n\t// State register\n\treg [1:0] state;\n\t\n\t// Next state logic\n\talways @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tstate <= STATE_A; // Reset to State A\n\t\telse\n\t\t\tcase(state)\n\t\t\t\tSTATE_A: if (x) state <= STATE_B; // Transition to State B when x is 1\n\t\t\t\tSTATE_B: ; // Stay in State B\n\t\t\t\tdefault: state <= STATE_A; // Default to State A\n\t\t\tendcase\n\tend\n\t\n\t// Output logic\n\tassign z = (state == STATE_A && !x) || (state == STATE_B); // z is 1 in State B or when transitioning from State A to State B\n\nendmodule\n", "result": "failed: 226 out of 436 samples.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n    reg state_reg;\n\n    always @(posedge clk) begin\n        if (b == 1 && a == 0)\n            state_reg <= 0;\n        else if (b == 1 && a == 1)\n            state_reg <= ~state_reg;\n        else\n            state_reg <= state_reg;\n    end\n\n    assign state = state_reg;\n    assign q = state_reg;\n\nendmodule\n", "result": "failed: 26 out of 232 samples.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\tlogic x3_not, x4_not;\n\n\tassign x3_not = ~x[3];\n\tassign x4_not = ~x[4];\n\n\tassign f = (x3_not & x4_not) | (x[3] & x[4]);\nendmodule\n", "result": "failed: 42 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7, S8 = 8;\n    reg [2:0] state, next_state;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case(state)\n            S0: if (in == 1'b1) next_state = S1; else next_state = S0;\n            S1: if (in == 1'b1) next_state = S2; else next_state = S0;\n            S2: if (in == 1'b1) next_state = S3; else next_state = S0;\n            S3: if (in == 1'b1) next_state = S4; else next_state = S0;\n            S4: if (in == 1'b1) next_state = S5; else next_state = S0;\n            S5: if (in == 1'b1) next_state = S6; else next_state = S8;\n            S6: if (in == 1'b1) next_state = S7; else next_state = S0;\n            S7: next_state = S7;\n            S8: next_state = S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        disc <= 0;\n        flag <= 0;\n        err <= 0;\n        if (state == S8) begin\n            disc <= 1;\n            flag <= 1;\n        end else if (state == S7) begin\n            err <= 1;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n\t// State definitions\n\ttypedef enum {SEARCH, CAPTURE_DELAY, COUNT_DOWN, NOTIFY} state_t;\n\tstate_t state, next_state;\n\n\t// Registers for storing intermediate values\n\treg [3:0] delay; // Stores the captured delay\n\treg [11:0] counter; // Counter for the countdown\n\treg [3:0] temp_count; // Temporary register for count output\n\n\t// State transition logic\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tstate <= SEARCH;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase(state)\n\t\t\tSEARCH: begin\n\t\t\t\tif ({data, data, data, data} == 4'b1101) begin\n\t\t\t\t\tnext_state = CAPTURE_DELAY;\n\t\t\t\tend\n\t\t\tend\n\t\t\tCAPTURE_DELAY: begin\n\t\t\t\tif (counter == 0) begin\n\t\t\t\t\tnext_state = COUNT_DOWN;\n\t\t\t\tend\n\t\t\tend\n\t\t\tCOUNT_DOWN: begin\n\t\t\t\tif (counter == 0) begin\n\t\t\t\t\tnext_state = NOTIFY;\n\t\t\t\tend\n\t\t\tend\n\t\t\tNOTIFY: begin\n\t\t\t\tif (ack) begin\n\t\t\t\t\tnext_state = SEARCH;\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\n\n\t// Pattern detection and delay capture\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tdelay <= 4'b0;\n\t\t\tcounter <= 12'b0;\n\t\t\tcounting <= 0;\n\t\t\tdone <= 0;\n\t\t\ttemp_count <= 4'b0;\n\t\tend else begin\n\t\t\tcase(state)\n\t\t\t\tSEARCH: begin\n\t\t\t\t\t// No action needed here\n\t\t\t\tend\n\t\t\t\tCAPTURE_DELAY: begin\n\t\t\t\t\tif (counter == 0) begin\n\t\t\t\t\t\tdelay <= {delay[2:0], data};\n\t\t\t\t\t\tcounter <= 12'd1000;\n\t\t\t\t\t\tcounting <= 1;\n\t\t\t\t\t\tdone <= 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tcounter <= counter - 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tCOUNT_DOWN: begin\n\t\t\t\t\tif (counter == 0) begin\n\t\t\t\t\t\tif (temp_count == 4'b0)\n\t\t\t\t\t\t\tnext_state <= NOTIFY;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttemp_count <= temp_count - 1;\n\t\t\t\t\t\tcounter <= 12'd1000;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tcounter <= counter - 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tNOTIFY: begin\n\t\t\t\t\tdone <= 1;\n\t\t\t\t\tcounting <= 0;\n\t\t\t\t\tif (ack) begin\n\t\t\t\t\t\tdelay <= 4'b0;\n\t\t\t\t\t\ttemp_count <= 4'b0;\n\t\t\t\t\t\tcounter <= 12'b0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\n\t// Output assignment\n\tassign count = temp_count;\n\nendmodule\n", "result": "failed: 234318 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n    \n    // Define the state variables\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    // State encoding: 00 - Below s[1], 01 - Between s[2] and s[1], 10 - Between s[3] and s[2], 11 - Above s[3]\n    \n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= 2'b00; // Reset state\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(current_state)\n            2'b00: begin\n                if (s == 3'b000) begin\n                    next_state = 2'b00;\n                end else if (s == 3'b001) begin\n                    next_state = 2'b01;\n                end else begin\n                    next_state = 2'b00;\n                end\n            end\n            2'b01: begin\n                if (s == 3'b000) begin\n                    next_state = 2'b00;\n                end else if (s == 3'b010) begin\n                    next_state = 2'b10;\n                end else begin\n                    next_state = 2'b01;\n                end\n            end\n            2'b10: begin\n                if (s == 3'b000) begin\n                    next_state = 2'b00;\n                end else if (s == 3'b100) begin\n                    next_state = 2'b11;\n                end else begin\n                    next_state = 2'b01;\n                end\n            end\n            2'b11: begin\n                if (s == 3'b000) begin\n                    next_state = 2'b00;\n                end else if (s == 3'b100) begin\n                    next_state = 2'b10;\n                end else begin\n                    next_state = 2'b11;\n                end\n            end\n            default: next_state = 2'b00;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n        \n        case(current_state)\n            2'b00: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n            2'b01: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n            2'b10: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n            2'b11: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n        endcase\n        \n        // Check if the level has risen\n        if (current_state < next_state) begin\n            dfr = 1'b1;\n        end\n    end\n\nendmodule\n", "result": "failed: 1522 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {IDLE, RECEIVING, STOP_BIT, ERROR} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: \n                if (~in)\n                    next_state = RECEIVING;\n                else\n                    next_state = IDLE;\n            RECEIVING: \n                if (in)\n                    next_state = STOP_BIT;\n                else\n                    next_state = RECEIVING;\n            STOP_BIT: \n                if (in)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_BIT;\n            default: \n                next_state = ERROR;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            IDLE: done = 0;\n            STOP_BIT: done = 1;\n            default: done = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\ntypedef enum { IDLE, RECEIVING_DATA, CHECK_STOP_BIT } state_t;\nstate_t state, next_state;\n\n// Register to hold the current state\nalways @(posedge clk or posedge reset)\n\tif (reset)\n\t\tstate <= IDLE;\n\telse\n\t\tstate <= next_state;\n\n// Next state logic\nalways @(*) begin\n\tcase(state)\n\t\tIDLE: \n\t\t\tif (!in) \n\t\t\t\tnext_state = RECEIVING_DATA;\n\t\t\telse \n\t\t\t\tnext_state = IDLE;\n\t\tRECEIVING_DATA: \n\t\t\tif ($countones(out_byte) < 8) \n\t\t\t\tnext_state = RECEIVING_DATA;\n\t\t\telse \n\t\t\t\tnext_state = CHECK_STOP_BIT;\n\t\tCHECK_STOP_BIT: \n\t\t\tif (in) \n\t\t\t\tnext_state = IDLE;\n\t\t\telse \n\t\t\t\tnext_state = CHECK_STOP_BIT;\n\t\tdefault: next_state = IDLE;\n\tendcase\nend\n\n// Output logic\nalways @(posedge clk or posedge reset)\n\tif (reset)\n\t\tout_byte <= 8'b0;\n\telse if (state == RECEIVING_DATA && $countones(out_byte) < 8)\n\t\tout_byte <= {out_byte[6:0], in};\n\telse if (state == CHECK_STOP_BIT)\n\t\tdone <= in;\n\n// Done signal\nassign done = (state == IDLE && in);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    \n    // Global History Register\n    reg [6:0] global_history;\n    reg [6:0] new_global_history;\n\n    // Pattern History Table (128 entries, each 2 bits)\n    reg [1:0] pht_table [0:127];\n\n    // Predicted taken signal\n    wire [1:0] pht_entry;\n    wire predict_taken_wire;\n\n    // Index calculation\n    wire [6:0] index = predict_pc ^ global_history;\n\n    // Prediction logic\n    assign pht_entry = pht_table[index];\n    assign predict_taken_wire = (pht_entry[1] > pht_entry[0]);\n\n    // Assign outputs\n    assign predict_taken = predict_taken_wire;\n    assign predict_history = global_history;\n\n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (int i = 0; i < 128; i = i + 1) begin\n                pht_table[i] <= 2'b00;\n            end\n        end else begin\n            // Training takes precedence over prediction\n            if (train_valid) begin\n                // Recover the global history if there was a misprediction\n                if (train_mispredicted) begin\n                    new_global_history <= global_history ^ {train_pc[6], train_pc[5:1] & ~train_history[0]};\n                end else begin\n                    new_global_history <= global_history ^ {train_pc[6], train_pc[5:1] & train_history[0]};\n                end\n\n                // Update the PHT based on the actual outcome\n                if (train_taken) begin\n                    case (pht_table[train_pc ^ global_history])\n                        2'b00: pht_table[train_pc ^ global_history] <= 2'b01;\n                        2'b01: pht_table[train_pc ^ global_history] <= 2'b11;\n                        2'b10: pht_table[train_pc ^ global_history] <= 2'b11;\n                        2'b11: pht_table[train_pc ^ global_history] <= 2'b11;\n                    endcase\n                end else begin\n                    case (pht_table[train_pc ^ global_history])\n                        2'b00: pht_table[train_pc ^ global_history] <= 2'b00;\n                        2'b01: pht_table[train_pc ^ global_history] <= 2'b00;\n                        2'b10: pht_table[train_pc ^ global_history] <= 2'b01;\n                        2'b11: pht_table[train_pc ^ global_history] <= 2'b10;\n                    endcase\n                end\n            end\n\n            // Update the global history if there's no training in the same cycle\n            if (!train_valid || train_mispredicted) begin\n                global_history <= new_global_history;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 593 out of 1083 samples.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [3:0] {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALLING,\n        DIGGING,\n        SPLATTERED\n    } state_t;\n\n    state_t state, next_state;\n    logic [4:0] fall_timer;  // 5-bit timer to count up to 20 cycles\n\n    // State register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = state;\n        case(state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_RIGHT;\n                else if (!ground && !dig)\n                    next_state = FALLING;\n                else if (ground && dig)\n                    next_state = DIGGING;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else if (bump_left)\n                    next_state = WALK_LEFT;\n                else if (!ground && !dig)\n                    next_state = FALLING;\n                else if (ground && dig)\n                    next_state = DIGGING;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = WALK_LEFT;  // Resume walking left if previously walking left\n                else if (ground)\n                    next_state = WALK_RIGHT; // Resume walking right if previously walking right\n                else if (!ground && dig)\n                    next_state = DIGGING;\n                else if (fall_timer >= 20)\n                    next_state = SPLATTERED;\n            end\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (ground && !dig)\n                    next_state = WALK_LEFT;  // Resume walking left if previously walking left\n                else if (ground && !dig)\n                    next_state = WALK_RIGHT; // Resume walking right if previously walking right\n            end\n            SPLATTERED: begin\n                // Remain in splattered state indefinitely\n            end\n        endcase\n    end\n\n    // Fall timer logic\n    always_ff @(posedge clk) begin\n        if (areset || state == SPLATTERED)\n            fall_timer <= 0;\n        else if (state == FALLING)\n            fall_timer <= fall_timer + 1;\n        else\n            fall_timer <= 0;\n    end\n\n    // Output generation\n    always_comb begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case(state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALLING: begin\n                aaah = 1;\n            end\n            DIGGING: begin\n                digging = 1;\n            end\n            SPLATTERED: begin\n                // All outputs are 0 in this state\n            end\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\ntypedef enum logic [2:0] { SEARCH, SHIFT_IN, COUNTING, DONE } state_t;\n\nstate_t current_state, next_state;\n\n// State register\nalways_ff @(posedge clk or posedge reset)\nbegin\n    if (reset)\n        current_state <= SEARCH;\n    else\n        current_state <= next_state;\nend\n\n// Next state logic\nalways_comb\nbegin\n    case (current_state)\n        SEARCH: begin\n            if ({data, {3{data}}} == 4'b1101)\n                next_state = SHIFT_IN;\n            else\n                next_state = SEARCH;\n        end\n        SHIFT_IN: begin\n            if ($countones({data, {3{data}}}) == 4)\n                next_state = COUNTING;\n            else\n                next_state = SHIFT_IN;\n        end\n        COUNTING: begin\n            if (done_counting)\n                next_state = DONE;\n            else\n                next_state = COUNTING;\n        end\n        DONE: begin\n            if (ack)\n                next_state = SEARCH;\n            else\n                next_state = DONE;\n        end\n    endcase\nend\n\n// Output generation\nalways_comb\nbegin\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n\n    case (current_state)\n        SEARCH: ;\n        SHIFT_IN: shift_ena = 1'b1;\n        COUNTING: counting = 1'b1;\n        DONE: done = 1'b1;\n    endcase\nend\n\nendmodule\n", "result": "failed: 4152 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    // Local parameter for grid size\n    localparam GRID_SIZE = 16;\n\n    // Internal signal to store the next state of the grid\n    reg [255:0] next_state;\n\n    // Function to calculate the index of a cell in the grid\n    function integer get_index;\n        input [3:0] x, y;\n        begin\n            get_index = y * GRID_SIZE + x;\n        end\n    endfunction\n\n    // Function to get the value of a cell at coordinates (x,y)\n    function bit get_cell_value;\n        input [3:0] x, y;\n        begin\n            get_cell_value = q[get_index(x, y)];\n        end\n    endfunction\n\n    // Function to count alive neighbours of a cell at coordinates (x,y)\n    function integer count_alive_neighbours;\n        input [3:0] x, y;\n        integer count;\n        begin\n            count = 0;\n            // Check all 8 neighbours\n            for (integer dx = -1; dx <= 1; dx = dx + 1) begin\n                for (integer dy = -1; dy <= 1; dy = dy + 1) begin\n                    if (!(dx == 0 && dy == 0)) begin // Exclude the cell itself\n                        count = count + get_cell_value(x + dx, y + dy);\n                    end\n                end\n            end\n            count_alive_neighbours = count;\n        end\n    endfunction\n\n    // Determine the next state of each cell\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (integer i = 0; i < GRID_SIZE * GRID_SIZE; i = i + 1) begin\n                integer x, y, alive_neighbours;\n                x = i % GRID_SIZE;\n                y = i / GRID_SIZE;\n                alive_neighbours = count_alive_neighbours(x, y);\n\n                case (alive_neighbours)\n                    0, 1: next_state[i] = 0; // Cell dies due to underpopulation\n                    2: next_state[i] = q[i]; // Cell survives\n                    3: next_state[i] = 1;    // Cell becomes alive due to reproduction\n                    default: next_state[i] = 0; // Cell dies due to overpopulation\n                endcase\n            end\n            q <= next_state;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [2:0] { WALK_LEFT, WALK_RIGHT, FALL, DIG_LEFT, DIG_RIGHT } state_t;\n    \n    // Current state\n    state_t state, next_state;\n    \n    // Output signals\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL);\n    assign digging = (state == DIG_LEFT || state == DIG_RIGHT);\n    \n    // Next state logic\n    always_comb begin\n        case(state)\n            WALK_LEFT: begin\n                if (bump_left) next_state = WALK_RIGHT;\n                else if (!ground && !dig) next_state = FALL;\n                else if (dig && ground) next_state = DIG_LEFT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right) next_state = WALK_LEFT;\n                else if (!ground && !dig) next_state = FALL;\n                else if (dig && ground) next_state = DIG_RIGHT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground) next_state = (state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                else next_state = FALL;\n            end\n            DIG_LEFT: begin\n                if (!ground) next_state = FALL;\n                else next_state = DIG_LEFT;\n            end\n            DIG_RIGHT: begin\n                if (!ground) next_state = FALL;\n                else next_state = DIG_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Initial state\n        endcase\n    end\n    \n    // State register\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset) state <= WALK_LEFT;\n        else state <= next_state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n    // Initialize signals\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            hh <= 8'b0001_0000; // 12:00 AM in BCD (10h)\n            mm <= 8'b0000_0000; // 00 minutes in BCD (00m)\n            ss <= 8'b0000_0000; // 00 seconds in BCD (00s)\n            pm <= 1'b0;         // AM mode initially\n        end else begin\n            if (ena) begin\n                ss <= ss + 1; // Increment seconds\n                \n                // Roll over seconds to 00 after 59\n                if (ss == 8'd59) begin\n                    ss <= 8'b0000_0000;\n                    \n                    mm <= mm + 1; // Increment minutes\n                    \n                    // Roll over minutes to 00 after 59\n                    if (mm == 8'd59) begin\n                        mm <= 8'b0000_0000;\n                        \n                        hh <= hh + 1; // Increment hours\n                        \n                        // Roll over hours to 01 after 12\n                        if (hh == 8'd12) begin\n                            hh <= 8'b0001_0000; // Reset to 12 (01h in BCD)\n                            \n                            // Toggle AM/PM indicator\n                            pm <= ~pm;\n                        end\n                    end\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    \n    // Define state register\n    reg [1:0] state;\n    \n    // Output signals\n    assign walk_left = (state == 2'b00);\n    assign walk_right = (state == 2'b01);\n    assign aaah = (state == 2'b10);\n    \n    // State transition logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            state <= 2'b00; // Walking Left\n        else\n        begin\n            case(state)\n                2'b00: // Walking Left\n                    if (bump_left)\n                        state <= 2'b01; // Switch to Walking Right\n                    else if (!ground)\n                        state <= 2'b10; // Start Falling\n                2'b01: // Walking Right\n                    if (bump_right)\n                        state <= 2'b00; // Switch to Walking Left\n                    else if (!ground)\n                        state <= 2'b10; // Start Falling\n                2'b10: // Falling\n                    if (ground)\n                        state <= 2'b00 | 2'b01; // Recover based on previous direction\n                    else\n                        state <= 2'b10; // Continue Falling\n                2'b11: // Recovering\n                    if (ground)\n                        state <= 2'b00 | 2'b01; // Finalize recovery\n                    else\n                        state <= 2'b10; // Continue Falling\n                default: state <= 2'b00; // Default to Walking Left\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 40 out of 441 samples.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n\t// Internal signals for carry propagation\n\treg [3:0] carry;\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 16'b0; // Synchronous reset\n\t\telse begin\n\t\t\t// Calculate carry-out for each digit\n\t\t\tcarry[0] = (q[3:0] == 4'b1001); // Carry out from LSB\n\t\t\tcarry[1] = (q[7:4] == 4'b1001);\n\t\t\tcarry[2] = (q[11:8] == 4'b1001);\n\t\t\tcarry[3] = (q[15:12] == 4'b1001);\n\t\t\t\n\t\t\t// Increment digits based on carry-out\n\t\t\tq[3:0] <= q[3:0] + carry[0];\n\t\t\tq[7:4] <= q[7:4] + carry[1];\n\t\t\tq[11:8] <= q[11:8] + carry[2];\n\t\t\tq[15:12] <= q[15:12] + carry[3];\n\t\t\t\n\t\t\t// Adjust for BCD rollover\n\t\t\tif (carry[0]) q[3:0] <= 4'b0000;\n\t\t\tif (carry[1]) q[7:4] <= 4'b0000;\n\t\t\tif (carry[2]) q[11:8] <= 4'b0000;\n\t\t\tif (carry[3]) q[15:12] <= 4'b0000;\n\t\tend\n\tend\n\t\n\t// Assign enable signals\n\tassign ena[1] = carry[1]; // Tens place\n\tassign ena[2] = carry[2]; // Hundreds place\n\tassign ena[3] = carry[3]; // Thousands place\n\nendmodule\n", "result": "failed: 39778 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tif (sel == 1'b0) \n\t\t\tout <= a;\n\t\telse \n\t\t\tout <= b;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0; // State A\n        3'b001: Y2 = w; // State B\n        3'b010: Y2 = 1; // State C\n        3'b011: Y2 = !w; // State D\n        3'b100: Y2 = 1; // State E\n        3'b101: Y2 = 1; // State F\n        default: Y2 = 0;\n    endcase\nend\n\nendmodule\n", "result": "failed: 20 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n    // Assignments based on conditions\n    assign ringer = (ring && !vibrate_mode); // Ringer is active if ring is true and vibrate_mode is false\n    assign motor = (ring && vibrate_mode);   // Motor is active if ring is true and vibrate_mode is true\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\t// Using assign statement\n\tassign out_assign = a & b;\n\n\t// Using combinational always block\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\t// Assigning the output 'zero' to a constant low value\n\tassign zero = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n\t\n\treg state; // Internal state register\n\n\talways @(posedge clk) begin\n\t\tif (a == 0 && state == 0) begin\n\t\t\tq <= 1;\n\t\t\tstate <= 1;\n\t\tend else if (a == 1 && state == 1) begin\n\t\t\tq <= 0;\n\t\t\tstate <= 0;\n\t\tend\n\tend\n\t\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    parameter INITIAL = 2'b00;\n    parameter FLIP = 2'b01;\n\n    reg [1:0] state, next_state;\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= INITIAL;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            INITIAL: \n                if (x == 1'b1)\n                    next_state = FLIP;\n                else\n                    next_state = INITIAL;\n            FLIP: \n                next_state = FLIP;\n            default: \n                next_state = INITIAL;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == FLIP) ? ~x : x;\n\nendmodule\n", "result": "failed: 209 out of 436 samples.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 1'b0) ? A : B;\n            B: next_state = (in == 1'b0) ? C : B;\n            C: next_state = (in == 1'b0) ? A : D;\n            D: next_state = (in == 1'b0) ? C : B;\n            default: next_state = A; // In case of undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 1'b0;\n            B: out = 1'b0;\n            C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0; // In case of undefined states\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Extract each byte from the input\n    wire [7:0] byte0 = in[7:0];\n    wire [7:0] byte1 = in[15:8];\n    wire [7:0] byte2 = in[23:16];\n    wire [7:0] byte3 = in[31:24];\n\n    // Swap the positions of the bytes\n    assign out[7:0] = byte3; // byte3 moves to position 0-7\n    assign out[15:8] = byte2; // byte2 moves to position 8-15\n    assign out[23:16] = byte1; // byte1 moves to position 16-23\n    assign out[31:24] = byte0; // byte0 moves to position 24-31\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0;  // Active high reset sets q to 0\n        else\n            q <= d;     // Otherwise, q follows d\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Step 1: Compute the XOR of x and y\n    wire xor_result;\n    assign xor_result = x ^ y;\n\n    // Step 2: Compute the AND of the XOR result with x\n    assign z = xor_result & x;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data; // Load data into the register\n        end else if (ena) begin\n            case (amount)\n                2'b00: q <= {q[62:0], q[63]}; // Shift left by 1 bit\n                2'b01: q <= {q[55:0], 8'b0}; // Shift left by 8 bits\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1 bit\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 1316 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // Define the states\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n    localparam S3 = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;  // Asynchronous reset\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            S0: if (x == 1'b1) next_state = S1; else next_state = S0;\n            S1: if (x == 1'b0) next_state = S2; else next_state = S0;\n            S2: if (x == 1'b1) next_state = S3; else next_state = S0;\n            S3: next_state = S0;  // Once the sequence is recognized, go back to S0\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        if (state == S3) z = 1'b1;\n        else z = 1'b0;\n    end\nendmodule\n", "result": "failed: 66 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // Enumerate states\n    typedef enum {A, B, C, D, E, F} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    reg [2:0] state_reg;\n\n    // Output assignment\n    assign z = (current_state == E);\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state_reg <= 3'b000;  // Initial state A\n        else\n            state_reg <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state_reg)\n            3'b000: next_state = (w) ? A : B;  // A\n            3'b001: next_state = (w) ? D : C;  // B\n            3'b010: next_state = (w) ? D : E;  // C\n            3'b011: next_state = (w) ? A : F;  // D\n            3'b100: next_state = (w) ? D : E;  // E\n            3'b101: next_state = (w) ? C : D;  // F\n            default: next_state = A;           // Default to A if out of bounds\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\n    // State definition\n    typedef enum logic [2:0] {\n        IDLE,\n        BYTE1,\n        BYTE2,\n        DONE\n    } state_t;\n\n    // State register\n    reg [2:0] state_reg;\n    reg [2:0] state_next;\n\n    // Byte registers\n    reg [7:0] byte1_reg;\n    reg [7:0] byte2_reg;\n    reg [7:0] byte3_reg;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state_reg <= IDLE;\n        else\n            state_reg <= state_next;\n    end\n\n    // Next state logic\n    always @(*) begin\n        state_next = state_reg;\n        case (state_reg)\n            IDLE: begin\n                if (in[3])\n                    state_next = BYTE1;\n            end\n            BYTE1: begin\n                if (in[3])\n                    state_next = BYTE2;\n            end\n            BYTE2: begin\n                if (in[3])\n                    state_next = DONE;\n            end\n            DONE: begin\n                // Stay in DONE state\n            end\n        endcase\n    end\n\n    // Byte accumulation logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            byte1_reg <= 0;\n            byte2_reg <= 0;\n            byte3_reg <= 0;\n        end else begin\n            case (state_reg)\n                IDLE: begin\n                    if (in[3])\n                        byte1_reg <= in;\n                end\n                BYTE1: begin\n                    if (in[3])\n                        byte2_reg <= in;\n                end\n                BYTE2: begin\n                    if (in[3])\n                        byte3_reg <= in;\n                end\n                DONE: begin\n                    // No action needed here\n                end\n            endcase\n        end\n    end\n\n    // Output generation\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            done <= 0;\n            out_bytes <= 0;\n        end else begin\n            if (state_reg == DONE) begin\n                done <= 1;\n                out_bytes <= {byte3_reg, byte2_reg, byte1_reg};\n            end else begin\n                done <= 0;\n                out_bytes <= 0;  // Don't care\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n\t\n\t// Y1 is the input to the flip-flop for state B\n\tassign Y1 = y[0] & ~w; // Transition from A (y[0]) to B when w = 0\n\t\n\t// Y3 is the input to the flip-flop for state D\n\tassign Y3 = (y[1] | y[2] | y[5]) & ~w; // Transitions to D from B, C, or F when w = 0\n\nendmodule\n", "result": "failed: 107 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Directly assign the input vector to the output vector\n    assign outv = vec;\n\n    // Assign each bit of the input vector to the respective output bits\n    assign o0 = vec[0];\n    assign o1 = vec[1];\n    assign o2 = vec[2];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    // Calculate the simplified Boolean expression\n    always @(*) begin\n        if (!a && b || !c && d)\n            out = 1;\n        else\n            out = 0;\n    end\nendmodule\n", "result": "failed: 116 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n    // Assign the lower 8 bits to out_lo\n    assign out_lo = in[7:0];\n    \n    // Assign the upper 8 bits to out_hi\n    assign out_hi = in[15:8];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Implementing NOR gate logic\n    assign out = ~(a | b);  // This line performs the NOR operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n    // Assign statement implementation for out_assign\n    assign out_assign = a ^ b;\n\n    // Combinational always block implementation for out_always_comb\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n\n    // Clocked always block implementation for out_always_ff\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\tassign Y2 = y[1] & ~w; // Set to 1 if in state A and input is 0\n\tassign Y4 = (y[2] | y[3] | y[6]) & w | (y[5] & w); // Set to 1 if in state B, C, or F and input is 1, or in state E and input is 1\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\talways @(*) begin\n\t\tout = in[sel];\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n\t\n\t// Internal signal to hold the multiplexer output\n\treg next_Q;\n\n\t// Comb logic to determine the next state of Q\n\talways @(*) begin\n\t\tif (L)\n\t\t\tnext_Q = R; // Load mode\n\t\telse if (E)\n\t\t\tnext_Q = w; // Shift mode, assuming w is the input to the first stage\n\t\telse\n\t\t\tnext_Q = Q; // Hold mode\n\tend\n\n\t// Flip flop to register the next state on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\tQ <= next_Q;\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\t\n\t// Define internal wires\n\twire dff1_in, dff2_in, dff3_in;\n\twire q1, q2, q3;\n\n\t// D flip-flops\n\talways @(posedge clk) begin\n\t\tq1 <= dff1_in;\n\t\tq2 <= dff2_in;\n\t\tq3 <= dff3_in;\n\tend\n\t\n\t// Gates\n\tassign dff1_in = x ^ q1; // XOR gate\n\tassign dff2_in = x & (~q2); // AND gate with inverted q2\n\tassign dff3_in = x | (~q3); // OR gate with inverted q3\n\n\t// XNOR gate using XOR and NOT\n\tassign z = ~(q1 ^ q2 ^ q3); // Final output\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Step 1: Compute a OR b\n    wire or_ab = a | b;\n\n    // Step 2: Compute d AND (a OR b)\n    assign q = d & or_ab;\nendmodule\n", "result": "failed: 57 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            for (integer i = 0; i < 512; i++) begin\n                // Handle boundaries\n                if (i == 0) begin\n                    q[i] <= (q[i+1] & ~q[i+1] & ~q[i+1]) | (~q[i+1] & q[i+1] & ~q[i+1]) | (~q[i+1] & ~q[i+1] & q[i+1]) | (q[i+1] & q[i+1] & ~q[i+1]);\n                end\n                else if (i == 511) begin\n                    q[i] <= (q[i-1] & q[i-1] & ~q[i-1]) | (q[i-1] & ~q[i-1] & q[i-1]) | (~q[i-1] & q[i-1] & q[i-1]) | (~q[i-1] & ~q[i-1] & q[i-1]);\n                end\n                else begin\n                    q[i] <= (q[i-1] & q[i] & q[i+1]) | (q[i-1] & q[i] & ~q[i+1]) | (q[i-1] & ~q[i] & q[i+1]) | (~q[i-1] & q[i] & q[i+1]) | (~q[i-1] & ~q[i] & q[i+1]) | (q[i-1] & ~q[i] & ~q[i+1]) | (~q[i-1] & q[i] & ~q[i+1]) | (~q[i-1] & ~q[i] & ~q[i+1]);\n                end\n            end\n    end\n\nendmodule\n", "result": "failed: 6220 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    \n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // Combinational logic to determine the next state\n    always @(*) begin\n        case(state)\n            A: next_state = (in == 1) ? B : A;\n            B: next_state = (in == 1) ? B : C;\n            C: next_state = (in == 1) ? D : A;\n            D: next_state = (in == 1) ? B : C;\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // Combinational logic to determine the output based on the current state\n    always @(*) begin\n        case(state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default output\n        endcase\n    end\n\n    // Synchronous state update with active high reset\n    always @(posedge clk or posedge reset) begin\n        if(reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n    always @(*) begin\n        if (c == 4'b0) begin\n            q = b;\n        end else begin\n            q = e;\n        end\n    end\nendmodule\n", "result": "failed: 114 out of 141 samples.", "passed": false}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= q_in ^ L; // Simplified logic based on the original module's behavior\n        end\n    end\nendmodule\n\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n    // Instantiate the top_module for each bit of q\n    top_module top_module_0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[0]),\n        .Q(q[0])\n    );\n\n    top_module top_module_1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1]),\n        .r_in(r[1]),\n        .Q(q[1])\n    );\n\n    top_module top_module_2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(q[2])\n    );\nendmodule\n", "result": "failed: 1 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    // Register to store the previous value of 'in'\n    reg [31:0] prev_in;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            // Reset all registers to 0 when reset is asserted\n            prev_in <= 0;\n        else\n            // Store the current value of 'in' for comparison in the next cycle\n            prev_in <= in;\n    end\n\n    always @(posedge clk) begin\n        // Initialize out to 0 at the beginning of each clock cycle\n        out <= 0;\n\n        // Check for transitions from 1 to 0 for each bit\n        for (int i = 0; i < 32; i = i + 1) begin\n            if (prev_in[i] == 1 && in[i] == 0)\n                // If a transition from 1 to 0 is detected, set the corresponding bit in out\n                out[i] <= 1;\n        end\n    end\nendmodule\n", "result": "failed: 227 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    \n    // Add the inputs to get the sum\n    wire [8:0] sum = {1'b0, a} + {1'b0, b}; // Adding an extra bit to detect overflow\n    \n    // Assign the sum to s, excluding the carry-out bit\n    assign s = sum[7:0];\n    \n    // Detect overflow: \n    // Overflow occurs if the sign bit changes during addition\n    // Overflow condition: (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7])\n    assign overflow = (a[7] & b[7] & ~sum[8]) | (~a[7] & ~b[7] & sum[8]);\nendmodule\n", "result": "failed: 24 out of 116 samples.", "passed": false}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n// Next-state logic\nalways @(*) begin\n    B3_next = state[8];  // State B3\n    S_next = state[9] ? !d : state[9];  // State S\n    S1_next = state[8] ? d : state[8];  // State S1\n    Count_next = state[1] ? !done_counting : state[1];  // State Count\n    Wait_next = state[0] ? !ack : state[0];  // State Wait\nend\n\n// Output logic\nassign done = state[0];  // Output done\nassign counting = state[1];  // Output counting\nassign shift_ena = state[8] | state[7] | state[6] | state[5];  // Output shift_ena\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    // Internal signals for next state\n    logic [1:0] next_state;\n\n    // Combinational logic to compute the next state\n    always_comb begin\n        // Default case: keep the current state\n        next_state = state;\n\n        // Increment condition\n        if (train_valid && train_taken)\n            next_state = state + 1;\n        \n        // Decrement condition\n        else if (train_valid && !train_taken)\n            next_state = state - 1;\n\n        // Saturation conditions\n        if (next_state > 2'b11) // Maximum value is 3 (binary 11)\n            next_state = 2'b11;\n        else if (next_state < 2'b00) // Minimum value is 0 (binary 00)\n            next_state = 2'b00;\n    end\n\n    // Synchronous process for state register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b01; // Reset to weakly not-taken (2'b01)\n        else\n            state <= next_state;\n    end\nendmodule\n", "result": "failed: 807 out of 1051 samples.", "passed": false}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n\talways @(*) begin\n\t\t// Initialize pos to 0 assuming no '1' bit is found\n\t\tpos = 3'b0;\n\t\tfor (int i = 0; i < 8; i = i + 1) begin\n\t\t\tif (in[i]) begin\n\t\t\t\t// Found a '1' bit at position i, assign pos to i\n\t\t\t\tpos = i;\n\t\t\t\tbreak;\n\t\t\tend\n\t\t// If the loop completes without finding a '1', pos remains 0\n\t\tend\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n\t// Initialize all outputs to 0\n\tleft = 0;\n\tdown = 0;\n\tright = 0;\n\tup = 0;\n\n\t// Case statement to check the scancode\n\tcase (scancode)\n\t\t16'hE06B: left = 1; // Left arrow\n\t\t16'hE072: down = 1; // Down arrow\n\t\t16'hE074: right = 1; // Right arrow\n\t\t16'hE075: up = 1; // Up arrow\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    // Declare intermediate signals for carries\n    wire c1, c2, c3, c4;\n    \n    // Full Adder for least significant bit (LSB)\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    \n    // Full Adder for the second bit\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    \n    // Full Adder for the third bit\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    \n    // Full Adder for the most significant bit (MSB)\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    \n    // Assign the overflow bit as the carry out of the MSB\n    assign sum[4] = c4;\n\nendmodule\n\n// Define the full_adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output reg sum,\n    output reg cout\n);\n    always @(*) begin\n        sum = a ^ b ^ cin; // Sum bit calculation\n        cout = (a & b) | (cin & (a ^ b)); // Carry-out calculation\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n\nlogic [31:0] next_predict_history;\n\n// Asynchronous reset\nalways_ff @(posedge areset or posedge clk)\nbegin\n    if (areset)\n        predict_history <= 32'b0;\n    else\n        predict_history <= next_predict_history;\nend\n\n// Determine the next state of the shift register\nalways_comb\nbegin\n    // Initialize to current state\n    next_predict_history = predict_history;\n\n    // Handle misprediction\n    if (train_mispredicted)\n        next_predict_history = {train_history, train_taken};\n\n    // Handle prediction\n    else if (predict_valid)\n        next_predict_history = {predict_history[30:0], predict_taken};\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n\n\twire and_out_1, and_out_2;\n\n\t// First AND gate\n\tand(and_out_1, a, b);\n\n\t// Second AND gate\n\tand(and_out_2, c, d);\n\n\t// OR gate\n\tor(out, and_out_1, and_out_2);\n\n\t// NOT gate for inverted output\n\tnot(out_n, out);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    \n    // At the rising edge of the clock, set q to the value of d\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    \n    // Internal signals\n    reg [7:0] shift_register;\n\n    // Shift register logic\n    always @(posedge clk) begin\n        if (enable)\n            shift_register <= {S, shift_register[7:1]};\n    end\n\n    // Mux to select the output based on A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_register[0];\n            3'b001: Z = shift_register[1];\n            3'b010: Z = shift_register[2];\n            3'b011: Z = shift_register[3];\n            3'b100: Z = shift_register[4];\n            3'b101: Z = shift_register[5];\n            3'b110: Z = shift_register[6];\n            3'b111: Z = shift_register[7];\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n    \n    // Assign heater based on mode and too_cold\n    assign heater = (mode && too_cold) ? 1 : 0;\n\n    // Assign aircon based on mode and too_hot\n    assign aircon = (!mode && too_hot) ? 1 : 0;\n\n    // Fan should be on if either heater or aircon is on, or fan_on is explicitly set\n    assign fan = (heater || aircon || fan_on) ? 1 : 0;\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\t// Sum-of-Products (SOP) form\n\twire w1 = a & b & ~c & ~d; // 7\n\twire w2 = a & b & c & ~d;  // 15\n\twire w3 = ~a & b & ~c & d; // 2\n\tassign out_sop = w1 | w2 | w3;\n\n\t// Product-of-Sums (POS) form\n\twire w4 = ~(a | b | ~c | ~d); // 0\n\twire w5 = ~(~a | b | ~c | d); // 1\n\twire w6 = ~(a | ~b | c | d);  // 14\n\twire w7 = ~(~a | b | c | ~d); // 6\n\twire w8 = ~(a | b | ~c | d);  // 10\n\twire w9 = ~(~a | ~b | c | d); // 4\n\twire w10 = ~(~a | ~b | ~c | d); // 5\n\twire w11 = ~(a | ~b | ~c | d); // 9\n\twire w12 = ~(~a | ~b | ~c | d); // 13\n\tassign out_pos = w4 & w5 & w6 & w7 & w8 & w9 & w10 & w11 & w12;\nendmodule\n", "result": "failed: 50 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n\t// Initialize q to 32'h1 when reset is high\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\tbegin\n\t\t\t// Compute the new LSB by XORing the bits at tap positions\n\t\t\treg xor_result;\n\t\t\txor_result = q[31] ^ q[21] ^ q[1] ^ q[0];\n\t\t\t\n\t\t\t// Shift the bits to the right and insert the xor_result as the new LSB\n\t\t\tq <= {q[30:0], xor_result};\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Combinational logic to compute q based on the inputs a, b, c, and d\n    assign q = (a & b) | (a & c) | (a & d) | (b & c) | (b & d) | (c & d);\nendmodule\n", "result": "failed: 15 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    \n    // Implementing the first 4-input NAND gate for p1y\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    \n    // Implementing the second 4-input NAND gate for p2y\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    // Local wires to hold intermediate counts\n    wire [7:0] count_16;\n    wire [3:0] count_4;\n    wire [1:0] count_2;\n    wire count_1;\n\n    // Count the number of 1s in every 16 bits and sum them up\n    assign count_16 = {in[240:224], in[208:192], in[176:160], in[144:128], in[112:96], in[80:64], in[48:32], in[16:0]} == 16'b1 ? 8'd1 : 8'd0;\n    \n    // Sum up the counts\n    assign count_4 = count_16[7:4] + count_16[3:0];\n    assign count_2 = count_4[3:2] + count_4[1:0];\n    assign count_1 = count_2[1] + count_2[0];\n\n    // Final count\n    always @(*) begin\n        out = count_16[7] + count_16[6] + count_16[5] + count_16[4] + count_4[3] + count_4[2] + count_2[1] + count_1;\n    end\nendmodule\n", "result": "failed: 207 out of 215 samples.", "passed": false}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    // Calculate out_both\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Calculate out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Calculate out_different\n    assign out_different[3] = in[3] != in[0];\n    assign out_different[2] = in[2] != in[3];\n    assign out_different[1] = in[1] != in[2];\n    assign out_different[0] = in[0] != in[1];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'b0000010011001000; // 1232\n            3'b001: q = 16'b1010111011100000; // aee0\n            3'b010: q = 16'b0010011111010100; // 27d4\n            3'b011: q = 16'b0101101000001110; // 5a0e\n            3'b100: q = 16'b0010000001100110; // 2066\n            3'b101: q = 16'b0110010011001110; // 64ce\n            3'b110: q = 16'b1100010100100110; // c526\n            3'b111: q = 16'b0010111100011001; // 2f19\n            default: q = 16'b0; // In case a takes an unexpected value\n        endcase\n    end\nendmodule\n", "result": "failed: 10 out of 113 samples.", "passed": false}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 4'b0;\n\t\telse if (slowena)\n\t\t\tif (q < 4'b1001) // 9 in binary is 1001\n\t\t\t\tq <= q + 1;\n\t\t\telse\n\t\t\t\tq <= 4'b0;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\tlogic inv_in2;\n\n\t// Invert in2\n\tassign inv_in2 = ~in2;\n\n\t// Connect the inverted in2 and in1 to an AND gate\n\tassign out = in1 & inv_in2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Assign output to be equal to input\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // Define the states\n    typedef enum logic [1:0] {STATE_B = 2'b10, STATE_A = 2'b01} state_t;\n    \n    state_t current_state, next_state;\n\n    // Asynchronous reset\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        case(current_state)\n            STATE_B: \n                if (in == 1'b0)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            STATE_A: \n                if (in == 1'b0)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            default: next_state = STATE_B; // Default to B if undefined\n        endcase\n    end\n\n    // Output logic\n    assign out = (current_state == STATE_B) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n\n    // Output of the rising-edge triggered flip-flop\n    reg q_posedge;\n\n    // Output of the falling-edge triggered flip-flop\n    reg q_negedge;\n\n    // Rising-edge triggered flip-flop\n    always @(posedge clk) begin\n        q_posedge <= d;\n    end\n\n    // Falling-edge triggered flip-flop\n    always @(negedge clk) begin\n        q_negedge <= d;\n    end\n\n    // Combine the outputs\n    always @(*) begin\n        q = (clk) ? q_posedge : q_negedge;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tlogic and_result1;\n\tlogic and_result2;\n\t\n\t// Step 1: Implement the AND operation for A and B\n\tand_result1 <= a & b;\n\t\n\t// Step 2: Implement the AND operation for NOT A and NOT B\n\tand_result2 <= (~a) & (~b);\n\t\n\t// Step 3: Implement the OR operation for the results of the above two steps\n\tout <= and_result1 | and_result2;\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // Output of Module A\n    wire a_out;\n    // Output of Module B\n    wire b_out;\n\n    // Instantiate Module A\n    assign a_out = (x ^ y) & x;\n    \n    // Instantiate Module B\n    assign b_out = x & ~y;\n\n    // First pair connected to OR gate\n    wire or_out;\n    assign or_out = a_out | b_out;\n\n    // Second pair connected to AND gate\n    wire and_out;\n    assign and_out = a_out & b_out;\n\n    // Final XOR gate\n    assign z = or_out ^ and_out;\n\nendmodule\n", "result": "failed: 142 out of 200 samples.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\n    // Internal register to hold the current state of q\n    reg [99:0] temp;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data directly into the register\n            temp <= data;\n        end else if (ena == 2'b10) begin\n            // Left rotation\n            temp <= {temp[98:0], temp[99]};\n        end else if (ena == 2'b01) begin\n            // Right rotation\n            temp <= {temp[0], temp[99:1]};\n        end else begin\n            // No rotation\n            temp <= temp;\n        end\n    end\n\n    // Assign the internal register to the output\n    assign q = temp;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    // Synchronous reset logic\n    always @(posedge clk) begin\n        if (reset)\n            q <= 0;  // Reset the counter to 0 if reset is high\n        else if (q < 999)  // Increment the counter if it's less than 999\n            q <= q + 1;\n    end\nendmodule\n", "result": "failed: 2296 out of 8027 samples.", "passed": false}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Invert the input signal and assign it to the output\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            10'b0000000001: next_state = (in) ? 10'b0000000010 : 10'b0000000001; // S0\n            10'b0000000010: next_state = (in) ? 10'b0000000100 : 10'b0000000001; // S1\n            10'b0000000100: next_state = (in) ? 10'b0000001000 : 10'b0000000001; // S2\n            10'b0000001000: next_state = (in) ? 10'b0000010000 : 10'b0000000001; // S3\n            10'b0000010000: next_state = (in) ? 10'b0000100000 : 10'b0000000001; // S4\n            10'b0000100000: next_state = (in) ? 10'b0001000000 : 10'b0010000000; // S5\n            10'b0010000000: next_state = (in) ? 10'b0100000000 : 10'b0000000100; // S6\n            10'b0100000000: next_state = 10'b0000000000;                          // S7\n            10'b0001000000: next_state = (in) ? 10'b0000000010 : 10'b0000000000;  // S8\n            10'b0100000000: next_state = (in) ? 10'b0000000010 : 10'b0000000000;  // S9\n            default: next_state = 10'b0000000001;                                // Default to S0\n        endcase\n    end\n\n    // Output logic\n    assign out1 = state[8]; // out1 = 1 in S8\n    assign out2 = state[7]; // out2 = 1 in S7\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\t\n\t// Always block triggered by the positive edge of the clock\n\talways @(posedge clk) begin\n\t\tcase ({j, k})\n\t\t\t2'b00: // If J=0 and K=0, the output remains the same\n\t\t\t\tQ <= Q;\n\t\t\t2'b01: // If J=0 and K=1, the output becomes 0\n\t\t\t\tQ <= 1'b0;\n\t\t\t2'b10: // If J=1 and K=0, the output becomes 1\n\t\t\t\tQ <= 1'b1;\n\t\t\t2'b11: // If J=1 and K=1, the output toggles\n\t\t\t\tQ <= ~Q;\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\t// Define intermediate signals to count the '1's\n\twire and_out_0 = in[0]; // Directly map the first bit to the least significant bit of the output\n\twire and_out_1 = in[1] & ~in[0]; // Map the second bit to the second bit of the output if the first bit is not set\n\twire and_out_2 = in[2] & ~(in[1] & in[0]); // Map the third bit to the second bit of the output if neither of the first two bits are set\n\n\tassign out[0] = and_out_0 | and_out_1 | and_out_2; // Sum up all the bits mapped to the least significant bit of the output\n\tassign out[1] = in[1] & in[0] | in[2] & (in[1] | in[0]); // Sum up all the bits that contribute to the most significant bit of the output\n\nendmodule\n", "result": "failed: 92 out of 220 samples.", "passed": false}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    // Calculate all pairwise comparisons and store results in 'out'\n    always @(*) begin\n        out[24] = ~e ^ e;      // a vs a\n        out[23] = ~e ^ d;      // a vs b\n        out[22] = ~e ^ c;      // a vs c\n        out[21] = ~e ^ b;      // a vs d\n        out[20] = ~e ^ a;      // a vs e\n        \n        out[19] = ~d ^ e;      // b vs a\n        out[18] = ~d ^ d;      // b vs b\n        out[17] = ~d ^ c;      // b vs c\n        out[16] = ~d ^ b;      // b vs d\n        out[15] = ~d ^ a;      // b vs e\n        \n        out[14] = ~c ^ e;      // c vs a\n        out[13] = ~c ^ d;      // c vs b\n        out[12] = ~c ^ c;      // c vs c\n        out[11] = ~c ^ b;      // c vs d\n        out[10] = ~c ^ a;      // c vs e\n        \n        out[ 9] = ~b ^ e;      // d vs a\n        out[ 8] = ~b ^ d;      // d vs b\n        out[ 7] = ~b ^ c;      // d vs c\n        out[ 6] = ~b ^ b;      // d vs d\n        out[ 5] = ~b ^ a;      // d vs e\n        \n        out[ 4] = ~a ^ e;      // e vs a\n        out[ 3] = ~a ^ d;      // e vs b\n        out[ 2] = ~a ^ c;      // e vs c\n        out[ 1] = ~a ^ b;      // e vs d\n        out[ 0] = ~a ^ a;      // e vs e\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    // Define the state register\n    reg [1:0] state;\n\n    // Output assignment based on state\n    assign walk_left = ~state[1];\n    assign walk_right = state[1];\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b00; // Reset to walk_left state\n        else begin\n            case ({bump_left, bump_right})\n                2'b10: state <= 2'b01; // Bumped on the left, switch to right\n                2'b01: state <= 2'b00; // Bumped on the right, switch to left\n                2'b11: state <= 2'b00; // Bumped on both sides, switch to left (preference)\n                default: state <= state; // No change in state\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 120 out of 229 samples.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\tassign q = a & b; // Implementing the AND operation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    \n    // Define intermediate signals for AND gate outputs\n    wire and1;\n    wire and2;\n    wire and3;\n    wire and4;\n\n    // Implement AND gates\n    assign and1 = p1a & p1b & p1c;  // AND gate for p1a, p1b, p1c\n    assign and2 = p1d & p1e & p1f;  // AND gate for p1d, p1e, p1f\n    assign and3 = p2a & p2b;        // AND gate for p2a, p2b\n    assign and4 = p2c & p2d;        // AND gate for p2c, p2d\n\n    // Implement OR gates\n    assign p1y = and1 | and2;       // OR gate for and1 and and2\n    assign p2y = and3 | and4;       // OR gate for and3 and and4\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\t// Define the next state variables\n\treg [2:0] next_state;\n\n\t// Determine the next state based on the current state and input x\n\talways @(*) begin\n\t\tcase ({y, x})\n\t\t\t3'b000_0: next_state = 3'b000;\n\t\t\t3'b000_1: next_state = 3'b001;\n\t\t\t3'b001_0: next_state = 3'b001;\n\t\t\t3'b001_1: next_state = 3'b100;\n\t\t\t3'b010_0: next_state = 3'b001;\n\t\t\t3'b010_1: next_state = 3'b001;\n\t\t\t3'b011_0: next_state = 3'b001;\n\t\t\t3'b011_1: next_state = 3'b010;\n\t\t\t3'b100_0: next_state = 3'b011;\n\t\t\t3'b100_1: next_state = 3'b100;\n\t\t\tdefault: next_state = 3'b000;\n\t\tendcase\n\tend\n\n\t// Update the state on the rising edge of the clock\n\talways @(posedge clk) begin\n\t\ty <= next_state;\n\tend\n\n\t// Determine the output z based on the current state and input x\n\talways @(*) begin\n\t\tcase ({y, x})\n\t\t\t3'b001_1: z = 1;\n\t\t\t3'b011_0: z = 1;\n\t\t\t3'b100_0: z = 1;\n\t\t\t3'b100_1: z = 1;\n\t\t\tdefault: z = 0;\n\t\tendcase\n\tend\n\n\t// Assign Y0 as the least significant bit of the current state\n\tassign Y0 = y[0];\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t// Implementing the NOR gate using logical operations\n\tassign out = ~(in1 | in2); // NOR gate implementation\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n    // Connect 'a' to 'w'\n\tassign w = a;\n    \n    // Connect 'b' to 'x' and 'y'\n\tassign x = b;\n\tassign y = b;\n    \n    // Connect 'c' to 'z'\n\tassign z = c;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n\t\n\talways @(posedge clk or negedge ar) begin\n\t\tif (!ar)\n\t\t\tq <= 1'b0; // Asynchronous reset active-low\n\t\telse\n\t\t\tq <= d; // Capture input d on rising edge of clk\n\tend\n\t\nendmodule\n", "result": "failed: 20 out of 100 samples.", "passed": false}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'b000: out = data0;\n\t\t\t3'b001: out = data1;\n\t\t\t3'b010: out = data2;\n\t\t\t3'b011: out = data3;\n\t\t\t3'b100: out = data4;\n\t\t\t3'b101: out = data5;\n\t\t\tdefault: out = 4'b0; // For sel values 6 and 7\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] counter;\n\n    // At the rising edge of the clock\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the data value\n            counter <= data;\n            // Reset terminal count signal\n            tc <= 0;\n        end else begin\n            // Decrement the counter\n            if (counter > 0) begin\n                counter <= counter - 1;\n            end else begin\n                // Counter has reached 0, set tc to 1\n                tc <= 1;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\t\n\t// State declaration\n\ttypedef enum logic [2:0] { S0, S1, S2, S3, S4 } state_t;\n\tstate_t current_state, next_state;\n\n\t// State register\n\talways_ff @(posedge clk, posedge reset)\n\t\tif (reset)\n\t\t\tcurrent_state <= S0;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase(current_state)\n\t\t\tS0: if (data == 1'b1) next_state = S1; else next_state = S0;\n\t\t\tS1: if (data == 1'b1) next_state = S1; else next_state = S0;\n\t\t\tS2: if (data == 1'b0) next_state = S2; else next_state = S0;\n\t\t\tS3: if (data == 1'b1) next_state = S4; else next_state = S0;\n\t\t\tS4: next_state = S4;\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways_ff @(posedge clk, posedge reset)\n\t\tif (reset)\n\t\t\tstart_shifting <= 1'b0;\n\t\telse if (current_state == S4)\n\t\t\tstart_shifting <= 1'b1;\n\t\telse\n\t\t\tstart_shifting <= 1'b0;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Set all outputs to 0 when reset is high\n        else\n            q <= d; // Otherwise, load the data from 'd' into 'q'\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    // Register to store the previous state of the input\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Store the current input state in prev_in for the next clock cycle\n        prev_in <= in;\n        \n        // Check for rising edges on each bit and set the corresponding output bit\n        for (integer i = 0; i < 8; i = i + 1) begin\n            if (prev_in[i] == 0 && in[i] == 1)\n                anyedge[i] <= 1'b1;\n            else\n                anyedge[i] <= 1'b0;\n        end\n    end\nendmodule\n", "result": "failed: 187 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\t// Initialize the counter value\n\treg [3:0] count;\n\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tcount <= 4'b0001; // Reset the counter to 1\n\t\telse begin\n\t\t\tif (count == 4'b1010) // Check if the counter has reached 10 (binary for 10)\n\t\t\t\tcount <= 4'b0001; // Wrap back to 1\n\t\t\telse\n\t\t\t\tcount <= count + 1; // Increment the counter\n\t\tend\n\tend\n\n\tassign q = count; // Output the current count\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (!a) begin\n            if (q == 7) // Since q is 3 bits wide, max value is 7 (binary 111)\n                q <= 0;\n            else\n                q <= q + 1;\n        end\n    end\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    // Internal state of 6 bits, including the extra bit for tap position 5\n    reg [5:0] state;\n\n    // Assign the lower 5 bits of the state to the output q\n    always @* begin\n        q = state[4:0];\n    end\n\n    // Update the state on every rising edge of the clock\n    always @(posedge clk) begin\n        if (reset) begin\n            // Initialize the state to '1' followed by four '0's when reset is high\n            state <= 6'b10000;\n        end else begin\n            // Shift left and XOR the appropriate taps\n            state <= {state[4], state[4] ^ state[2], state[3:1]};\n        end\n    end\nendmodule\n", "result": "failed: 4290 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(*) begin\n        // Assign out based on the operation specified by do_sub\n        if (do_sub) begin\n            out = a - b;\n        end else begin\n            out = a + b;\n        end\n        \n        // Check if out is exactly zero to set the result_is_zero flag\n        result_is_zero = (out == 8'b0);\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // Implementing the derived Boolean expression\n    assign f = (x[4] & ~x[3] & x[2]) | (~x[2] & x[3] & x[1]);\nendmodule\n", "result": "failed: 19 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n\t// Initialize the outputs\n\talways @(*) begin\n\t\tout = 4'b0;\n\t\tvalid = 1'b0;\n\n\t\t// Compare the input with each scancode\n\t\tif (code == 8'h45) begin\n\t\t\tout = 4'd0;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h16) begin\n\t\t\tout = 4'd1;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h1e) begin\n\t\t\tout = 4'd2;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h26) begin\n\t\t\tout = 4'd3;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h25) begin\n\t\t\tout = 4'd4;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h2e) begin\n\t\t\tout = 4'd5;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h36) begin\n\t\t\tout = 4'd6;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h3d) begin\n\t\t\tout = 4'd7;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h3e) begin\n\t\t\tout = 4'd8;\n\t\t\tvalid = 1'b1;\n\t\tend else if (code == 8'h46) begin\n\t\t\tout = 4'd9;\n\t\t\tvalid = 1'b1;\n\t\tend\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tout[0] = in[7];\n\t\tout[1] = in[6];\n\t\tout[2] = in[5];\n\t\tout[3] = in[4];\n\t\tout[4] = in[3];\n\t\tout[5] = in[2];\n\t\tout[6] = in[1];\n\t\tout[7] = in[0];\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tout = ~a;\n\tend\n\nendmodule\n", "result": "failed: 168 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift the register right and insert data at the MSB\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Decrement the register value\n            q <= q - 1;\n        end\n    end\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\tassign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [1:0] {STATE_RESET = 2'b00, STATE_ENABLE = 2'b01, STATE_DISABLE = 2'b10} state_t;\n    state_t curr_state, next_state;\n    \n    // Counter to count up to 4 clock cycles\n    reg [3:0] counter;\n    \n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            curr_state <= STATE_RESET;\n        else\n            curr_state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        case (curr_state)\n            STATE_RESET: \n                if (reset)\n                    next_state = STATE_ENABLE;\n                else\n                    next_state = STATE_RESET;\n            STATE_ENABLE: \n                if (counter == 4'b100)\n                    next_state = STATE_DISABLE;\n                else\n                    next_state = STATE_ENABLE;\n            STATE_DISABLE: \n                next_state = STATE_DISABLE;\n            default: \n                next_state = STATE_RESET;\n        endcase\n    end\n    \n    // Counter increment\n    always_ff @(posedge clk) begin\n        if (curr_state == STATE_ENABLE && counter != 4'b100)\n            counter <= counter + 1;\n        else if (reset)\n            counter <= 4'b0000;\n    end\n    \n    // Output generation\n    assign shift_ena = (curr_state == STATE_ENABLE) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: 10 out of 200 samples.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0;\n        end else begin\n            if (q == 4'b1111) begin\n                q <= 4'b0;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n    // Combinational logic using assign statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Sequential logic using always block\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    // Simplified expression: out = a + (not a) * b\n    assign out = a | (~a & b);\nendmodule\n", "result": "failed: 22 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {A, B, C, D} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, negedge resetn) begin\n        if (!resetn) begin\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            A: begin\n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            end\n            B: begin\n                if (r[1]) next_state = B;\n                else next_state = A;\n            end\n            C: begin\n                if (r[2]) next_state = C;\n                else next_state = A;\n            end\n            D: next_state = A; // Since D is only entered if r3 is high and r1, r2 are low, no other conditions apply here.\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output generation\n    always_comb begin\n        g[1] = (current_state == B);\n        g[2] = (current_state == C);\n        g[3] = (current_state == D);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 4'b0000; // Reset the counter to 0 when reset is high\n\t\tend else begin\n\t\t\tif (q == 4'b1001) begin // Check if the counter has reached 9 (binary for 9 is 1001)\n\t\t\t\tq <= 4'b0000; // Reset the counter to 0\n\t\t\tend else begin\n\t\t\t\tq <= q + 1; // Increment the counter\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\n    // State definitions\n    typedef enum {IDLE, BYTE_1, BYTE_2, BYTE_3} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3])\n                    next_state = BYTE_1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE_1: next_state = BYTE_2;\n            BYTE_2: next_state = BYTE_3;\n            BYTE_3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            BYTE_3: done = 1;\n            default: done = 0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    // Output is a when sel is 0, otherwise it's b\n    assign out = (sel == 1'b0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\t\n\t// AND Operation\n\tassign out_and = in[0] & in[1] & in[2] & in[3];\n\t\n\t// OR Operation\n\tassign out_or = in[0] | in[1] | in[2] | in[3];\n\t\n\t// XOR Operation\n\tassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // Define state variables\n    reg [2:0] state;\n    reg [2:0] next_state;\n\n    // State transition logic\n    always @(state, x) begin\n        case(state)\n            3'b000: next_state = (x == 1'b0) ? 3'b000 : 3'b001;\n            3'b001: next_state = (x == 1'b0) ? 3'b001 : 3'b100;\n            3'b010: next_state = (x == 1'b0) ? 3'b001 : 3'b001;\n            3'b011: next_state = (x == 1'b0) ? 3'b001 : 3'b010;\n            3'b100: next_state = (x == 1'b0) ? 3'b011 : 3'b100;\n            default: next_state = 3'b000;\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case(state)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\n    // Synchronous state register\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 3'b000;\n        end else begin\n            state <= next_state;\n        end\n    end\nendmodule\n", "result": "failed: 78 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {A, B, C, D, E, F} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge resetn)\n        if (!resetn)\n            state <= A;  // Reset state\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: if (!resetn) next_state = A;\n               else next_state = B;\n            B: next_state = C;\n            C: if ((x == 1 && prev_x == 0 && prev_prev_x == 1)) next_state = D;\n               else next_state = C;\n            D: if (y == 1) next_state = E;\n               else next_state = F;\n            E: next_state = E;\n            F: next_state = F;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge resetn)\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end else begin\n            case(next_state)\n                B: f <= 1;\n                   g <= 0;\n                C: f <= 0;\n                   g <= 0;\n                D: f <= 0;\n                   g <= 0;\n                E: f <= 0;\n                   g <= 1;\n                F: f <= 0;\n                   g <= 0;\n                default: f <= 0;\n                         g <= 0;\n            endcase\n        end\n    \n    // Previous inputs\n    reg prev_x, prev_prev_x;\n    always @(posedge clk or negedge resetn)\n        if (!resetn) begin\n            prev_x <= 0;\n            prev_prev_x <= 0;\n        end else begin\n            prev_prev_x <= prev_x;\n            prev_x <= x;\n        end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    // Negative edge triggered D flip-flop with active high synchronous reset\n    always @(negedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the output to 0x34 when reset is high\n            q <= 8'b00110100; // Binary representation of 0x34\n        end else begin\n            // Update the output with the input data d on the negative edge of the clock\n            q <= d;\n        end\n    end\n    \nendmodule\n", "result": "failed: 46 out of 436 samples.", "passed": false}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Compute the parity bit by XORing all 8 input bits\n    assign parity = ^in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        // Determine next state based on current state and input\n        case ({state, in})\n            4'b000: next_state = 2'b00; // State A, in=0\n            4'b001: next_state = 2'b01; // State A, in=1\n            4'b010: next_state = 2'b10; // State B, in=0\n            4'b011: next_state = 2'b01; // State B, in=1\n            4'b100: next_state = 2'b00; // State C, in=0\n            4'b101: next_state = 2'b11; // State C, in=1\n            4'b110: next_state = 2'b10; // State D, in=0\n            4'b111: next_state = 2'b01; // State D, in=1\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case(state)\n            2'b00: out = 1'b0; // State A\n            2'b01: out = 1'b0; // State B\n            2'b10: out = 1'b0; // State C\n            2'b11: out = 1'b1; // State D\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = (x & y);\n\nendmodule\n", "result": "failed: 21 out of 110 samples.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\n    // State definitions\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11,\n        E = 2'b00,\n        F = 2'b01\n    } state_t;\n\n    // Current state and next state registers\n    state_t current_state, next_state;\n\n    // Output declaration\n    assign z = (current_state == C) | (current_state == E);\n\n    // State register always block\n    always_ff @(posedge clk, posedge reset) begin\n        if (reset) begin\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // State transition logic always block\n    always_comb begin\n        case (current_state)\n            A: if (w) next_state = B; else next_state = A;\n            B: if (w) next_state = C; else next_state = D;\n            C: if (w) next_state = E; else next_state = D;\n            D: if (w) next_state = F; else next_state = A;\n            E: if (w) next_state = E; else next_state = D;\n            default: next_state = A;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            // Reset all outputs to 0 when resetn is low\n            q <= 16'b0;\n        end else begin\n            // Update the flip-flops based on byteena signals\n            if (byteena[1]) begin\n                // Update the upper byte (bits 15:8)\n                q[15:8] <= d[15:8];\n            end\n            if (byteena[0]) begin\n                // Update the lower byte (bits 7:0)\n                q[7:0] <= d[7:0];\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 1 out of 443 samples.", "passed": false}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Register to hold the previous state of the input vector\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Update the previous state\n        prev_in <= in;\n        \n        // Detect positive edges and set the output accordingly\n        pedge <= {in[0] & ~prev_in[0], in[1] & ~prev_in[1], in[2] & ~prev_in[2], \n                  in[3] & ~prev_in[3], in[4] & ~prev_in[4], in[5] & ~prev_in[5],\n                  in[6] & ~prev_in[6], in[7] & ~prev_in[7]};\n    end\nendmodule\n", "result": "failed: 164 out of 227 samples.", "passed": false}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\t\n\talways @(posedge clock) begin\n\t\tif (a == 1 && q == 0)\n\t\t\tp <= 1;\n\t\telse if (a == 0 && q == 0)\n\t\t\tp <= 0;\n\t\tend\n\t\t\n\t\tif (p == 1)\n\t\t\tq <= ~q;\n\tend\n\t\n\talways @(negedge clock) begin\n\t\tif (a == 0 && q == 0)\n\t\t\tp <= 0;\n\t\tq <= 0;\n\tend\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    // Initialize the state when load is high\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n    end\n\n    // Advance the state every clock cycle\n    always @(posedge clk) begin\n        if (!load) begin\n            // Temporarily store the new values in a temporary register\n            reg [511:0] temp_q;\n\n            // Compute the next state for each cell\n            for (int i = 0; i < 512; i++) begin\n                // Boundary conditions: q[-1] and q[512] are always 0\n                temp_q[i] <= (i == 0) ? data[1] : // Special case for the first cell\n                             (i == 511) ? data[510] : // Special case for the last cell\n                             (q[i-1] ^ q[i+1]);\n            end\n\n            // Assign the computed values back to q\n            q <= temp_q;\n        end\n    end\nendmodule\n", "result": "failed: 7058 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\t// Compare each bit of A and B\n\tassign z = (A[0] == B[0]) & (A[1] == B[1]);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    // For out_both, we use AND between current bit and previous bit\n    assign out_both = {in[98:0], 1'b0} & {1'b0, in[99:1]};\n    \n    // For out_any, we use OR between current bit and next bit\n    assign out_any = {1'b0, in[99:1]} | {in[98:0], 1'b0};\n    \n    // For out_different, we use XOR between current bit and previous bit.\n    // Special case for in[99] which compares with in[0]\n    assign out_different = {in[0], in[99:1]} ^ {in[99:0], 1'b0};\nendmodule\n", "result": "failed: 201 out of 201 samples.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n    \n    // Always block triggered by the positive edge of ena\n    always @(posedge ena) begin\n        q <= d;  // Assign the value of d to q when ena goes high\n    end\n\nendmodule\n", "result": "failed: 40 out of 100 samples.", "passed": false}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the start index of the selected 4-bit segment\n    integer start_index;\n    assign start_index = sel * 4;\n\n    // Extract the 4-bit segment from the input vector\n    always @(*) begin\n        out = in[start_index + 3 : start_index];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n    always_comb begin\n        case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'b1;\n        endcase\n    end\nendmodule\n", "result": "failed: 101 out of 220 samples.", "passed": false}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\t// Compute bitwise OR of a and b\n\tassign out_or_bitwise = a | b;\n\t\n\t// Check if any bit in the result of bitwise OR is 1\n\tassign out_or_logical = |(a | b);\n\t\n\t// Compute NOT of a and b\n\tassign out_not[5:3] = ~b; // Inverse of b in the upper half\n\tassign out_not[2:0] = ~a; // Inverse of a in the lower half\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\tassign out = state[3]; // Output depends on state D\n\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001: begin // State A\n\t\t\t\tif (!in) next_state = 4'b0001; // Stay at A if in is 0\n\t\t\t\telse next_state = 4'b0010; // Go to B if in is 1\n\t\t\tend\n\t\t\t4'b0010: begin // State B\n\t\t\t\tif (!in) next_state = 4'b0100; // Go to C if in is 0\n\t\t\t\telse next_state = 4'b0010; // Stay at B if in is 1\n\t\t\tend\n\t\t\t4'b0100: begin // State C\n\t\t\t\tif (!in) next_state = 4'b0001; // Go to A if in is 0\n\t\t\t\telse next_state = 4'b1000; // Go to D if in is 1\n\t\t\tend\n\t\t\t4'b1000: begin // State D\n\t\t\t\tif (!in) next_state = 4'b0100; // Go to C if in is 0\n\t\t\t\telse next_state = 4'b0010; // Go to B if in is 1\n\t\t\tend\n\t\t\tdefault: next_state = 4'b0001; // Default to state A\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n\t// Step 1: Compare a and b, store the smaller one in min1\n\treg [7:0] min1;\n\talways @(*) begin\n\t\tif (a < b) \n\t\t\tmin1 = a;\n\t\telse \n\t\t\tmin1 = b;\n\tend\n\n\t// Step 2: Compare c and d, store the smaller one in min2\n\treg [7:0] min2;\n\talways @(*) begin\n\t\tif (c < d) \n\t\t\tmin2 = c;\n\t\telse \n\t\t\tmin2 = d;\n\tend\n\n\t// Step 3: Compare min1 and min2, assign the smaller one to min\n\talways @(*) begin\n\t\tif (min1 < min2) \n\t\t\tmin = min1;\n\t\telse \n\t\t\tmin = min2;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\t// Define intermediate signals for clarity\n\twire and_result;\n\twire or_result;\n\twire xor_result;\n\twire not_b;\n\n\t// Compute AND, OR, XOR operations\n\tand (and_result, a, b);\n\tor (or_result, a, b);\n\txor (xor_result, a, b);\n\n\t// Compute NOT of b\n\tnot (not_b, b);\n\n\t// Compute NAND, NOR, XNOR, ANOTB operations\n\tnand (out_nand, a, b);\n\tnor (out_nor, a, b);\n\txnor (out_xnor, a, b);\n\tand (out_and, a, b);\n\tor (out_or, a, b);\n\tand (out_anotb, a, not_b);\n\nendmodule\n", "result": "failed: 208 out of 210 samples.", "passed": false}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\tassign out = (~a & ~d) | (~c & ~d) | (a & d) | (b & d);\nendmodule\n", "result": "failed: 64 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {A, B1, B2, B3, Z} state_t;\n    state_t current_state, next_state;\n\n    // Internal signal to count the number of ones in w\n    reg [1:0] count_w;\n\n    // Initialize the state and count\n    always @(posedge clk or posedge reset)\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n\n    // Determine the next state\n    always @(*) begin\n        next_state = current_state;\n        case (current_state)\n            A: \n                if (s)\n                    next_state = B1;\n            B1: \n                next_state = B2;\n            B2: \n                next_state = B3;\n            B3: \n                next_state = Z;\n            Z: \n                next_state = B1;\n        endcase\n    end\n\n    // Update the count of w\n    always @(posedge clk or posedge reset)\n        if (reset)\n            count_w <= 0;\n        else if (current_state == Z)\n            count_w <= 0;\n        else if (current_state == B1 || current_state == B2 || current_state == B3)\n            if (w)\n                count_w <= count_w + 1;\n            else\n                count_w <= count_w;\n        \n    // Determine z based on the count\n    always @(posedge clk or posedge reset)\n        if (reset)\n            z <= 0;\n        else if (current_state == Z)\n            z <= (count_w == 2) ? 1 : 0;\n\nendmodule\n", "result": "failed: 571 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Sign extend the 8-bit input to 32 bits\n    assign out = {24{in[7]}, in};\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t\n\t// Internal signals to represent the states of each flip-flop\n\treg [3:0] shift_reg;\n\n\t// On the rising edge of the clock and when resetn is low, clear the shift register\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) // Active-low reset\n\t\t\tshift_reg <= 4'b0; // All bits set to 0\n\t\telse\n\t\t\tshift_reg <= {shift_reg[2:0], in}; // Shift right with new input\n\tend\n\n\t// Output is the last bit of the shift register\n\tassign out = shift_reg[3];\n\nendmodule\n", "result": "failed: 14 out of 299 samples.", "passed": false}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n    always @(*) begin\n        case (in)\n            4'b1xxx: pos = 2'b11;\n            4'b01xx: pos = 2'b10;\n            4'b001x: pos = 2'b01;\n            4'b0001: pos = 2'b00;\n            default: pos = 2'b00; // If none of the inputs are high, output zero.\n        endcase\n    end\nendmodule\n", "result": "failed: 38 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // State definition\n    localparam OFF = 0;\n    localparam ON = 1;\n\n    // Current state register\n    reg [1:0] state;\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            OFF: if (j) state <= ON; else state <= OFF;\n            ON: if (k) state <= OFF; else state <= ON;\n            default: state <= OFF;\n        endcase\n    end\n\n    // Asynchronous reset\n    always @(posedge areset or posedge clk) begin\n        if (areset) state <= OFF;\n        else state <= state;\n    end\n\n    // Output logic (Moore machine)\n    always @(*) begin\n        case(state)\n            OFF: out <= 0;\n            ON: out <= 1;\n            default: out <= 0;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\tassign out = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\tassign one = 1;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        // Reverse the bits of the input vector\n        for (integer i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    \n    // Intermediate signal to hold the output of the XOR gate\n    logic xor_out;\n    \n    // Compute the XOR of 'in' and 'out'\n    assign xor_out = in ^ out;\n    \n    // Positive edge-triggered D flip-flop\n    always_ff @(posedge clk) begin\n        out <= xor_out;  // Update 'out' on the rising edge of 'clk'\n    end\n    \nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n\t\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 4'b0; // Reset to 0\n\t\telse if (load)\n\t\t\tq <= data; // Load data\n\t\telse if (ena)\n\t\t\tq <= {1'b0, q[3:1]}; // Shift right\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\t\n\t// Calculate the intermediate signals\n\twire cond1 = x2 & (~x1); // This covers cases where x2 is 1 and x1 is 0\n\twire cond2 = x3 & x2;    // This covers cases where x3 is 1 and x2 is 1\n\t\n\t// Final output is the OR of the two conditions\n\tassign f = cond1 | cond2;\n\nendmodule\n", "result": "failed: 6 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;  // Set all outputs to 0 if areset is high\n        else\n            q <= d;     // Update outputs on positive edge of clk\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\tlogic and_temp = 1'b1;\n\tlogic or_temp = 1'b0;\n\tlogic xor_temp = 1'b0;\n\tinteger i;\n\tinteger count;\n\n\talways_comb begin\n\t\t// AND operation\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tand_temp = and_temp & in[i];\n\t\tend\n\t\tout_and = and_temp;\n\n\t\t// OR operation\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tor_temp = or_temp | in[i];\n\t\tend\n\t\tout_or = or_temp;\n\n\t\t// XOR operation\n\t\tcount = 0;\n\t\tfor (i = 0; i < 100; i = i + 1) begin\n\t\t\tif (in[i]) begin\n\t\t\t\tcount = count + 1;\n\t\t\tend\n\t\tend\n\t\tif (count % 2 == 1) begin\n\t\t\txor_temp = 1'b1;\n\t\tend else begin\n\t\t\txor_temp = 1'b0;\n\t\tend\n\t\tout_xor = xor_temp;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n    // Calculate the sum using XOR operation\n    assign sum = a ^ b;\n    \n    // Calculate the carry out using AND operation\n    assign cout = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    \n    // Combinational logic for shut_off_computer\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    // Combinational logic for keep_driving\n    always @(*) begin\n        if (arrived)\n            keep_driving = 0; // If arrived, stop driving regardless of gas tank status\n        else\n            keep_driving = ~gas_tank_empty; // Only drive if not arrived and gas tank is not empty\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t\n\tenum {OFF, ON} state, next_state;\n\t\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\t\tstate <= OFF;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*)\n\tbegin\n\t\tcase(state)\n\t\t\tOFF: begin\n\t\t\t\tnext_state = (j) ? ON : OFF;\n\t\t\t\tout = 0;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tnext_state = (k) ? OFF : ON;\n\t\t\t\tout = 1;\n\t\t\tend\n\t\t\tdefault: next_state = OFF;\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\t\n\t// Concatenate all inputs and add two 1 bits at the end\n\twire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\t\n\t// Assign the 8-bit segments to the outputs\n\tassign w = concatenated[31:24];\n\tassign x = concatenated[23:16];\n\tassign y = concatenated[15:8];\n\tassign z = concatenated[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Compute the logic expression\n    assign q = ~(a & b & c) ^ d;\nendmodule\n", "result": "failed: 43 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Assign the logical AND of inputs a and b to the output 'out'\n    assign out = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // Define the state variable\n    reg [1:0] state;\n\n    // Define the state transitions\n    always @(posedge clk) begin\n        if (reset)\n            state <= 2'b10; // State B represented as '10'\n        else\n            case (state)\n                2'b10: // State B\n                    if (in == 1'b0)\n                        state <= 2'b01; // Transition to State A\n                    else\n                        state <= 2'b10; // Stay in State B\n                2'b01: // State A\n                    if (in == 1'b0)\n                        state <= 2'b10; // Transition to State B\n                    else\n                        state <= 2'b01; // Stay in State A\n                default: state <= 2'b10; // Default to State B\n            endcase\n    end\n\n    // Output logic based on the current state\n    always @(*) begin\n        case (state)\n            2'b10: out = 1'b1; // Output is 1 when in State B\n            2'b01: out = 1'b0; // Output is 0 when in State A\n            default: out = 1'b1; // Default output is 1\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    \n    // Intermediate signals for the half adder\n    wire int_sum;\n    wire int_carry;\n\n    // Half adder logic for inputs a and b\n    assign int_sum = a ^ b;  // Initial sum of a and b\n    assign int_carry = a & b;  // Carry from a and b\n\n    // Final sum combining the initial sum with cin\n    assign sum = int_sum ^ cin;  // XOR operation between int_sum and cin\n\n    // Final carry-out combining the initial carry with cin\n    assign cout = int_carry | (int_sum & cin);  // OR operation between int_carry and the AND of int_sum and cin\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\tlogic xnor_out;\n\n\t// Calculate the output of the XNOR gate\n\txnor_out = ~(in1 ^ in2);\n\n\t// Connect the XNOR output and in3 to the XOR gate\n\tout = xnor_out ^ in3;\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n\twire d_not;\n\t\n\t// Using a 2-to-1 multiplexer to generate d_not\n\tmux2to1 d_mux (\n\t\t.a(d),\n\t\t.b(!d),\n\t\t.sel(c),\n\t\t.out(d_not)\n\t);\n\t\n\tassign mux_in[0] = d_not; // !d when c=0, d when c=1\n\tassign mux_in[1] = d;     // d when c=0, !d when c=1\n\tassign mux_in[2] = 1'b1;  // Constant 1\n\tassign mux_in[3] = 1'b1;  // Constant 1\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // One-hot encoding for states\n    localparam [1:0] STATE_A = 2'b01;\n    localparam [1:0] STATE_B = 2'b10;\n\n    reg [1:0] current_state, next_state;\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset)\n        if (areset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: \n                if (x == 1'b0)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            STATE_B: \n                next_state = STATE_B;\n            default: \n                next_state = STATE_A; // Safe default\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: \n                z = x; // z = 1 when x = 1, otherwise z = 0\n            STATE_B: \n                z = ~x; // z = 0 when x = 1, otherwise z = 1\n            default: \n                z = 1'b0; // Safe default\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n    reg q_reg;\n\n    always @(posedge clk) begin\n        if (a == 1)\n            q_reg <= 0;  // Reset q to 0 if a is high\n        else if (b == 1)\n            q_reg <= ~q_reg;  // Toggle q if b is high\n        else\n            q_reg <= q_reg;  // Keep q unchanged otherwise\n    end\n\n    assign q = q_reg;\n    assign state = 1'b0;  // State is not used in the logic, set to 0\n\nendmodule\n", "result": "failed: 138 out of 232 samples.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    // Define the function f based on the minterms identified from the K-map\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000, 4'b0010, 4'b1100, 4'b1101, 4'b1000, 4'b1001, 4'b1010: f = 1;\n            default: f = 0;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    \n    // Define states\n    typedef enum {S0, S1, S2, S3, S4, S5, S6, S7} state_t;\n    state_t state, next_state;\n\n    // Initialize state\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= S0;  // Reset to initial state\n        else\n            state <= next_state;\n    end\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            S0: next_state = (in == 1'b1) ? S1 : S0;\n            S1: next_state = (in == 1'b1) ? S2 : S0;\n            S2: next_state = (in == 1'b1) ? S3 : S0;\n            S3: next_state = (in == 1'b1) ? S4 : S0;\n            S4: next_state = (in == 1'b1) ? S5 : S0;\n            S5: next_state = (in == 1'b1) ? S6 : S0;\n            S6: next_state = (in == 1'b1) ? S7 : S0;\n            S7: next_state = S7;  // Stay in error state\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        disc <= (state == S5) && (in == 1'b0);\n        flag <= (state == S6) && (in == 1'b0);\n        err <= (state == S7);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State definition\n    typedef enum logic [3:0] { SEARCH, READ_DELAY, COUNT_DOWN, DONE } state_t;\n    state_t state, next_state;\n\n    // Variables\n    reg [3:0] delay;\n    reg [3:0] counter;\n    reg [3:0] bit_shift;\n    reg [3:0] bit_pattern = 4'b1101; // Pattern to detect\n    reg [3:0] mask = 4'b1110; // Mask to detect pattern\n\n    // State register\n    always_ff @(posedge clk or posedge reset)\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        case(state)\n            SEARCH: begin\n                if ((bit_pattern & mask) == bit_pattern)\n                    next_state = READ_DELAY;\n            end\n            READ_DELAY: begin\n                if (bit_shift == 4)\n                    next_state = COUNT_DOWN;\n                else\n                    next_state = READ_DELAY;\n            end\n            COUNT_DOWN: begin\n                if (counter == 0)\n                    next_state = DONE;\n                else\n                    next_state = COUNT_DOWN;\n            end\n            DONE: begin\n                if (ack)\n                    next_state = SEARCH;\n                else\n                    next_state = DONE;\n            end\n        endcase\n    end\n\n    // Bit shifting and delay loading\n    always_ff @(posedge clk)\n        if (state == SEARCH)\n            bit_pattern = {bit_pattern[2:0], data};\n        else if (state == READ_DELAY && bit_shift < 4)\n            delay = {delay[2:0], data};\n\n    // Counter initialization and decrement\n    always_ff @(posedge clk)\n        if (state == COUNT_DOWN)\n            counter <= counter - 1;\n\n    // Resetting delay and counter on reset\n    always_ff @(posedge clk or posedge reset)\n        if (reset || state == SEARCH)\n            counter <= delay + 1;\n        else if (state == COUNT_DOWN)\n            counter <= counter - 1;\n\n    // Output signals\n    assign count = delay - counter / 1000;\n    assign counting = (state == COUNT_DOWN);\n    assign done = (state == DONE);\n\nendmodule\n", "result": "failed: 234318 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\treg [1:0] current_state;\n\t\n\t// Define states\n\tlocalparam STATE_0 = 2'b00; // Below s[1]\n\tlocalparam STATE_1 = 2'b01; // Between s[1] and s[2]\n\tlocalparam STATE_2 = 2'b10; // Between s[2] and s[3]\n\tlocalparam STATE_3 = 2'b11; // Above s[3]\n\t\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= STATE_0;\n\t\t\tfr3 <= 1;\n\t\t\tfr2 <= 1;\n\t\t\tfr1 <= 1;\n\t\t\tdfr <= 1;\n\t\tend else begin\n\t\t\tcase (current_state)\n\t\t\t\tSTATE_0: begin\n\t\t\t\t\tif (s == 3'b001) begin\n\t\t\t\t\t\tcurrent_state <= STATE_1;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTATE_1: begin\n\t\t\t\t\tif (s == 3'b011) begin\n\t\t\t\t\t\tcurrent_state <= STATE_2;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse if (s == 3'b000) begin\n\t\t\t\t\t\tcurrent_state <= STATE_0;\n\t\t\t\t\t\tfr3 <= 1;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTATE_2: begin\n\t\t\t\t\tif (s == 3'b111) begin\n\t\t\t\t\t\tcurrent_state <= STATE_3;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 0;\n\t\t\t\t\t\tdfr <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse if (s == 3'b011) begin\n\t\t\t\t\t\tcurrent_state <= STATE_1;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tSTATE_3: begin\n\t\t\t\t\tif (s == 3'b111) begin\n\t\t\t\t\t\t// Stay in STATE_3\n\t\t\t\t\tend\n\t\t\t\t\telse if (s == 3'b011) begin\n\t\t\t\t\t\tcurrent_state <= STATE_2;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 0;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse if (s == 3'b001) begin\n\t\t\t\t\t\tcurrent_state <= STATE_1;\n\t\t\t\t\t\tfr3 <= 0;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\t\telse if (s == 3'b000) begin\n\t\t\t\t\t\tcurrent_state <= STATE_0;\n\t\t\t\t\t\tfr3 <= 1;\n\t\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\t\tdfr <= 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n", "result": "failed: 1389 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    parameter IDLE = 0;\n    parameter DATA_1 = 1;\n    parameter DATA_2 = 2;\n    parameter DATA_3 = 3;\n    parameter DATA_4 = 4;\n    parameter DATA_5 = 5;\n    parameter DATA_6 = 6;\n    parameter DATA_7 = 7;\n    parameter DATA_8 = 8;\n    parameter STOP = 9;\n\n    reg [3:0] state;\n    reg [2:0] data_cnt;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else begin\n            case(state)\n                IDLE: begin\n                    if (!in)\n                        state <= DATA_1;\n                end\n                DATA_1: begin\n                    state <= DATA_2;\n                end\n                DATA_2: begin\n                    state <= DATA_3;\n                end\n                DATA_3: begin\n                    state <= DATA_4;\n                end\n                DATA_4: begin\n                    state <= DATA_5;\n                end\n                DATA_5: begin\n                    state <= DATA_6;\n                end\n                DATA_6: begin\n                    state <= DATA_7;\n                end\n                DATA_7: begin\n                    state <= DATA_8;\n                end\n                DATA_8: begin\n                    state <= STOP;\n                end\n                STOP: begin\n                    if (in)\n                        state <= IDLE;\n                    else\n                        state <= STOP;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            data_cnt <= 0;\n            done <= 0;\n        end else begin\n            case(state)\n                IDLE: begin\n                    data_cnt <= 0;\n                    done <= 0;\n                end\n                DATA_8: begin\n                    done <= 1;\n                end\n                default: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    \n    // Define states\n    typedef enum {IDLE, DATA0, DATA1, DATA2, DATA3, DATA4, DATA5, DATA6, DATA7, STOP} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: if (!in) next_state = DATA0; else next_state = IDLE;\n            DATA0: next_state = DATA1;\n            DATA1: next_state = DATA2;\n            DATA2: next_state = DATA3;\n            DATA3: next_state = DATA4;\n            DATA4: next_state = DATA5;\n            DATA5: next_state = DATA6;\n            DATA6: next_state = DATA7;\n            DATA7: next_state = STOP;\n            STOP: if (in) next_state = IDLE; else next_state = STOP;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out_byte <= 8'b0;\n        else if (state == DATA0)\n            out_byte[0] <= in;\n        else if (state == DATA1)\n            out_byte[1] <= in;\n        else if (state == DATA2)\n            out_byte[2] <= in;\n        else if (state == DATA3)\n            out_byte[3] <= in;\n        else if (state == DATA4)\n            out_byte[4] <= in;\n        else if (state == DATA5)\n            out_byte[5] <= in;\n        else if (state == DATA6)\n            out_byte[6] <= in;\n        else if (state == DATA7)\n            out_byte[7] <= in;\n    end\n\n    // Done signal\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            done <= 1'b0;\n        else if (state == STOP && in)\n            done <= 1'b1;\n        else\n            done <= 1'b0;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    \n    // Global History Register\n    reg [6:0] global_history;\n\n    // Pattern History Table (PHT)\n    reg [1:0] pht_table [0:127];\n\n    // Initialize PHT\n    initial begin\n        for (integer i = 0; i < 128; i = i + 1) begin\n            pht_table[i] = 2'b00;\n        end\n    end\n\n    // Function to saturate the counter\n    function [1:0] saturate_counter;\n        input [1:0] count;\n        begin\n            if (count == 2'b11) begin\n                saturate_counter = 2'b11;\n            end else begin\n                saturate_counter = count + 1;\n            end\n        end\n    endfunction\n\n    // Function to update the PHT\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            for (integer i = 0; i < 128; i = i + 1) begin\n                pht_table[i] <= 2'b00;\n            end\n        end else begin\n            if (train_valid) begin\n                // Calculate the index for training\n                integer train_index = train_pc ^ train_history;\n                // Update the PHT based on the outcome\n                if (train_taken) begin\n                    pht_table[train_index] <= saturate_counter(pht_table[train_index]);\n                end else begin\n                    pht_table[train_index] <= saturate_counter({pht_table[train_index][0], 1'b0});\n                end\n                // Update global history if there is no misprediction\n                if (!train_mispredicted) begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n            end else if (predict_valid) begin\n                // Calculate the index for prediction\n                integer predict_index = predict_pc ^ global_history;\n                // Output the prediction\n                predict_taken <= pht_table[predict_index][1];\n                predict_history <= global_history;\n                // Update global history based on prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    // State definition\n    typedef enum logic [3:0] {WALK_LEFT, WALK_RIGHT, FALLING, DIGGING, SPLATTERED} state_t;\n    state_t curr_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            curr_state <= WALK_LEFT;\n        else\n            curr_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        next_state = curr_state;\n        case (curr_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else if (bump_right)\n                    next_state = WALK_RIGHT;\n                else if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n            end\n            WALK_RIGHT: begin\n                if (bump_left)\n                    next_state = WALK_LEFT;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (curr_state == WALK_LEFT)\n                        next_state = WALK_LEFT;\n                    else if (curr_state == WALK_RIGHT)\n                        next_state = WALK_RIGHT;\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end\n            end\n            SPLATTERED: begin\n                // No change in state\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        case (curr_state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING: aaah = 1;\n            DIGGING: digging = 1;\n        endcase\n    end\n\n    // Falling counter\n    reg [4:0] fall_count;\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            fall_count <= 0;\n        else if (fall_count < 20 && curr_state == FALLING && !ground)\n            fall_count <= fall_count + 1;\n        else if (ground)\n            fall_count <= 0;\n\n    // Splatter condition\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            curr_state <= WALK_LEFT;\n        else if (fall_count >= 20 && curr_state == FALLING && ground)\n            curr_state <= SPLATTERED;\n    endmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State definition\n    typedef enum { IDLE, PATTERN_FOUND, SHIFTING_DURATION, WAIT_FOR_COUNTS, NOTIFY_USER, WAIT_ACKNOWLEDGEMENT } state_t;\n    \n    // Register to hold the last four bits and the duration bits\n    reg [3:0] last_four_bits;\n    reg [3:0] duration_bits;\n\n    // Current state register\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: begin\n                if ({last_four_bits[2:0], data} == 4'b1101)\n                    next_state = PATTERN_FOUND;\n                else\n                    next_state = IDLE;\n            end\n            PATTERN_FOUND: begin\n                next_state = SHIFTING_DURATION;\n            end\n            SHIFTING_DURATION: begin\n                if (duration_bits == 4'b1111)\n                    next_state = WAIT_FOR_COUNTS;\n                else\n                    next_state = SHIFTING_DURATION;\n            end\n            WAIT_FOR_COUNTS: begin\n                if (done_counting)\n                    next_state = NOTIFY_USER;\n                else\n                    next_state = WAIT_FOR_COUNTS;\n            end\n            NOTIFY_USER: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = NOTIFY_USER;\n            end\n            WAIT_ACKNOWLEDGEMENT: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACKNOWLEDGEMENT;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            case(state)\n                IDLE: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                end\n                PATTERN_FOUND: begin\n                    shift_ena <= 1;\n                    counting <= 0;\n                    done <= 0;\n                end\n                SHIFTING_DURATION: begin\n                    shift_ena <= 1;\n                    counting <= 0;\n                    done <= 0;\n                end\n                WAIT_FOR_COUNTS: begin\n                    shift_ena <= 0;\n                    counting <= 1;\n                    done <= 0;\n                end\n                NOTIFY_USER: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 1;\n                end\n                WAIT_ACKNOWLEDGEMENT: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                end\n                default: begin\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Update last four bits and duration bits\n    always @(posedge clk) begin\n        if (!reset) begin\n            last_four_bits <= {last_four_bits[2:0], data};\n            if (state == SHIFTING_DURATION)\n                duration_bits <= {duration_bits[2:0], data};\n        end\n    end\n\nendmodule\n", "result": "failed: 2239 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n\n    // Function to calculate the index of the neighbor\n    function integer get_index;\n        input [7:0] x, y;\n        begin\n            get_index = y * 16 + x;\n        end\n    endfunction\n\n    // Calculate the new state of the grid\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else begin\n            reg [255:0] next_state;\n\n            // Iterate over each cell in the grid\n            for (integer y = 0; y < 16; y = y + 1) begin\n                for (integer x = 0; x < 16; x = x + 1) begin\n                    integer live_neighbors = 0;\n                    // Check all 8 neighbors\n                    for (integer dy = -1; dy <= 1; dy = dy + 1) begin\n                        for (integer dx = -1; dx <= 1; dx = dx + 1) begin\n                            if (dx == 0 && dy == 0)\n                                continue;\n                            integer nx = x + dx;\n                            integer ny = y + dy;\n                            if (nx < 0)\n                                nx = 15;\n                            else if (nx >= 16)\n                                nx = 0;\n                            if (ny < 0)\n                                ny = 15;\n                            else if (ny >= 16)\n                                ny = 0;\n                            live_neighbors = live_neighbors + q[get_index(nx, ny)];\n                        end\n                    end\n                    // Apply the game rules\n                    case (live_neighbors)\n                        0, 1: next_state[get_index(x, y)] = 0;\n                        2: next_state[get_index(x, y)] = q[get_index(x, y)];\n                        3: next_state[get_index(x, y)] = 1;\n                        default: next_state[get_index(x, y)] = 0;\n                    endcase\n                end\n            end\n            q <= next_state;\n        end\n    end\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    typedef enum logic [2:0] {WALK_LEFT, WALK_RIGHT, FALL, DIGGING} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            current_state <= WALK_LEFT;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            WALK_LEFT: begin\n                if (bump_left || bump_right)\n                    next_state = WALK_RIGHT;\n                else if (!ground)\n                    next_state = FALL;\n                else if (dig && ground)\n                    next_state = DIGGING;\n            end\n            WALK_RIGHT: begin\n                if (bump_right || bump_left)\n                    next_state = WALK_LEFT;\n                else if (!ground)\n                    next_state = FALL;\n                else if (dig && ground)\n                    next_state = DIGGING;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (current_state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n            end\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALL;\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = (current_state == WALK_LEFT);\n        walk_right = (current_state == WALK_RIGHT);\n        aaah = (current_state == FALL);\n        digging = (current_state == DIGGING);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n    // Internal signals for BCD conversion\n    reg [3:0] h1, h2;\n    reg [3:0] m1, m2;\n    reg [3:0] s1, s2;\n\n    // BCD to Binary conversion\n    always @(*) begin\n        hh = {h1, h2};\n        mm = {m1, m2};\n        ss = {s1, s2};\n    end\n\n    // Counter increment logic\n    always @(posedge clk) begin\n        if (reset) begin\n            h1 <= 1; h2 <= 0;\n            m1 <= 0; m2 <= 0;\n            s1 <= 0; s2 <= 0;\n            pm <= 0;\n        end else if (ena) begin\n            s2 <= s2 + 1;\n            if (s2 == 10'd10) begin\n                s2 <= 0;\n                s1 <= s1 + 1;\n                if (s1 == 10'd6) begin\n                    s1 <= 0;\n                    m2 <= m2 + 1;\n                    if (m2 == 10'd10) begin\n                        m2 <= 0;\n                        m1 <= m1 + 1;\n                        if (m1 == 10'd6) begin\n                            m1 <= 0;\n                            h2 <= h2 + 1;\n                            if (h2 == 10'd10) begin\n                                h2 <= 0;\n                                h1 <= h1 + 1;\n                                if (h1 == 10'd2) begin\n                                    h1 <= 1;\n                                    h2 <= 0;\n                                    pm <= ~pm;\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    \n    // State encoding\n    typedef enum logic [1:0] {WL, WR, F} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset) begin\n            current_state <= WL;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always_comb begin\n        unique case (current_state)\n            WL: begin\n                if (bump_left) next_state = WR;\n                else if (!ground) next_state = F;\n                else next_state = WL;\n            end\n            WR: begin\n                if (bump_right) next_state = WL;\n                else if (!ground) next_state = F;\n                else next_state = WR;\n            end\n            F: begin\n                if (ground) next_state = (current_state == WL) ? WL : WR;\n                else next_state = F;\n            end\n            default: next_state = WL; // Default state\n        endcase\n    end\n    \n    // Output logic\n    always_comb begin\n        walk_left = (current_state == WL);\n        walk_right = (current_state == WR);\n        aaah = (current_state == F);\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n    // Internal signals for individual digits\n    reg [3:0] digit_0;\n    reg [3:0] digit_1;\n    reg [3:0] digit_2;\n    reg [3:0] digit_3;\n\n    // Enable signals for upper three digits\n    assign ena = {digit_3[3], digit_2[3], digit_1[3]};\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            digit_0 <= 4'b0000;\n            digit_1 <= 4'b0000;\n            digit_2 <= 4'b0000;\n            digit_3 <= 4'b0000;\n        end else begin\n            // Increment the least significant digit\n            digit_0 <= digit_0 + 1;\n\n            // Handle BCD rollover for digit_0\n            if (digit_0 == 4'b1001) begin\n                digit_0 <= 4'b0000; // Roll over to 0\n                digit_1 <= digit_1 + 1;\n            end\n\n            // Handle BCD rollover for digit_1\n            if (digit_1 == 4'b1001) begin\n                digit_1 <= 4'b0000;\n                digit_2 <= digit_2 + 1;\n            end\n\n            // Handle BCD rollover for digit_2\n            if (digit_2 == 4'b1001) begin\n                digit_2 <= 4'b0000;\n                digit_3 <= digit_3 + 1;\n            end\n\n            // Handle BCD rollover for digit_3\n            if (digit_3 == 4'b1001) begin\n                digit_3 <= 4'b0000;\n            end\n        end\n    end\n\n    // Assign output q based on internal digits\n    always @* begin\n        q = {digit_3, digit_2, digit_1, digit_0};\n    end\nendmodule\n", "result": "failed: 39187 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n    // Generate block to instantiate 1-bit multiplexers for each bit of the output\n    genvar i;\n    generate\n        for (i = 0; i < 100; i = i + 1) begin : bit_selector\n            assign out[i] = sel ? b[i] : a[i];\n        end\n    endgenerate\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\n\talways @(*) begin\n\t\tcase(y)\n\t\t\t3'b000: Y2 = w; // State A\n\t\t\t3'b001: Y2 = ~w; // State B\n\t\t\t3'b010: Y2 = 1; // State C\n\t\t\t3'b011: Y2 = 1; // State D\n\t\t\t3'b100: Y2 = 0; // State E\n\t\t\t3'b101: Y2 = 1; // State F\n\t\t\tdefault: Y2 = 0;\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 30 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n\t\n\t// Assigning values to ringer and motor based on the input conditions\n\tassign ringer = ~vibrate_mode & ring; // Ringer is active when ring is true and vibrate_mode is false\n\tassign motor = vibrate_mode & ring;   // Motor is active when ring is true and vibrate_mode is true\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\t// Using assign statement for combinational logic\n\tassign out_assign = a & b;\n\n\t// Combinational always block\n\talways @(a or b) begin\n\t\tout_alwaysblock = a & b;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\tassign zero = 0; // Always assign a low value to the output\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    reg q_prev;\n\n    always @(posedge clk) begin\n        // On the first rising edge of the clock\n        if (!q_prev && !a) begin\n            q <= 1;\n        end else if (a) begin\n            q <= 0;\n        end\n        \n        // Update q_prev for the next clock cycle\n        q_prev <= q;\n    end\n\nendmodule\n", "result": "failed: 14 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\t\n\t// State definitions\n\ttypedef enum logic [1:0] {IDLE, COMPLEMENTING} state_t;\n\tstate_t state, next_state;\n\tlogic z_reg; // Register to hold the output bit\n\t\n\t// State register\n\talways_ff @(posedge clk or posedge areset)\n\t\tif (areset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\n\t// Next state logic\n\talways_comb begin\n\t\tnext_state = state;\n\t\tcase(state)\n\t\t\tIDLE: if (!areset)\n\t\t\t\t\tnext_state = COMPLEMENTING;\n\t\t\tCOMPLEMENTING: next_state = COMPLEMENTING; // Stay in COMPLEMENTING state\n\t\tendcase\n\tend\n\t\n\t// Output generation\n\talways_ff @(posedge clk)\n\t\tif (areset)\n\t\t\tz_reg <= 1'b0; // Reset output\n\t\telse begin\n\t\t\tcase(state)\n\t\t\t\tIDLE: z_reg <= 1'b0; // Do nothing in IDLE\n\t\t\t\tCOMPLEMENTING: begin\n\t\t\t\t\tif (state == IDLE) // Initial transition\n\t\t\t\t\t\tz_reg <= ~x; // Invert the first bit\n\t\t\t\t\telse if (z_reg == 1'b1) // Start inverting after encountering a '1'\n\t\t\t\t\t\tz_reg <= ~x;\n\t\t\t\t\telse\n\t\t\t\t\t\tz_reg <= x; // Pass through the bit\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\n\t// Assign the output\n\tassign z = z_reg;\n\nendmodule\n", "result": "failed: 186 out of 436 samples.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // Define state variables\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            2'b00: if (in == 1) next_state = 2'b01; else next_state = 2'b00;\n            2'b01: if (in == 1) next_state = 2'b01; else next_state = 2'b10;\n            2'b10: if (in == 1) next_state = 2'b11; else next_state = 2'b00;\n            2'b11: if (in == 1) next_state = 2'b01; else next_state = 2'b10;\n            default: next_state = 2'b00; // Should never happen\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            2'b00, 2'b01, 2'b10: out = 1'b0;\n            2'b11: out = 1'b1;\n            default: out = 1'b0; // Should never happen\n        endcase\n    end\n\n    // State register with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= 2'b00;\n        else\n            state <= next_state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\t// Assign the bytes in reversed order\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n    always_ff @(posedge clk) begin\n        if (r) begin\n            q <= 1'b0; // Active high reset sets q to 0\n        end else begin\n            q <= d; // Normal operation: q follows d\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // Compute the XOR of x and y\n    wire xor_result;\n    assign xor_result = x ^ y;\n\n    // Compute the AND of the XOR result and x\n    assign z = xor_result & x;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\nalways @(posedge clk)\nbegin\n\tif (load)\n\t\tq <= data;\n\telse if (ena)\n\tbegin\n\t\tcase (amount)\n\t\t\t2'b00: q <= {q[62:0], q[63]}; // Shift left by 1 bit\n\t\t\t2'b01: q <= {q[55:0], {8{q[63]}}}; // Shift left by 8 bits\n\t\t\t2'b10: q <= {{q[63]}, q[62:0]}; // Arithmetic shift right by 1 bit\n\t\t\t2'b11: q <= {{8{q[63]}}, q[55:0]}; // Arithmetic shift right by 8 bits\n\t\t\tdefault: q <= q; // No change\n\t\tendcase\n\tend\nend\n\nendmodule\n", "result": "failed: 3890 out of 4041 samples.", "passed": false}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // Define the states\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    // State register\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            S0: next_state = (x == 1'b1) ? S1 : S0;\n            S1: next_state = (x == 1'b0) ? S2 : S0;\n            S2: next_state = (x == 1'b1) ? S1 : S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2 && x == 1'b1) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "result": "failed: 18 out of 440 samples.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    // State definitions\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Output definition\n    assign z = (current_state == E) ? 1'b1 : 1'b0; // Output is 1 when in state E\n\n    // State register\n    always_ff @(posedge clk, posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        unique case (current_state)\n            A: next_state = (w == 1'b0) ? B : A;\n            B: next_state = (w == 1'b0) ? C : D;\n            C: next_state = (w == 1'b0) ? E : D;\n            D: next_state = (w == 1'b0) ? F : A;\n            E: next_state = (w == 1'b0) ? E : D;\n            F: next_state = (w == 1'b0) ? C : D;\n            default: next_state = A; // In case of undefined states\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\t\n\t// Define states\n\ttypedef enum {IDLE, BYTE_1, BYTE_2, DONE} state_t;\n\tstate_t state, next_state;\n\t\n\t// Register to store the current state\n\treg [7:0] byte_buffer [2:0];\n\t\n\t// State register\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\t\tstate <= IDLE;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\t\n\t// Next state logic\n\talways @(*)\n\tbegin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: if (in[3]) next_state = BYTE_1;\n\t\t\tBYTE_1: next_state = BYTE_2;\n\t\t\tBYTE_2: next_state = DONE;\n\t\t\tDONE: next_state = IDLE;\n\t\tendcase\n\tend\n\t\n\t// Byte buffer update\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t\tbyte_buffer[0] <= 8'b0;\n\t\t\tbyte_buffer[1] <= 8'b0;\n\t\t\tbyte_buffer[2] <= 8'b0;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tcase (state)\n\t\t\t\tBYTE_1: byte_buffer[0] <= in;\n\t\t\t\tBYTE_2: byte_buffer[1] <= in;\n\t\t\t\tDONE: byte_buffer[2] <= in;\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\t// Output generation\n\tassign out_bytes = {byte_buffer[2], byte_buffer[1], byte_buffer[0]};\n\tassign done = (state == DONE);\n\t\nendmodule\n", "result": "failed: 664 out of 1619 samples.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    assign Y1 = y[0] & w; // Y1 is 1 if current state is A and w is 1\n    assign Y3 = y[2] & ~w; // Y3 is 1 if current state is C and w is 0\nendmodule\n", "result": "failed: 124 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Assign the input vector to the output vector\n    assign outv = vec;\n    \n    // Split the input vector into individual bits\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n    always @(*) begin\n        // Calculate the output based on the simplified expression\n        out = ~(a) | (b & c);\n    end\nendmodule\n", "result": "failed: 125 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n\t// Assigning the lower 8 bits of the input to out_lo\n\tassign out_lo = in[7:0];\n\t\n\t// Assigning the higher 8 bits of the input to out_hi\n\tassign out_hi = in[15:8];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Implementing NOR gate using NOT and OR operations\n    assign out = ~(a | b); \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n    \n    // Using assign statement for out_assign\n    assign out_assign = a ^ b;\n    \n    // Combinational always block for out_always_comb\n    always @(*) begin\n        out_always_comb = a ^ b;\n    end\n    \n    // Clocked always block for out_always_ff\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;  // Update on the positive edge of the clock\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n\tassign Y2 = y[5] & ~w; // Next state E only when w is 0\n\tassign Y4 = y[3] | y[4]; // Next state D or F\nendmodule\n", "result": "failed: 388 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n    // Assign the selected bit from the input vector to the output\n    always @(*) begin\n        out = in[sel];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n    // Internal signal to select the input to the D flip-flop\n    reg d_in;\n\n    // Determine the input to the D flip-flop based on control signals\n    always @(posedge clk) begin\n        if (L)\n            d_in <= R; // Load R when L is asserted\n        else if (E)\n            d_in <= w; // Shift in w when E is asserted\n        else\n            d_in <= Q; // Keep the current value otherwise\n    end\n\n    // Update the output Q based on the input to the D flip-flop\n    always @(posedge clk) begin\n        Q <= d_in;\n    end\nendmodule\n", "result": "failed: 64 out of 200 samples.", "passed": false}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // Define internal signals for the states\n    reg q1;\n    reg q2;\n    reg q3;\n\n    // Calculate the next state inputs for each flip-flop\n    reg d1;\n    reg d2;\n    reg d3;\n\n    assign d1 = x ^ q1;  // XOR gate input calculation\n    assign d2 = x & ~q2; // AND gate input calculation\n    assign d3 = x | ~q3; // OR gate input calculation\n\n    // Clocking mechanism for the flip-flops\n    always @(posedge clk) begin\n        q1 <= d1;\n        q2 <= d2;\n        q3 <= d3;\n    end\n    \n    // Calculate the output z as the XNOR of the three flip-flop outputs\n    assign z = ~(q1 ^ q2 ^ q3);  // XNOR operation using De Morgan's laws\n\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\t// Connect q to the AND of b, c, and d\n\tassign q = b & c & d;\nendmodule\n", "result": "failed: 78 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    // At the rising edge of the clock, update the state\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the initial state from data\n            q <= data;\n        end else begin\n            // Compute the next state for each cell\n            for (integer i = 0; i < 512; i = i + 1) begin\n                // Treat boundaries as 0\n                integer left = (i == 0) ? 0 : q[i - 1];\n                integer right = (i == 511) ? 0 : q[i + 1];\n                // Determine the next state based on Rule 110\n                case ({left, q[i], right})\n                    3'b111: q[i] <= 0;\n                    3'b110: q[i] <= 1;\n                    3'b101: q[i] <= 1;\n                    3'b100: q[i] <= 0;\n                    3'b011: q[i] <= 1;\n                    3'b010: q[i] <= 1;\n                    3'b001: q[i] <= 1;\n                    3'b000: q[i] <= 0;\n                endcase\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case(current_state)\n            A: begin\n                if (in == 1'b0)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            B: begin\n                if (in == 1'b0)\n                    next_state = C;\n                else\n                    next_state = B;\n            end\n            C: begin\n                if (in == 1'b0)\n                    next_state = A;\n                else\n                    next_state = D;\n            end\n            D: begin\n                if (in == 1'b0)\n                    next_state = C;\n                else\n                    next_state = B;\n            end\n            default: next_state = A; // default case to avoid latches\n        endcase\n    end\n\n    always @(*) begin\n        case(current_state)\n            A: out = 1'b0;\n            B: out = 1'b0;\n            C: out = 1'b0;\n            D: out = 1'b1;\n            default: out = 1'b0; // default case to avoid latches\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n    always @(*) begin\n        case (c)\n            4'b0000: q = b;\n            4'b0001: q = e;\n            4'b0010: q = a;\n            4'b0011: q = d;\n            default: q = 4'b1111; // This represents 'f' in binary\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n    always @(*) begin\n        if (sel)\n            out <= b;\n        else\n            out <= a;\n    end\nendmodule\n", "result": "failed: 111 out of 114 samples.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    // Inside the top_module, implement the behavior described in the full_module\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;  // Load r_in into Q when L is high\n        end else begin\n            Q <= q_in ^ Q;  // Follow the specific logic operation\n        end\n    end\nendmodule\n\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n    // Instantiate the top_module three times for each bit of q\n    wire q0, q1, q2;\n\n    top_module top0 (.clk(clk), .L(L), .q_in(q[0]), .r_in(r[0]), .Q(q0));\n    top_module top1 (.clk(clk), .L(L), .q_in(q[1]), .r_in(r[1]), .Q(q1));\n    top_module top2 (.clk(clk), .L(L), .q_in(q[2]), .r_in(r[2]), .Q(q2));\n\n    // Assign the outputs of the instances to q\n    assign q = {q2, q1, q0};\nendmodule\n", "result": "failed: 49 out of 199 samples.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    // Register to hold the previous state of 'in'\n    reg [31:0] prev_in;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            prev_in <= 0; // Clear previous state on reset\n        else\n            prev_in <= in; // Update previous state with current 'in' value\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out <= 0; // Clear output on reset\n        else begin\n            // Detect transitions from 1 to 0 for each bit\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (prev_in[i] && !in[i])\n                    out[i] <= 1;\n            end\n        end\n    end\nendmodule\n", "result": "failed: 150 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n    // At every positive edge of the clock, set q to d\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire [7:0] cin; // Carry input for each bit, initialized to 0 except the first bit which is connected to the previous carry out\n    wire [7:0] cout; // Carry output for each bit\n\n    // Initialize carry input for the first bit as 0\n    assign cin = {1'b0, s[6:0]};\n\n    // Full adder for each bit\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : full_adder_gen\n            assign {cout[i], s[i]} = a[i] ^ b[i] ^ cin[i];\n            assign cin[i+1] = (a[i] & b[i]) | (cin[i] & (a[i] ^ b[i]));\n        end\n    endgenerate\n\n    // Detect overflow based on carry-in and carry-out of the MSB\n    assign overflow = (cout[7] != cin[7]);\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": " // OR of B0, B1, B2, B3 and Count\nassign counting = state[8];     // State Count\nassign done = state[9];         // State Wait\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    \n    // Asynchronous reset\n    always_ff @(posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Reset to weakly not-taken\n        end\n    end\n    \n    // Synchronized update of the counter\n    always_ff @(posedge clk) begin\n        if (!areset && train_valid) begin\n            case ({train_taken, train_valid})\n                2'b11: state <= (state == 2'b11) ? 2'b11 : state + 1;  // Increment up to max\n                2'b01: state <= (state == 2'b00) ? 2'b00 : state - 1;  // Decrement down to min\n                default: state <= state;  // Hold state during non-training periods\n            endcase\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @(*) begin\n        // Initialize output to 0\n        pos = 3'b0;\n        \n        // Check each bit from LSB to MSB\n        if (in[0]) pos = 3'b000; // Bit 0\n        else if (in[1]) pos = 3'b001; // Bit 1\n        else if (in[2]) pos = 3'b010; // Bit 2\n        else if (in[3]) pos = 3'b011; // Bit 3\n        else if (in[4]) pos = 3'b100; // Bit 4\n        else if (in[5]) pos = 3'b101; // Bit 5\n        else if (in[6]) pos = 3'b110; // Bit 6\n        else if (in[7]) pos = 3'b111; // Bit 7\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n    always @(*) begin\n        // Initialize outputs to default value (0)\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n\n        // Compare scancode with known values for arrow keys\n        case(scancode)\n            16'hE06B: left = 1; // Left arrow\n            16'hE072: down = 1; // Down arrow\n            16'hE074: right = 1; // Right arrow\n            16'hE075: up = 1; // Up arrow\n            default: ; // No action needed for other values, outputs remain 0\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    // Declare intermediate signals for carry-outs\n    wire c1, c2, c3;\n\n    // Full Adder for the least significant bit\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\n    \n    // Full Adder for the second bit\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    \n    // Full Adder for the third bit\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    \n    // Full Adder for the fourth bit\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n\n// Full Adder module definition\nmodule full_adder (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput reg sum,\n\toutput reg cout\n);\n    always @(*) begin\n        sum = a ^ b ^ cin;\n        cout = (a & b) | (cin & (a ^ b));\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    // Internal state register\n    logic [31:0] reg_history;\n\n    // Asynchronous reset\n    always_ff @(posedge areset or posedge clk)\n    begin\n        if (areset)\n            reg_history <= 32'b0;\n        else if (train_mispredicted)\n            reg_history <= {train_history, train_taken};\n        else if (predict_valid)\n            reg_history <= {reg_history[30:0], predict_taken};\n    end\n\n    // Output assignment\n    assign predict_history = reg_history;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n    // Intermediate wires for AND gates\n    wire and_out1;\n    wire and_out2;\n\n    // AND gate connections\n    assign and_out1 = a & b;  // First AND gate\n    assign and_out2 = c & d;  // Second AND gate\n\n    // OR gate connection\n    assign out = and_out1 | and_out2;\n\n    // Inverted output\n    assign out_n = ~out;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    \n    // On the rising edge of the clock, set q to the value of d\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    // Declare the 8-bit shift register\n    reg [7:0] Q;\n\n    // Shift register implementation\n    always @(posedge clk) begin\n        if (enable) begin\n            Q <= {S, Q[7:1]};\n        end\n    end\n\n    // Multiplexer logic to select Q[i] based on ABC\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = Q[0];\n            3'b001: Z = Q[1];\n            3'b010: Z = Q[2];\n            3'b011: Z = Q[3];\n            3'b100: Z = Q[4];\n            3'b101: Z = Q[5];\n            3'b110: Z = Q[6];\n            3'b111: Z = Q[7];\n        endcase\n    end\nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n    \n    // Heater control\n    assign heater = (mode && too_cold) ? 1 : 0;\n\n    // Air Conditioner control\n    assign aircon = (!mode && too_hot) ? 1 : 0;\n\n    // Fan control\n    // Fan should be on if heater or air conditioner is on, or if fan_on is set\n    assign fan = (heater || aircon || fan_on) ? 1 : 0;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\t\n\t// Sum of Products (SOP) form\n\twire sop_term_1 = (~a & ~b & c & d); // 2\n\twire sop_term_2 = (~a & b & c & d);   // 7\n\twire sop_term_3 = (a & b & c & d);    // 15\n\t\n\tassign out_sop = sop_term_1 | sop_term_2 | sop_term_3;\n\t\n\t// Product of Sums (POS) form\n\twire pos_term_1 = (a | b | c | d);           // 0\n\twire pos_term_2 = (a | b | c | ~d);          // 1\n\twire pos_term_3 = (a | ~b | c | d);          // 4\n\twire pos_term_4 = (a | ~b | c | ~d);         // 5\n\twire pos_term_5 = (a | ~b | ~c | d);         // 6\n\twire pos_term_6 = (~a | b | c | d);          // 9\n\twire pos_term_7 = (~a | b | c | ~d);         // 10\n\twire pos_term_8 = (~a | b | ~c | d);         // 13\n\twire pos_term_9 = (~a | b | ~c | ~d);        // 14\n\t\n\tassign out_pos = pos_term_1 & pos_term_2 & pos_term_3 & pos_term_4 & pos_term_5 & pos_term_6 & pos_term_7 & pos_term_8 & pos_term_9;\n\t\nendmodule\n", "result": "failed: 35 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n    // Initialize the LFSR to 32'h1 when reset is high\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            q <= 32'h1;\n        else\n        begin\n            // Calculate the new MSB (bit 31) as XOR of bit 31, bit 21, bit 1, and bit 0\n            q[31] <= q[30] ^ q[21] ^ q[1] ^ q[0];\n            // Shift the rest of the bits to the right\n            q[30:1] <= q[29:0];\n            // The LSB (bit 0) is set to 0 since it's not part of the XOR calculation\n            q[0] <= 1'b0; // Assuming the initial state has the lowest bit as 1, otherwise adjust accordingly\n        end\n    end\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Step 1: Compute the OR of b, c, and d\n    wire or_result;\n    assign or_result = b | c | d;\n\n    // Step 2: Determine the final output q\n    // If a is 0, q is or_result; otherwise, q is 1\n    assign q = ~a & or_result | a;\n\nendmodule\n", "result": "failed: 41 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Compute the NAND of the first set of inputs\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    \n    // Compute the NAND of the second set of inputs\n    assign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    \n    // Lookup table for counting 1's in an 8-bit input\n    localparam [7:0] lut[0:255] = {\n        8'b00000000, 8'b00000001, 8'b00000010, 8'b00000011, 8'b00000100, 8'b00000101, 8'b00000110, 8'b00000111,\n        8'b00001000, 8'b00001001, 8'b00001010, 8'b00001011, 8'b00001100, 8'b00001101, 8'b00001110, 8'b00001111,\n        8'b00010000, 8'b00010001, 8'b00010010, 8'b00010011, 8'b00010100, 8'b00010101, 8'b00010110, 8'b00010111,\n        8'b00011000, 8'b00011001, 8'b00011010, 8'b00011011, 8'b00011100, 8'b00011101, 8'b00011110, 8'b00011111,\n        8'b00100000, 8'b00100001, 8'b00100010, 8'b00100011, 8'b00100100, 8'b00100101, 8'b00100110, 8'b00100111,\n        8'b00101000, 8'b00101001, 8'b00101010, 8'b00101011, 8'b00101100, 8'b00101101, 8'b00101110, 8'b00101111,\n        8'b00110000, 8'b00110001, 8'b00110010, 8'b00110011, 8'b00110100, 8'b00110101, 8'b00110110, 8'b00110111,\n        8'b00111000, 8'b00111001, 8'b00111010, 8'b00111011, 8'b00111100, 8'b00111101, 8'b00111110, 8'b00111111,\n        8'b01000000, 8'b01000001, 8'b01000010, 8'b01000011, 8'b01000100, 8'b01000101, 8'b01000110, 8'b01000111,\n        8'b01001000, 8'b01001001, 8'b01001010, 8'b01001011, 8'b01001100, 8'b01001101, 8'b01001110, 8'b01001111,\n        8'b01010000, 8'b01010001, 8'b01010010, 8'b01010011, 8'b01010100, 8'b01010101, 8'b01010110, 8'b01010111,\n        8'b01011000, 8'b01011001, 8'b01011010, 8'b01011011, 8'b01011100, 8'b01011101, 8'b01011110, 8'b01011111,\n        8'b01100000, 8'b01100001, 8'b01100010, 8'b01100011, 8'b01100100, 8'b01100101, 8'b01100110, 8'b01100111,\n        8'b01101000, 8'b01101001, 8'b01101010, 8'b01101011, 8'b01101100, 8'b01101101, 8'b01101110, 8'b01101111,\n        8'b01110000, 8'b01110001, 8'b01110010, 8'b01110011, 8'b01110100, 8'b01110101, 8'b01110110, 8'b01110111,\n        8'b01111000, 8'b01111001, 8'b01111010, 8'b01111011, 8'b01111100, 8'b01111101, 8'b01111110, 8'b01111111,\n        8'b10000000, 8'b10000001, 8'b10000010, 8'b10000011, 8'b10000100, 8'b10000101, 8'b10000110, 8'b10000111,\n        8'b10001000, 8'b10001001, 8'b10001010, 8'b10001011, 8'b10001100, 8'b10001101, 8'b10001110, 8'b10001111,\n        8'b10010000, 8'b10010001, 8'b10010010, 8'b10010011, 8'b10010100, 8'b10010101, 8'b10010110, 8'b10010111,\n        8'b10011000, 8'b10011001, 8'b10011010, 8'b10011011, 8'b10011100, 8'b10011101, 8'b10011110, 8'b10011111,\n        8'b10100000, 8'b10100001, 8'b10100010, 8'b10100011, 8'b10100100, 8'b10100101, 8'b10100110, 8'b10100111,\n        8'b10101000, 8'b10101001, 8'b10101010, 8'b10101011, 8'b10101100, 8'b10101101, 8'b10101110, 8'b10101111,\n        8'b10110000, 8'b10110001, 8'b10110010, 8'b10110011, 8'b10110100, 8'b10110101, 8'b10110110, 8'b10110111,\n        8'b10111000, 8'b10111001, 8'b10111010, 8'b10111011, 8'b10111100, 8'b10111101, 8'b10111110, 8'b10111111,\n        8'b11000000, 8'b11000001, 8'b11000010, 8'b11000011, 8'b11000100, 8'b11000101, 8'b11000110, 8'b11000111,\n        8'b11001000, 8'b11001001, 8'b11001010, 8'b11001011, 8'b11001100, 8'b11001101, 8'b11001110, 8'b11001111,\n        8'b11010000, 8'b11010001, 8'b11010010, 8'b11010011, 8'b11010100, 8'b11010101, 8'b11010110, 8'b11010111,\n        8'b11011000, 8'b11011001, 8'b11011010, 8'b11011011, 8'b11011100, 8'b11011101, 8'b11011110, 8'b11011111,\n        8'b11100000, 8'b11100001, 8'b11100010, 8'b11100011, 8'b11100100, 8'b11100101, 8'b11100110, 8'b11100111,\n        8'b11101000, 8'b11101001, 8'b11101010, 8'b11101011, 8'b11101100, 8'b11101101, 8'b11101110, 8'b11101111,\n        8'b11110000, 8'b11110001, 8'b11110010, 8'b11110011, 8'b11110100, 8'b11110101, 8'b11110110, 8'b11110111,\n        8'b11111000, 8'b11111001, 8'b11111010, 8'b11111011, 8'b11111100, 8'b11111101, 8'b11111110, 8'b11111111\n    };\n\n    reg [7:0] byte_count[31:0];\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 31; i = i + 1) begin\n            byte_count[i] = lut[in[i*8 +: 8]];\n        end\n    end\n\n    assign out = byte_count[0] + byte_count[1] + byte_count[2] + byte_count[3] +\n                 byte_count[4] + byte_count[5] + byte_count[6] + byte_count[7] +\n                 byte_count[8] + byte_count[9] + byte_count[10] + byte_count[11] +\n                 byte_count[12] + byte_count[13] + byte_count[14] + byte_count[15] +\n                 byte_count[16] + byte_count[17] + byte_count[18] + byte_count[19] +\n                 byte_count[20] + byte_count[21] + byte_count[22] + byte_count[23] +\n                 byte_count[24] + byte_count[25] + byte_count[26] + byte_count[27] +\n                 byte_count[28] + byte_count[29] + byte_count[30];\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\t// Calculate out_both\n\tassign out_both = {in[3]&in[2], in[2]&in[1], in[1]&in[0]};\n\t\n\t// Calculate out_any\n\tassign out_any = {in[3]|in[0], in[2]|in[3], in[1]|in[2], in[0]|in[1]};\n\t\n\t// Calculate out_different\n\tassign out_different = {in[3]^in[0], in[0]^in[1], in[1]^in[2], in[2]^in[3]};\nendmodule\n", "result": "failed: 88 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\n    \n    always @(*) begin\n        case(a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'hAEE0;\n            3'b010: q = 16'h27D4;\n            3'b011: q = 16'h5A0E;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64CE;\n            3'b110: q = 16'hC526;\n            3'b111: q = 16'h2F19;\n            default: q = 16'hXXXX; // Optional: handle invalid inputs\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    // State variable to hold the current count\n    reg [3:0] count;\n\n    // Always block to handle clock edges and reset\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the counter to 0 if reset is high\n            count <= 4'b0;\n        end else begin\n            // Normal operation: check if slowena is high to increment\n            if (slowena) begin\n                // Increment the counter\n                count <= count + 1;\n                // Check if we have reached 9\n                if (count == 4'b1001) begin\n                    // Wrap around to 0\n                    count <= 4'b0;\n                end\n            end\n        end\n    end\n    \n    // Assign the current count to the output q\n    assign q = count;\nendmodule\n", "result": "failed: 112 out of 499 samples.", "passed": false}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Step 1: Invert in2\n    logic inv_in2;\n    assign inv_in2 = ~in2;\n\n    // Step 2: Perform AND operation between in1 and inv_in2\n    assign out = in1 & inv_in2;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\tassign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // State declaration\n    localparam [1:0] STATE_A = 2'b00;\n    localparam [1:0] STATE_B = 2'b01;\n    \n    reg [1:0] current_state;\n    reg [1:0] next_state;\n\n    // Asynchronous reset\n    always @(posedge areset)\n        current_state <= STATE_B;\n\n    // State transition logic\n    always @(posedge clk or posedge areset)\n        if (areset)\n            current_state <= STATE_B;\n        else\n            current_state <= next_state;\n\n    // Determine next state based on current state and input\n    always @(*) begin\n        case(current_state)\n            STATE_B: \n                if (in == 1'b0)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            STATE_A: \n                if (in == 1'b0)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            default: \n                next_state = STATE_B; // Default to state B\n        endcase\n    end\n\n    // Output the current state\n    always @(*) begin\n        case(current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b1; // Default output when in an unknown state\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    // Positive edge detection\n    always @(posedge clk) begin\n        q <= d; // On the rising edge, update q with d\n    end\n\n    // Negative edge detection\n    always @(negedge clk) begin\n        q <= d; // On the falling edge, update q with d\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\t// Calculate the XNOR result by inverting the XOR result of a and b\n\tassign out = ~(a ^ b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    always @(*) begin\n        z = (x ^ y) & x;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data directly into q when load is high\n            q <= data;\n        end else begin\n            case (ena)\n                2'b01: begin\n                    // Rotate right by one bit\n                    q[0] <= q[99];\n                    q[99:1] <= q[98:0];\n                end\n                2'b10: begin\n                    // Rotate left by one bit\n                    q[99] <= q[0];\n                    q[98:0] <= q[99:1];\n                end\n                default: begin\n                    // No rotation (do nothing)\n                    q <= q;\n                end\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 3292 out of 4005 samples.", "passed": false}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 0;  // Reset to 0 when reset is high\n        end else begin\n            if (q == 999) begin\n                q <= 0;  // Wrap around to 0 after reaching 999\n            end else begin\n                q <= q + 1;  // Increment the counter\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Invert the input signal 'in' and assign it to output 'out'\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n    \n    // State transition logic\n    assign next_state[0] = ~in & state[0] | in & state[1]; // S0\n    assign next_state[1] = in & state[0];                   // S1\n    assign next_state[2] = in & state[1];                   // S2\n    assign next_state[3] = in & state[2];                   // S3\n    assign next_state[4] = in & state[3];                   // S4\n    assign next_state[5] = ~in & state[4];                  // S5\n    assign next_state[6] = ~in & state[5];                  // S6\n    assign next_state[7] = in & state[5];                   // S7\n    assign next_state[8] = in & state[4];                   // S8\n    assign next_state[9] = in & state[6];                   // S9\n    \n    // Output logic\n    assign out1 = state[8];\n    assign out2 = state[7];\n\nendmodule\n", "result": "failed: 1337 out of 1424 samples.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n\t\nalways @(posedge clk) begin\n\tcase ({j,k})\n\t\t2'b00: Q <= Q; // Q remains unchanged\n\t\t2'b01: Q <= 0; // Q is reset to 0\n\t\t2'b10: Q <= 1; // Q is set to 1\n\t\t2'b11: Q <= ~Q; // Q toggles\n\tendcase\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    // Calculate the population count\n    assign out = {in[0] + in[1] + in[2] >= 2, in[0] + in[1] + in[2] >= 1};\nendmodule\n", "result": "failed: 92 out of 220 samples.", "passed": false}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\t// Compute all pairwise comparisons\n\tassign out[24] = a ^ e;\n\tassign out[23] = a ^ d;\n\tassign out[22] = a ^ c;\n\tassign out[21] = a ^ b;\n\tassign out[20] = b ^ e;\n\tassign out[19] = b ^ d;\n\tassign out[18] = b ^ c;\n\tassign out[17] = c ^ e;\n\tassign out[16] = c ^ d;\n\tassign out[15] = d ^ e;\n\n\t// Self comparisons (all will be 0)\n\tassign out[14] = a ^ a;\n\tassign out[13] = b ^ b;\n\tassign out[12] = c ^ c;\n\tassign out[11] = d ^ d;\n\tassign out[10] = e ^ e;\n\n\t// Remaining bits are 0\n\tassign out[9:0] = 0;\nendmodule\n", "result": "failed: 99 out of 100 samples.", "passed": false}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\t\n\t// Define state encoding\n\ttypedef enum logic [1:0] {STATE_WALK_LEFT, STATE_WALK_RIGHT} state_t;\n\tstate_t current_state, next_state;\n\n\t// Register to hold the current state\n\talways_ff @(posedge clk, posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tcurrent_state <= STATE_WALK_LEFT; // Reset to walking left\n\t\telse\n\t\t\tcurrent_state <= next_state; // Update state on clock edge\n\tend\n\t\n\t// Determine the next state based on the current state and inputs\n\talways_comb\n\tbegin\n\t\tcase(current_state)\n\t\t\tSTATE_WALK_LEFT: \n\t\t\t\tif (bump_right)\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\tSTATE_WALK_RIGHT: \n\t\t\t\tif (bump_left)\n\t\t\t\t\tnext_state = STATE_WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = STATE_WALK_RIGHT;\n\t\t\tdefault: next_state = STATE_WALK_LEFT;\n\t\tendcase\n\tend\n\n\t// Outputs based on the current state\n\tassign walk_left = (current_state == STATE_WALK_LEFT);\n\tassign walk_right = (current_state == STATE_WALK_RIGHT);\n\nendmodule\n", "result": "failed: 186 out of 229 samples.", "passed": false}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n    \n    // Implementing the AND operation between inputs a and b.\n    assign q = a & b;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\t// Intermediate signals for the AND gates\n\twire and1_result, and2_result;\n\twire and3_result, and4_result;\n\n\t// AND gate for p1y\n\tand1_result <= p1a & p1b & p1c;\n\tand2_result <= p1d & p1e & p1f;\n\n\t// OR gate for p1y\n\tp1y <= and1_result | and2_result;\n\n\t// AND gate for p2y\n\tand3_result <= p2a & p2b;\n\tand4_result <= p2c & p2d;\n\n\t// OR gate for p2y\n\tp2y <= and3_result | and4_result;\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n\t\n\t// Internal signals for next state\n\treg [2:0] next_state;\n\n\talways @(posedge clk) begin\n\t\tcase ({y, x})\n\t\t\t3'b000, 3'b001, 3'b010: begin // States 000, 001, 010\n\t\t\t\tnext_state = (x == 0) ? 3'b000 : 3'b001;\n\t\t\t\tY0 = next_state[0];\n\t\t\t\tz = 0;\n\t\t\tend\n\t\t\t3'b011: begin // State 011\n\t\t\t\tnext_state = (x == 0) ? 3'b001 : 3'b010;\n\t\t\t\tY0 = next_state[0];\n\t\t\t\tz = 1;\n\t\t\tend\n\t\t\t3'b100: begin // State 100\n\t\t\t\tnext_state = (x == 0) ? 3'b011 : 3'b100;\n\t\t\t\tY0 = next_state[0];\n\t\t\t\tz = 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = 3'b000; // Default state\n\t\t\t\tY0 = next_state[0];\n\t\t\t\tz = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 80 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\t// Perform the OR operation on the two inputs\n\tlogic or_result;\n\tor_result = in1 | in2;\n\n\t// Negate the result to get the NOR output\n\tout = ~or_result;\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n    // Assigning the inputs to the outputs based on the problem statement\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    // Internal signals\n    logic prev_clk;\n\n    // Edge detection for rising edge of clk\n    always_ff @(posedge clk) begin\n        prev_clk <= clk;\n    end\n\n    // Main logic for D flip flop\n    always_ff @(posedge clk or posedge ar) begin\n        if (ar) begin\n            q <= 1'b0; // Asynchronous reset\n        end else if (prev_clk == 1'b0 && clk == 1'b1) begin\n            q <= d; // Rising edge of clk\n        end\n    end\nendmodule\n", "result": "failed: 10 out of 100 samples.", "passed": false}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n    \n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0;\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    // Register to hold the current count value\n    reg [9:0] count;\n\n    // Loading logic: Load the counter with 'data' when 'load' is high\n    always @(posedge clk or posedge load)\n        if (load) count <= data;\n    \n    // Counting down logic: Decrement the counter on each clock cycle when 'load' is low\n    always @(posedge clk)\n        if (!load && count > 0) count <= count - 1;\n    \n    // Output signal: Assert 'tc' when the counter reaches 0\n    assign tc = (count == 0);\nendmodule\n", "result": "failed: 126 out of 7127 samples.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n\n// Define states\ntypedef enum logic [2:0] {\n    S0, S1, S2, S3, S4, S5, S6, S7, FOUND\n} state_t;\n\nstate_t state, next_state;\n\n// State register\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= S0;\n    else\n        state <= next_state;\nend\n\n// Next state logic\nalways_comb begin\n    case(state)\n        S0: next_state = (data) ? S1 : S0;\n        S1: next_state = (data) ? S2 : S0;\n        S2: next_state = (data) ? S3 : S1;\n        S3: next_state = (data) ? FOUND : S2;\n        FOUND: next_state = FOUND;\n        default: next_state = S0;\n    endcase\nend\n\n// Output logic\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset)\n        start_shifting <= 0;\n    else if (state == FOUND)\n        start_shifting <= 1;\nend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    \n    // Always block triggered by the positive edge of the clock\n    always @(posedge clk) begin\n        if (reset) begin\n            // If reset is high, set all q to 0\n            q <= 8'b0;\n        end else begin\n            // Otherwise, load the data from d into q\n            q <= d;\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    // Register to hold the previous value of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Detect rising edges for each bit\n        anyedge <= (prev_in == 8'b0) ? 8'b0 : (in & ~prev_in);\n        // Store the current value of 'in' for the next clock cycle\n        prev_in <= in;\n    end\nendmodule\n", "result": "failed: 193 out of 228 samples.", "passed": false}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0001; // Reset to 1\n        end else begin\n            if (q == 4'b1010) begin // Check if q is 10\n                q <= 4'b0001; // Wrap around to 1\n            end else begin\n                q <= q + 1; // Increment q\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (a == 1'b1) begin\n            // Increment by 4 when a is high\n            q <= q + 4;\n            // Wrap around if q exceeds 7\n            if (q >= 7)\n                q <= 0;\n        end else begin\n            // Increment by 1 when a is low\n            case (q)\n                4'd4: q <= 4'd5;\n                4'd5: q <= 4'd6;\n                4'd6: q <= 4'd0;\n                4'd0: q <= 4'd1;\n                default: q <= q; // No change for other values\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the LFSR to '10000' when reset is active\n            q <= 5'b10000;\n        end else begin\n            // Perform the shift operation\n            q <= {q[4], q[4] ^ q[2], q[3:1]};\n        end\n    end\nendmodule\n", "result": "failed: 4292 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tif (do_sub) \n\t\t\tout = a - b[7:0]; // Perform subtraction\n\t\telse \n\t\t\tout = a + b[7:0]; // Perform addition\n\t\t\n\t\tresult_is_zero = (out == 8'b0); // Check if result is zero\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\tlogic not_x4;\n\t\n\tassign not_x4 = ~x[4];\n\tassign f = x[3] | (not_x4 & x[1] & x[2]);\nendmodule\n", "result": "failed: 9 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n    always @(*) begin\n        valid = 0;\n        out = 0;\n        \n        if (code == 8'h45) begin\n            out = 4'b0000; // Key 0\n            valid = 1;\n        end else if (code == 8'h16) begin\n            out = 4'b0001; // Key 1\n            valid = 1;\n        end else if (code == 8'h1e) begin\n            out = 4'b0010; // Key 2\n            valid = 1;\n        end else if (code == 8'h26) begin\n            out = 4'b0011; // Key 3\n            valid = 1;\n        end else if (code == 8'h25) begin\n            out = 4'b0100; // Key 4\n            valid = 1;\n        end else if (code == 8'h2e) begin\n            out = 4'b0101; // Key 5\n            valid = 1;\n        end else if (code == 8'h36) begin\n            out = 4'b0110; // Key 6\n            valid = 1;\n        end else if (code == 8'h3d) begin\n            out = 4'b0111; // Key 7\n            valid = 1;\n        end else if (code == 8'h3e) begin\n            out = 4'b1000; // Key 8\n            valid = 1;\n        end else if (code == 8'h46) begin\n            out = 4'b1001; // Key 9\n            valid = 1;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    // Reverse the bit order of the input\n    always @(*) begin\n        out[0] = in[7];\n        out[1] = in[6];\n        out[2] = in[5];\n        out[3] = in[4];\n        out[4] = in[3];\n        out[5] = in[2];\n        out[6] = in[1];\n        out[7] = in[0];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\t// Calculate the simplified terms\n\twire term1 = ~a & c; // a'c\n\twire term2 = b & d; // b'd\n\t\n\t// Combine the terms using OR gate\n\tassign out = term1 | term2;\n\nendmodule\n", "result": "failed: 130 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    // Register to hold the current state\n    reg [3:0] current_state;\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data into MSB and shift others to the right\n            current_state <= {data, current_state[3:1]};\n        end else if (count_ena) begin\n            // Decrement the current state, handle underflow\n            if (current_state == 0) begin\n                current_state <= 15; // Wrap around to 15 (binary 1111)\n            end else begin\n                current_state <= current_state - 1;\n            end\n        end\n    end\n\n    // Assign the current state to the output\n    assign q = current_state;\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\t// Directly connect the input to the output\n\tassign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    // Define the states\n    typedef enum logic [2:0] {\n        IDLE,\n        SHIFT_ENABLE_1,\n        SHIFT_ENABLE_2,\n        SHIFT_ENABLE_3,\n        SHIFT_ENABLE_4\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Register to hold the current state\n    always_ff @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            IDLE:     next_state = reset ? IDLE : SHIFT_ENABLE_1;\n            SHIFT_ENABLE_1: next_state = SHIFT_ENABLE_2;\n            SHIFT_ENABLE_2: next_state = SHIFT_ENABLE_3;\n            SHIFT_ENABLE_3: next_state = SHIFT_ENABLE_4;\n            SHIFT_ENABLE_4: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    assign shift_ena = (current_state == SHIFT_ENABLE_1) |\n                       (current_state == SHIFT_ENABLE_2) |\n                       (current_state == SHIFT_ENABLE_3) |\n                       (current_state == SHIFT_ENABLE_4);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n    \n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n    \n    // Using procedural if statement in an always block\n    always @(sel_b1 or sel_b2) begin\n        if (sel_b1 & sel_b2)\n            out_always <= b;\n        else\n            out_always <= a;\n    end\n\nendmodule\n", "result": "failed: 19 out of 114 samples.", "passed": false}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    assign out = a | b | c; // Using logical OR to implement the derived Boolean expression\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    // State encoding\n    parameter A = 2'b00;\n    parameter B = 2'b01;\n    parameter C = 2'b10;\n    parameter D = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: if (r[1]) next_state = B; \n               else if (r[2]) next_state = C;\n               else if (r[3]) next_state = D;\n               else next_state = A;\n            B: if (r[1]) next_state = B;\n               else next_state = A;\n            C: if (r[2]) next_state = C;\n               else next_state = A;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;\n        case(state)\n            B: g[1] = 1;\n            C: g[2] = 1;\n            D: g[3] = 1;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0; // Reset the counter to 0 when reset is high\n        end else begin\n            if (q == 4'b1001) begin // Check if counter value is 9 (binary 1001)\n                q <= 4'b0;          // Wrap around to 0\n            end else begin\n                q <= q + 1;         // Otherwise, increment the counter\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    \n    typedef enum reg [2:0] {\n        IDLE,\n        BYTE1,\n        BYTE2,\n        BYTE3\n    } state_t;\n    \n    state_t state, next_state;\n\n    // Next state logic\n    always @(state, in, reset) begin\n        case(state)\n            IDLE: if (in[3]) next_state = BYTE1; else next_state = IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Output logic\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == BYTE3) done <= 1;\n            else done <= 0;\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    // Implementing the 2-to-1 multiplexer logic\n    assign out = (sel == 1'b0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    // Calculate AND output\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    \n    // Calculate OR output\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    \n    // Calculate XOR output\n    wire xor_temp1 = in[0] ^ in[1];\n    wire xor_temp2 = in[2] ^ in[3];\n    assign out_xor = xor_temp1 ^ xor_temp2;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define the state register\n    reg [2:0] y;\n    \n    // Determine the next state based on the current state and input x\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            y <= 3'b000;  // Synchronous reset to state 000\n        else\n            case(y)\n                3'b000: y <= (x == 1'b0) ? 3'b000 : 3'b001;\n                3'b001: y <= (x == 1'b0) ? 3'b001 : 3'b100;\n                3'b010: y <= (x == 1'b0) ? 3'b010 : 3'b001;\n                3'b011: y <= (x == 1'b0) ? 3'b001 : 3'b010;\n                3'b100: y <= (x == 1'b0) ? 3'b011 : 3'b100;\n                default: y <= 3'b000;  // Default state\n            endcase\n    end\n    \n    // Determine the output z based on the current state\n    always @(*) \n    begin\n        case(y)\n            3'b011, 3'b100: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 2 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\t\n\t// Define states\n\ttypedef enum logic [1:0] {A, B, C, D, E, F} state_t;\n\tstate_t current_state, next_state;\n\t\n\t// Register to hold the current state\n\treg [1:0] state_reg;\n\t\n\t// Registers to hold previous x and y values\n\treg [2:0] x_history;\n\t\n\t// Output signals\n\twire f_signal;\n\twire g_signal;\n\t\n\t// State transition logic\n\talways_ff @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tstate_reg <= A;\n\t\tend else begin\n\t\t\tstate_reg <= next_state;\n\t\tend\n\tend\n\t\n\t// Next state logic\n\talways_comb begin\n\t\tnext_state = current_state;\n\t\tf_signal = 0;\n\t\tg_signal = 0;\n\t\t\n\t\tcase (current_state)\n\t\t\tA: begin\n\t\t\t\tif (!resetn) begin\n\t\t\t\t\tnext_state = A;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tf_signal = 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tB: begin\n\t\t\t\tnext_state = C;\n\t\t\tend\n\t\t\t\n\t\t\tC: begin\n\t\t\t\tx_history[2:1] = x_history[1:0];\n\t\t\t\tx_history[0] = x;\n\t\t\t\t\n\t\t\t\tif (x_history == 3'b101) begin\n\t\t\t\t\tnext_state = D;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = C;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tD: begin\n\t\t\t\tg_signal = 1;\n\t\t\t\tif (y) begin\n\t\t\t\t\tnext_state = E;\n\t\t\t\tend else if (x_history != 3'b101) begin\n\t\t\t\t\tnext_state = F;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tE: begin\n\t\t\t\tg_signal = 1;\n\t\t\tend\n\t\t\t\n\t\t\tF: begin\n\t\t\t\tg_signal = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\t// Assign outputs\n\tassign f = f_signal;\n\tassign g = g_signal;\n\t\n\t// Assign current state\n\tassign current_state = state_reg;\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    // Initialize q to 0x34 when reset is high\n    always @(negedge clk or posedge reset)\n    begin\n        if (reset)\n            q <= 8'b00110100; // 0x34 in binary\n        else\n            q <= d;\n    end\nendmodule\n", "result": "failed: 46 out of 436 samples.", "passed": false}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Compute the XOR of all 8 input bits\n    wire xor_result;\n    assign xor_result = ^in;\n\n    // The parity bit is the XOR result inverted if needed to maintain even parity\n    assign parity = xor_result; // Since we want even parity, parity = xor_result\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\t\n\t// Define the output based on the current state\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t2'b00: out = 0; // State A\n\t\t\t2'b01: out = 0; // State B\n\t\t\t2'b10: out = 0; // State C\n\t\t\t2'b11: out = 1; // State D\n\t\t\tdefault: out = 0;\n\t\tendcase\n\tend\n\t\n\t// Define the next state based on the current state and input\n\talways @(*) begin\n\t\tcase({state, in})\n\t\t\t2'b000: next_state = 2'b00; // A, in=0 -> A\n\t\t\t2'b001: next_state = 2'b01; // A, in=1 -> B\n\t\t\t2'b010: next_state = 2'b10; // B, in=0 -> C\n\t\t\t2'b011: next_state = 2'b01; // B, in=1 -> B\n\t\t\t2'b100: next_state = 2'b00; // C, in=0 -> A\n\t\t\t2'b101: next_state = 2'b11; // C, in=1 -> D\n\t\t\t2'b110: next_state = 2'b10; // D, in=0 -> C\n\t\t\t2'b111: next_state = 2'b01; // D, in=1 -> B\n\t\t\tdefault: next_state = 2'b00;\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = ~(x & ~y); // z is high if x is not high when y is low.\nendmodule\n", "result": "failed: 36 out of 110 samples.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    \n    // Define state type and state variables\n    typedef enum logic [2:0] {A, B, C, D, E, F} state_t;\n    state_t state, next_state;\n\n    // Next state logic\n    always_comb begin\n        unique case (state)\n            A: if (w) next_state = B; else next_state = A;\n            B: if (w) next_state = C; else next_state = D;\n            C: if (w) next_state = E; else next_state = D;\n            D: if (w) next_state = F; else next_state = A;\n            E: if (w) next_state = E; else next_state = D;\n            F: if (w) next_state = C; else next_state = D;\n            default: next_state = A;\n        endcase\n    end\n    \n    // State register update\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n    \n    // Output definition\n    assign z = (state == E);\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            case (byteena)\n                2'b00: q <= q; // No change\n                2'b01: q <= {d[15:8], q[7:0]}; // Write upper byte\n                2'b10: q <= {q[15:8], d[7:0]}; // Write lower byte\n                2'b11: q <= d; // Write both bytes\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: 173 out of 443 samples.", "passed": false}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Register to hold the previous state of 'in'\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Update the previous state register\n        prev_in <= in;\n        \n        // Detect positive edges and set the corresponding bits in 'pedge'\n        pedge <= { \n            (prev_in[0] == 0 && in[0] == 1),\n            (prev_in[1] == 0 && in[1] == 1),\n            (prev_in[2] == 0 && in[2] == 1),\n            (prev_in[3] == 0 && in[3] == 1),\n            (prev_in[4] == 0 && in[4] == 1),\n            (prev_in[5] == 0 && in[5] == 1),\n            (prev_in[6] == 0 && in[6] == 1),\n            (prev_in[7] == 0 && in[7] == 1)\n        };\n    end\nendmodule\n", "result": "failed: 164 out of 227 samples.", "passed": false}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\talways @(posedge clock) begin\n\t\tif (a)\n\t\t\tp <= 1;\n\tend\n\t\n\talways @(negedge clock) begin\n\t\tif (!a)\n\t\t\tq <= p;\n\tend\n\nendmodule\n", "result": "failed: 144 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    // Register to hold the previous state\n    reg [511:0] q_prev;\n\n    // Initialize the state when load is high\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            // Calculate the next state for each cell\n            for (int i = 0; i < 512; i = i + 1) begin\n                q[i] <= (i == 0) ? q_prev[1] ^ 0 : \n                        (i == 511) ? q_prev[510] ^ 0 : \n                                     q_prev[i-1] ^ q_prev[i+1];\n            end\n    end\n\n    // Store the current state in q_prev for the next cycle\n    always @(posedge clk) begin\n        q_prev <= q;\n    end\nendmodule\n", "result": "failed: 7054 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n    // Compare each bit of A and B\n    assign z = (A[0] == B[0]) & (A[1] == B[1]);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n\t// out_both calculation: Both current and previous bits are 1\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 0; i < 99; i = i + 1) begin : gen_out_both\n\t\t\tassign out_both[i] = in[i] & in[i+1];\n\t\tend\n\tendgenerate\n\n\t// out_any calculation: Either current or next bit is 1\n\tgenerate\n\t\tfor (i = 0; i < 99; i = i + 1) begin : gen_out_any\n\t\t\tassign out_any[i+1] = in[i] | in[i+1];\n\t\tend\n\tendgenerate\n\n\t// out_different calculation: Current bit is different from the previous bit\n\tgenerate\n\t\tfor (i = 0; i < 99; i = i + 1) begin : gen_out_diff\n\t\t\tassign out_different[i] = in[i] ^ in[i+1];\n\t\tend\n\tendgenerate\n\n\t// Special case for out_different[99]: Treat the vector as wrapping around\n\tassign out_different[99] = in[99] ^ in[0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n    // The always block is triggered by the rising edge of ena\n    always @(posedge ena) begin\n        // Assign the value of d to q when ena is high\n        q <= d;\n    end\nendmodule\n", "result": "failed: 40 out of 100 samples.", "passed": false}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting bit position based on sel\n    wire [9:0] starting_bit = sel * 4;\n\n    // Extract the 4 bits from in starting at the calculated position\n    always @(*) begin\n        out = in[starting_bit + 3:starting_bit];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\t\n\talways_comb begin\n\t\tcase (sel)\n\t\t\t0: out = a;\n\t\t\t1: out = b;\n\t\t\t2: out = c;\n\t\t\t3: out = d;\n\t\t\t4: out = e;\n\t\t\t5: out = f;\n\t\t\t6: out = g;\n\t\t\t7: out = h;\n\t\t\tdefault: out = 16'b1;\n\t\tendcase\n\tend\n\nendmodule\n", "result": "failed: 121 out of 220 samples.", "passed": false}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\t// Compute bitwise OR of a and b\n\tassign out_or_bitwise = a | b;\n\n\t// Compute logical OR of a and b\n\tassign out_or_logical = |(a | b);\n\n\t// Compute NOT of a and b\n\tassign out_not[5:3] = ~b; // Upper half of out_not\n\tassign out_not[2:0] = ~a; // Lower half of out_not\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\t\n\t// State Transition Logic\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001: // State A\n\t\t\t\tif (in == 1'b0)\n\t\t\t\t\tnext_state = 4'b0001; // Stay in A\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0010; // Go to B\n\t\t\t4'b0010: // State B\n\t\t\t\tif (in == 1'b0)\n\t\t\t\t\tnext_state = 4'b0100; // Go to C\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0010; // Stay in B\n\t\t\t4'b0100: // State C\n\t\t\t\tif (in == 1'b0)\n\t\t\t\t\tnext_state = 4'b0001; // Go to A\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b1000; // Go to D\n\t\t\t4'b1000: // State D\n\t\t\t\tif (in == 1'b0)\n\t\t\t\t\tnext_state = 4'b0100; // Go to C\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0010; // Go to B\n\t\t\tdefault:\n\t\t\t\tnext_state = 4'b0001; // Default to State A\n\t\tendcase\n\tend\n\t\n\t// Output Logic\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0;\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n    always @(*) begin\n        // Step 1: Compare a and b\n        if (a < b)\n            min = a;\n        else\n            min = b;\n\n        // Step 2: Compare the result with c\n        if (min > c)\n            min = c;\n\n        // Step 3: Compare the result with d\n        if (min > d)\n            min = d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n    // AND operation\n    assign out_and = a & b;\n    \n    // OR operation\n    assign out_or = a | b;\n    \n    // XOR operation\n    assign out_xor = a ^ b;\n    \n    // NAND operation\n    assign out_nand = ~(a & b);\n    \n    // NOR operation\n    assign out_nor = ~(a | b);\n    \n    // XNOR operation\n    assign out_xnor = ~(a ^ b);\n    \n    // AND-NOT operation\n    assign out_anotb = a & (~b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\tassign out = (~b | ~d | (a & c & ~d));\nendmodule\n", "result": "failed: 82 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {A, B0, B1, B2, B3} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case(current_state)\n            A: \n                if (s)\n                    next_state = B0; // Move to B0 since w can be either 0 or 1.\n                else\n                    next_state = A;\n            \n            B0: \n                if (w)\n                    next_state = B1;\n                else\n                    next_state = B0;\n            \n            B1: \n                if (w)\n                    next_state = B2;\n                else\n                    next_state = B0;\n            \n            B2: \n                if (w)\n                    next_state = B3;\n                else\n                    next_state = B1;\n            \n            B3: \n                if (w)\n                    next_state = B3;\n                else\n                    next_state = B2;\n            \n            default: next_state = A;\n        endcase\n    end\n    \n    // Output determination\n    always_ff @(posedge clk) begin\n        case(current_state)\n            B2: z <= 1;\n            default: z <= 0;\n        endcase\n    end\nendmodule\n", "result": "failed: 372 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Sign extend the 8-bit input to 32-bits\n    assign out = {24{in[7]}, in};\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Internal signals for the intermediate flip-flop outputs\n    reg [2:0] shift_reg;\n\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            // Reset all flip-flops to 0 when resetn is low\n            shift_reg <= 3'b0;\n            out <= 1'b0;\n        end else begin\n            // Shift right operation\n            shift_reg <= {shift_reg[1:0], in};\n            out <= shift_reg[2];\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\n\talways @(*) begin\n\t\tif (in[3]) begin // Check MSB\n\t\t\tpos = 2'b11; // Position 3 in binary is 11\n\t\tend else if (in[2]) begin\n\t\t\tpos = 2'b10; // Position 2 in binary is 10\n\t\tend else if (in[1]) begin\n\t\t\tpos = 2'b01; // Position 1 in binary is 01\n\t\tend else if (in[0]) begin\n\t\t\tpos = 2'b00; // Position 0 in binary is 00\n\t\tend else begin\n\t\t\tpos = 2'b00; // If no '1' is found, output 00\n\t\tend\n\tend\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // Define states\n    localparam OFF = 2'b00;\n    localparam ON = 2'b01;\n\n    // Current state register\n    reg [1:0] state_reg;\n\n    // Next state logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset) \n            state_reg <= OFF;  // Asynchronous reset to OFF\n        else\n            case(state_reg)\n                OFF:\n                    if (j)\n                        state_reg <= ON;\n                    else\n                        state_reg <= OFF;\n                ON:\n                    if (k)\n                        state_reg <= OFF;\n                    else\n                        state_reg <= ON;\n                default:\n                    state_reg <= OFF;\n            endcase\n    end\n\n    // Output logic\n    always @* begin\n        case(state_reg)\n            OFF: out <= 1'b0;\n            ON: out <= 1'b1;\n            default: out <= 1'b0;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\t// Continuously assign the output 'out' to 0\n\tassign out = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\t// Assign the output 'one' to logic high (1)\n\tassign one = 1'b1;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        for (integer i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    // Internal signal to represent the D input of the flip-flop\n    logic d;\n\n    // XOR gate\n    assign d = in ^ out;\n\n    // Positive-edge-triggered D flip-flop\n    always_ff @(posedge clk) begin\n        out <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset) // Asynchronous reset\n            q <= 4'b0;\n        else\n        begin\n            if (load) // Synchronous load\n                q <= data;\n            else if (ena) // Right shift when enable is high and not loading\n                q <= {1'b0, q[3:1]};\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n    // Implementing the logic\n    assign f = x1 & (x2 | x3); // This line represents the Boolean equation derived above\nendmodule\n", "result": "failed: 2 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n\tif (areset)\n\t\tq <= 8'b0;\n\telse\n\t\tq <= d;\nend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\t\n\t// Intermediate signals to store the results of AND/OR/XOR operations\n\twire [99:0] and_result;\n\twire [99:0] or_result;\n\twire [99:0] xor_result;\n\n\t// Implementing the AND gate\n\tassign and_result[0] = in[0];\n\tgenvar i;\n\tgenerate\n\t\tfor (i = 1; i < 100; i = i + 1) begin : gen_and\n\t\t\tassign and_result[i] = and_result[i - 1] & in[i];\n\t\tend\n\tendgenerate\n\n\t// Implementing the OR gate\n\tassign or_result[0] = in[0];\n\tgenerate\n\t\tfor (i = 1; i < 100; i = i + 1) begin : gen_or\n\t\t\tassign or_result[i] = or_result[i - 1] | in[i];\n\t\tend\n\tendgenerate\n\n\t// Implementing the XOR gate\n\tassign xor_result[0] = in[0];\n\tgenerate\n\t\tfor (i = 1; i < 100; i = i + 1) begin : gen_xor\n\t\t\tassign xor_result[i] = xor_result[i - 1] ^ in[i];\n\t\tend\n\tendgenerate\n\n\t// Assign the final results to the outputs\n\tassign out_and = and_result[99];\n\tassign out_or = or_result[99];\n\tassign out_xor = xor_result[99];\n\nendmodule\n", "result": "timed out", "passed": false}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\t// Calculate the sum using XOR gate\n\tassign sum = a ^ b;\n\t\n\t// Calculate the carry out using AND gate\n\tassign cout = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    always @(*) begin\n        // Set shut_off_computer to 1 if cpu_overheated is high\n        shut_off_computer = cpu_overheated;\n\n        // Set keep_driving to ~gas_tank_empty if arrived is low\n        // Otherwise, set keep_driving to 0 if arrived is high\n        keep_driving = (~arrived) ? ~gas_tank_empty : 1'b0;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= 0; // Reset to OFF state\n        else\n            case(state)\n                0: state <= j ? 1 : 0; // OFF -> ON if j=1, otherwise stay OFF\n                1: state <= k ? 0 : 1; // ON -> OFF if k=1, otherwise stay ON\n                default: state <= 0; // Default to OFF\n            endcase\n    end\n\n    // Output is based on the current state\n    always @* begin\n        out = state;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\tlogic [31:0] concatenated;\n\n\t// Concatenate all inputs into a 30-bit vector\n\tassign concatenated = {a, b, c, d, e, f};\n\n\t// Append two 1s to the concatenated vector\n\tassign concatenated[31:30] = 2'b11;\n\n\t// Assign the appropriate segments of the 32-bit vector to each output vector\n\tassign w = concatenated[31:24];\n\tassign x = concatenated[23:16];\n\tassign y = concatenated[15:8];\n\tassign z = concatenated[7:0];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // XOR the inputs to determine the parity\n    wire xora_b = a ^ b;\n    wire xorab_c = xora_b ^ c;\n    wire xorabc_d = xorab_c ^ d;\n\n    // Assign the output q based on the parity result\n    assign q = ~xorabc_d; // Invert the result to get the desired output (1 for even number of 1s, 0 for odd)\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Directly assign the output to be the AND of the two inputs\n    assign out = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    \n    // Define states\n    parameter B = 2'b00;\n    parameter A = 2'b01;\n\n    // Internal state register\n    reg [1:0] state_reg, state_next;\n\n    // Output assignment based on current state\n    assign out = (state_reg == B) ? 1'b1 : 1'b0;\n\n    // Next state logic\n    always @(state_reg or in or reset)\n        begin\n            if (reset) // Active-high synchronous reset\n                state_next <= B;\n            else\n                case(state_reg)\n                    B: \n                        if (in == 1'b0)\n                            state_next <= A;\n                        else\n                            state_next <= B;\n                    A: \n                        if (in == 1'b0)\n                            state_next <= B;\n                        else\n                            state_next <= A;\n                    default: \n                        state_next <= B; // Default to reset state\n                endcase\n        end\n\n    // State register update on clock edge\n    always @(posedge clk)\n        state_reg <= state_next;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // Intermediate signals for clarity\n    wire s0, s1;\n    \n    // Calculate the sum\n    assign s0 = a ^ b; // XOR of a and b\n    assign s1 = s0 ^ cin; // XOR of result with cin\n    \n    // Assign final sum\n    assign sum = s1;\n    \n    // Calculate the carry-out\n    assign cout = (a & b) | (s0 & cin); // OR of AND operations\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n    \n    // Define the intermediate signal for the XNOR output\n    logic xnor_out;\n\n    // Compute the XNOR output\n    assign xnor_out = (in1 == in2);\n\n    // Compute the final output using XOR operation\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    // Define intermediate signals\n    wire c_d_dash;\n    wire c_dash;\n    wire c_plus_d;\n\n    // Implement c'd'\n    assign c_d_dash = ~(c & d);  // Complement of c AND d\n\n    // Implement c'\n    assign c_dash = ~c;          // Complement of c\n\n    // Implement c + d\n    assign c_plus_d = c | d;     // OR of c and d\n\n    // Assign the values to the mux_in outputs based on the K-map\n    assign mux_in[0] = c_d_dash; // For ab=00\n    assign mux_in[1] = c_dash;   // For ab=01\n    assign mux_in[2] = c_plus_d; // For ab=11\n    assign mux_in[3] = c;        // For ab=10\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // Define state variables\n    reg [1:0] s;  // Current state\n    reg [1:0] ns; // Next state\n    \n    // Output variable\n    wire out;\n    \n    // State transition logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            s <= 2'b01;  // Reset to state A\n        else\n            s <= ns;     // Update state on rising edge of clock\n    end\n    \n    // Next state logic\n    always @(*)\n    begin\n        case(s)\n            2'b01: // State A\n                if (x == 1)\n                    ns = 2'b10; // Transition to state B\n                else\n                    ns = 2'b01; // Stay in state A\n            2'b10: // State B\n                ns = 2'b10; // Stay in state B\n            default: ns = 2'b01; // Default to state A\n        endcase\n    end\n    \n    // Output logic\n    assign z = (s == 2'b01 && x == 1) || s == 2'b10; // Output 1 in state B and when transitioning from A to B\n    \nendmodule\n", "result": "failed: 189 out of 436 samples.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nreg q_reg;\n\nalways @(posedge clk) begin\n    // Update state and q on rising edge of clk\n    case ({a, b})\n        2'b00: q_reg <= q_reg; // No change if both a and b are 0\n        2'b01: q_reg <= ~q_reg; // Toggle q if b is 1 and a is 0\n        2'b10: q_reg <= q_reg; // No change if b is 0 and a is 1\n        2'b11: q_reg <= ~q_reg; // Toggle q if both a and b are 1\n    endcase\nend\n\n// Assign the output q and state\nassign q = q_reg;\nassign state = q_reg;\n\nendmodule\n", "result": "failed: 229 out of 232 samples.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    assign f = (~x[3] & ~x[4] & ~x[2]) | x[3];\nendmodule\n", "result": "failed: 16 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    \n    // State declaration\n    typedef enum logic [2:0] {\n        IDLE = 3'b000,\n        ONE_1 = 3'b001,\n        TWO_1S = 3'b010,\n        THREE_1S = 3'b011,\n        FOUR_1S = 3'b100,\n        FIVE_1S = 3'b101,\n        SIX_1S = 3'b110,\n        SEVEN_1S = 3'b111\n    } state_t;\n    \n    state_t curr_state, next_state;\n    \n    // Output signals\n    reg disc, flag, err;\n\n    // State register\n    always_ff @(posedge clk) begin\n        if (reset)\n            curr_state <= IDLE;\n        else\n            curr_state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = curr_state;\n        \n        case (curr_state)\n            IDLE: if (in) next_state = ONE_1;\n            ONE_1: if (in) next_state = TWO_1S; else next_state = IDLE;\n            TWO_1S: if (in) next_state = THREE_1S; else next_state = IDLE;\n            THREE_1S: if (in) next_state = FOUR_1S; else next_state = IDLE;\n            FOUR_1S: if (in) next_state = FIVE_1S; else next_state = IDLE;\n            FIVE_1S: if (in) next_state = SIX_1S; else next_state = IDLE;\n            SIX_1S: if (in) next_state = SEVEN_1S; else begin next_state = IDLE; flag = 1'b1; end\n            SEVEN_1S: if (!in) next_state = IDLE; else next_state = SEVEN_1S;\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Output generation\n    always_ff @(posedge clk) begin\n        if (reset)\n            {disc, flag, err} <= 3'b000;\n        else begin\n            if (next_state == SIX_1S && !in)\n                disc <= 1'b1;\n            else if (next_state == SEVEN_1S)\n                err <= 1'b1;\n            else\n                {disc, flag, err} <= 3'b000;\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\ntypedef enum logic [3:0] {\n\tSEARCHING,\n\tREADING_DELAY,\n\tCOUNTING_DOWN,\n\tWAIT_ACK\n} state_t;\n\nstate_t state, next_state;\nlogic [3:0] delay;\nlogic [11:0] counter;\nlogic [3:0] pattern_reg;\nlogic [3:0] bit_shift_reg;\n\nalways_ff @(posedge clk or posedge reset) begin\n\tif (reset)\n\t\tstate <= SEARCHING;\n\telse\n\t\tstate <= next_state;\nend\n\nalways_comb begin\n\tcase(state)\n\t\tSEARCHING: begin\n\t\t\tif ({pattern_reg[2], pattern_reg[1], pattern_reg[0], data} == 4'b1101) begin\n\t\t\t\tnext_state = READING_DELAY;\n\t\t\t\tpattern_reg = 4'b0000;\n\t\t\tend else begin\n\t\t\t\tpattern_reg = {pattern_reg[2:0], data};\n\t\t\t\tnext_state = SEARCHING;\n\t\t\tend\n\t\tend\n\n\t\tREADING_DELAY: begin\n\t\t\tbit_shift_reg = {bit_shift_reg[2:0], data};\n\t\t\tif (bit_shift_reg == 4'b1111)\n\t\t\t\tnext_state = COUNTING_DOWN;\n\t\t\telse\n\t\t\t\tnext_state = READING_DELAY;\n\t\tend\n\n\t\tCOUNTING_DOWN: begin\n\t\t\tdelay = bit_shift_reg;\n\t\t\tif (counter == (delay + 1) * 1000 - 1) begin\n\t\t\t\tcount = 4'd0;\n\t\t\t\tnext_state = WAIT_ACK;\n\t\t\tend else if (counter < (delay + 1) * 1000 - delay * 1000) begin\n\t\t\t\tcount = delay;\n\t\t\tend else if (counter < (delay + 1) * 1000 - (delay - 1) * 1000) begin\n\t\t\t\tcount = delay - 1;\n\t\t\tend else begin\n\t\t\t\tcount = delay - 2;\n\t\t\tend\n\t\t\tif (counter == (delay + 1) * 1000 - delay * 1000 - 1)\n\t\t\t\tdone = 1'b1;\n\t\t\telse\n\t\t\t\tdone = 1'b0;\n\t\t\tif (counter < (delay + 1) * 1000 - 1)\n\t\t\t\tcounter++;\n\t\t\telse\n\t\t\t\tcounter = 0;\n\t\t\tnext_state = COUNTING_DOWN;\n\t\tend\n\n\t\tWAIT_ACK: begin\n\t\t\tif (ack)\n\t\t\t\tnext_state = SEARCHING;\n\t\t\telse\n\t\t\t\tnext_state = WAIT_ACK;\n\t\tend\n\n\t\tdefault: next_state = SEARCHING;\n\tendcase\nend\n\nassign counting = (state == COUNTING_DOWN);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\n    typedef enum logic [1:0] {LOW, MID_LOW, MID_HIGH, HIGH} state_t;\n\n    state_t curr_state, next_state;\n\n    always_ff @(posedge clk or posedge reset)\n        if (reset)\n            curr_state <= LOW;\n        else\n            curr_state <= next_state;\n\n    always_comb begin\n        next_state = curr_state;\n        case (curr_state)\n            LOW: begin\n                if (s == 3'b001) next_state = MID_LOW;\n                else if (s == 3'b011) next_state = MID_HIGH;\n                else if (s == 3'b111) next_state = HIGH;\n            end\n            MID_LOW: begin\n                if (s == 3'b011) next_state = MID_HIGH;\n                else if (s == 3'b111) next_state = HIGH;\n                else if (s == 3'b000) next_state = LOW;\n            end\n            MID_HIGH: begin\n                if (s == 3'b111) next_state = HIGH;\n                else if (s == 3'b000) next_state = LOW;\n                else if (s == 3'b001) next_state = MID_LOW;\n            end\n            HIGH: begin\n                if (s == 3'b000) next_state = LOW;\n                else if (s == 3'b001) next_state = MID_LOW;\n                else if (s == 3'b011) next_state = MID_HIGH;\n            end\n        endcase\n    end\n\n    always_comb begin\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n\n        case (curr_state)\n            LOW: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            MID_LOW: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            MID_HIGH: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n            end\n            HIGH: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "result": "failed: 1241 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    \n    typedef enum {IDLE, START_BIT, DATA_BITS_1, DATA_BITS_2, DATA_BITS_3, DATA_BITS_4, DATA_BITS_5, DATA_BITS_6, DATA_BITS_7, DATA_BITS_8, STOP_BIT} state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    always @(*) begin\n        case(state)\n            IDLE: \n                if (!in)\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            START_BIT: \n                next_state = DATA_BITS_1;\n            DATA_BITS_1: \n                next_state = DATA_BITS_2;\n            DATA_BITS_2: \n                next_state = DATA_BITS_3;\n            DATA_BITS_3: \n                next_state = DATA_BITS_4;\n            DATA_BITS_4: \n                next_state = DATA_BITS_5;\n            DATA_BITS_5: \n                next_state = DATA_BITS_6;\n            DATA_BITS_6: \n                next_state = DATA_BITS_7;\n            DATA_BITS_7: \n                next_state = DATA_BITS_8;\n            DATA_BITS_8: \n                if (in)\n                    next_state = STOP_BIT;\n                else\n                    next_state = DATA_BITS_8;\n            STOP_BIT: \n                if (in)\n                    next_state = IDLE;\n                else\n                    next_state = STOP_BIT;\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    assign done = (state == STOP_BIT);\n\nendmodule\n", "result": "failed: 123 out of 905 samples.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    \n    // State definition\n    typedef enum {IDLE, DATA_1, DATA_2, DATA_3, DATA_4, DATA_5, DATA_6, DATA_7, DATA_8, STOP, ERROR} state_t;\n    state_t current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset)\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: if (!in) next_state = DATA_1; else next_state = IDLE;\n            DATA_1: next_state = DATA_2;\n            DATA_2: next_state = DATA_3;\n            DATA_3: next_state = DATA_4;\n            DATA_4: next_state = DATA_5;\n            DATA_5: next_state = DATA_6;\n            DATA_6: next_state = DATA_7;\n            DATA_7: next_state = DATA_8;\n            DATA_8: next_state = STOP;\n            STOP: if (in) next_state = IDLE; else next_state = ERROR;\n            ERROR: if (in) next_state = IDLE; else next_state = ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge reset)\n        if (reset)\n            out_byte <= 8'b0;\n        else if (current_state == DATA_1) out_byte[0] <= in;\n        else if (current_state == DATA_2) out_byte[1] <= in;\n        else if (current_state == DATA_3) out_byte[2] <= in;\n        else if (current_state == DATA_4) out_byte[3] <= in;\n        else if (current_state == DATA_5) out_byte[4] <= in;\n        else if (current_state == DATA_6) out_byte[5] <= in;\n        else if (current_state == DATA_7) out_byte[6] <= in;\n        else if (current_state == DATA_8) out_byte[7] <= in;\n        else if (current_state == IDLE) out_byte <= 8'b0;\n\n    // Done signal\n    assign done = (current_state == IDLE);\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    // Global History Register\n    reg [6:0] global_history;\n    \n    // Pattern History Table (PHT)\n    reg [1:0] pht [0:127];\n\n    // Initialization of PHT entries\n    initial begin\n        for (int i = 0; i < 128; i = i + 1) begin\n            pht[i] = 2'b00;\n        end\n    end\n\n    // Combinational logic for prediction\n    always @(*) begin\n        // Calculate index\n        reg [6:0] index = predict_pc ^ global_history;\n\n        // Get PHT entry\n        reg [1:0] pht_entry = pht[index];\n        \n        // Determine prediction based on PHT entry\n        if (pht_entry == 2'b00 || pht_entry == 2'b01)\n            predict_taken = 0;\n        else\n            predict_taken = 1;\n        \n        // Output the current global history\n        predict_history = global_history;\n    end\n    \n    // Sequential logic for training and history update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n        end else begin\n            // Training\n            if (train_valid) begin\n                reg [6:0] index_train = train_pc ^ global_history;\n                if (train_mispredicted) begin\n                    // Recover the branch history register\n                    global_history <= train_history;\n                end else begin\n                    // Update PHT\n                    case ({pht[index_train], train_taken})\n                        4'b0000: pht[index_train] <= 2'b00;\n                        4'b0001: pht[index_train] <= 2'b01;\n                        4'b0010: pht[index_train] <= 2'b01;\n                        4'b0011: pht[index_train] <= 2'b10;\n                        4'b0100: pht[index_train] <= 2'b01;\n                        4'b0101: pht[index_train] <= 2'b10;\n                        4'b0110: pht[index_train] <= 2'b10;\n                        4'b0111: pht[index_train] <= 2'b11;\n                        4'b1000: pht[index_train] <= 2'b01;\n                        4'b1001: pht[index_train] <= 2'b10;\n                        4'b1010: pht[index_train] <= 2'b10;\n                        4'b1011: pht[index_train] <= 2'b11;\n                        4'b1100: pht[index_train] <= 2'b10;\n                        4'b1101: pht[index_train] <= 2'b11;\n                        4'b1110: pht[index_train] <= 2'b11;\n                        4'b1111: pht[index_train] <= 2'b11;\n                    endcase\n                end\n            end\n            \n            // Prediction\n            if (predict_valid) begin\n                reg [6:0] index_predict = predict_pc ^ global_history;\n                reg [1:0] pht_entry = pht[index_predict];\n                \n                // Shift global history left and add new bit\n                if (predict_taken) begin\n                    global_history <= {global_history[5:0], pht_entry[1]};\n                end else begin\n                    global_history <= {global_history[5:0], 1'b0};\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // Define state encoding\n    typedef enum logic [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALLING = 3'b010,\n        DIGGING = 3'b011,\n        SPLATTERED = 3'b100\n    } state_t;\n\n    state_t curr_state, next_state;\n    reg [4:0] fall_count; // Count the number of cycles the Lemming is falling\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            curr_state <= WALK_LEFT;\n        else\n            curr_state <= next_state;\n    end\n\n    always_comb begin\n        case(curr_state)\n            WALK_LEFT: begin\n                if (!ground && !dig) next_state = FALLING;\n                else if (ground && bump_left) next_state = WALK_RIGHT;\n                else if (ground && bump_right) next_state = WALK_LEFT;\n                else if (ground && dig) next_state = DIGGING;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground && !dig) next_state = FALLING;\n                else if (ground && bump_left) next_state = WALK_RIGHT;\n                else if (ground && bump_right) next_state = WALK_LEFT;\n                else if (ground && dig) next_state = DIGGING;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground && fall_count > 20) next_state = SPLATTERED;\n                else if (ground) next_state = WALK_LEFT;\n                else next_state = FALLING;\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n                else if (ground && dig) next_state = DIGGING;\n                else if (ground) next_state = WALK_LEFT;\n                else next_state = DIGGING;\n            end\n            SPLATTERED: next_state = SPLATTERED;\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    always_ff @(posedge clk) begin\n        if (curr_state == FALLING) begin\n            if (ground) fall_count <= 0;\n            else fall_count <= fall_count + 1;\n        end else begin\n            fall_count <= 0;\n        end\n    end\n\n    assign walk_left = (curr_state == WALK_LEFT);\n    assign walk_right = (curr_state == WALK_RIGHT);\n    assign aaah = (curr_state == FALLING);\n    assign digging = (curr_state == DIGGING);\n\nendmodule\n", "result": "failed: 366 out of 1003 samples.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // Define states\n    typedef enum { SEARCHING, SHIFTING, COUNTING, NOTIFYING } state_t;\n    state_t state, next_state;\n\n    // Bit buffer for pattern matching\n    reg [3:0] bit_buffer;\n\n    // State transition logic\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= SEARCHING;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*)\n        case (state)\n            SEARCHING:\n                if (bit_buffer == 4'b1101)\n                    next_state = SHIFTING;\n                else\n                    next_state = SEARCHING;\n\n            SHIFTING:\n                if (bit_buffer[2:0] == 3'b110 && data == 1)\n                    next_state = SHIFTING; // Continue shifting\n                else if (bit_buffer == 4'b1101 && data == 1)\n                    next_state = SHIFTING; // Continue shifting\n                else if (bit_buffer[3:0] == 4'b1101)\n                    next_state = COUNTING;\n                else\n                    next_state = SEARCHING;\n\n            COUNTING:\n                if (done_counting)\n                    next_state = NOTIFYING;\n                else\n                    next_state = COUNTING;\n\n            NOTIFYING:\n                if (ack)\n                    next_state = SEARCHING;\n                else\n                    next_state = NOTIFYING;\n\n            default:\n                next_state = SEARCHING;\n        endcase\n\n    // Output assignments based on state\n    always @(*)\n        case (state)\n            SEARCHING:\n                begin\n                    shift_ena = 0;\n                    counting = 0;\n                    done = 0;\n                end\n\n            SHIFTING:\n                begin\n                    shift_ena = 1;\n                    counting = 0;\n                    done = 0;\n                end\n\n            COUNTING:\n                begin\n                    shift_ena = 0;\n                    counting = 1;\n                    done = 0;\n                end\n\n            NOTIFYING:\n                begin\n                    shift_ena = 0;\n                    counting = 0;\n                    done = 1;\n                end\n\n            default:\n                begin\n                    shift_ena = 0;\n                    counting = 0;\n                    done = 0;\n                end\n        endcase\n\n    // Update bit buffer\n    always @(posedge clk or posedge reset)\n        if (reset)\n            bit_buffer <= 4'b0;\n        else\n            bit_buffer <= {bit_buffer[2:0], data};\n\nendmodule\n", "result": "failed: 4112 out of 5069 samples.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    \n    // Function to get the neighbor count for a given cell\n    function integer get_neighbor_count;\n        input [7:0] x, y;\n        integer i, j, count;\n        begin\n            count = 0;\n            for (i = -1; i <= 1; i = i + 1) begin\n                for (j = -1; j <= 1; j = j + 1) begin\n                    if ((i != 0) || (j != 0)) begin\n                        integer nx, ny;\n                        nx = x + i;\n                        ny = y + j;\n                        if (nx < 0) nx = 15;\n                        else if (nx > 15) nx = 0;\n                        if (ny < 0) ny = 15;\n                        else if (ny > 15) ny = 0;\n                        count = count + q[nx*16 + ny];\n                    end\n                end\n            end\n            get_neighbor_count = count;\n        end\n    endfunction\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            integer i, j;\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    integer count;\n                    count = get_neighbor_count(i, j);\n                    case (count)\n                        0, 1: q[i*16+j] <= 0;\n                        2: q[i*16+j] <= q[i*16+j];\n                        3: q[i*16+j] <= 1;\n                        default: q[i*16+j] <= 0;\n                    endcase\n                end\n            end\n        end\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // Define the states\n    typedef enum logic [1:0] {\n        WALK_LEFT = 2'b00,\n        WALK_RIGHT = 2'b01,\n        FALLING = 2'b10,\n        DIGGING = 2'b11\n    } state_t;\n    \n    // Current state register\n    state_t state, next_state;\n    \n    // Output signals\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n    \n    // Next state logic\n    always_comb begin\n        case(state)\n            WALK_LEFT: begin\n                if (bump_left) next_state = WALK_RIGHT;\n                else if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right) next_state = WALK_LEFT;\n                else if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground) next_state = WALK_LEFT; // Resume previous direction\n                else next_state = FALLING;\n            end\n            DIGGING: begin\n                if (ground) next_state = WALK_LEFT; // Resume previous direction\n                else next_state = DIGGING;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n    \n    // State register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) state <= WALK_LEFT;\n        else state <= next_state;\n    end\nendmodule\n", "result": "failed: 220 out of 443 samples.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n    \n    // Internal signals\n    reg [7:0] next_hh;\n    reg [7:0] next_mm;\n    reg [7:0] next_ss;\n\n    // Seconds Counter\n    always @(posedge clk) begin\n        if (reset)\n            next_ss <= 8'b0000_0000; // Reset to 00\n        else if (ena)\n            next_ss <= ss + 1; // Increment ss\n        else\n            next_ss <= ss; // Hold current value\n        \n        // Roll-over check\n        if (next_ss == 8'd59) \n            next_mm <= mm + 1; // Increment mm when ss rolls over\n    end\n\n    // Minutes Counter\n    always @(posedge clk) begin\n        if (reset)\n            next_mm <= 8'b0000_0000; // Reset to 00\n        else if (ena)\n            next_mm <= mm; // Hold current value\n        else\n            next_mm <= mm; // Hold current value\n        \n        // Roll-over check\n        if (next_mm == 8'd59) \n            next_hh <= hh + 1; // Increment hh when mm rolls over\n    end\n\n    // Hours Counter\n    always @(posedge clk) begin\n        if (reset)\n            next_hh <= 8'b0001_0000; // Reset to 01\n        else if (ena)\n            next_hh <= hh; // Hold current value\n        else\n            next_hh <= hh; // Hold current value\n        \n        // Roll-over check\n        if (next_hh == 8'd12) \n            next_hh <= 8'b0001_0000; // Reset to 01 when hh rolls over\n        \n        // Toggle PM indicator\n        if ((next_hh == 8'b0001_0000) && (hh == 8'd12)) \n            pm <= ~pm; // Toggle PM indicator when rolling from 12 to 01\n    end\n\n    // Assign outputs\n    always @(posedge clk) begin\n        if (reset)\n            {hh, mm, ss} <= {8'b0001_0000, 8'b0000_0000, 8'b0000_0000}; // Reset to 12:00 AM\n        else\n            {hh, mm, ss} <= {next_hh, next_mm, next_ss};\n    end\nendmodule\n", "result": "failed: 352412 out of 352413 samples.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    // State definition\n    typedef enum logic [1:0] {WALK_LEFT, WALK_RIGHT, FALLING} state_t;\n    \n    state_t curr_state, next_state;\n\n    // Output signals\n    assign walk_left = (curr_state == WALK_LEFT);\n    assign walk_right = (curr_state == WALK_RIGHT);\n    assign aaah = (curr_state == FALLING);\n\n    // State register\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset)\n            curr_state <= WALK_LEFT;  // Reset to walk left\n        else\n            curr_state <= next_state; // Update state on clock edge\n    end\n\n    // Next state logic\n    always_comb begin\n        unique case (curr_state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (curr_state == WALK_LEFT && bump_right) begin\n                        next_state = WALK_RIGHT;\n                    end else if (curr_state == WALK_RIGHT && bump_left) begin\n                        next_state = WALK_LEFT;\n                    end else begin\n                        next_state = curr_state; // Stay in falling state until ground appears\n                    end\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            default: next_state = WALK_LEFT; // Default to walking left\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\n\t// Internal wires for easier readability\n\twire inc_ones, inc_tens, inc_hundreds, inc_thousands;\n\n\t// Increment logic for each digit\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset)\n\t\t\tq <= 16'b0; // Reset all digits to 0\n\t\telse begin\n\t\t\tif (inc_ones) q[3:0] <= q[3:0] + 1; // Increment the ones digit\n\t\t\tif (inc_tens) q[7:4] <= q[7:4] + 1; // Increment the tens digit\n\t\t\tif (inc_hundreds) q[11:8] <= q[11:8] + 1; // Increment the hundreds digit\n\t\t\tif (inc_thousands) q[15:12] <= q[15:12] + 1; // Increment the thousands digit\n\t\tend\n\tend\n\n\t// Generate the increment signals based on BCD rollover\n\tassign inc_ones = (q[3:0] == 4'b1001); // When ones reach 9\n\tassign inc_tens = (q[7:4] == 4'b1001); // When tens reach 9\n\tassign inc_hundreds = (q[11:8] == 4'b1001); // When hundreds reach 9\n\tassign inc_thousands = (q[15:12] == 4'b1001); // When thousands reach 9\n\n\t// Assign the enable signals based on the increment signals\n\tassign ena[1] = inc_ones;\n\tassign ena[2] = inc_tens;\n\tassign ena[3] = inc_hundreds;\n\nendmodule\n", "result": "failed: 39774 out of 39805 samples.", "passed": false}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        if (sel == 1'b0)\n            out <= a;\n        else\n            out <= b;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\n\nalways @(y or w)\nbegin\n    case(y)\n        3'b000: // State A\n            if(w == 0) begin\n                Y2 <= 1'b0; // Next state B (001), so y[2] = 0\n            end else begin\n                Y2 <= 1'b0; // Stay at A (000), so y[2] = 0\n            end\n        3'b001: // State B\n            if(w == 0) begin\n                Y2 <= 1'b1; // Next state C (010), so y[2] = 1\n            end else begin\n                Y2 <= 1'b1; // Next state D (011), so y[2] = 1\n            end\n        3'b010: // State C\n            if(w == 0) begin\n                Y2 <= 1'b1; // Next state E (100), so y[2] = 1\n            end else begin\n                Y2 <= 1'b1; // Next state D (011), so y[2] = 1\n            end\n        3'b011: // State D\n            if(w == 0) begin\n                Y2 <= 1'b1; // Next state F (101), so y[2] = 1\n            end else begin\n                Y2 <= 1'b0; // Next state A (000), so y[2] = 0\n            end\n        3'b100: // State E\n            if(w == 0) begin\n                Y2 <= 1'b1; // Stay at E (100), so y[2] = 1\n            end else begin\n                Y2 <= 1'b1; // Next state D (011), so y[2] = 1\n            end\n        3'b101: // State F\n            if(w == 0) begin\n                Y2 <= 1'b0; // Next state C (010), so y[2] = 0\n            end else begin\n                Y2 <= 1'b1; // Next state D (011), so y[2] = 1\n            end\n        default: Y2 <= 1'bx; // Default case\n    endcase\nend\n\nendmodule\n", "result": "failed: 20 out of 100 samples.", "passed": false}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\n    // If vibrate_mode is 1, activate the motor and deactivate the ringer\n    // If vibrate_mode is 0, activate the ringer and deactivate the motor\n    assign motor = vibrate_mode & ring;\n    assign ringer = !vibrate_mode & ring;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\t\n\t// Using assign statement for out_assign\n\tassign out_assign = a & b;\n\n\t// Combinational always block for out_alwaysblock\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\n\t// Drive the output to '0'\n\tassign zero = 0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\n    always @(posedge clk or negedge clk) begin\n        if (!clk && a) // Falling edge of clk and a is high\n            q <= ~q;   // Toggle q\n    end\nendmodule\n", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Define states\n    typedef enum logic [1:0] {\n        START = 2'b00,\n        INVERT = 2'b01,\n        ADDONE = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n    reg invert_flag;\n    reg carry_flag;\n\n    // State register\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            state <= START;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            START: begin\n                if (!areset)\n                    next_state = INVERT;\n                else\n                    next_state = START;\n            end\n            INVERT: begin\n                if (invert_flag)\n                    next_state = ADDONE;\n                else\n                    next_state = INVERT;\n            end\n            ADDONE: begin\n                next_state = ADDONE; // Stay in ADDONE until new data starts\n            end\n        endcase\n    end\n\n    // Output generation\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            z <= 1'b0;\n        else\n            case(state)\n                START: z <= 1'b0; // No output during start state\n                INVERT: z <= ~x; // Invert the bit\n                ADDONE: z <= x ^ carry_flag; // Add one by XORing with carry flag\n            endcase\n\n    // Invert flag logic\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            invert_flag <= 1'b0;\n        else if (state == INVERT && x)\n            invert_flag <= 1'b1;\n\n    // Carry flag logic\n    always_ff @(posedge clk or posedge areset)\n        if (areset)\n            carry_flag <= 1'b0;\n        else if (state == ADDONE)\n            carry_flag <= 1'b1; // Propagate carry\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // State encoding: A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11\n    typedef enum {STATE_A, STATE_B, STATE_C, STATE_D} state_t;\n    state_t state, next_state;\n\n    // Register to hold the current state\n    always @(posedge clk or posedge areset)\n        if (areset)\n            state <= STATE_A;  // Asynchronous reset to state A\n        else\n            state <= next_state;  // Update state on rising clock edge\n\n    // Combinational logic to calculate next state\n    always @(*) begin\n        unique case (state)\n            STATE_A: next_state = (in) ? STATE_B : STATE_A;\n            STATE_B: next_state = (in) ? STATE_B : STATE_C;\n            STATE_C: next_state = (in) ? STATE_D : STATE_A;\n            STATE_D: next_state = (in) ? STATE_B : STATE_C;\n            default: next_state = STATE_A;  // Default to A\n        endcase\n    end\n\n    // Output generation based on current state\n    always @(*) begin\n        unique case (state)\n            STATE_A, STATE_B, STATE_C: out = 0;  // Outputs 0 for states A, B, C\n            STATE_D: out = 1;  // Output 1 for state D\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Reversing the byte order of the input vector\n    assign out[7:0] = in[31:24];  // Move the MSB byte to LSB byte position\n    assign out[15:8] = in[23:16]; // Move the third byte to second byte position\n    assign out[23:16] = in[15:8]; // Move the second byte to third byte position\n    assign out[31:24] = in[7:0];  // Move the LSB byte to MSB byte position\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\n\t\n\t// Define the always_ff block for the clocked behavior\n\talways_ff @(posedge clk) begin\n\t\tif (r)\n\t\t\tq <= 1'b0; // Reset output to 0 when r is high\n\t\telse\n\t\t\tq <= d; // Set output to input d when r is low\n\tend\n\t\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    // Step 1: Compute the XOR of x and y\n    wire xor_result;\n    assign xor_result = x ^ y;\n\n    // Step 2: AND the result with x\n    assign z = xor_result & x;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\n\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data; // Load data into q when load is high\n\t\telse if (ena) begin\n\t\t\tcase (amount)\n\t\t\t\t2'b00: q <= {q[62:0], 1'b0}; // Shift left by 1 bit\n\t\t\t\t2'b01: q <= {q[55:0], 8'b0}; // Shift left by 8 bits\n\t\t\t\t2'b10: q <= {{1{q[63]}}, q[63:1]}; // Arithmetic shift right by 1 bit\n\t\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8 bits\n\t\t\t\tdefault: q <= q; // No change if amount is not recognized\n\t\t\tendcase\n\t\tend else\n\t\t\tq <= q; // No change if ena is low\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    \n    // Define the states\n    typedef enum {S0, S1, S2} state_t;\n    state_t curr_state, next_state;\n\n    // State register\n    always @(posedge clk or negedge aresetn)\n        if (!aresetn)\n            curr_state <= S0;\n        else\n            curr_state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (curr_state)\n            S0: next_state = (x == 1'b1) ? S1 : S0;\n            S1: next_state = (x == 1'b0) ? S2 : S1;\n            S2: next_state = (x == 1'b1) ? S1 : S2;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (curr_state == S2) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    // State definition\n    localparam [2:0] A = 3'b000;\n    localparam [2:0] B = 3'b001;\n    localparam [2:0] C = 3'b010;\n    localparam [2:0] D = 3'b011;\n    localparam [2:0] E = 3'b100;\n    localparam [2:0] F = 3'b101;\n\n    // Current state register\n    reg [2:0] current_state;\n\n    // Next state logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset state to A\n        else\n            case(current_state)\n                A: if (w == 0) current_state <= B;\n                   else current_state <= A;\n                B: if (w == 0) current_state <= C;\n                   else current_state <= D;\n                C: if (w == 0) current_state <= E;\n                   else current_state <= D;\n                D: if (w == 0) current_state <= F;\n                   else current_state <= A;\n                E: current_state <= E; // Stay in E\n                F: if (w == 0) current_state <= C;\n                   else current_state <= D;\n                default: current_state <= A; // Default to A if undefined\n            endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(current_state)\n            E: z = 1; // Set z to 1 when in state E\n            default: z = 0; // Otherwise, z is 0\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    \n    // States definition\n    typedef enum logic [2:0] {\n        IDLE,\n        RECEIVING_BYTE_1,\n        RECEIVING_BYTE_2,\n        RECEIVING_BYTE_3,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n    reg [7:0] byte_buffer[2:0]; // Buffer to hold the last three bytes\n    \n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic\n    always_comb begin\n        case(state)\n            IDLE: begin\n                if (in[3])\n                    next_state = RECEIVING_BYTE_1;\n                else\n                    next_state = IDLE;\n            end\n            RECEIVING_BYTE_1: begin\n                next_state = RECEIVING_BYTE_2;\n            end\n            RECEIVING_BYTE_2: begin\n                next_state = RECEIVING_BYTE_3;\n            end\n            RECEIVING_BYTE_3: begin\n                next_state = DONE;\n            end\n            DEFAULT: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Output logic\n    always_ff @(posedge clk) begin\n        case(state)\n            IDLE: begin\n                done <= 0;\n                out_bytes <= 0;\n            end\n            RECEIVING_BYTE_1: begin\n                byte_buffer[0] <= in;\n                done <= 0;\n                out_bytes <= 0;\n            end\n            RECEIVING_BYTE_2: begin\n                byte_buffer[1] <= in;\n                done <= 0;\n                out_bytes <= {byte_buffer[0], byte_buffer[1]};\n            end\n            RECEIVING_BYTE_3: begin\n                byte_buffer[2] <= in;\n                done <= 1;\n                out_bytes <= {byte_buffer[0], byte_buffer[1], byte_buffer[2]};\n            end\n            DONE: begin\n                done <= 1;\n                out_bytes <= {byte_buffer[0], byte_buffer[1], byte_buffer[2]};\n            end\n            DEFAULT: begin\n                done <= 0;\n                out_bytes <= 0;\n            end\n        endcase\n    end\n    \nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    \n    // Determine Y1\n    assign Y1 = (y == 6'b000001) ? w : 0;\n    \n    // Determine Y3\n    assign Y3 = (y == 6'b000010 || y == 6'b000100 || y == 6'b001000 || y == 6'b010000 || y == 6'b100000) ? w : 0;\n\nendmodule\n", "result": "failed: 390 out of 600 samples.", "passed": false}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\n    // Assign the input vector to the output vector\n    always @(*) begin\n        outv = vec;\n    end\n    \n    // Assign each bit of the input vector to the corresponding output\n    assign o2 = vec[2];\n    assign o1 = vec[1];\n    assign o0 = vec[0];\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tout = ~a | ~b; // Simplified expression based on Karnaugh map\n\tend\n\t\nendmodule\n", "result": "failed: 126 out of 232 samples.", "passed": false}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\n    // Assign the upper 8 bits to out_hi\n    assign out_hi = in[15:8];\n    \n    // Assign the lower 8 bits to out_lo\n    assign out_lo = in[7:0];\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Compute the NOR of inputs a and b\n    assign out = ~(a | b); \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\t// Using assign statement for immediate computation\n\tassign out_assign = a ^ b;\n\n\t// Combinational always block\n\talways @(*) begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\t// Clocked always block with flip-flop\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\n    // Assignments for Y2 and Y4 based on the derived logic equations\n    assign Y2 = (y[1] & ~w) | (y[2] & ~w) | (y[3] & ~w) | (y[5] & ~w);\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[4] & w) | (y[5] & w);\nendmodule\n", "result": "failed: 270 out of 600 samples.", "passed": false}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\n\t\n\t// Assign the selected bit from the input vector to the output\n\talways @(*) begin\n\t\tout = in[sel];\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\n    // Internal signal to select between R, w, and Q for the D input of the flip-flop\n    reg d;\n\n    always @(posedge clk) begin\n        // Determine the input to the D flip-flop\n        case ({L, E})\n            2'b00: d <= Q;           // Hold current value if neither L nor E is high\n            2'b01: d <= w;           // Shift in w if E is high and L is low\n            2'b10: d <= R;           // Load R if L is high and E is low\n            2'b11: d <= R;           // Load R if both L and E are high (L takes precedence)\n        endcase\n\n        // Update the output Q with the new value of d\n        Q <= d;\n    end\nendmodule\n", "result": "failed: 64 out of 200 samples.", "passed": false}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    // Declare internal wires\n    wire dff_input1, dff_input2, dff_input3;\n    reg q1, q2, q3;\n\n    // XOR gate for first DFF\n    assign dff_input1 = x ^ q1;\n    \n    // AND gate for second DFF\n    assign dff_input2 = x & ~q2;\n    \n    // OR gate for third DFF\n    assign dff_input3 = x | ~q3;\n    \n    // D flip-flops\n    always @(posedge clk) begin\n        q1 <= dff_input1;\n        q2 <= dff_input2;\n        q3 <= dff_input3;\n    end\n    \n    // Three-input XNOR gate\n    assign z = ~(q1 ^ q2 ^ q3);\nendmodule\n", "result": "failed: 118 out of 118 samples.", "passed": false}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    \n    // Case when a is 0\n    wire q_a0;\n    assign q_a0 = (b == 0) ? d : 1'b1;\n\n    // Case when a is 1\n    wire q_a1;\n    assign q_a1 = (b == 0) ? c : 1'b1;\n\n    // Final output q combines both cases\n    assign q = (a == 0) ? q_a0 : q_a1;\n\nendmodule\n", "result": "failed: 18 out of 121 samples.", "passed": false}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n\n    // Initialize the system when load is high\n    always @(posedge clk or posedge load) begin\n        if (load)\n            q <= data;\n    end\n\n    // Advance the state every clock cycle\n    always @(posedge clk) begin\n        // Temporary storage for the new state\n        reg [511:0] next_state;\n\n        // Compute the new state for each cell\n        for (int i = 0; i < 512; i++) begin\n            // Treat q[-1] and q[512] as 0\n            reg left, center, right;\n            left = (i == 0) ? 0 : q[i - 1];\n            center = q[i];\n            right = (i == 511) ? 0 : q[i + 1];\n\n            // Apply Rule 110\n            case ({left, center, right})\n                3'b111: next_state[i] = 0;\n                3'b110: next_state[i] = 1;\n                3'b101: next_state[i] = 1;\n                3'b100: next_state[i] = 0;\n                3'b011: next_state[i] = 1;\n                3'b010: next_state[i] = 1;\n                3'b001: next_state[i] = 1;\n                default: next_state[i] = 0;\n            endcase\n        end\n\n        // Assign the computed new state to q\n        q <= next_state;\n    end\nendmodule\n", "result": "failed: 6234 out of 6283 samples.", "passed": false}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n\t\n\treg [1:0] state, next_state;\n\n\t// State encoding\n\tlocalparam STATE_A = 2'b00;\n\tlocalparam STATE_B = 2'b01;\n\tlocalparam STATE_C = 2'b10;\n\tlocalparam STATE_D = 2'b11;\n\n\t// Next state logic\n\talways @(state or in) begin\n\t\tcase(state)\n\t\t\tSTATE_A: next_state = (in == 1'b0) ? STATE_A : STATE_B;\n\t\t\tSTATE_B: next_state = (in == 1'b0) ? STATE_C : STATE_B;\n\t\t\tSTATE_C: next_state = (in == 1'b0) ? STATE_A : STATE_D;\n\t\t\tSTATE_D: next_state = (in == 1'b0) ? STATE_C : STATE_B;\n\t\t\tdefault: next_state = STATE_A; // Safe default\n\t\tendcase\n\tend\n\n\t// Output logic\n\talways @(state) begin\n\t\tcase(state)\n\t\t\tSTATE_D: out = 1'b1;\n\t\t\tdefault: out = 1'b0;\n\t\tendcase\n\tend\n\n\t// Synchronous reset and state register\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tstate <= STATE_A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tcase(c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'b1111; // Assigning 15 (binary 1111) to q when c >= 4\n\t\tendcase\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": "\n\n    reg temp;\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            // Compute the new value of Q[2]\n            temp <= q_in[1] ^ q_in[2];\n            // Update Q with the new values\n            Q <= {temp, q_in[0], q_in[2]};\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\n    // Register to hold the previous input value\n    reg [31:0] prev_in;\n    \n    // Register to hold the output value\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            prev_in <= 0;\n            out <= 0;\n        end else begin\n            prev_in <= in;  // Update previous input value\n            for (int i = 0; i < 32; i = i + 1) begin\n                if (prev_in[i] == 1 && in[i] == 0) begin\n                    out[i] <= 1;  // Set output bit if transition detected\n                end else if (out[i] == 1 && in[i] == 1) begin\n                    out[i] <= 0;  // Clear output bit if current bit is 1 again\n                end\n            end\n        end\n    end\nendmodule\n", "result": "failed: 219 out of 266 samples.", "passed": false}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n", "result": "failed: 1 out of 41 samples.", "passed": false}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n\t// Compute the sum\n\tassign {overflow, s} = a + b;\n\nendmodule\n", "result": "failed: 55 out of 116 samples.", "passed": false}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n\n// State variables\nwire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n\nassign {S, S1, S11, S110, B0, B1, B2, B3, Count, Wait} = state;\n\n// Next state logic\nassign S_next = ~d & S | d & ~S1;\nassign S1_next = d & S | ~d & S1;\nassign B3_next = B2;\nassign Count_next = ~done_counting & Count;\nassign Wait_next = ~ack & Wait;\n\n// Output logic\nassign done = Wait;\nassign counting = Count;\nassign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule\n", "result": "failed: 3198 out of 3303 samples.", "passed": false}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    \n    // Internal signal for next state\n    logic [1:0] next_state;\n\n    // Determine next state based on train_taken and train_valid\n    always_comb begin\n        // Default behavior: keep current state\n        next_state = state;\n        \n        // Increment the counter if train_taken is 1 and train_valid is 1\n        if (train_valid && train_taken)\n            next_state = state + 1;\n        \n        // Decrement the counter if train_taken is 0 and train_valid is 1\n        else if (train_valid && !train_taken)\n            next_state = state - 1;\n        \n        // Saturate at max (3 - '11')\n        if (next_state > 2'b11)\n            next_state = 2'b11;\n        \n        // Saturate at min (0 - '00')\n        if (next_state < 2'b00)\n            next_state = 2'b00;\n    end\n\n    // Asynchronous reset\n    always_ff @(posedge clk or negedge areset) begin\n        if (!areset)\n            state <= 2'b01; // Weakly not-taken\n        else\n            state <= next_state;\n    end\n    \nendmodule\n", "result": "failed: 765 out of 1051 samples.", "passed": false}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    // Initialize pos to 0\n    always @(*) begin\n        pos = 3'b0;\n        if (in[0]) pos = 3'b0;   // Check bit 0\n        else if (in[1]) pos = 3'b1; // Check bit 1\n        else if (in[2]) pos = 3'b10; // Check bit 2\n        else if (in[3]) pos = 3'b11; // Check bit 3\n        else if (in[4]) pos = 3'b100; // Check bit 4\n        else if (in[5]) pos = 3'b101; // Check bit 5\n        else if (in[6]) pos = 3'b110; // Check bit 6\n        else if (in[7]) pos = 3'b111; // Check bit 7\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\n\nalways @(*) begin\n\t// Initialize all outputs to 0\n\tleft = 0;\n\tdown = 0;\n\tright = 0;\n\tup = 0;\n\n\t// Check for each scancode and set the corresponding output\n\tif (scancode == 16'hE06B) begin // Left arrow\n\t\tleft = 1;\n\tend else if (scancode == 16'hE072) begin // Down arrow\n\t\tdown = 1;\n\tend else if (scancode == 16'hE074) begin // Right arrow\n\t\tright = 1;\n\tend else if (scancode == 16'hE075) begin // Up arrow\n\t\tup = 1;\n\tend\nend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\n    wire c1, c2, c3;\n\n    // Full Adder for bit 0\n    full_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .s(sum[0]), .cout(c1));\n\n    // Full Adder for bit 1\n    full_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .s(sum[1]), .cout(c2));\n\n    // Full Adder for bit 2\n    full_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .s(sum[2]), .cout(c3));\n\n    // Full Adder for bit 3\n    full_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .s(sum[3]), .cout(sum[4]));\n\nendmodule\n\n// Full Adder module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output reg s,\n    output reg cout\n);\n    always @(*) begin\n        s = a ^ b ^ cin;\n        cout = (a & b) | (cin & (a ^ b));\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    // Internal signal to hold the shifted value\n    logic [30:0] shifted_history;\n\n    // Handle reset condition\n    always_ff @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            predict_history <= 32'b0;\n        else\n        begin\n            // Determine whether to handle misprediction or prediction\n            if (train_mispredicted)\n                predict_history <= {train_history, train_taken};\n            else if (predict_valid)\n                predict_history <= {shifted_history, predict_taken};\n        end\n    end\n\n    // Shift the history register to make room for the new bit\n    always_comb\n    begin\n        shifted_history = predict_history[30:0];\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n    // Declare intermediate wires\n    wire and_out_1;\n    wire and_out_2;\n\n    // AND gate for inputs a and b\n    assign and_out_1 = a & b;\n\n    // AND gate for inputs c and d\n    assign and_out_2 = c & d;\n\n    // OR gate to combine the outputs of the AND gates\n    assign out = and_out_1 | and_out_2;\n\n    // Invert the output 'out' to get 'out_n'\n    assign out_n = ~out;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    // Rising edge detection\n    always @(posedge clk) begin\n        // On the rising edge of the clock, assign the input 'd' to the output 'q'\n        q <= d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n    \n    // Internal registers to hold the 8-bit shift register data\n    reg [7:0] shift_reg;\n\n    // Always block to handle the shift register operation\n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift in new data at the MSB (left shift)\n            shift_reg <= {S, shift_reg[7:1]};\n        end\n    end\n\n    // Output selection based on A, B, C inputs\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_reg[0]; // Select Q[0]\n            3'b001: Z = shift_reg[1]; // Select Q[1]\n            3'b010: Z = shift_reg[2]; // Select Q[2]\n            3'b011: Z = shift_reg[3]; // Select Q[3]\n            3'b100: Z = shift_reg[4]; // Select Q[4]\n            3'b101: Z = shift_reg[5]; // Select Q[5]\n            3'b110: Z = shift_reg[6]; // Select Q[6]\n            3'b111: Z = shift_reg[7]; // Select Q[7]\n            default: Z = 1'b0;        // Default case (optional)\n        endcase\n    end\n    \nendmodule\n", "result": "failed: 263 out of 530 samples.", "passed": false}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n    // Determine heater status based on mode and temperature\n    assign heater = (mode && too_cold);  // Heater is ON if mode is heating and it's too cold\n\n    // Determine air conditioner status based on mode and temperature\n    assign aircon = (!mode && too_hot);  // Air conditioner is ON if mode is cooling and it's too hot\n\n    // Determine fan status based on heater, air conditioner, and fan_on\n    assign fan = (heater || aircon || fan_on);  // Fan is ON if heater or air conditioner is ON, or if fan_on is set\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\n\t\n\t// Minimum Sum of Products (SOP)\n\tassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\t\n\t// Minimum Product of Sums (POS)\n\tassign out_pos = (a | b | c | d) & (a | b | c | ~d) & (a | b | ~c | d) &\n\t                 (a | b | ~c | ~d) & (a | ~b | c | d) & (~a | b | c | d) &\n\t                 (~a | b | c | ~d) & (~a | ~b | c | d);\nendmodule\n", "result": "failed: 64 out of 107 samples.", "passed": false}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tq <= 32'h1; // Initialize to 32'h1 when reset is asserted\n\t\telse\n\t\t\tq <= {q[30:0], ~(^{q[31], q[21], q[1], q[0]})}; // Update the state based on the taps\n\tend\n\nendmodule\n", "result": "failed: 400356 out of 400411 samples.", "passed": false}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    // Output q is the logical OR of b and d\n    assign q = b | d;\nendmodule\n", "result": "failed: 34 out of 121 samples.", "passed": false}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\t// Implementing the first 4-input NAND gate\n\twire and1;\n\tand and1_gate(p1y, ~and1, p1a, p1b, p1c, p1d);\n\t\n\t// Implementing the second 4-input NAND gate\n\twire and2;\n\tand and2_gate(p2y, ~and2, p2a, p2b, p2c, p2d);\nendmodule\n", "result": "failed: 239 out of 239 samples.", "passed": false}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\n    // Define intermediate signals for counting\n    wire [254:0] level1;\n    wire [126:0] level2;\n    wire [62:0] level3;\n    wire [30:0] level4;\n    wire [14:0] level5;\n    wire [6:0] level6;\n    wire [2:0] level7;\n    wire [0:0] level8;\n\n    // Level 1: Pairwise sum of 2 bits\n    genvar i;\n    generate\n        for (i = 0; i < 127; i = i + 1) begin : level1_gen\n            assign level1[2*i+1] = in[2*i] + in[2*i+1];\n        end\n    endgenerate\n\n    // Level 2: Pairwise sum of 4 bits\n    generate\n        for (i = 0; i < 63; i = i + 1) begin : level2_gen\n            assign level2[i] = level1[2*i] + level1[2*i+1];\n        end\n    endgenerate\n\n    // Level 3: Pairwise sum of 8 bits\n    generate\n        for (i = 0; i < 31; i = i + 1) begin : level3_gen\n            assign level3[i] = level2[2*i] + level2[2*i+1];\n        end\n    endgenerate\n\n    // Level 4: Pairwise sum of 16 bits\n    generate\n        for (i = 0; i < 15; i = i + 1) begin : level4_gen\n            assign level4[i] = level3[2*i] + level3[2*i+1];\n        end\n    endgenerate\n\n    // Level 5: Pairwise sum of 32 bits\n    generate\n        for (i = 0; i < 7; i = i + 1) begin : level5_gen\n            assign level5[i] = level4[2*i] + level4[2*i+1];\n        end\n    endgenerate\n\n    // Level 6: Pairwise sum of 64 bits\n    generate\n        for (i = 0; i < 3; i = i + 1) begin : level6_gen\n            assign level6[i] = level5[2*i] + level5[2*i+1];\n        end\n    endgenerate\n\n    // Level 7: Pairwise sum of 128 bits\n    generate\n        for (i = 0; i < 1; i = i + 1) begin : level7_gen\n            assign level7[i] = level6[2*i] + level6[2*i+1];\n        end\n    endgenerate\n\n    // Final sum of remaining bits\n    assign out = {level7[0], level5[7], level3[31], level1[254]};\nendmodule\n", "result": "failed: 215 out of 215 samples.", "passed": false}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    // out_both: Both bits are '1'\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // out_any: Either bit is '1'\n    assign out_any[3] = in[3] | in[0];\n    assign out_any[2] = in[2] | in[3];\n    assign out_any[1] = in[1] | in[2];\n\n    // out_different: Bits are different\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "result": "failed: 109 out of 213 samples.", "passed": false}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @(*) begin\n    case(a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx; // This line is optional but good for handling unexpected inputs.\n    endcase\nend\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    // State variable to hold the current count\n    reg [3:0] next_q;\n\n    // On the rising edge of the clock\n    always @(posedge clk) begin\n        // Synchronous reset\n        if (reset) begin\n            q <= 4'b0;\n        end else begin\n            // Update the output only if slowena is high\n            if (slowena) begin\n                q <= next_q;\n            end else begin\n                // If not paused, keep the current value\n                q <= q;\n            end\n        end\n    end\n\n    // Calculate the next state based on the current state\n    always @(*) begin\n        if (q == 4'b1001) begin\n            // Wrap around from 9 to 0\n            next_q = 4'b0000;\n        end else begin\n            // Otherwise, increment the counter\n            next_q = q + 1;\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\tlogic inverted_in2;\n\n\t// Invert in2\n\tassign inverted_in2 = ~in2;\n\n\t// Perform AND operation between in1 and inverted_in2\n\tassign out = in1 & inverted_in2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n    // Directly assign the input 'in' to the output 'out'\n    assign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    // Define the states\n    typedef enum logic [1:0] {B, A} state_t;\n    state_t current_state, next_state;\n\n    // Output assignment based on the current state\n    assign out = (current_state == A) ? 1'b1 : 1'b0;\n\n    // State register\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= B;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        unique case (current_state)\n            B: if (in == 1'b0) next_state = A; else next_state = B;\n            A: if (in == 1'b0) next_state = B; else next_state = A;\n            default: next_state = B;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\n    \n    // Intermediate signals to store the input 'd' on each edge\n    reg q_posedge;\n    reg q_negedge;\n\n    // Positive edge triggered flip-flop\n    always @(posedge clk) begin\n        q_posedge <= d;\n    end\n\n    // Negative edge triggered flip-flop\n    always @(negedge clk) begin\n        q_negedge <= d;\n    end\n\n    // Output 'q' is the OR combination of the two intermediate signals\n    assign q = q_posedge | q_negedge;\n\nendmodule\n", "result": "failed: 47 out of 224 samples.", "passed": false}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Using logical equivalence for XNOR gate\n    assign out = (a & b) | (~a & ~b);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n    // Define intermediate wires\n    wire a1_out, b1_out, or_out;\n    wire a2_out, b2_out, and_out;\n\n    // Instantiate module A for the first pair\n    module_a a1 (\n        .x(x),\n        .y(y),\n        .z(a1_out)\n    );\n\n    // Instantiate module B for the first pair\n    module_b b1 (\n        .x(x),\n        .y(y),\n        .z(b1_out)\n    );\n\n    // Instantiate module A for the second pair\n    module_a a2 (\n        .x(x),\n        .y(y),\n        .z(a2_out)\n    );\n\n    // Instantiate module B for the second pair\n    module_b b2 (\n        .x(x),\n        .y(y),\n        .z(b2_out)\n    );\n\n    // OR gate for the first pair\n    assign or_out = a1_out | b1_out;\n\n    // AND gate for the second pair\n    assign and_out = a2_out & b2_out;\n\n    // XOR gate for final output\n    assign z = or_out ^ and_out;\n\nendmodule\n\n// Define module A\nmodule module_a(\n    input x,\n    input y,\n    output reg z\n);\n    always @(x, y) begin\n        z = (x ^ y) & x;\n    end\nendmodule\n\n// Define module B\nmodule module_b(\n    input x,\n    input y,\n    output reg z\n);\n    always @(x, y) begin\n        if (x == 0 && y == 0)\n            z = 1;\n        else\n            z = 0;\n    end\nendmodule\n", "result": "failed: 44 out of 200 samples.", "passed": false}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n    \n    always @(posedge clk) begin\n        case (ena)\n            2'b01: // Right rotation\n                if (load) q <= data;\n                else q <= {q[0], q[99:1]};\n            2'b10: // Left rotation\n                if (load) q <= data;\n                else q <= {q[98:0], q[99]};\n            default: // No rotation\n                if (load) q <= data;\n        endcase\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 10'b0;\n        else begin\n            if (q == 10'd999)\n                q <= 10'b0;\n            else\n                q <= q + 1;\n        end\n    end\nendmodule\n", "result": "failed: 834 out of 8027 samples.", "passed": false}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\n\t// Invert the input signal and assign it to the output\n\tassign out = ~in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n\t// Determine the next state based on current state and input\n\tassign next_state = (state == 10'b0000000001) ? (in ? 10'b0000000010 : 10'b0000000001) :\n\t                    (state == 10'b0000000010) ? (in ? 10'b0000000100 : 10'b0000000001) :\n\t                    (state == 10'b0000000100) ? (in ? 10'b0000001000 : 10'b0000000001) :\n\t                    (state == 10'b0000001000) ? (in ? 10'b0000010000 : 10'b0000000001) :\n\t                    (state == 10'b0000010000) ? (in ? 10'b0000100000 : 10'b0000000001) :\n\t                    (state == 10'b0000100000) ? (in ? 10'b0001000000 : 10'b0000000001) :\n\t                    (state == 10'b0001000000) ? (in ? 10'b0010000000 : 10'b0000000001) :\n\t                    (state == 10'b0010000000) ? (in ? 10'b0100000000 : 10'b0000000001) :\n\t                    (state == 10'b0100000000) ? (in ? 10'b1000000000 : 10'b0000000001) :\n\t                    (state == 10'b1000000000) ? (in ? 10'b0000000001 : 10'b0000000001) : 10'b0000000001;\n\n\t// Determine the outputs based on the current state\n\tassign out1 = |(state & 10'b0000000000); // No state sets out1\n\tassign out2 = |(state & 10'b00000000100000); // S7 sets out2\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\n    // State variable to hold the current value of Q\n    reg Q_next;\n\n    // Combinational logic to calculate the next state\n    always @(*) begin\n        case ({j, k})\n            2'b00: Q_next = Q;  // No change\n            2'b01: Q_next = 1'b0;  // Reset (set Q to 0)\n            2'b10: Q_next = 1'b1;  // Set (set Q to 1)\n            2'b11: Q_next = ~Q;  // Toggle (invert Q)\n        endcase\n    end\n\n    // Sequential logic to update the state on the positive edge of the clock\n    always @(posedge clk) begin\n        Q <= Q_next;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\t// Logic to count the number of '1's in the input vector\n\twire and_all = &in; // This wire will be high if all inputs are '1'\n\twire or_two = (in[0] & in[1]) | (in[0] & in[2]) | (in[1] & in[2]); // This wire will be high if exactly two inputs are '1'\n\twire or_one = in[0] ^ in[1] ^ in[2]; // This wire will be high if exactly one input is '1'\n\n\tassign out = {and_all, or_two} + {or_two, or_one}; // Summing up the counts\nendmodule\n", "result": "failed: 119 out of 220 samples.", "passed": false}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n    // Self comparisons\n    assign out[24] = ~a ^ a; // Always 0\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n\n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b; // Always 0\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n\n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c; // Always 0\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n\n    assign out[ 9] = ~d ^ a;\n    assign out[ 8] = ~d ^ b;\n    assign out[ 7] = ~d ^ c;\n    assign out[ 6] = ~d ^ d; // Always 0\n    assign out[ 5] = ~d ^ e;\n\n    assign out[ 4] = ~e ^ a;\n    assign out[ 3] = ~e ^ b;\n    assign out[ 2] = ~e ^ c;\n    assign out[ 1] = ~e ^ d;\n    assign out[ 0] = ~e ^ e; // Always 0\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\t\n\t// Define states\n\tlocalparam STATE_LEFT = 2'b00;\n\tlocalparam STATE_RIGHT = 2'b01;\n\n\t// Internal state variable\n\treg [1:0] state;\n\n\t// Output assignments based on state\n\tassign walk_left = (state == STATE_LEFT);\n\tassign walk_right = (state == STATE_RIGHT);\n\n\t// State register\n\talways @(posedge clk or posedge areset)\n\tbegin\n\t\tif (areset)\n\t\t\tstate <= STATE_LEFT; // Reset to left\n\t\telse\n\t\tbegin\n\t\t\tcase ({bump_left, bump_right})\n\t\t\t\t2'b00: state <= state; // No bump, stay in current state\n\t\t\t\t2'b01: state <= STATE_LEFT; // Bumped right, go left\n\t\t\t\t2'b10: state <= STATE_RIGHT; // Bumped left, go right\n\t\t\t\t2'b11: begin\n\t\t\t\t\tif (state == STATE_LEFT)\n\t\t\t\t\t\tstate <= STATE_RIGHT; // Both bumps, but currently left, go right\n\t\t\t\t\telse\n\t\t\t\t\t\tstate <= STATE_LEFT; // Both bumps, but currently right, go left\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\n\tassign q = a & b; // Combinational logic to compute the output q based on inputs a and b using the AND operation.\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n    // Intermediate signals for AND gate outputs\n    wire and_p1_1;\n    wire and_p1_2;\n    wire and_p2_1;\n    wire and_p2_2;\n\n    // AND gate implementations for p1y\n    assign and_p1_1 = p1a & p1b & p1c;  // First 3-input AND gate\n    assign and_p1_2 = p1d & p1e & p1f;  // Second 3-input AND gate\n\n    // OR gate implementation for p1y\n    assign p1y = and_p1_1 | and_p1_2;\n\n    // AND gate implementations for p2y\n    assign and_p2_1 = p2a & p2b;        // First 2-input AND gate\n    assign and_p2_2 = p2c & p2d;        // Second 2-input AND gate\n\n    // OR gate implementation for p2y\n    assign p2y = and_p2_1 | and_p2_2;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\n    reg [2:0] Y;\n\n    always @(posedge clk) begin\n        case ({y, x})\n            4'b0000: {Y, z} <= 4'b0000;\n            4'b0001: {Y, z} <= 4'b0010;\n            4'b0010: {Y, z} <= 4'b0010;\n            4'b0011: {Y, z} <= 4'b1000;\n            4'b0100: {Y, z} <= 4'b0100;\n            4'b0101: {Y, z} <= 4'b0010;\n            4'b0110: {Y, z} <= 4'b0011;\n            4'b0111: {Y, z} <= 4'b0101;\n            4'b1000: {Y, z} <= 4'b0111;\n            4'b1001: {Y, z} <= 4'b1001;\n            default: {Y, z} <= 4'b0000;\n        endcase\n    end\n\n    assign Y0 = Y[0];\nendmodule\n", "result": "failed: 86 out of 200 samples.", "passed": false}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n    // Implementing the NOR gate using the nor keyword\n    nor(out, in1, in2);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n    // Assigning inputs to outputs based on the requirements\n    assign w = a;\n    assign x = b;\n    assign y = b;\n    assign z = c;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (ar == 1'b0)\n            q <= 1'b0; // Asynchronous reset\n        else\n            q <= d; // Capture the input 'd' on the rising edge of the clock\n    end\nendmodule\n", "result": "failed: 30 out of 100 samples.", "passed": false}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0;\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\n    reg [9:0] count;\n\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;\n            tc <= 0; // Reset terminal count when loading new value\n        end else if (count > 0) begin\n            count <= count - 1;\n        end else begin\n            tc <= 1; // Assert terminal count when count reaches 0\n        end\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n    \n    // State definition\n    typedef enum logic [2:0] {\n        S0 = 3'b000, // Initial state or no match\n        S1 = 3'b001, // Seen 1\n        S2 = 3'b010, // Seen 11\n        S3 = 3'b011, // Seen 110\n        S4 = 3'b100  // Detected 1101\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk, posedge reset) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            S0: next_state = (data == 1) ? S1 : S0;\n            S1: next_state = (data == 1) ? S2 : S0;\n            S2: next_state = (data == 1) ? S3 : S1;\n            S3: next_state = (data == 1) ? S4 : S2;\n            S4: next_state = S4; // Stay in S4 when 1101 is detected\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    assign start_shifting = (state == S4) || reset;\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    // Always block for D flip-flops\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Set all q to 0 when reset is high\n            q <= 8'b0;\n        end else begin\n            // On rising edge of clk, load the value of d into q\n            q <= d;\n        end\n    end\nendmodule\n", "result": "failed: 41 out of 432 samples.", "passed": false}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\n    // Register to store the previous state of 'in'\n    reg [7:0] prev_in;\n\n    // At every clock edge, update 'prev_in' with the current state of 'in'\n    always @(posedge clk) begin\n        prev_in <= in;\n    end\n\n    // Detect rising edges and assign the result to 'anyedge'\n    always @(posedge clk) begin\n        anyedge <= {in[7], in[6], in[5], in[4], in[3], in[2], in[1], in[0]} ^ {prev_in[7], prev_in[6], prev_in[5], prev_in[4], prev_in[3], prev_in[2], prev_in[1], prev_in[0]};\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    // Internal register for counting\n    reg [3:0] count;\n\n    // Synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0001;  // Reset to 1 when reset is high\n        else\n            count <= count + 1;  // Increment the count on every clock cycle\n    end\n\n    // Assign the output to the internal counter\n    assign q = count;\n\n    // Reset condition to ensure the counter doesn't overflow past 10\n    always @(posedge clk) begin\n        if (count == 4'b1010)  // When count reaches 10 (binary 1010)\n            count <= 4'b0001;  // Reset back to 1\n    end\n\nendmodule\n", "result": "failed: 185 out of 439 samples.", "passed": false}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    // Detecting the rising edge of clk\n    reg clk_rise;\n    always @(posedge clk) begin\n        clk_rise <= 1'b1;\n    end\n    \n    // Detecting the transition of a from 1 to 0\n    reg a_prev;\n    always @(posedge clk) begin\n        a_prev <= a;\n    end\n    \n    always @(posedge clk) begin\n        if (clk_rise && a_prev == 1'b1 && a == 1'b0) begin\n            // Increment q\n            q <= q + 1;\n            // Reset q to 0 when it reaches 7 (binary 111)\n            if (q == 3'b111) begin\n                q <= 3'b000;\n            end\n        end\n    end\n\nendmodule\n", "result": "failed: 244 out of 245 samples.", "passed": false}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\n    \n    // Internal signal for feedback\n    reg feedback;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 5'b00001; // Reset to 1 (00001 in binary)\n        else begin\n            // Compute the feedback bit\n            feedback = q[4] ^ q[2]; // XOR the MSB (q[4]) and the third bit (q[2])\n            \n            // Shift the register to the right and insert the feedback bit into the MSB\n            q <= {feedback, q[4:1]};\n        end\n    end\n\nendmodule\n", "result": "failed: 4412 out of 4443 samples.", "passed": false}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(do_sub, a, b) begin\n        // Calculate the output based on the value of do_sub\n        if (do_sub == 1'b0) begin\n            out <= a + b;\n        end else begin\n            out <= a - b;\n        end\n        \n        // Check if the output is zero\n        if (out == 8'b0) begin\n            result_is_zero <= 1'b1;\n        end else begin\n            result_is_zero <= 1'b0;\n        end\n    end\nendmodule\n", "result": "failed: 6 out of 118 samples.", "passed": false}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    \n    // Simplified Boolean expression from the K-map\n    assign f = (x[4] & x[3]) | (~x[3]);\n    \nendmodule\n", "result": "failed: 27 out of 100 samples.", "passed": false}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\n    always @(*) begin\n        valid = 0;\n        out = 4'b0000; // Initialize out to 0\n        \n        case (code)\n            8'h45: begin // Key '0'\n                out = 4'b0000;\n                valid = 1;\n            end\n            8'h16: begin // Key '1'\n                out = 4'b0001;\n                valid = 1;\n            end\n            8'h1e: begin // Key '2'\n                out = 4'b0010;\n                valid = 1;\n            end\n            8'h26: begin // Key '3'\n                out = 4'b0011;\n                valid = 1;\n            end\n            8'h25: begin // Key '4'\n                out = 4'b0100;\n                valid = 1;\n            end\n            8'h2e: begin // Key '5'\n                out = 4'b0101;\n                valid = 1;\n            end\n            8'h36: begin // Key '6'\n                out = 4'b0110;\n                valid = 1;\n            end\n            8'h3d: begin // Key '7'\n                out = 4'b0111;\n                valid = 1;\n            end\n            8'h3e: begin // Key '8'\n                out = 4'b1000;\n                valid = 1;\n            end\n            8'h46: begin // Key '9'\n                out = 4'b1001;\n                valid = 1;\n            end\n            default: begin // No match, do nothing\n            end\n        endcase\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\n    // Map each bit of 'in' to its corresponding reversed position in 'out'\n    always @(*) begin\n        out[0] = in[7];\n        out[1] = in[6];\n        out[2] = in[5];\n        out[3] = in[4];\n        out[4] = in[3];\n        out[5] = in[2];\n        out[6] = in[1];\n        out[7] = in[0];\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\n\t\n\talways @(*) begin\n\t\tout = c ^ d; // XOR operation between c and d\n\tend\n\t\nendmodule\n", "result": "failed: 133 out of 232 samples.", "passed": false}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift operation: MSB = data, others shift right\n            q <= {data, q[3:1]};\n        end else if (count_ena) begin\n            // Count down operation: Decrement by 1, avoid underflow\n            q <= q - 1'b1;\n        end\n    end\nendmodule\n", "result": "failed: 1886 out of 2071 samples.", "passed": false}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\t// Directly assign the input to the output\n\tassign out = in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\n    // State definition\n    typedef enum logic [1:0] { IDLE = 2'b00, RESET_ASSERT = 2'b01, RESET_DEASSERT = 2'b10 } state_t;\n    \n    state_t current_state, next_state;\n\n    // Next state logic\n    always_ff @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Output generation\n    always_comb begin\n        case (current_state)\n            IDLE: begin\n                if (reset)\n                    next_state = RESET_ASSERT;\n                else\n                    next_state = IDLE;\n                shift_ena = 1'b0;\n            end\n            RESET_ASSERT: begin\n                if (reset)\n                    next_state = RESET_ASSERT; // Stay in RESET_ASSERT for 4 cycles\n                else\n                    next_state = RESET_DEASSERT;\n                shift_ena = 1'b1;\n            end\n            RESET_DEASSERT: begin\n                if (reset)\n                    next_state = RESET_ASSERT;\n                else\n                    next_state = RESET_DEASSERT;\n                shift_ena = 1'b0;\n            end\n            default: begin\n                next_state = IDLE;\n                shift_ena = 1'b0;\n            end\n        endcase\n    end\n\n    // Counter for 4 clock cycles in RESET_ASSERT state\n    reg [1:0] counter;\n    always_ff @(posedge clk) begin\n        if (reset || current_state != RESET_ASSERT)\n            counter <= 2'b00;\n        else if (counter == 2'b11)\n            counter <= 2'b00;\n        else\n            counter <= counter + 1;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0;  // Synchronous reset\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural if statement for sequential logic\n    always @(a or b or sel_b1 or sel_b2) begin\n        if (sel_b1 & sel_b2)\n            out_always <= b;\n        else\n            out_always <= a;\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\n    // Implement the derived Boolean expression\n    assign out = a | (~b & ~c);\nendmodule\n", "result": "failed: 110 out of 219 samples.", "passed": false}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    \n    // Define state encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Declare state variable\n    state_t state, next_state;\n\n    // Next state logic\n    always_comb begin\n        unique case (state)\n            A: \n                if (r[1]) next_state = B;\n                else if (r[2]) next_state = C;\n                else if (r[3]) next_state = D;\n                else next_state = A;\n            B: \n                if (r[1]) next_state = B;\n                else next_state = A;\n            C: \n                if (r[2]) next_state = C;\n                else next_state = A;\n            D: \n                if (r[3]) next_state = D;\n                else next_state = A;\n            default: next_state = A;\n        endcase\n    end\n    \n    // Output logic\n    always_comb begin\n        g[1] = (state == B) && r[1];\n        g[2] = (state == C) && r[2];\n        g[3] = (state == D) && r[3];\n    end\n    \n    // State register\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) state <= A;\n        else state <= next_state;\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\n    reg [3:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else begin\n            if (count == 4'b1001) begin // 9 in binary\n                count <= 4'b0;          // Reset to 0\n            end else begin\n                count <= count + 1;     // Increment the count\n            end\n        end\n    end\n\n    assign q = count;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    // Define states\n    typedef enum {IDLE, BYTE1, BYTE2, BYTE3, DONE} state_t;\n    state_t state, next_state;\n\n    // Register for storing the current state\n    reg [1:0] state_reg;\n    assign state = state_t'(state_reg);\n\n    // Next state logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state_reg <= IDLE;\n        else\n            state_reg <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        case(state)\n            IDLE: \n                if (in[3])\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            BYTE1:\n                next_state = BYTE2;\n            BYTE2:\n                next_state = BYTE3;\n            BYTE3:\n                next_state = IDLE;\n            default:\n                next_state = IDLE;\n        endcase\n\n        // Output logic\n        case(state)\n            DONE: done = 1;\n            default: done = 0;\n        endcase\n    end\n\n    // Transition to DONE after receiving the third byte\n    always @(posedge clk) begin\n        if (state == BYTE3 && !reset)\n            done <= 1;\n        else if (state == IDLE && !reset)\n            done <= 0;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\n    // Using a ternary operator to select between a and b based on sel\n    assign out = (sel == 1'b0) ? a : b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    // AND operation: all inputs must be 1 for the output to be 1\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    \n    // OR operation: at least one input must be 1 for the output to be 1\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    \n    // XOR operation: the output is 1 if an odd number of inputs are 1\n    assign out_xor = ^in; // The ^ operator performs XOR across all bits of the vector\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    // State definition\n    parameter S0 = 3'b000;\n    parameter S1 = 3'b001;\n    parameter S2 = 3'b010;\n    parameter S3 = 3'b011;\n    parameter S4 = 3'b100;\n\n    // Register to hold the present state\n    reg [2:0] present_state;\n    reg [2:0] next_state;\n\n    // Determine the next state and output z based on the current state and input x\n    always @(present_state, x) begin\n        case (present_state)\n            S0: if (x == 0) next_state = S0; else next_state = S1;\n            S1: if (x == 0) next_state = S1; else next_state = S4;\n            S2: if (x == 0) next_state = S2; else next_state = S1;\n            S3: if (x == 0) next_state = S1; else next_state = S2;\n            S4: if (x == 0) next_state = S3; else next_state = S4;\n            default: next_state = S0;\n        endcase\n        \n        // Determine the output z\n        case (present_state)\n            S3: if (x == 1) z = 1; else z = 0;\n            S4: if (x == 1) z = 1; else z = 0;\n            default: z = 0;\n        endcase\n    end\n\n    // Update the present state on the rising edge of the clock with synchronous reset\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            present_state <= S0;\n        else\n            present_state <= next_state;\n    end\nendmodule\n", "result": "failed: 198 out of 1006 samples.", "passed": false}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    \n    typedef enum logic [2:0] {A, B, C, D, E, F} state_t;\n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case(state)\n            A: if (!resetn) begin\n                next_state = A;\n            end else begin\n                next_state = B;\n            end\n            B: next_state = C;\n            C: if (x == 1 && prev_x == 0 && prev_prev_x == 1) begin\n                next_state = D;\n            end else if (x == 0 && prev_x == 1 && prev_prev_x == 1) begin\n                next_state = C;\n            end else if (x == 1 && prev_x == 1 && prev_prev_x == 1) begin\n                next_state = C;\n            end else begin\n                next_state = C;\n            end\n            D: if (y == 1) begin\n                next_state = E;\n            end else begin\n                next_state = F;\n            end\n            E: next_state = E;\n            F: next_state = F;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end else begin\n            case(next_state)\n                B: f <= 1;\n                default: f <= 0;\n            endcase\n            case(state)\n                E: g <= 1;\n                F: g <= 0;\n                default: g <= g; // Keep previous value\n            endcase\n        end\n    end\n\n    // Previous x and previous previous x registers\n    reg [1:0] x_history;\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            x_history <= 0;\n        end else begin\n            x_history <= {x_history[0], x};\n        end\n    end\n    \n    assign prev_x = x_history[0];\n    assign prev_prev_x = x_history[1];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'b00110100; // Binary equivalent of 0x34\n        else\n            q <= d;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\n    // Calculate the parity bit by XORing all 8 input bits\n    assign parity = ^in;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\n\t\n\talways @(state or in) begin\n\t\tcase(state)\n\t\t\t2'b00: begin // State A\n\t\t\t\tif(in == 0) next_state <= 2'b00;\n\t\t\t\telse next_state <= 2'b01;\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\t\t2'b01: begin // State B\n\t\t\t\tif(in == 0) next_state <= 2'b10;\n\t\t\t\telse next_state <= 2'b01;\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\t\t2'b10: begin // State C\n\t\t\t\tif(in == 0) next_state <= 2'b00;\n\t\t\t\telse next_state <= 2'b11;\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\t\t2'b11: begin // State D\n\t\t\t\tif(in == 0) next_state <= 2'b10;\n\t\t\t\telse next_state <= 2'b01;\n\t\t\t\tout <= 1;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state <= 2'b00; // Default to state A\n\t\t\t\tout <= 0;\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\n\tassign z = x & y;\n\nendmodule\n", "result": "failed: 21 out of 110 samples.", "passed": false}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n\t\n\tparameter A = 3'b000;\n\tparameter B = 3'b001;\n\tparameter C = 3'b010;\n\tparameter D = 3'b011;\n\tparameter E = 3'b100;\n\tparameter F = 3'b101;\n\n\treg [2:0] current_state;\n\twire [2:0] next_state;\n\t\n\t// Next state logic\n\talways @(current_state or w) begin\n\t\tcase(current_state)\n\t\t\tA: next_state = (w == 1'b1) ? B : A;\n\t\t\tB: next_state = (w == 1'b1) ? C : D;\n\t\t\tC: next_state = (w == 1'b1) ? E : D;\n\t\t\tD: next_state = (w == 1'b1) ? F : A;\n\t\t\tE: next_state = (w == 1'b1) ? E : D;\n\t\t\tF: next_state = (w == 1'b1) ? C : D;\n\t\t\tdefault: next_state = A; // Reset state\n\t\tendcase\n\tend\n\t\n\t// Output logic\n\tassign z = (current_state == E) ? 1'b1 : 1'b0;\n\t\n\t// State register update\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= A;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tq <= 16'b0; // Reset value when resetn is low\n\t\tend else begin\n\t\t\tcase (byteena)\n\t\t\t\t2'b00: q <= q; // No bytes are enabled\n\t\t\t\t2'b01: q <= {d[15:8], q[7:0]}; // Only upper byte is enabled\n\t\t\t\t2'b10: q <= {q[15:8], d[7:0]}; // Only lower byte is enabled\n\t\t\t\tdefault: q <= d; // Both bytes are enabled\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: 173 out of 443 samples.", "passed": false}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    // Register to hold the previous input value\n    reg [7:0] prev_in;\n\n    // At every clock cycle, store the current input in prev_in\n    always @(posedge clk) begin\n        prev_in <= in;\n    end\n\n    // Detect rising edges and update pedge\n    always @(posedge clk) begin\n        // Initialize pedge to 0\n        pedge <= 8'b0;\n        \n        // Loop through each bit of the input vector\n        for (int i = 0; i < 8; i = i + 1) begin\n            // Check if the current bit is 1 and the previous bit was 0\n            if (in[i] == 1 && prev_in[i] == 0) begin\n                // Set the corresponding bit in pedge to 1\n                pedge[i] <= 1;\n            end\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\n\t\n\talways @(posedge clock) begin\n\t\tp <= a; // Set p to a on the rising edge of clock\n\tend\n\t\n\talways @(posedge clock) begin\n\t\tq <= p; // Set q to p on the rising edge of clock\n\tend\n\nendmodule\n", "result": "failed: 186 out of 240 samples.", "passed": false}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            // Calculate the next state for each cell\n            for (int i = 0; i < 512; i = i + 1) begin\n                case (i)\n                    0: q[i] <= data[i+1]; // Boundary condition for q[0]\n                    511: q[i] <= data[i-1]; // Boundary condition for q[511]\n                    default: q[i] <= data[i-1] ^ data[i+1];\n                endcase\n            end\n        end\n    end\nendmodule\n", "result": "failed: 7050 out of 7121 samples.", "passed": false}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\n\t// Comparing each bit of A and B\n\twire eq0 = (A[0] == B[0]);\n\twire eq1 = (A[1] == B[1]);\n\n\t// Output z is true only if both bits are equal\n\tassign z = eq0 & eq1;\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    \n    // out_both: Check if both bits are '1'\n    assign out_both = {in[98:0] & in[99:1], 1'b0}; // Last bit comparison is not needed\n    \n    // out_any: Check if either bit is '1'\n    assign out_any = {1'b0, in[0:98] | in[1:99]};\n    \n    // out_different: Check if bits are different, including wrap-around\n    assign out_different = {in[0]^in[99], in[99:1]^in[98:0]};\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\n    // Use an always block to capture the behavior of the D latch\n    always @(posedge ena) begin\n        q <= d;  // Assign the value of 'd' to 'q' when 'ena' goes high\n    end\nendmodule\n", "result": "failed: 40 out of 100 samples.", "passed": false}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    // Calculate the starting index of the 4-bit segment\n    wire [9:0] start_index = (sel << 2); // sel * 4\n\n    // Extract the 4-bit segment from the input vector\n    assign out = in[start_index + 3:start_index];\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n\t\nalways_comb begin\n\tcase (sel)\n\t\t4'b0000: out = a;\n\t\t4'b0001: out = b;\n\t\t4'b0010: out = c;\n\t\t4'b0011: out = d;\n\t\t4'b0100: out = e;\n\t\t4'b0101: out = f;\n\t\t4'b0110: out = g;\n\t\t4'b0111: out = h;\n\t\t4'b1000: out = i;\n\t\tdefault: out = 16'b1; // All bits set to '1' for sel >= 9\n\tendcase\nend\n\nendmodule\n", "result": "failed: 101 out of 220 samples.", "passed": false}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = (a | b) != 3'b0;\n\n    // Compute inversion of a and b\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\t// State transition logic\n\talways @(*) begin\n\t\tcase(state)\n\t\t\t4'b0001: // State A\n\t\t\t\tif (in == 0) next_state = 4'b0001; // Stay at A\n\t\t\t\telse         next_state = 4'b0010; // Go to B\n\t\t\t4'b0010: // State B\n\t\t\t\tif (in == 0) next_state = 4'b0100; // Go to C\n\t\t\t\telse         next_state = 4'b0010; // Stay at B\n\t\t\t4'b0100: // State C\n\t\t\t\tif (in == 0) next_state = 4'b0001; // Go to A\n\t\t\t\telse         next_state = 4'b1000; // Go to D\n\t\t\t4'b1000: // State D\n\t\t\t\tif (in == 0) next_state = 4'b0100; // Go to C\n\t\t\t\telse         next_state = 4'b0010; // Go to B\n\t\t\tdefault: next_state = 4'b0001; // Default to state A\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == 4'b1000) ? 1 : 0; // Output is 1 only when in state D\n\nendmodule\n", "result": "failed: 284 out of 600 samples.", "passed": false}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\n    reg [7:0] temp1;\n    reg [7:0] temp2;\n\n    // Step 1: Compare a and b\n    always @(*) begin\n        if (a < b)\n            temp1 = a;\n        else\n            temp1 = b;\n    end\n\n    // Step 2: Compare c and d\n    always @(*) begin\n        if (c < d)\n            temp2 = c;\n        else\n            temp2 = d;\n    end\n\n    // Step 3: Compare the results of Step 1 and Step 2\n    always @(*) begin\n        if (temp1 < temp2)\n            min = temp1;\n        else\n            min = temp2;\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\n\tassign out_and = a & b; // AND operation\n\tassign out_or = a | b; // OR operation\n\tassign out_xor = a ^ b; // XOR operation\n\tassign out_nand = ~(a & b); // NAND operation\n\tassign out_nor = ~(a | b); // NOR operation\n\tassign out_xnor = ~(a ^ b); // XNOR operation\n\tassign out_anotb = a & (~b); // AND with NOT b\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\n\t\n\tassign out = a | b;\n\nendmodule\n", "result": "failed: 109 out of 232 samples.", "passed": false}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    \n    parameter A = 4'b0000;\n    parameter B = 4'b0001;\n    parameter C = 4'b0010;\n    parameter D = 4'b0011;\n    parameter E = 4'b0100;\n    parameter F = 4'b0101;\n\n    reg [3:0] state;\n    reg [1:0] count_w_ones;\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            case(state)\n                A: begin\n                    if (s)\n                        state <= B;\n                    else\n                        state <= A;\n                end\n                B: state <= C;\n                C: state <= D;\n                D: state <= E;\n                E: begin\n                    if (count_w_ones == 2)\n                        state <= F;\n                    else\n                        state <= B;\n                end\n                F: state <= B;\n                default: state <= A;\n            endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset)\n            count_w_ones <= 2'b00;\n        else\n            case(state)\n                B: count_w_ones <= w;\n                C: count_w_ones <= {count_w_ones[0], w};\n                D: count_w_ones <= {count_w_ones[0], w};\n                E: count_w_ones <= {count_w_ones[0], w};\n                default: count_w_ones <= 2'b00;\n            endcase\n    end\n\n    always @(posedge clk) begin\n        if (reset)\n            z <= 1'b0;\n        else\n            z <= (state == F) ? 1'b1 : 1'b0;\n    end\nendmodule\n", "result": "failed: 240 out of 1414 samples.", "passed": false}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n    // Extract the MSB of the 8-bit input\n    wire sign_bit = in[7];\n    \n    // Replicate the sign bit 24 times\n    reg [23:0] replicated_sign_bits;\n    assign replicated_sign_bits = {24{sign_bit}};\n    \n    // Concatenate the replicated sign bits with the original 8-bit input\n    assign out = {replicated_sign_bits, in};\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n    // Internal signals for the shift register stages\n\treg [2:0] shift_reg;\n\n\t// On each positive edge of the clock\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\t// If reset is active (low), set all registers to 0\n\t\t\tshift_reg <= 3'b0;\n\t\t\tout <= 1'b0; // Output also set to 0\n\t\tend else begin\n\t\t\t// Perform right shift operation\n\t\t\tshift_reg <= {shift_reg[1:0], in};\n\t\t\t// Assign the output to the MSB of the shift register\n\t\t\tout <= shift_reg[2];\n\t\tend\n\tend\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n    // Initialize pos to 0\n    pos = 2'b00;\n    \n    // Check each bit in order of priority\n    if (in[3]) begin\n        pos = 2'b11;\n    end else if (in[2]) begin\n        pos = 2'b10;\n    end else if (in[1]) begin\n        pos = 2'b01;\n    end else if (in[0]) begin\n        pos = 2'b00;\n    end\nend\nendmodule\n", "result": "failed: 61 out of 94 samples.", "passed": false}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    \n    // Define the states\n    localparam OFF = 2'b00;\n    localparam ON = 2'b01;\n\n    // State register\n    reg [1:0] current_state;\n\n    // Next state logic\n    always @(posedge clk or posedge areset)\n    begin\n        if (areset)\n            current_state <= OFF; // Asynchronous reset to OFF state\n        else\n            case (current_state)\n                OFF:\n                    if (j) current_state <= ON; // Transition to ON when j is 1\n                    else current_state <= OFF; // Stay in OFF when j is 0\n                \n                ON:\n                    if (k) current_state <= OFF; // Transition to OFF when k is 1\n                    else current_state <= ON; // Stay in ON when k is 0\n            endcase\n    end\n\n    // Output logic\n    always @(*) \n    begin\n        case (current_state)\n            OFF: out <= 0; // Output 0 when in OFF state\n            ON: out <= 1; // Output 1 when in ON state\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\t// Assign the output to 0\n\tassign out = 1'b0;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\t// Assign a constant 1 to the output 'one'\n\tassign one = 1;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\n    always @(*) begin\n        for (integer i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\n    \n    // Internal signal for XOR output\n    logic xor_output;\n    \n    // Assign the XOR output to the internal signal\n    always_comb begin\n        xor_output = in ^ out;\n    end\n    \n    // Positive edge triggered D flip-flop\n    always_ff @(posedge clk) begin\n        out <= xor_output;\n    end\n\nendmodule\n", "result": "failed: 1 out of 100 samples.", "passed": false}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\n    \n    // Asynchronous reset block\n    always @(posedge areset or posedge clk) begin\n        if (areset)\n            q <= 4'b0;\n        else if (load)\n            q <= data;  // Load data into the shift register\n        else if (ena)\n            q <= {1'b0, q[3:1]};  // Right shift operation\n    end\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\n\tassign f = (x3 == 0) ? x2 : 1;\nendmodule\n", "result": "failed: 4 out of 58 samples.", "passed": false}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;  // Asynchronous reset to 0\n        else\n            q <= d;     // Update q with d on the rising edge of clk\n    end\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n    // Initialize the AND, OR, and XOR outputs\n    reg out_and;\n    reg out_or;\n    reg out_xor;\n\n    // Assigning the outputs based on the input vector\n    assign out_and = &in;  // All inputs must be 1 for out_and to be 1\n    assign out_or = |in;   // At least one input must be 1 for out_or to be 1\n    assign out_xor = ^in;  // Output is 1 if an odd number of inputs are 1\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\n\t// Compute the sum using XOR operation\n\tassign sum = a ^ b;\n\t\n\t// Compute the carry-out using AND operation\n\tassign cout = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    \n    always @(*) begin\n        // CPU overheated condition\n        if (cpu_overheated) \n            shut_off_computer = 1;\n        else \n            shut_off_computer = 0;\n\n        // Driving conditions\n        if (~arrived) \n            keep_driving = ~gas_tank_empty;\n        else \n            keep_driving = 0;\n    end\n    \nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    // Define state variable\n    reg [1:0] state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= 2'b00;  // Reset to OFF state\n        end else begin\n            case (state)\n                2'b00: begin  // OFF state\n                    if (j == 1) begin\n                        state <= 2'b01;  // Transition to ON state\n                    end\n                end\n                2'b01: begin  // ON state\n                    if (k == 1) begin\n                        state <= 2'b00;  // Transition to OFF state\n                    end\n                end\n                default: begin\n                    state <= 2'b00;  // Default to OFF state\n                end\n            endcase\n        end\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (state)\n            2'b00: out = 0;  // OFF state\n            2'b01: out = 1;  // ON state\n            default: out = 0;  // Default to OFF state\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    // Concatenate inputs and add two 1s at the end\n    wire [31:0] concatenated_output = {a, b, c, d, e, f, 2'b11};\n\n    // Assign the concatenated output to the outputs\n    assign w = concatenated_output[31:24];\n    assign x = concatenated_output[23:16];\n    assign y = concatenated_output[15:8];\n    assign z = concatenated_output[7:0];\n\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n    assign q = (a & b & c) & (~d);\nendmodule\n", "result": "failed: 71 out of 121 samples.", "passed": false}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n    // Perform the AND operation on inputs a and b\n    assign out = a & b;\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    parameter B = 1'b1; // State B represented as 1\n    parameter A = 1'b0; // State A represented as 0\n\n    reg currentState;\n\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset == 1'b1) // Active-high synchronous reset\n            currentState <= B;\n        else\n            case (currentState)\n                B: \n                    if (in == 1'b0)\n                        currentState <= A;\n                    else\n                        currentState <= B;\n                A: \n                    if (in == 1'b0)\n                        currentState <= B;\n                    else\n                        currentState <= A;\n                default: currentState <= B; // Default to B in case of unexpected conditions\n            endcase\n    end\n\n    assign out = currentState; // Output is 1 for B and 0 for A\n\nendmodule\n", "result": "failed: 57 out of 230 samples.", "passed": false}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n    // Compute the sum using XOR for all inputs\n    assign sum = a ^ b ^ cin;\n\n    // Compute the carry-out using AND/OR logic for carry conditions\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n", "result": "passed", "passed": true}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\n\tlogic xnor_out;\n\n\t// Compute the XNOR of in1 and in2\n\tassign xnor_out = (in1 == in2);\n\n\t// Compute the XOR of xnor_out and in3\n\tassign out = ^(xnor_out, in3);\n\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    // Define intermediate signals\n    wire c_n, d_n;\n    wire sel0, sel1, sel2;\n\n    // Negate c and d\n    assign c_n = ~c;\n    assign d_n = ~d;\n\n    // Generate intermediate values for mux_in[0] and mux_in[1]\n    assign sel0 = c_n & d_n; // mux_in[0]\n    assign sel1 = c_n & d;   // mux_in[1]\n\n    // Use 2-to-1 multiplexers to generate mux_in[2] and mux_in[3]\n    // mux_in[2] = cd + c'd\n    assign sel2 = (c & d) | (c_n & d); \n\n    // mux_in[3] = cd + c'd'\n    assign mux_in[3] = (c & d) | (c_n & d_n);\n\n    // Assign the remaining values\n    assign mux_in[0] = sel0;\n    assign mux_in[1] = sel1;\n    assign mux_in[2] = sel2;\n\nendmodule\n", "result": "failed: 60 out of 60 samples.", "passed": false}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    \n    // State definition using one-hot encoding\n    reg state_a;\n    reg state_b;\n\n    // Output assignment\n    assign z = state_a ? ~x : x;  // Invert x only when in state A\n\n    // State register\n    always @(posedge clk or posedge areset)\n        begin\n            if (areset)\n                begin\n                    state_a <= 1'b1;  // Initial state is A\n                    state_b <= 1'b0;\n                end\n            else\n                begin\n                    case ({state_a, state_b})\n                        2'b00: \n                            begin\n                                state_a <= 1'b1;  // Invalid state, should not occur\n                                state_b <= 1'b0;\n                            end\n                        2'b01: \n                            begin\n                                state_a <= 1'b0;  // Stay in B\n                                state_b <= 1'b1;\n                            end\n                        2'b10: \n                            begin\n                                state_a <= x ? 1'b0 : 1'b1;  // Transition to B if x=1, stay in A if x=0\n                                state_b <= x ? 1'b1 : 1'b0;\n                            end\n                        2'b11: \n                            begin\n                                state_a <= 1'b0;  // Invalid state, should not occur\n                                state_b <= 1'b0;\n                            end\n                    endcase\n                end\n        end\n\nendmodule\n", "result": "failed: 436 out of 436 samples.", "passed": false}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\n\nreg q_next;\n\nalways @(posedge clk) begin\n    case ({a, b, q})\n        3'b000: q_next <= q; // No change if a=0, b=0\n        3'b001: q_next <= ~q; // Toggle if a=0, b=1\n        3'b010: q_next <= q; // No change if a=1, b=0\n        3'b011: q_next <= 1'b0; // Set to 0 if a=1, b=1\n        default: q_next <= q; // Default case\n    endcase\n    q <= q_next;\nend\n\nassign state = {a, b, q};\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n\tlogic term1, term2, term3, term4;\n\n\tassign term1 = (~x[3] & ~x[4]);\n\tassign term2 = (~x[3] & x[4]);\n\tassign term3 = (x[3] & x[2]);\n\tassign term4 = (x[3] & x[4]);\n\n\tassign f = term1 | term2 | term3 | term4;\nendmodule\n", "result": "failed: 65 out of 100 samples.", "passed": false}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\n    // State definition\n    typedef enum {IDLE, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, FLAG, DISC} state_t;\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: next_state = (in) ? ONE : IDLE;\n            ONE: next_state = (in) ? TWO : IDLE;\n            TWO: next_state = (in) ? THREE : IDLE;\n            THREE: next_state = (in) ? FOUR : IDLE;\n            FOUR: next_state = (in) ? FIVE : IDLE;\n            FIVE: next_state = (in) ? SIX : DISC;\n            SIX: next_state = (in) ? SEVEN : FLAG;\n            SEVEN: next_state = IDLE; // Error state\n            FLAG: next_state = IDLE; // Frame flag detected\n            DISC: next_state = IDLE; // Discard bit detected\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk)\n        case(state)\n            DISC: disc <= 1;\n            FLAG: flag <= 1;\n            SEVEN: err <= 1;\n            default: begin\n                disc <= 0;\n                flag <= 0;\n                err <= 0;\n            end\n        endcase\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n\n    // State definitions\n    typedef enum {SEARCHING, SHIFTING, COUNTING, NOTIFIED, ACKNOWLEDGED} state_t;\n    state_t state, next_state;\n\n    // Internal registers\n    reg [3:0] delay;  // Holds the delay value\n    reg [3:0] counter;  // Counter to track the delay\n    reg [7:0] pattern_reg;  // Shift register for detecting 1101\n\n    // State transition logic\n    always @(posedge clk or posedge reset)\n        if (reset)\n            state <= SEARCHING;\n        else\n            state <= next_state;\n\n    // Next state logic\n    always @(*)\n        case(state)\n            SEARCHING:\n                if (&pattern_reg[7:4]) begin // Check if pattern_reg is 1101\n                    next_state = SHIFTING;\n                end else begin\n                    next_state = SEARCHING;\n                end\n            SHIFTING:\n                if (counter == 4'd4) begin // After 4 shifts, go to COUNTING\n                    next_state = COUNTING;\n                end else begin\n                    next_state = SHIFTING;\n                end\n            COUNTING:\n                if (counter == 0) begin // Countdown finished, go to NOTIFIED\n                    next_state = NOTIFIED;\n                end else begin\n                    next_state = COUNTING;\n                end\n            NOTIFIED:\n                if (ack) begin // Acknowledged, go back to SEARCHING\n                    next_state = SEARCHING;\n                end else begin\n                    next_state = NOTIFIED;\n                end\n            default:\n                next_state = SEARCHING;\n        endcase\n\n    // Pattern detection and delay loading\n    always @(posedge clk or posedge reset)\n        if (reset)\n            pattern_reg <= 8'b0;\n        else\n            pattern_reg <= {pattern_reg[6:0], data};\n\n    // Delay loading\n    always @(posedge clk or posedge reset)\n        if (reset)\n            delay <= 4'b0;\n        else if (state == SHIFTING && counter == 4'd4)\n            delay <= pattern_reg[3:0];\n\n    // Counting logic\n    always @(posedge clk or posedge reset)\n        if (reset)\n            counter <= 4'b0;\n        else if (state == COUNTING && counter == 0)\n            counter <= delay + 1;\n        else if (state == COUNTING && counter != 0)\n            counter <= counter - 1;\n\n    // Output assignments\n    assign count = counter;\n    assign counting = (state == COUNTING);\n    assign done = (state == NOTIFIED);\n\nendmodule\n", "result": "failed: 234318 out of 235447 samples.", "passed": false}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\nreg [1:0] prev_state;\nreg [1:0] curr_state;\n\nalways @(posedge clk or posedge reset)\nbegin\n    if (reset)\n    begin\n        curr_state <= 2'b11; // Below s[1] state\n        prev_state <= 2'b11; // Initialize prev_state to below s[1]\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 0;\n    end\n    else\n    begin\n        // Determine the current state based on sensor inputs\n        case (s)\n            3'b111: curr_state <= 2'b00; // Above s[3]\n            3'b011: curr_state <= 2'b01; // Between s[3] and s[2]\n            3'b001: curr_state <= 2'b10; // Between s[2] and s[1]\n            default: curr_state <= 2'b11; // Below s[1]\n        endcase\n        \n        // Update the outputs based on the current state\n        case (curr_state)\n            2'b00: begin // Above s[3]\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 0;\n                dfr <= 0;\n            end\n            2'b01: begin // Between s[3] and s[2]\n                fr3 <= 0;\n                fr2 <= 0;\n                fr1 <= 1;\n                dfr <= 0;\n            end\n            2'b10: begin // Between s[2] and s[1]\n                fr3 <= 0;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= 0;\n            end\n            2'b11: begin // Below s[1]\n                fr3 <= 1;\n                fr2 <= 1;\n                fr1 <= 1;\n                dfr <= 0;\n            end\n        endcase\n        \n        // Check if the water level rose and set dfr accordingly\n        if (prev_state < curr_state)\n            dfr <= 1;\n        \n        // Update the previous state\n        prev_state <= curr_state;\n    end\nend\n\nendmodule\n", "result": "failed: 1399 out of 2040 samples.", "passed": false}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    parameter IDLE = 2'b00;\n    parameter DATA = 2'b01;\n    parameter STOP = 2'b10;\n    parameter ERROR = 2'b11;\n\n    reg [1:0] state;\n    reg [2:0] bit_count;\n    reg [7:0] data;\n    reg prev_in;\n    reg done_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else begin\n            case (state)\n                IDLE: begin\n                    if (~in)\n                        state <= DATA;\n                end\n                DATA: begin\n                    if (bit_count == 7) begin\n                        state <= STOP;\n                    end else begin\n                        data[bit_count] <= in;\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                STOP: begin\n                    if (in)\n                        state <= IDLE;\n                    else\n                        state <= ERROR;\n                end\n                ERROR: begin\n                    if (in)\n                        state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            done_reg <= 0;\n            bit_count <= 0;\n        end else begin\n            case (state)\n                IDLE: done_reg <= 0;\n                DATA: done_reg <= 0;\n                STOP: done_reg <= 1;\n                ERROR: done_reg <= 0;\n            endcase\n        end\n    end\n\n    assign done = done_reg;\n\nendmodule\n", "result": "failed: 116 out of 905 samples.", "passed": false}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    typedef enum { IDLE, START_BIT, DATA_BIT_1, DATA_BIT_2, DATA_BIT_3, DATA_BIT_4, DATA_BIT_5, DATA_BIT_6, DATA_BIT_7, DATA_BIT_8, STOP_BIT, DONE } state_t;\n    state_t state, next_state;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case(state)\n            IDLE: \n                if (!in) \n                    next_state = START_BIT;\n                else \n                    next_state = IDLE;\n            START_BIT: \n                next_state = DATA_BIT_1;\n            DATA_BIT_1: \n                next_state = DATA_BIT_2;\n            DATA_BIT_2: \n                next_state = DATA_BIT_3;\n            DATA_BIT_3: \n                next_state = DATA_BIT_4;\n            DATA_BIT_4: \n                next_state = DATA_BIT_5;\n            DATA_BIT_5: \n                next_state = DATA_BIT_6;\n            DATA_BIT_6: \n                next_state = DATA_BIT_7;\n            DATA_BIT_7: \n                next_state = DATA_BIT_8;\n            DATA_BIT_8: \n                next_state = STOP_BIT;\n            STOP_BIT: \n                if (in) \n                    next_state = DONE;\n                else \n                    next_state = IDLE;\n            DONE: \n                next_state = IDLE;\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            out_byte <= 8'b0;\n        else if (state == DATA_BIT_1)\n            out_byte[0] <= in;\n        else if (state == DATA_BIT_2)\n            out_byte[1] <= in;\n        else if (state == DATA_BIT_3)\n            out_byte[2] <= in;\n        else if (state == DATA_BIT_4)\n            out_byte[3] <= in;\n        else if (state == DATA_BIT_5)\n            out_byte[4] <= in;\n        else if (state == DATA_BIT_6)\n            out_byte[5] <= in;\n        else if (state == DATA_BIT_7)\n            out_byte[6] <= in;\n        else if (state == DATA_BIT_8)\n            out_byte[7] <= in;\n    end\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            done <= 0;\n        else if (state == DONE)\n            done <= 1;\n        else\n            done <= 0;\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n    \n    // Parameters\n    parameter TABLE_SIZE = 128;\n    parameter HISTORY_SIZE = 7;\n\n    // Internal Signals\n    reg [HISTORY_SIZE-1:0] global_history_reg;\n    reg [TABLE_SIZE-1:0][1:0] pht_table; // 128 entries, each 2 bits\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            global_history_reg <= 0;\n        else if (predict_valid && !train_valid) begin\n            // Update global history based on prediction\n            global_history_reg <= {global_history_reg[HISTORY_SIZE-2:0], predict_taken};\n        end\n    end\n    \n    assign predict_history = global_history_reg;\n    wire [HISTORY_SIZE-1:0] predict_index = predict_pc ^ global_history_reg;\n    wire [1:0] predict_entry = pht_table[predict_index];\n    assign predict_taken = (predict_entry == 2'b11) || (predict_entry == 2'b00); // Strongly taken/strongly not taken\n    \n    // Training logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            pht_table <= 'b0;\n        end else if (train_valid) begin\n            wire [HISTORY_SIZE-1:0] train_index = train_pc ^ global_history_reg;\n            if (train_mispredicted) begin\n                // Recover global history\n                global_history_reg <= {global_history_reg[HISTORY_SIZE-2:0], ~train_taken};\n            end\n            // Update PHT entry\n            case (pht_table[train_index])\n                2'b00: pht_table[train_index] <= (train_taken) ? 2'b01 : 2'b00; // Weakly not taken -> weakly taken / weakly not taken\n                2'b01: pht_table[train_index] <= (train_taken) ? 2'b10 : 2'b00; // Weakly taken -> strongly taken / weakly not taken\n                2'b10: pht_table[train_index] <= (train_taken) ? 2'b11 : 2'b01; // Strongly taken -> strongly taken / weakly taken\n                2'b11: pht_table[train_index] <= (train_taken) ? 2'b11 : 2'b10; // Strongly taken -> strongly taken / strongly not taken\n            endcase\n        end\n    end\nendmodule\n", "result": "failed: syntax error.", "passed": false}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    typedef enum logic [2:0] {\n        WALK_LEFT = 3'b000,\n        WALK_RIGHT = 3'b001,\n        FALLING = 3'b010,\n        DIGGING = 3'b011,\n        SPLATTERED = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n    reg [4:0] fall_count;\n\n    always_ff @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n        \n        unique case(state)\n            WALK_LEFT:\n                if (bump_left) next_state = WALK_RIGHT;\n                else if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else next_state = WALK_LEFT;\n            \n            WALK_RIGHT:\n                if (bump_right) next_state = WALK_LEFT;\n                else if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else next_state = WALK_RIGHT;\n            \n            FALLING:\n                if (ground) begin\n                    if (fall_count > 20) next_state = SPLATTERED;\n                    else next_state = state;\n                end\n                else begin\n                    fall_count <= fall_count + 1;\n                    next_state = FALLING;\n                end\n            \n            DIGGING:\n                if (ground) next_state = state;\n                else next_state = WALK_LEFT;\n            \n            SPLATTERED:\n                next_state = SPLATTERED;\n        endcase\n        \n        unique case(state)\n            WALK_LEFT: walk_left = 1'b1;\n            WALK_RIGHT: walk_right = 1'b1;\n            FALLING: aaah = 1'b1;\n            DIGGING: digging = 1'b1;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n\n    // State definition\n    typedef enum logic [2:0] {\n        SEARCH,\n        SHIFT,\n        WAIT,\n        NOTIFY,\n        ACK\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= SEARCH;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            SEARCH: begin\n                if (data == 1'b1) begin\n                    next_state = SEARCH + 1;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n            3'b010: begin\n                if (data == 1'b0) begin\n                    next_state = SEARCH + 1;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n            3'b011: begin\n                if (data == 1'b1) begin\n                    next_state = SEARCH + 1;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n            3'b100: begin\n                if (data == 1'b1) begin\n                    next_state = SEARCH;\n                end else begin\n                    next_state = SEARCH + 1;\n                end\n            end\n            3'b101: begin\n                if (data == 1'b0) begin\n                    next_state = SEARCH + 1;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n            3'b110: begin\n                if (data == 1'b1) begin\n                    next_state = SEARCH + 1;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n            3'b111: begin\n                next_state = SEARCH;\n            end\n            SHIFT: begin\n                if (shift_ena == 4'b1111) begin\n                    next_state = WAIT;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            WAIT: begin\n                if (done_counting) begin\n                    next_state = NOTIFY;\n                end else begin\n                    next_state = WAIT;\n                end\n            end\n            NOTIFY: begin\n                if (ack) begin\n                    next_state = ACK;\n                end else begin\n                    next_state = NOTIFY;\n                end\n            end\n            ACK: begin\n                if (ack) begin\n                    next_state = SEARCH;\n                end else begin\n                    next_state = ACK;\n                end\n            end\n            default: next_state = SEARCH;\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            SEARCH: ;\n            SHIFT: begin\n                shift_ena = 1'b1;\n            end\n            WAIT: begin\n                counting = 1'b1;\n            end\n            NOTIFY: begin\n                done = 1'b1;\n            end\n            ACK: ;\n            default: ;\n        endcase\n    end\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    // Internal signals\n    reg [255:0] next_state;\n\n    // Function to count live neighbors for a given cell\n    function integer count_neighbors;\n        input [255:0] state;\n        input [7:0] i;\n        input [7:0] j;\n        integer k, l, n, m;\n        begin\n            n = i + 1; m = j + 1;\n            count_neighbors = 0;\n            // Check all 8 neighbors\n            for(k = -1; k <= 1; k = k + 1) begin\n                for(l = -1; l <= 1; l = l + 1) begin\n                    if(k != 0 || l != 0) begin\n                        count_neighbors = count_neighbors + state[((n+k)%16)*16 + ((m+l)%16)];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    // Compute next state\n    always @(*) begin\n        for(int i = 0; i < 16; i = i + 1) begin\n            for(int j = 0; j < 16; j = j + 1) begin\n                integer neighbors = count_neighbors(q, i, j);\n                if(load) begin\n                    next_state[i*16+j] = data[i*16+j];\n                end else if(neighbors == 2) begin\n                    next_state[i*16+j] = q[i*16+j];\n                end else if(neighbors == 3) begin\n                    next_state[i*16+j] = 1;\n                end else begin\n                    next_state[i*16+j] = 0;\n                end\n            end\n        end\n    end\n\n    // Clock synchronization\n    always @(posedge clk) begin\n        if(load) begin\n            q <= data;\n        end else begin\n            q <= next_state;\n        end\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    \n    // Define states\n    typedef enum logic [2:0] { WALK_LEFT, WALK_RIGHT, FALL, DIG } state_t;\n    state_t curr_state, next_state;\n\n    // Register to hold current state\n    always_ff @(posedge clk, posedge areset)\n        if (areset)\n            curr_state <= WALK_LEFT;  // Initialize to WALK_LEFT on reset\n        else\n            curr_state <= next_state;\n\n    // Next state logic\n    always_comb begin\n        next_state = curr_state;\n        \n        case (curr_state)\n            WALK_LEFT: begin\n                if (bump_right) next_state = WALK_RIGHT;\n                else if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n            end\n            WALK_RIGHT: begin\n                if (bump_left) next_state = WALK_LEFT;\n                else if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n            end\n            FALL: begin\n                if (ground) next_state = WALK_LEFT;  // Resume walking left after falling\n            end\n            DIG: begin\n                if (!ground) next_state = FALL;  // Fall when ground disappears\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        walk_left = 1'b0;\n        walk_right = 1'b0;\n        aaah = 1'b0;\n        digging = 1'b0;\n\n        case (curr_state)\n            WALK_LEFT: walk_left = 1'b1;\n            WALK_RIGHT: walk_right = 1'b1;\n            FALL: aaah = 1'b1;\n            DIG: digging = 1'b1;\n        endcase\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\n    // Internal signals for the counters\n    reg [3:0] ss_int;\n    reg [3:0] mm_int;\n    reg [3:0] hh_int;\n\n    // Initialize the internal counters\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the counters to 12:00 AM\n            ss_int <= 4'd0;   // 00\n            mm_int <= 4'd0;   // 00\n            hh_int <= 4'd1;   // 1\n            pm <= 0;          // AM\n        end else if (ena) begin\n            // Increment the seconds counter\n            if (ss_int == 4'd59) begin\n                ss_int <= 4'd0;\n                // Increment the minutes counter\n                if (mm_int == 4'd59) begin\n                    mm_int <= 4'd0;\n                    // Increment the hours counter\n                    if (hh_int == 4'd12) begin\n                        hh_int <= 4'd1;  // Wrap around to 1\n                        pm <= ~pm;       // Toggle AM/PM\n                    end else begin\n                        hh_int <= hh_int + 1;\n                    end\n                end else begin\n                    mm_int <= mm_int + 1;\n                end\n            end else begin\n                ss_int <= ss_int + 1;\n            end\n        end\n    end\n\n    // Assign the outputs based on the internal counters\n    assign hh = {3'b0, hh_int};\n    assign mm = {4'b0, mm_int};\n    assign ss = {4'b0, ss_int};\n\nendmodule\n", "result": "failed: compile error.", "passed": false}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n\t\n\t// Define state type and variables\n\ttypedef enum logic [1:0] { WALK_LEFT, WALK_RIGHT } state_t;\n\tstate_t curr_state, next_state;\n\n\t// Output assignments\n\tassign walk_left = (curr_state == WALK_LEFT);\n\tassign walk_right = (curr_state == WALK_RIGHT);\n\tassign aaah = (!ground && (curr_state == WALK_LEFT || curr_state == WALK_RIGHT));\n\n\t// State transition logic\n\talways_ff @(posedge clk, posedge areset) begin\n\t\tif (areset) begin\n\t\t\tcurr_state <= WALK_LEFT;\n\t\tend else begin\n\t\t\tcurr_state <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways_comb begin\n\t\tcase (curr_state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (bump_right || (bump_left && bump_right))\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (bump_left || (bump_left && bump_right))\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\telse\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = WALK_LEFT;\n\t\tendcase\n\tend\nendmodule\n", "result": "failed: 349 out of 441 samples.", "passed": false}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n    // Internal signals for individual BCD counters\n    reg [3:0] digit_ones;\n    reg [3:0] digit_tens;\n    reg [3:0] digit_hundreds;\n    reg [3:0] digit_thousands;\n\n    // Enable signals for each of the upper three digits\n    wire enable_tens;\n    wire enable_hundreds;\n    wire enable_thousands;\n\n    // Synchronous reset for each BCD counter\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            digit_ones <= 4'b0000;\n            digit_tens <= 4'b0000;\n            digit_hundreds <= 4'b0000;\n            digit_thousands <= 4'b0000;\n        end else begin\n            // BCD Counter Logic\n            if (enable_tens) begin\n                digit_ones <= 4'b0000;\n            end else if (digit_ones == 4'b1001) begin\n                digit_ones <= 4'b0000;\n                enable_tens = 1;\n            end else begin\n                digit_ones <= digit_ones + 1;\n                enable_tens = 0;\n            end\n\n            if (enable_hundreds) begin\n                digit_tens <= 4'b0000;\n            end else if (digit_tens == 4'b1001 && enable_tens) begin\n                digit_tens <= 4'b0000;\n                enable_hundreds = 1;\n            end else begin\n                digit_tens <= digit_tens + 1;\n                enable_hundreds = 0;\n            end\n\n            if (enable_thousands) begin\n                digit_hundreds <= 4'b0000;\n            end else if (digit_hundreds == 4'b1001 && enable_hundreds) begin\n                digit_hundreds <= 4'b0000;\n                enable_thousands = 1;\n            end else begin\n                digit_hundreds <= digit_hundreds + 1;\n                enable_thousands = 0;\n            end\n\n            if (enable_thousands) begin\n                digit_thousands <= digit_thousands + 1;\n            end\n        end\n    end\n\n    // Output the enable signals\n    assign ena = {enable_thousands, enable_hundreds, enable_tens};\n\n    // Assign the outputs to the final q register\n    always @* begin\n        q = {digit_thousands, digit_hundreds, digit_tens, digit_ones};\n    end\nendmodule\n", "result": "failed: compile error.", "passed": false}
