{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": " out = (sel == 1'b0) ? a : b;\nendmodule\n"}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = (w == 1'b0) ? 1'b0 : 1'b0; // State A\n        3'b001: Y2 = (w == 1'b0) ? 1'b0 : 1'b0; // State B\n        3'b010: Y2 = (w == 1'b0) ? 1'b1 : 1'b0; // State C\n        3'b011: Y2 = (w == 1'b0) ? 1'b1 : 1'b0; // State D\n        3'b100: Y2 = 1'b1;                     // State E\n        3'b101: Y2 = (w == 1'b0) ? 1'b0 : 1'b0; // State F\n        default: Y2 = 1'b0;                     // Default case\n    endcase\nend\nendmodule\n"}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\nassign motor = vibrate_mode ? 1 : (ring ? 0 : 0);\nassign ringer = vibrate_mode ? 0 : (ring ? 1 : 0);\nendmodule\n"}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n    assign out_assign = a & b;\n\n    always @(*) begin\n        out_alwaysblock = a & b;\n    end\nendmodule\n"}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": " zero = 1'b0;\nendmodule\n"}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a == 0) begin\n        q <= q;\n    end else begin\n        q <= ~q;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] num; // Assume a maximum length of 32 bits\n    reg [5:0] count;\n    reg [31:0] result;\n    reg z_reg;\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            num <= 0;\n            count <= 0;\n            result <= 0;\n            z_reg <= 0;\n        end else begin\n            if (count < 32) begin\n                num <= {x, num[31:1]}; // Shift in the new bit\n                count <= count + 1;\n            end else begin\n                result <= ~num + 1; // Compute 2's complement\n                z_reg <= result[0]; // Output the least significant bit of the result\n            end\n        end\n    end\n\n    assign z = z_reg;\n\nendmodule\n"}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nassign out = (state == D) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\tstate <= A;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tA: next_state = (in == 0) ? A : B;\n\t\tB: next_state = (in == 0) ? C : B;\n\t\tC: next_state = (in == 0) ? A : D;\n\t\tD: next_state = (in == 0) ? C : B;\n\t\tdefault: next_state = A;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge r) begin\n    if (r) \n        q <= 0;\n    else \n        q <= d;\nend\nendmodule\n"}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = (x ^ y) & x;\n\nendmodule\n"}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= {q[62:0], 1'b0}; // shift left by 1 bit\n            2'b01: q <= {q[55:0], 8'b0}; // shift left by 8 bits\n            2'b10: q <= {q[63], q[62:1]}; // arithmetic right shift by 1 bit\n            2'b11: q <= {q[63:8], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0}; // arithmetic right shift by 8 bits\n            default: q <= q; // no change for any invalid amount\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\tparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn) \n\t\t\tstate <= S0;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\t\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: begin\n\t\t\t\tz = 0;\n\t\t\t\tif (x) \n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse \n\t\t\t\t\tnext_state = S0;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tz = 0;\n\t\t\t\tif (x) \n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse \n\t\t\t\t\tnext_state = S2;\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tz = 0;\n\t\t\t\tif (x) begin\n\t\t\t\t\tz = 1; // \"101\" detected\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tend else \n\t\t\t\t\tnext_state = S0;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tz = 0;\n\t\t\t\tnext_state = S0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    reg [2:0] state, next_state;\n\n    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    // Output logic\n    assign z = (state == E) ? 1 : 0;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (w == 0) next_state = B;\n                else next_state = A;\n            end\n            B: begin\n                if (w == 0) next_state = C;\n                else next_state = D;\n            end\n            C: begin\n                if (w == 0) next_state = E;\n                else next_state = D;\n            end\n            D: begin\n                if (w == 0) next_state = F;\n                else next_state = A;\n            end\n            E: begin\n                if (w == 0) next_state = E;\n                else next_state = D;\n            end\n            F: begin\n                if (w == 0) next_state = C;\n                else next_state = D;\n            end\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    // State update logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A; // Reset to initial state\n        end else begin\n            state <= next_state; // Update state\n        end\n    end\n\nendmodule\n"}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\treg [23:0] out_bytes_reg;\n\treg [1:0] byte_count;\n\treg done_reg;\n\t\n\tassign out_bytes = out_bytes_reg;\n\tassign done = done_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout_bytes_reg <= 24'b0;\n\t\t\tbyte_count <= 2'b0;\n\t\t\tdone_reg <= 1'b0;\n\t\tend else begin\n\t\t\tif (byte_count == 2'b00) begin\n\t\t\t\tif (in[3] == 1'b1) begin\n\t\t\t\t\tout_bytes_reg[23:16] <= in; // First byte\n\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\t\tdone_reg <= 1'b0;\n\t\t\t\tend\n\t\t\tend else if (byte_count == 2'b01) begin\n\t\t\t\tout_bytes_reg[15:8] <= in; // Second byte\n\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\tdone_reg <= 1'b0;\n\t\t\tend else if (byte_count == 2'b10) begin\n\t\t\t\tout_bytes_reg[7:0] <= in; // Third byte\n\t\t\t\tdone_reg <= 1'b1;\n\t\t\t\tbyte_count <= 2'b00; // Reset for next message\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\nassign Y1 = (y[0] & ~w) | (y[1] & ~w) | (y[4] & ~w);\nassign Y3 = (y[2] & ~w) | (y[3] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n"}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": " outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule\n"}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({c, d, b, a})\n        4'b0000: out = 0; // cd = 00, ab = 00\n        4'b0001: out = 1; // cd = 00, ab = 01\n        4'b0010: out = 0; // cd = 00, ab = 10\n        4'b0011: out = 1; // cd = 00, ab = 11\n        4'b0100: out = 1; // cd = 01, ab = 00\n        4'b0101: out = 0; // cd = 01, ab = 01\n        4'b0110: out = 1; // cd = 01, ab = 10\n        4'b0111: out = 0; // cd = 01, ab = 11\n        4'b1000: out = 0; // cd = 10, ab = 00\n        4'b1001: out = 1; // cd = 10, ab = 01\n        4'b1010: out = 0; // cd = 10, ab = 10\n        4'b1011: out = 1; // cd = 10, ab = 11\n        4'b1100: out = 1; // cd = 11, ab = 00\n        4'b1101: out = 0; // cd = 11, ab = 01\n        4'b1110: out = 1; // cd = 11, ab = 10\n        4'b1111: out = 0; // cd = 11, ab = 11\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": " out_lo = in[7:0];\nassign out_hi = in[15:8];\nendmodule\n"}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\nassign out = ~(a | b);\nendmodule\n"}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\nassign out_assign = a ^ b;\n\nalways @* begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n"}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\nalways @(*) begin\n    case (y)\n        6'b000001: begin // State A\n            Y2 = 0;\n            Y4 = 0;\n        end\n        6'b000010: begin // State B\n            Y2 = 0;\n            Y4 = 0;\n        end\n        6'b000100: begin // State C\n            Y2 = 0;\n            Y4 = 1;\n        end\n        6'b001000: begin // State D\n            Y2 = 1;\n            Y4 = 0;\n        end\n        6'b010000: begin // State E\n            Y2 = 0;\n            Y4 = 0;\n        end\n        6'b100000: begin // State F\n            Y2 = 0;\n            Y4 = 1;\n        end\n        default: begin\n            Y2 = 0;\n            Y4 = 0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\nreg dff_a, dff_b, dff_c;\nwire a_xor, b_and, c_or;\n\nalways @(posedge clk) begin\n    dff_a <= a_xor;\n    dff_b <= b_and;\n    dff_c <= c_or;\nend\n\nassign a_xor = x ^ dff_a;\nassign b_and = x & ~dff_b;\nassign c_or = x | ~dff_c;\n\nassign z = ~(dff_a ^ dff_b ^ dff_c);\n\nendmodule\n"}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (a & ~b & ~c & ~d) | (a & ~b & c & ~d) | (a & ~b & c & d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & d) | (~a & b & c & d);\nendmodule\n"}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 0; // q[-1] is considered as 0\n        for (int i = 1; i < 511; i++) begin\n            q[i] <= (q[i-1] & q[i] & q[i+1]) ? 0 :\n                     (q[i-1] & q[i] & ~q[i+1]) ? 1 :\n                     (q[i-1] & ~q[i] & q[i+1]) ? 1 :\n                     (q[i-1] & ~q[i] & ~q[i+1]) ? 0 :\n                     (~q[i-1] & q[i] & q[i+1]) ? 1 :\n                     (~q[i-1] & q[i] & ~q[i+1]) ? 1 :\n                     (~q[i-1] & ~q[i] & q[i+1]) ? 1 :\n                     0; // (~q[i-1] & ~q[i] & ~q[i+1]) case\n        end\n        q[511] <= 0; // q[512] is considered as 0\n    end\nend\nendmodule\n"}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nassign out = (state == D) ? 1 : 0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // default to A for safety\n    endcase\nend\n\nendmodule\n"}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (c)\n        4'd0: q = b;\n        4'd1: q = e;\n        4'd2: q = a;\n        4'd3: q = d;\n        4'd4, 4'd5, 4'd6, 4'd7, 4'd8, 4'd9: q = f;\n        4'd10: q = f;\n        4'd11: q = f;\n        4'd12: q = f;\n        4'd13: q = f;\n        4'd14: q = f;\n        4'd15: q = f;\n        default: q = 4'bxxxx;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\n\talways @(*) begin\n\t\tif (sel) \n\t\t\tout = b;\n\t\telse \n\t\t\tout = a;\n\tend\nendmodule\n"}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": ""}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        out <= (in & ~{in[30:0], 1'b0}) | out;\n    end\nend\nendmodule\n"}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\nwire [8:0] sum;\nassign sum = {1'b0, a} + {1'b0, b}; // perform addition with carry bit\n\nassign s = sum[7:0]; // take the lower 8 bits as sum\nassign overflow = (a[7] == b[7]) && (s[7] != a[7]); // overflow occurs if the sign of a and b are the same and different from the sign of the result\n\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    assign B3_next = state[8]; // B3 goes to Count on next cycle\n    assign S_next = ~state[0] & d; // From S to S1 if d = 1\n    assign S1_next = state[1] & d; // From S1 to S11 if d = 1\n    assign Count_next = state[9] & ~done_counting; // Count remains if done_counting = 0\n    assign Wait_next = state[9] & done_counting; // Wait if done_counting = 1\n    assign done = state[9] & done_counting & ack; // done signal when in Wait state and ack is 1\n    assign counting = state[9]; // counting is high when in Count state\n    assign shift_ena = state[4]; // shift_ena is high when in B0 state\n\nendmodule\n"}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) // Increment if less than maximum\n                    state <= state + 1;\n            end else begin\n                if (state > 2'b00) // Decrement if greater than minimum\n                    state <= state - 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\n    always @* begin\n        pos = 3'b0; // Default to zero\n        casez (in)\n            8'b1??????? : pos = 3'd0;\n            8'b01?????? : pos = 3'd1;\n            8'b001????? : pos = 3'd2;\n            8'b0001???? : pos = 3'd3;\n            8'b00001??? : pos = 3'd4;\n            8'b000001?? : pos = 3'd5;\n            8'b0000001? : pos = 3'd6;\n            8'b00000001 : pos = 3'd7;\n            default: pos = 3'b0; // No bits set\n        endcase\n    end\nendmodule\n"}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\nalways @* begin\n    // Default all outputs to low\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode to determine which output to assert\n    case (scancode)\n        16'hE06B: left = 1;   // left arrow\n        16'hE072: down = 1;   // down arrow\n        16'hE074: right = 1;  // right arrow\n        16'hE075: up = 1;     // up arrow\n        default: ;             // no output\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\nwire c1, c2, c3;\n\nfull_adder FA0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder FA1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder FA2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder FA3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n"}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule\n"}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\nwire and1_out;\nwire and2_out;\n\nand(and1_out, a, b);\nand(and2_out, c, d);\nor(out, and1_out, and2_out);\nnot(out_n, out);\n\nendmodule\n"}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\nreg [7:0] Q;\nwire [2:0] sel;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {S, Q[7:1]};\n    end\nend\n\nassign sel = {A, B, C};\n\nalways @(*) begin\n    case (sel)\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n        default: Z = 1'b0; //default case for safety\n    endcase\nend\n\nendmodule\n"}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\nassign heater = (mode == 1 && too_cold) || fan_on;\nassign aircon = (mode == 0 && too_hot) || fan_on;\nassign fan = (heater || aircon || fan_on);\nendmodule\n"}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\nwire [3:0] in = {a, b, c, d};\n\n// Sum of Products\nassign out_sop = (in == 4'b0010) | (in == 4'b0111) | (in == 4'b1111);\n\n// Product of Sums\nassign out_pos = ~((in == 4'b0000) | (in == 4'b0001) | (in == 4'b0100) | (in == 4'b0101) | \n                   (in == 4'b0110) | (in == 4'b1001) | (in == 4'b1010) | (in == 4'b1101) | \n                   (in == 4'b1110));\n\nendmodule\n"}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])};\n    end\nend\nendmodule\n"}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": " q = (b & d) | (b & c) | (a & ~b & d) | (a & b & ~c);\nendmodule\n"}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nwire n1, n2, n3, n4;\nwire n5, n6, n7, n8;\n\nassign n1 = ~(p1a & p1b & p1c & p1d);\nassign n2 = ~(p2a & p2b & p2c & p2d);\n\nassign p1y = n1;\nassign p2y = n2;\n\nendmodule\n"}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @* begin\n    out = 0; // Initialize output to zero\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i]; // Count the number of 1's\n    end\nend\n\nendmodule\n"}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule\n"}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @* begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'hxxxx; // Undefined case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'b1001) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\n\tassign out = in1 & ~in2;\nendmodule\n"}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": " out = in;\nendmodule\n"}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nlocalparam A = 2'b00, B = 2'b01;\n\nassign out = (state == A) ? 1'b0 : 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) \n\t\tstate <= B;\n\telse \n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tA: begin\n\t\t\tif (in == 0)\n\t\t\t\tnext_state = B;\n\t\t\telse \n\t\t\t\tnext_state = A;\n\t\tend\n\t\tB: begin\n\t\t\tif (in == 0)\n\t\t\t\tnext_state = A;\n\t\t\telse \n\t\t\t\tnext_state = B;\n\t\tend\n\t\tdefault: next_state = B; // default case to handle unexpected states\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nalways @(negedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a ^ b);\nendmodule\n"}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\nA A1(.x(x), .y(y), .z(a1_out));\nA A2(.x(x), .y(y), .z(a2_out));\nB B1(.x(x), .y(y), .z(b1_out));\nB B2(.x(x), .y(y), .z(b2_out));\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\n\nassign z = or_out ^ and_out;\n\nendmodule\n"}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: begin // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            2'b00: begin // Do not rotate\n                q <= q;\n            end\n            2'b11: begin // Do not rotate\n                q <= q;\n            end\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b000000000;\n    end else if (q == 10'b111110100) begin // 999 in binary\n        q <= 10'b000000000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": " out = ~in;\nendmodule\n"}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n  assign next_state = (state[0] && !in) ? 10'b0000000001 :\n                      (state[0] && in)  ? 10'b0000000010 :\n                      (state[1] && !in) ? 10'b0000000001 :\n                      (state[1] && in)  ? 10'b0000000100 :\n                      (state[2] && !in) ? 10'b0000000001 :\n                      (state[2] && in)  ? 10'b0000001000 :\n                      (state[3] && !in) ? 10'b0000000001 :\n                      (state[3] && in)  ? 10'b0000010000 :\n                      (state[4] && !in) ? 10'b0000000001 :\n                      (state[4] && in)  ? 10'b0000100000 :\n                      (state[5] && !in) ? 10'b0001000000 :\n                      (state[5] && in)  ? 10'b0010000000 :\n                      (state[6] && !in) ? 10'b0010000000 :\n                      (state[6] && in)  ? 10'b0100000000 :\n                      (state[7] && !in) ? 10'b0000000001 :\n                      (state[7] && in)  ? 10'b0000000001 :\n                      (state[8] && !in) ? 10'b0000000001 :\n                      (state[8] && in)  ? 10'b0000000010 :\n                      (state[9] && !in) ? 10'b0000000001 :\n                      (state[9] && in)  ? 10'b0000000010 :\n                      10'b0000000000;\n\n  assign out1 = state[7] || state[8] || state[9];\n  assign out2 = state[7] || state[9];\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;          // Qold\n        2'b01: Q <= 0;          // Reset\n        2'b10: Q <= 1;          // Set\n        2'b11: Q <= ~Q;         // Toggle\n    endcase\nend\n\nendmodule\n"}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": " out = in[0] + in[1] + in[2];\n\nendmodule\n"}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\tassign out[24] = ~(a ^ a);\n\tassign out[23] = ~(a ^ b);\n\tassign out[22] = ~(a ^ c);\n\tassign out[21] = ~(a ^ d);\n\tassign out[20] = ~(a ^ e);\n\tassign out[19] = ~(b ^ a);\n\tassign out[18] = ~(b ^ b);\n\tassign out[17] = ~(b ^ c);\n\tassign out[16] = ~(b ^ d);\n\tassign out[15] = ~(b ^ e);\n\tassign out[14] = ~(c ^ a);\n\tassign out[13] = ~(c ^ b);\n\tassign out[12] = ~(c ^ c);\n\tassign out[11] = ~(c ^ d);\n\tassign out[10] = ~(c ^ e);\n\tassign out[9] = ~(d ^ a);\n\tassign out[8] = ~(d ^ b);\n\tassign out[7] = ~(d ^ c);\n\tassign out[6] = ~(d ^ d);\n\tassign out[5] = ~(d ^ e);\n\tassign out[4] = ~(e ^ a);\n\tassign out[3] = ~(e ^ b);\n\tassign out[2] = ~(e ^ c);\n\tassign out[1] = ~(e ^ d);\n\tassign out[0] = ~(e ^ e);\nendmodule\n"}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n\treg state, next_state;\n\n\tlocalparam LEFT = 1'b0, RIGHT = 1'b1;\n\n\tassign walk_left = (state == LEFT);\n\tassign walk_right = (state == RIGHT);\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= LEFT;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tLEFT: begin\n\t\t\t\tif (bump_right) \n\t\t\t\t\tnext_state = RIGHT;\n\t\t\t\telse \n\t\t\t\t\tnext_state = LEFT;\n\t\t\tend\n\t\t\tRIGHT: begin\n\t\t\t\tif (bump_left) \n\t\t\t\t\tnext_state = LEFT;\n\t\t\t\telse \n\t\t\t\t\tnext_state = RIGHT;\n\t\t\tend\n\t\t\tdefault: next_state = LEFT;\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\nassign q = a & b;\n\nendmodule\n"}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\twire and1_out, and2_out, and3_out, and4_out;\n\n\tassign and1_out = p1a & p1b & p1c;\n\tassign and2_out = p1d & p1e & p1f;\n\tassign p1y = and1_out | and2_out;\n\n\tassign and3_out = p2a & p2b;\n\tassign and4_out = p2c & p2d;\n\tassign p2y = and3_out | and4_out;\n\nendmodule\n"}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x) Y0 <= 1'b0; // Next state 001\n            else Y0 <= 1'b0;  // Next state 000\n            z <= 1'b0;\n        end\n        3'b001: begin\n            if (x) Y0 <= 1'b1; // Next state 100\n            else Y0 <= 1'b1;  // Next state 001\n            z <= 1'b0;\n        end\n        3'b010: begin\n            if (x) Y0 <= 1'b1; // Next state 001\n            else Y0 <= 1'b0;  // Next state 010\n            z <= 1'b0;\n        end\n        3'b011: begin\n            if (x) Y0 <= 1'b0; // Next state 010\n            else Y0 <= 1'b1;  // Next state 001\n            z <= 1'b1;\n        end\n        3'b100: begin\n            if (x) Y0 <= 1'b0; // Next state 100\n            else Y0 <= 1'b1;  // Next state 011\n            z <= 1'b1;\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nalways @(*) begin\n    out = ~(in1 | in2);\nend\n\nendmodule\n"}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": " w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n"}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\nendmodule\n"}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\nreg [9:0] counter;\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data; // Load the counter with the input data\n    end else if (counter > 0) begin\n        counter <= counter - 1; // Decrement the counter\n    end\nend\n\nassign tc = (counter == 0); // Terminal count signal\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n    reg [3:0] state, next_state;\n    reg start_shifting;\n\n    localparam S0 = 4'b0000,  // Initial state\n               S1 = 4'b0001,  // Received 1\n               S2 = 4'b0010,  // Received 11\n               S3 = 4'b0011,  // Received 110\n               S4 = 4'b0100;  // Received 1101\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            start_shifting <= 0;\n        end else begin\n            state <= next_state;\n            if (next_state == S4) begin\n                start_shifting <= 1;\n            end\n        end\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (state)\n            S0: next_state = (data) ? S1 : S0;\n            S1: next_state = (data) ? S2 : S0;\n            S2: next_state = (data) ? S3 : S0;\n            S3: next_state = (data) ? S4 : S2;\n            S4: next_state = S4;  // Remain in S4 when sequence found\n            default: next_state = S0;\n        endcase\n    end\n\n    assign start_shifting = (state == S4) ? 1 : start_shifting;\n\nendmodule\n"}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\nreg [7:0] in_d;\n\nalways @(posedge clk) begin\n    in_d <= in;\n    anyedge <= 8'b0; // Reset output\n    anyedge <= (in & ~in_d); // Detect rising edge\nend\nendmodule\n"}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset to 1\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001; // Roll over to 1 after 10\n    end else begin\n        q <= q + 1; // Increment the counter\n    end\nend\nendmodule\n"}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\n    always @(posedge clk) begin\n        if (a) begin\n            q <= q; // Keep the value if 'a' is high\n        end else begin\n            q <= q + 1; // Increment q if 'a' is low\n        end\n    end\nendmodule\n"}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset to 1\n    end else begin\n        q <= {q[3] ^ q[4], q[4:1]};\n    end\nend\nendmodule\n"}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(*) begin\n        if (do_sub == 0) \n            out = a + b;\n        else \n            out = a - b;\n\n        result_is_zero = (out == 8'b0);\n    end\n\nendmodule\n"}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 0; // d\n            4'b0001: f = 0; \n            4'b0010: f = 0; // d\n            4'b0011: f = 1; \n            4'b0100: f = 0; \n            4'b0101: f = 1; \n            4'b0110: f = 1; \n            4'b0111: f = 1; \n            4'b1000: f = 1; \n            4'b1001: f = 1; \n            4'b1010: f = 0; \n            4'b1011: f = 1; // d\n            4'b1100: f = 1; \n            4'b1101: f = 1; \n            4'b1110: f = 0; // d\n            4'b1111: f = 0; // d\n            default: f = 0; // default case\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'b0000; valid = 1; end // Key 0\n        8'h16: begin out = 4'b0001; valid = 1; end // Key 1\n        8'h1e: begin out = 4'b0010; valid = 1; end // Key 2\n        8'h26: begin out = 4'b0011; valid = 1; end // Key 3\n        8'h25: begin out = 4'b0100; valid = 1; end // Key 4\n        8'h2e: begin out = 4'b0101; valid = 1; end // Key 5\n        8'h36: begin out = 4'b0110; valid = 1; end // Key 6\n        8'h3d: begin out = 4'b0111; valid = 1; end // Key 7\n        8'h3e: begin out = 4'b1000; valid = 1; end // Key 8\n        8'h46: begin out = 4'b1001; valid = 1; end // Key 9\n        default: begin out = 4'b0000; valid = 0; end // No valid key\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\nassign out[0] = in[7];\nassign out[1] = in[6];\nassign out[2] = in[5];\nassign out[3] = in[4];\nassign out[4] = in[3];\nassign out[5] = in[2];\nassign out[6] = in[1];\nassign out[7] = in[0];\nendmodule\n"}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'bx;  // don't-care\n        4'b0001: out = 0;\n        4'b0010: out = 1;\n        4'b0011: out = 1;\n        4'b0100: out = 0;\n        4'b0101: out = 0;\n        4'b0110: out = 1; \n        4'b0111: out = 1;\n        4'b1000: out = 0;\n        4'b1001: out = 1;\n        4'b1010: out = 1;\n        4'b1011: out = 1;\n        4'b1100: out = 0;\n        4'b1101: out = 1;\n        4'b1110: out = 1;\n        4'b1111: out = 1;\n        default: out = 1'bx;  // default case if none match\n    endcase\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (shift_ena) begin\n\t\t\tq <= {data, q[3:1]}; // Shift in data MSB first\n\t\tend else if (count_ena) begin\n\t\t\tq <= q - 1; // Decrement the value in the shift register\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\n\tassign out = in;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\nreg [3:0] count;\nreg shift_enable;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n        shift_enable <= 1'b1;\n    end else if (count < 4'b0011) begin\n        count <= count + 1;\n    end else begin\n        shift_enable <= 1'b0;\n    end\nend\n\nassign shift_ena = shift_enable;\n\nendmodule\n"}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\nalways @* begin\n    if (sel_b1 && sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\n\nendmodule\n"}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\nassign out = (b & c) | (a & b) | (a & c) | (b & ~c);\nendmodule\n"}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\ntypedef enum logic [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\nstate_t state, next_state;\n\nalways_ff @(posedge clk or negedge resetn) begin\n    if (!resetn)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways_comb begin\n    case (state)\n        A: begin\n            if (r[1] == 1) \n                next_state = B;\n            else if (r[2] == 1) \n                next_state = C;\n            else if (r[3] == 1)\n                next_state = D;\n            else \n                next_state = A;\n        end\n        B: begin\n            if (r[1] == 1) \n                next_state = B;\n            else \n                next_state = A;\n        end\n        C: begin\n            if (r[2] == 1) \n                next_state = C;\n            else \n                next_state = A;\n        end\n        D: begin\n            next_state = A;\n        end\n        default: next_state = A;\n    endcase\nend\n\nassign g[1] = (state == B) ? 1 : 0;\nassign g[2] = (state == C) ? 1 : 0;\nassign g[3] = (state == D) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'b1001) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\tlocalparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n\t// State transition logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1)\n\t\t\t\t\tnext_state = BYTE1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE1: begin\n\t\t\t\tif (in[3] == 1)\n\t\t\t\t\tnext_state = BYTE2;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE2: begin\n\t\t\t\tif (in[3] == 1)\n\t\t\t\t\tnext_state = BYTE3;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE3: begin\n\t\t\t\tnext_state = IDLE; // After receiving third byte, go back to IDLE\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\n\tassign done = (state == BYTE3);\n\nendmodule\n"}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": " out = (sel) ? b : a;\nendmodule\n"}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": " out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\nendmodule\n"}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [2:0] y;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        y <= 3'b000;\n        z <= 1'b0;\n    end else begin\n        case (y)\n            3'b000: begin\n                if (x) begin\n                    y <= 3'b001;\n                end else begin\n                    y <= 3'b000;\n                end\n                z <= 1'b0;\n            end\n            3'b001: begin\n                if (x) begin\n                    y <= 3'b100;\n                end else begin\n                    y <= 3'b001;\n                end\n                z <= 1'b0;\n            end\n            3'b010: begin\n                if (x) begin\n                    y <= 3'b001;\n                end else begin\n                    y <= 3'b010;\n                end\n                z <= 1'b0;\n            end\n            3'b011: begin\n                if (x) begin\n                    y <= 3'b010;\n                end else begin\n                    y <= 3'b001;\n                end\n                z <= 1'b1;\n            end\n            3'b100: begin\n                if (x) begin\n                    y <= 3'b100;\n                end else begin\n                    y <= 3'b011;\n                end\n                z <= 1'b1;\n            end\n            default: begin\n                y <= 3'b000;\n                z <= 1'b0;\n            end\n        endcase\n    end\nend\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\ntypedef enum logic [2:0] {\n    STATE_A, // Beginning state\n    STATE_B, // State after reset\n    STATE_C, // Monitoring x\n    STATE_D, // Setting g to 1\n    STATE_E  // Monitoring y\n} state_t;\n\nstate_t current_state, next_state;\nlogic [1:0] x_count;\nlogic f_reg, g_reg;\n\nassign f = f_reg;\nassign g = g_reg;\n\nalways_ff @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n        current_state <= STATE_A;\n        f_reg <= 0;\n        g_reg <= 0;\n        x_count <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\nalways_ff @(posedge clk) begin\n    case (current_state)\n        STATE_A: begin\n            f_reg <= 0; // Output f is 0\n            x_count <= 0; // Reset x counter\n        end\n\n        STATE_B: begin\n            f_reg <= 1; // Output f is 1 for one clock cycle\n        end\n\n        STATE_C: begin\n            if (x_count < 2)\n                x_count <= x_count + 1; // Count x values\n            else\n                next_state <= STATE_D; // Move to set g to 1\n        end\n\n        STATE_D: begin\n            g_reg <= 1; // Set g to 1\n            next_state <= STATE_E; // Move to monitor y\n        end\n\n        STATE_E: begin\n            if (y) begin\n                // Maintain g = 1 permanently\n                g_reg <= 1;\n            end else if (x_count < 3) begin\n                // Do nothing, stay in this state\n            end else begin\n                g_reg <= 0; // Set g = 0 permanently\n            end\n        end\n        \n        default: begin\n            next_state <= STATE_A;\n        end\n    endcase\nend\n\nalways_ff @(posedge clk) begin\n    if (current_state == STATE_C) begin\n        if (x == 1) begin\n            if (x_count == 0) next_state <= STATE_C; // first 1\n            else if (x_count == 1) next_state <= STATE_C; // followed by 0\n            else if (x_count == 2) next_state <= STATE_C; // followed by another 1\n        end else if (x == 0 && x_count == 1) begin\n            // Proceed normally, count remains the same\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(negedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b00110100; // 0x34 in binary\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\nassign parity = ~(in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7]);\nendmodule\n"}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\nalways @(*) begin\n    case (state)\n        2'b00: begin // State A\n            next_state = (in == 0) ? 2'b00 : 2'b01; // A or B\n            out = 1'b0;\n        end\n        2'b01: begin // State B\n            next_state = (in == 0) ? 2'b10 : 2'b01; // C or B\n            out = 1'b0;\n        end\n        2'b10: begin // State C\n            next_state = (in == 0) ? 2'b00 : 2'b11; // A or D\n            out = 1'b0;\n        end\n        2'b11: begin // State D\n            next_state = (in == 0) ? 2'b10 : 2'b01; // C or B\n            out = 1'b1;\n        end\n        default: begin\n            next_state = 2'b00; // Default to state A\n            out = 1'b0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    reg z;\n\n    always @(*) begin\n        case ({x, y})\n            2'b00: z = 1;\n            2'b01: z = 0;\n            2'b10: z = 0;\n            2'b11: z = 1;\n            default: z = 1;\n        endcase\n    end\nendmodule\n"}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= A;\n        else \n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (w) \n                    next_state = B;\n                else \n                    next_state = A;\n            end\n            B: begin\n                if (w) \n                    next_state = C;\n                else \n                    next_state = D;\n            end\n            C: begin\n                if (w) \n                    next_state = E;\n                else \n                    next_state = D;\n            end\n            D: begin\n                if (w) \n                    next_state = F;\n                else \n                    next_state = A;\n            end\n            E: begin\n                if (w) \n                    next_state = E;\n                else \n                    next_state = D;\n            end\n            F: begin\n                if (w) \n                    next_state = C;\n                else \n                    next_state = D;\n            end\n            default: next_state = A; // Default state\n        endcase\n    end\n\n    assign z = (current_state == E);\nendmodule\n"}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0; // Reset output to 0 on active-low reset\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0]; // Write to lower byte\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8]; // Write to upper byte\n        end\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\nalways @(posedge clk) begin\n    pedge <= 8'b0; // Clear the output at the start of each clock cycle\n    pedge <= in & ~({1'b0, in[7:1]}); // Detect the 0 to 1 transition\nend\nendmodule\n"}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\nalways @(posedge clock) begin\n    if (a) begin\n        p <= 1;\n        q <= 0;\n    end\n    else begin\n        p <= 0;\n        q <= p;\n    end\nend\n\nendmodule\n"}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 1'b0 ^ q[1]; // q[-1] is considered as 0\n        for (int i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n        q[511] <= q[510] ^ 1'b0; // q[512] is considered as 0\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\nassign z = (A == B) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\nassign out_both = in[98:0] & in[99:1];\nassign out_any = in[99:1] | in[98:0];\nassign out_different = (in[98:0] ^ {in[0], in[99:1]});\n\nendmodule\n"}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\nalways @(ena, d) begin\n    if (ena) \n        q <= d;\nend\nendmodule\n"}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    assign out = in[(sel * 4) +: 4];\nendmodule\n"}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\nalways_comb begin\n    case(sel)\n        4'b0000: out = a;\n        4'b0001: out = b;\n        4'b0010: out = c;\n        4'b0011: out = d;\n        4'b0100: out = e;\n        4'b0101: out = f;\n        4'b0110: out = g;\n        4'b0111: out = h;\n        4'b1000: out = i;\n        default: out = 16'b1111111111111111; // sets all bits to '1' for sel 9 to 15\n    endcase\nend\nendmodule\n"}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = |(a | b);\n\tassign out_not = {~b, ~a};\n\nendmodule\n"}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: next_state = (in) ? 4'b0010 : 4'b0001; // A\n\t\t\t4'b0010: next_state = (in) ? 4'b0010 : 4'b0100; // B\n\t\t\t4'b0100: next_state = (in) ? 4'b1000 : 4'b0001; // C\n\t\t\t4'b1000: next_state = (in) ? 4'b0010 : 4'b0100; // D\n\t\t\tdefault: next_state = 4'b0001; // Default to A\n\t\tendcase\n\tend\n\t\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output logic\n\nendmodule\n"}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\nalways @(*) begin\n    min = a; // Assume a is the minimum initially\n    if (b < min) min = b;\n    if (c < min) min = c;\n    if (d < min) min = d;\nend\nendmodule\n"}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "assign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule"}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = ( (~c & ~d & a) | \n               (~c & d & a) | \n               (~b & ~c & d) | \n               (b & c & ~d) | \n               (b & c & d) | \n               (a & ~b & ~d) );\n\nendmodule\n"}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\nreg [1:0] state, next_state;\nreg [2:0] count;\n\nparameter A = 2'b00, B = 2'b01;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= A;\n        z <= 0;\n        count <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        A: begin\n            if (s) begin\n                next_state = B;\n                count = 0; // Reset count when entering state B\n            end else begin\n                next_state = A;\n            end\n            z = 0; // z remains 0 in state A\n        end\n        B: begin\n            if (count < 3) begin\n                if (w) begin\n                    count = count + 1;\n                end\n                next_state = B;\n                z = 0; // Default\n            end else begin\n                if (count == 2) begin\n                    z = 1;  // Set z to 1 if w was 1 exactly two times\n                end else begin\n                    z = 0;  // Reset z to 0 otherwise\n                end\n                count = 0; // Reset count for next sequence of three checks\n                next_state = B; // Remain in state B\n            end\n        end\n        default: begin\n            next_state = A;\n            z = 0;\n            count = 0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": "\n\tassign out = { {24{in[7]}}, in };\nendmodule\n"}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule\n"}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @* begin\n    casez (in)\n        4'b???1: pos = 2'd0;  // in[0] is the first high bit\n        4'b??10: pos = 2'd1;  // in[1] is the first high bit\n        4'b?100: pos = 2'd2;  // in[2] is the first high bit\n        4'b1000: pos = 2'd3;  // in[3] is the first high bit\n        default: pos = 2'd0;   // If none are high, output 0\n    endcase\nend\nendmodule\n"}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg state, next_state;\n\nlocalparam OFF = 1'b0, ON = 1'b1;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= OFF;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        OFF: begin\n            if (j) begin\n                next_state = ON;\n            end else begin\n                next_state = OFF;\n            end\n        end\n        ON: begin\n            if (k) begin\n                next_state = OFF;\n            end else begin\n                next_state = ON;\n            end\n        end\n        default: next_state = OFF; // Default case to prevent latches\n    endcase\nend\n\nassign out = (state == ON);\n\nendmodule\n"}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\nassign out = 0;\nendmodule\n"}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\nassign one = 1'b1;\nendmodule\n"}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\nalways @* begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99 - i];\n    end\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\nlogic xor_out;\n\nassign xor_out = in ^ out;\n\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n"}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule\n"}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\nassign f = (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);\n\nendmodule\n"}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule\n"}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n"}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    typedef enum logic [1:0] {OFF, ON} state_t;\n    state_t current_state, next_state;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= OFF;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always_comb begin\n        case (current_state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON;\n                end else begin\n                    next_state = OFF;\n                end\n            end\n            ON: begin\n                if (k) begin\n                    next_state = OFF;\n                end else begin\n                    next_state = ON;\n                end\n            end\n            default: next_state = OFF;\n        endcase\n    end\n\n    assign out = (current_state == ON) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    wire [29:0] concatenated_input;\n    assign concatenated_input = {a, b, c, d, e, f};\n    \n    assign w = concatenated_input[7:0];\n    assign x = concatenated_input[15:8];\n    assign y = concatenated_input[23:16];\n    assign z = {concatenated_input[29:24], 2'b11};\n\nendmodule\n"}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d);\nendmodule\n"}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = a & b;\nendmodule\n"}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    localparam B = 1'b0, A = 1'b1; \n\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\n    always @(posedge clk) begin\n        if (reset) \n            state <= B;\n        else \n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            B: begin\n                if (in) \n                    next_state = B;\n                else \n                    next_state = A;\n            end\n            A: begin\n                if (in) \n                    next_state = A;\n                else \n                    next_state = B;\n            end\n            default: next_state = B; \n        endcase\n    end\nendmodule\n"}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n"}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\nlogic xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\nassign mux_in[0] = 1'b0; // ab = 00\nassign mux_in[1] = c;    // ab = 01\nassign mux_in[2] = (c & d) | (c & ~d) | (~c & d); // ab = 11\nassign mux_in[3] = 1'b1; // ab = 10\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    \n    localparam A = 2'b01, B = 2'b10;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A;\n        else \n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = A;\n                    z = 0;\n                end\n            end\n            B: begin\n                next_state = B;\n                z = (x) ? 0 : 1;\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\nreg ff_state;\n\nassign state = a & ~b;\nassign q = ff_state;\n\nalways @(posedge clk) begin\n    if (state) \n        ff_state <= 1;\n    else \n        ff_state <= 0;\nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 1; // 1 at (00, 00)\n            4'b0001: f = 0; // 0 at (00, 01)\n            4'b0011: f = 0; // 0 at (00, 11)\n            4'b0010: f = 1; // 1 at (00, 10)\n            4'b0100: f = 0; // 0 at (01, 00)\n            4'b0101: f = 0; // 0 at (01, 01)\n            4'b0111: f = 0; // 0 at (01, 11)\n            4'b0110: f = 0; // 0 at (01, 10)\n            4'b1100: f = 1; // 1 at (11, 00)\n            4'b1101: f = 1; // 1 at (11, 01)\n            4'b1111: f = 1; // 1 at (11, 11)\n            4'b1110: f = 0; // 0 at (11, 10)\n            4'b1000: f = 1; // 1 at (10, 00)\n            4'b1001: f = 1; // 1 at (10, 01)\n            4'b1011: f = 0; // 0 at (10, 11)\n            4'b1010: f = 1; // 1 at (10, 10)\n            default: f = 0; // Default case\n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    parameter S0 = 3'b000, \n              S1 = 3'b001, \n              S2 = 3'b010, \n              S3 = 3'b011, \n              S4 = 3'b100, \n              S5 = 3'b101, \n              S6 = 3'b110, \n              S7 = 3'b111;\n\n    reg [2:0] state, next_state;\n    reg [2:0] count;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            count <= 3'b000;\n        end else begin\n            state <= next_state;\n            if (state == S3 && in) \n                count <= count + 1;\n            else if (state == S0 && !in) \n                count <= 3'b000; \n            else begin\n                if (in) \n                    count <= count + 1;\n                else \n                    count <= 3'b000;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in) \n                    next_state = S1;\n                else \n                    next_state = S0;\n            end\n            S1: begin\n                if (in) \n                    next_state = S2;\n                else \n                    next_state = S0;\n            end\n            S2: begin\n                if (in) \n                    next_state = S3;\n                else \n                    next_state = S0;\n            end\n            S3: begin\n                if (in) \n                    next_state = S4;  \n                else \n                    next_state = S0;\n            end\n            S4: begin\n                if (in) \n                    next_state = S5;\n                else \n                    next_state = S0;\n            end\n            S5: begin\n                if (in) \n                    next_state = S6;\n                else \n                    next_state = S0;\n            end\n            S6: begin\n                if (in) \n                    next_state = S7; \n                else \n                    next_state = S0;\n            end\n            S7: begin\n                if (in) \n                    next_state = S7; \n                else \n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    assign disc = (next_state == S3) ? 1'b1 : 1'b0;\n    assign flag = (next_state == S6) ? 1'b1 : 1'b0;\n    assign err = (next_state == S7) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n    reg [3:0] delay;\n    reg [3:0] remaining_time;\n    reg [9:0] count_cycles; // 1000 cycles max\n    reg [2:0] state;\n    \n    localparam IDLE = 3'b000;\n    localparam PATTERN = 3'b001;\n    localparam SHIFT = 3'b010;\n    localparam COUNT = 3'b011;\n    localparam NOTIFY = 3'b100;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            count_cycles <= 0;\n            remaining_time <= 0;\n            delay <= 0;\n        end\n        else begin\n            case (state)\n                IDLE: begin\n                    counting <= 0;\n                    done <= 0;\n                    if (data == 1) begin\n                        state <= PATTERN;\n                    end\n                end\n                \n                PATTERN: begin\n                    if (data == 1) begin\n                        count_cycles <= count_cycles + 1; // counting 1's\n                        if (count_cycles == 3) begin\n                            // Detected '110'\n                            state <= SHIFT;\n                            count_cycles <= 0; // reset count_cycles\n                        end\n                    end\n                    else begin\n                        // If we detect 0 at this point, we reset our detection stage\n                        state <= IDLE;\n                        count_cycles <= 0;\n                    end\n                end\n                \n                SHIFT: begin\n                    if (count_cycles < 4) begin\n                        delay[count_cycles] <= data; // Shift in delay bits\n                        count_cycles <= count_cycles + 1;\n                    end\n                    else begin\n                        state <= COUNT;\n                        remaining_time <= delay; // Set remaining time\n                        counting <= 1;\n                        count_cycles <= 0; // Reset for counting\n                    end\n                end\n                \n                COUNT: begin\n                    if (count_cycles < (delay + 1) * 1000) begin\n                        if (count_cycles % 1000 == 0 && remaining_time > 0) begin\n                            remaining_time <= remaining_time - 1; // Decrement every 1000 cycles\n                        end\n                        count_cycles <= count_cycles + 1;\n                    end\n                    else begin\n                        counting <= 0;\n                        done <= 1; // Timer done\n                        state <= NOTIFY;\n                    end\n                end\n                \n                NOTIFY: begin\n                    if (ack) begin\n                        state <= IDLE;\n                    end\n                end\n                \n                default: state <= IDLE; // safety\n            endcase\n        end\n    end\n    \n    assign count = counting ? remaining_time : 4'bxxxx; // Don't care when not counting\nendmodule\n"}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\nreg [1:0] state, next_state;\nparameter [1:0] IDLE = 2'b00, HIGH = 2'b01, MID = 2'b10, LOW = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= LOW;\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case(state)\n        LOW: begin\n            fr3 = 1;\n            fr2 = 1;\n            fr1 = 1;\n            dfr = 0;\n            if (s[1] && !s[2] && !s[3])\n                next_state = MID;\n            else\n                next_state = LOW;\n        end\n        \n        MID: begin\n            fr3 = 0;\n            fr2 = 1;\n            fr1 = 1;\n            dfr = (s[1] && !s[2] && !s[3]) ? 1 : 0;\n            if (s[2] && !s[3])\n                next_state = HIGH;\n            else if (!s[1] && !s[2] && !s[3])\n                next_state = LOW;\n            else\n                next_state = MID;\n        end\n        \n        HIGH: begin\n            fr3 = 0;\n            fr2 = 0;\n            fr1 = 1;\n            dfr = (s[2] && s[1]) ? 1 : 0;\n            if (s[3])\n                next_state = IDLE;\n            else if (!s[1] && !s[2] && !s[3])\n                next_state = LOW;\n            else\n                next_state = HIGH;\n        end\n        \n        IDLE: begin\n            fr3 = 0;\n            fr2 = 0;\n            fr1 = 0;\n            dfr = 0; \n            if (!s[1] && !s[2] && !s[3])\n                next_state = LOW;\n            else if (s[3])\n                next_state = IDLE;\n            else\n                next_state = HIGH;\n        end\n        \n        default: next_state = LOW;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [3:0] state;\n\treg [3:0] next_state;\n\treg [7:0] data;\n\treg valid;\n\t\n\tparameter IDLE = 4'b0000,\n\t          START = 4'b0001,\n\t          DATA = 4'b0010,\n\t          STOP = 4'b0011,\n\t          VALIDATE = 4'b0100;\n\t\n\tassign done = valid;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tvalid <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tvalid = 0;\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in == 0) // Detect start bit\n\t\t\t\t\tnext_state = START;\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tnext_state = DATA;\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (data_count < 8) begin\n\t\t\t\t\tdata[data_count] = in; // Store data bit\n\t\t\t\t\tdata_count = data_count + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STOP;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in == 1) begin // Check stop bit\n\t\t\t\t\tvalid = 1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = IDLE; // Wait for stop bit\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\nreg [3:0] state, next_state;\nreg [7:0] byte;\nreg [2:0] bit_count; // count the number of received bits\nreg done_reg;\n\nlocalparam IDLE = 4'd0,\n           START_BIT = 4'd1,\n           DATA_BITS = 4'd2,\n           STOP_BIT = 4'd3;\n\nassign out_byte = (done_reg) ? byte : 8'bz;\nassign done = done_reg;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n        byte <= 8'b0;\n        bit_count <= 3'b0;\n        done_reg <= 1'b0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (in == 1'b0)\n                next_state = START_BIT;\n            else\n                next_state = IDLE;\n        end\n        START_BIT: begin\n            next_state = DATA_BITS;\n        end\n        DATA_BITS: begin\n            if (bit_count < 3'b111) begin\n                next_state = DATA_BITS;\n            end else begin\n                next_state = STOP_BIT;\n            end\n        end\n        STOP_BIT: begin\n            if (in == 1'b1) begin\n                done_reg = 1'b1;\n            end else begin\n                next_state = IDLE; // wait for a stop bit to return to IDLE\n            end\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        byte <= 8'b0;\n        bit_count <= 3'b0;\n        done_reg <= 1'b0;\n    end else begin\n        case (state)\n            DATA_BITS: begin\n                byte[bit_count] <= in; // collect data bits\n                bit_count <= bit_count + 1;\n                done_reg <= 1'b0; // reset done when receiving data\n            end\n            STOP_BIT: begin\n                if (in == 1'b1) begin\n                    done_reg <= 1'b1; // indicate completion only if stop bit is correct\n                end\n                bit_count <= 3'b0; // reset bit counter after processing\n            end\n            default: begin\n                // other states do not change the byte and bit_count\n            end\n        endcase\n    end\nend\n\nendmodule\n"}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\n\treg [6:0] global_history;\n\treg [1:0] PHT[127:0];\n\twire [6:0] index;\n\twire [1:0] counter_state;\n\twire [1:0] updated_state;\n\n\tassign index = predict_pc ^ global_history;\n\tassign counter_state = PHT[index];\n\n\tassign predict_taken = (counter_state[1] == 1'b1);\n\tassign predict_history = global_history;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tglobal_history <= 7'b0;\n\t\t\tinteger i;\n\t\t\tfor (i = 0; i < 128; i = i + 1) begin\n\t\t\t\tPHT[i] <= 2'b00;\n\t\t\tend\n\t\tend else begin\n\t\t\tif (train_valid) begin\n\t\t\t\tif (train_mispredicted) begin\n\t\t\t\t\tglobal_history <= train_history;\n\t\t\t\tend\n\t\t\t\tif (train_taken) begin\n\t\t\t\t\tif (PHT[train_pc ^ global_history] != 2'b11) // increment if not maxed\n\t\t\t\t\t\tPHT[train_pc ^ train_history] <= PHT[train_pc ^ train_history] + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tif (PHT[train_pc ^ global_history] != 2'b00) // decrement if not min\n\t\t\t\t\t\tPHT[train_pc ^ train_history] <= PHT[train_pc ^ train_history] - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tif (predict_valid) begin\n\t\t\t\tglobal_history <= {global_history[5:0], predict_taken}; // Update global history with prediction\n\t\t\tend\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [3:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    localparam WALK_LEFT = 4'b0001,\n               WALK_RIGHT = 4'b0010,\n               FALL = 4'b0100,\n               DIGGING = 4'b1000,\n               SPLATTER = 4'b1111;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL) begin\n                fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLATTER;\n                    else if (walk_left) next_state = WALK_LEFT;\n                    else if (walk_right) next_state = WALK_RIGHT;\n                    else next_state = FALL;\n                end else begin\n                    next_state = FALL;\n                end\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIGGING;\n                else next_state = WALK_LEFT; // Default to walking left unless otherwise dotted\n            end\n            SPLATTER: begin\n                next_state = SPLATTER; // Remain in splatter state\n            end\n            default: next_state = WALK_LEFT; // Safety case\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    reg [2:0] state, next_state;\n    reg [1:0] bit_counter;\n\n    localparam S_IDLE = 3'b000,\n               S_PATTERN = 3'b001,\n               S_SHIFT = 3'b010,\n               S_COUNTING = 3'b011,\n               S_DONE = 3'b100;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= S_IDLE;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            bit_counter <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            S_IDLE: begin\n                if (data == 1) begin\n                    next_state = S_PATTERN;\n                end\n            end\n            \n            S_PATTERN: begin\n                if (data == 1) begin\n                    bit_counter = 1;\n                end else if (bit_counter == 1 && data == 0) begin\n                    bit_counter = 2;\n                end else if (bit_counter == 2 && data == 1) begin\n                    bit_counter = 3;\n                end else if (bit_counter == 3 && data == 1) begin\n                    next_state = S_SHIFT;\n                end else begin\n                    bit_counter = 0;\n                    next_state = S_IDLE;\n                end\n            end\n            \n            S_SHIFT: begin\n                shift_ena = 1;\n                if (bit_counter < 4) begin\n                    bit_counter = bit_counter + 1;\n                end else begin\n                    bit_counter = 0;\n                    next_state = S_COUNTING;\n                end\n            end\n            \n            S_COUNTING: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = S_DONE;\n                end\n            end\n\n            S_DONE: begin\n                done = 1;\n                if (ack) begin\n                    next_state = S_IDLE;\n                end\n            end\n\n        endcase\n    end\nendmodule\n"}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\nreg [255:0] next_state;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= next_state;\n    end\nend\n\nalways @(*) begin\n    integer i, j, count;\n    next_state = 0;\n    for (i = 0; i < 16; i = i + 1) begin\n        for (j = 0; j < 16; j = j + 1) begin\n            count = 0;\n            // Counting neighbors\n            for (integer di = -1; di <= 1; di = di + 1) begin\n                for (integer dj = -1; dj <= 1; dj = dj + 1) begin\n                    if (di == 0 && dj == 0) continue; // skip the cell itself\n                    count = count + q[(((i + di + 16) % 16) * 16) + ((j + dj + 16) % 16))];\n                end\n            end\n            \n            // Applying the rules\n            if (q[(i * 16) + j] == 1) begin\n                if (count < 2 || count > 3) begin\n                    next_state[(i * 16) + j] = 0; // Cell becomes 0\n                else begin\n                    next_state[(i * 16) + j] = 1; // Cell remains 1\n                end\n            end else begin\n                if (count == 3) begin\n                    next_state[(i * 16) + j] = 1; // Cell becomes 1\n                end else begin\n                    next_state[(i * 16) + j] = 0; // Cell remains 0\n                end\n            end\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    reg walk_left, walk_right, aaah, digging;\n    \n    localparam WALK_LEFT = 2'b00, \n               WALK_RIGHT = 2'b01, \n               FALLING = 2'b10, \n               DIGGING = 2'b11;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALLING;\n                end else if (dig) begin\n                    digging = 1;\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    walk_right = 1;\n                    next_state = WALK_RIGHT;\n                end else begin\n                    walk_left = 1;\n                end\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALLING;\n                end else if (dig) begin\n                    digging = 1;\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    walk_left = 1;\n                    next_state = WALK_LEFT;\n                end else begin\n                    walk_right = 1;\n                end\n            end\n            \n            FALLING: begin\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end\n                aaah = 1;\n            end\n            \n            DIGGING: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALLING;\n                end else begin\n                    digging = 1;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        hh <= 8'b00010000; // Reset hours to 12 in BCD\n        mm <= 8'b00000000; // Reset minutes to 00 BCD\n        ss <= 8'b00000000; // Reset seconds to 00 BCD\n        pm <= 0;           // Reset to AM\n    end else if (ena) begin\n        if (ss == 8'b00111001) begin // If seconds reach 59\n            ss <= 8'b00000000; // Reset seconds to 00\n            if (mm == 8'b00111001) begin // If minutes reach 59\n                mm <= 8'b00000000; // Reset minutes to 00\n                if (hh == 8'b00011000) begin // If hours reach 12\n                    hh <= 8'b00010000; // Reset to 12\n                    pm <= ~pm; // Toggle AM/PM\n                end else begin\n                    hh <= hh + 1; // Increment hour\n                end\n            end else begin\n                mm <= mm + 1; // Increment minutes\n            end\n        end else begin\n            ss <= ss + 1; // Increment seconds\n        end\n    end\nend\nendmodule\n"}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    reg falling;\n    \n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (falling);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            falling <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    falling = 1;\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    falling = 1;\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            FALLING: begin\n                falling = 1;\n                if (ground) begin\n                    falling = 0;\n                    next_state = (bump_right) ? WALK_LEFT : WALK_RIGHT;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        // Ones place\n        if (q[3:0] == 4'b1001) begin\n            q[3:0] <= 4'b0000;\n            ena[1] <= 1'b1; // Enable tens place\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n            ena[1] <= 1'b0;\n        end\n        \n        // Tens place\n        if (ena[1]) begin\n            if (q[7:4] == 4'b1001) begin\n                q[7:4] <= 4'b0000;\n                ena[2] <= 1'b1; // Enable hundreds place\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n                ena[2] <= 1'b0;\n            end\n        end else begin\n            ena[2] <= 1'b0;\n        end\n        \n        // Hundreds place\n        if (ena[2]) begin\n            if (q[11:8] == 4'b1001) begin\n                q[11:8] <= 4'b0000;\n                ena[3] <= 1'b1; // Enable thousands place\n            end else begin\n                q[11:8] <= q[11:8] + 1;\n                ena[3] <= 1'b0;\n            end\n        end else begin\n            ena[3] <= 1'b0;\n        end\n        \n        // Thousands place\n        if (ena[3]) begin\n            if (q[15:12] == 4'b1001) begin\n                q[15:12] <= 4'b0000;\n            end else begin\n                q[15:12] <= q[15:12] + 1;\n            end\n        end\n    end\nend\nendmodule\n"}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\nassign out = (sel == 1'b0) ? a : b;\nendmodule\n"}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = (w == 0) ? 0 : 0; // State A\n        3'b001: Y2 = (w == 0) ? 0 : 1; // State B\n        3'b010: Y2 = (w == 0) ? 0 : 1; // State C\n        3'b011: Y2 = (w == 0) ? 1 : 1; // State D\n        3'b100: Y2 = 1;                 // State E\n        3'b101: Y2 = (w == 0) ? 0 : 1; // State F\n        default: Y2 = 0;                // Default case\n    endcase\nend\nendmodule\n"}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\nassign motor = vibrate_mode ? 1 : (ring ? 1 : 0);\nassign ringer = !vibrate_mode ? (ring ? 1 : 0) : 0;\n\nendmodule\n"}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\nassign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n"}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\nassign zero = 1'b0;\nendmodule\n"}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a == 0) begin\n        q <= q; // retain value\n    end else begin\n        q <= ~q; // toggle output\n    end\nend\n\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] store; // assuming a maximum of 32 bits for the 2's complement result\n    reg [5:0] count;  // To count the number of bits received\n    reg output_valid; // Indicates when the output z is valid\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            store <= 0;\n            count <= 0;\n            output_valid <= 0;\n        end else begin\n            if (count < 32) begin\n                store[count] <= x; // Store the bit in the corresponding position\n                count <= count + 1; // Increment the counter\n            end\n            if (count == 32) begin\n                store <= ~store + 1; // Compute 2's complement\n                output_valid <= 1; // Set the output valid flag\n            end\n        end\n    end\n\n    assign z = output_valid ? store[0] : 0; // Output the least significant bit of the result when valid\n\nendmodule\n"}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\n\t// Define states\n\tlocalparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\t// State transition on clock edge\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= A;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: next_state = (in == 0) ? A : B;\n\t\t\tB: next_state = (in == 0) ? C : B;\n\t\t\tC: next_state = (in == 0) ? A : D;\n\t\t\tD: next_state = (in == 0) ? C : B;\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == D) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge r) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load)\n        q <= data;\n    else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;           // Shift left by 1 bit\n            2'b01: q <= q << 8;           // Shift left by 8 bits\n            2'b10: q <= {q[62:0], q[63]};  // Arithmetic shift right by 1 bit\n            2'b11: q <= {q[63:8], q[63]};  // Arithmetic shift right by 8 bits\n            default: q <= q;               // No shift\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [1:0] state, next_state;\n\nlocalparam IDLE = 2'b00,\n           ONE = 2'b01,\n           TEN = 2'b10;\n\nalways @(posedge clk or negedge aresetn) begin\n    if (!aresetn)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (x)\n                next_state = ONE;\n            else\n                next_state = IDLE;\n        end\n        ONE: begin\n            if (~x)\n                next_state = TEN;\n            else\n                next_state = ONE;\n        end\n        TEN: begin\n            if (x)\n                next_state = IDLE;\n            else\n                next_state = IDLE;\n        end\n    endcase\nend\n\nalways @(posedge clk) begin\n    if (state == TEN && x) begin\n        z <= 1'b1;\n    end else if (state == IDLE && x) begin\n        z <= 1'b0;\n    end else if (state == ONE && ~x) begin\n        z <= 1'b0;\n    end else if (state == TEN && ~x) begin\n        z <= 1'b0;\n    end else begin\n        z <= 1'b0;\n    end\nend\n\nendmodule\n"}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    reg [2:0] state, next_state;\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case(state)\n            A: begin\n                if (w == 0) next_state = B;\n                else next_state = A;\n            end\n            B: begin\n                if (w == 0) next_state = C;\n                else next_state = D;\n            end\n            C: begin\n                if (w == 0) next_state = E;\n                else next_state = D;\n            end\n            D: begin\n                if (w == 0) next_state = F;\n                else next_state = A;\n            end\n            E: begin\n                if (w == 0) next_state = E;\n                else next_state = D;\n            end\n            F: begin\n                if (w == 0) next_state = C;\n                else next_state = D;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign z = (state == E) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\treg [1:0] byte_count;\n\treg [23:0] message;\n\treg scanning;\n\n\tassign out_bytes = (done) ? message : 24'bx; \n\tassign done = (byte_count == 2'b11) && scanning;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tbyte_count <= 2'b00;\n\t\t\tmessage <= 24'b0;\n\t\t\tscanning <= 1'b0;\n\t\tend else begin\n\t\t\tif (~scanning) begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tscanning <= 1'b1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tmessage <= {message[15:0], in};\n\t\t\t\tif (byte_count < 2'b11) begin\n\t\t\t\t\tbyte_count <= byte_count + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tscanning <= 1'b0;\n\t\t\t\t\tbyte_count <= 2'b00;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\nassign Y1 = (y[0] & ~w) | (y[1] & ~w) | (y[2] & ~w) | (y[3] & ~w) | (y[4] & ~w);\nassign Y3 = (y[2] & w) | (y[3] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n"}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": " outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule\n"}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({c, d, b, a})\n        4'b0000: out = 0;\n        4'b0001: out = 1;\n        4'b0010: out = 0;\n        4'b0011: out = 1;\n        4'b0100: out = 1;\n        4'b0101: out = 0;\n        4'b0110: out = 1;\n        4'b0111: out = 0;\n        4'b1000: out = 1;\n        4'b1001: out = 0;\n        4'b1010: out = 1;\n        4'b1011: out = 0;\n        4'b1100: out = 0;\n        4'b1101: out = 1;\n        4'b1110: out = 0;\n        4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\nassign out_lo = in[7:0];\nassign out_hi = in[15:8];\nendmodule\n"}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a | b);\nendmodule\n"}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n    assign out_assign = a ^ b;\n\n    always @* begin\n        out_always_comb = a ^ b;\n    end\n\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\nendmodule\n"}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\nassign Y2 = (y[2] & w) | (y[4] & ~w) | (y[5] & ~w);\nassign Y4 = (y[1] & w) | (y[6] & w) | (y[3] & ~w);\n\nendmodule\n"}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\nreg [2:0] d_ff; // 3 D flip-flops\n\nwire xor_out;\nwire and_out;\nwire or_out;\n\n// D flip-flops\nalways @(posedge clk) begin\n    d_ff[0] <= xor_out; // D flip-flop 0\n    d_ff[1] <= and_out; // D flip-flop 1\n    d_ff[2] <= or_out;  // D flip-flop 2\nend\n\n// Gate Outputs\nassign xor_out = x ^ d_ff[0];\nassign and_out = x & ~d_ff[1];\nassign or_out = x | ~d_ff[2];\n\n// Output Z\nassign z = d_ff[0] ~^ d_ff[1] ~^ d_ff[2];\n\nendmodule\n"}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (a & b) | (b & c) | (c & d) | (a & d);\nendmodule\n"}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [511:0] next_q;\n        next_q[0] = (q[0] & q[1]) | (q[1] & ~q[2]);\n        next_q[511] = (q[510] & q[511]) | (q[511] & ~0);\n        for (integer i = 1; i < 511; i = i + 1) begin\n            next_q[i] = (q[i-1] & q[i]) | (q[i] & ~q[i+1]);\n        end\n        q <= next_q;\n    end\nend\nendmodule\n"}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State transition\n    always @ (posedge clk or posedge reset) begin\n        if (reset) \n            state <= A;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic\n    always @ (*) begin\n        case (state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (c)\n        4'b0000: q = b;      // c = 0\n        4'b0001: q = e;      // c = 1\n        4'b0010: q = a;      // c = 2\n        4'b0011: q = d;      // c = 3\n        4'b0100: q = 4'b1111; // c = 4\n        4'b0101: q = 4'b1111; // c = 5\n        4'b0110: q = 4'b1111; // c = 6\n        4'b0111: q = 4'b1111; // c = 7\n        4'b1000: q = 4'b1111; // c = 8\n        4'b1001: q = 4'b1111; // c = 9\n        4'b1010: q = 4'b1111; // c = a\n        4'b1011: q = 4'b1111; // c = b\n        4'b1100: q = 4'b1111; // c = c\n        4'b1101: q = 4'b1111; // c = d\n        4'b1110: q = 4'b1111; // c = e\n        4'b1111: q = 4'b1111; // c = f\n        default: q = 4'b0000; // Default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @* begin\n    if (sel) \n        out = b;\n    else \n        out = a;\nend\n\nendmodule\n"}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": ""}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 32'b0;\n\tend else begin\n\t\tout <= out | ((in & ~{in[30:0], 1'b0}) & {32{~out}});\n\tend\nend\nendmodule\n"}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire signed [8:0] sum;\n    assign sum = a + b;\n    assign s = sum[7:0];\n    assign overflow = (a[7] == b[7]) && (a[7] != s[7]);\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    assign B3_next = state[9]; // Transition logic for B3\n    assign S_next = ~state[0] & ~state[1] & ~state[2] & ~state[3] & ~state[4] & ~state[5] & ~state[6] & ~state[7] & ~state[8]; // Return to S from any state\n    assign S1_next = state[0] & d; // Transition from S to S1\n    assign Count_next = state[8] & ~done_counting; // Stay in Count while not done counting\n    assign Wait_next = state[8] & done_counting; // Transition from Count to Wait when done counting\n    assign done = state[7] & ack; // Output done when in Wait and ack is high\n    assign counting = state[8]; // Output counting when in Count state\n    assign shift_ena = state[4] | state[5] | state[6] | state[7]; // Output shift_ena when in B0, B1, B2, or B3\n\nendmodule\n"}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 2'b01;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 2'b01;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\nalways @* begin\n    pos = 3'b000; // Default to zero\n    case (in)\n        8'b00000001: pos = 3'b000;\n        8'b00000010: pos = 3'b001;\n        8'b00000100: pos = 3'b010;\n        8'b00001000: pos = 3'b011;\n        8'b00010000: pos = 3'b100;\n        8'b00100000: pos = 3'b101;\n        8'b01000000: pos = 3'b110;\n        8'b10000000: pos = 3'b111;\n        default: pos = 3'b000; // Reporting zero if no bits are high\n    endcase\nend\nendmodule\n"}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\nalways @(*) begin\n    // Default all outputs to low\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    case (scancode)\n        16'hE06B: left = 1;   // Left arrow\n        16'hE072: down = 1;   // Down arrow\n        16'hE074: right = 1;  // Right arrow\n        16'hE075: up = 1;     // Up arrow\n        default: ;            // None\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\nwire c1, c2, c3;\n\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c1));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c1), .sum(sum[1]), .cout(c2));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c2), .sum(sum[2]), .cout(c3));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\n"}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule\n"}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\nwire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule\n"}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\nreg [7:0] Q;\nwire [2:0] sel;\n\nalways @(posedge clk) begin\n\tif (enable) begin\n\t\tQ <= {S, Q[7:1]};\n\tend\nend\n\nassign sel = {A, B, C};\n\nalways @(*) begin\n\tcase (sel)\n\t\t3'b000: Z = Q[0];\n\t\t3'b001: Z = Q[1];\n\t\t3'b010: Z = Q[2];\n\t\t3'b011: Z = Q[3];\n\t\t3'b100: Z = Q[4];\n\t\t3'b101: Z = Q[5];\n\t\t3'b110: Z = Q[6];\n\t\t3'b111: Z = Q[7];\n\t\tdefault: Z = 1'b0;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\nassign heater = mode & too_cold;           // Heater on if in heating mode and too cold\nassign aircon = ~mode & too_hot;           // Air conditioner on if in cooling mode and too hot\nassign fan = heater | aircon | fan_on;     // Fan on if heater, air conditioner are on or fan_on is requested\nendmodule\n"}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\nassign out_sop = (a & ~b & ~c & d) | (~a & b & c & d) | (a & b & c & d);\nassign out_pos = (~a | b | c | d) & (a | ~b | ~c | ~d) & (a | b | ~c | ~d);\nendmodule\n"}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\nendmodule\n"}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (b & d) | (c & (b | d));\nendmodule\n"}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @* begin\n    out = 0; // Initialize output\n    for (int i = 0; i < 255; i = i + 1) begin\n        out = out + in[i]; // Count the number of 1's\n    end\nend\n\nendmodule\n"}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\nassign out_both[2] = in[2] & in[3];\nassign out_both[1] = in[1] & in[2];\nassign out_both[0] = in[0] & in[1];\n\nassign out_any[3] = in[3] | in[2];\nassign out_any[2] = in[2] | in[1];\nassign out_any[1] = in[1] | in[0];\n\nassign out_different[3] = in[3] ^ in[0];\nassign out_different[2] = in[2] ^ in[3];\nassign out_different[1] = in[1] ^ in[2];\nassign out_different[0] = in[0] ^ in[1];\n\nendmodule\n"}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'h0000; // default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'b1001) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nassign out = in1 & ~in2;\nendmodule\n"}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\n\nendmodule\n"}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg state, next_state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 1; // state B\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        1: begin // state B\n            if (in == 0) next_state = 0; // go to state A\n            else next_state = 1; // stay in state B\n        end\n        0: begin // state A\n            if (in == 0) next_state = 1; // go to state B\n            else next_state = 0; // stay in state A\n        end\n        default: next_state = 1; // default to state B\n    endcase\nend\n\nassign out = state;\n\nendmodule\n"}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nalways @(negedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a ^ b);\nendmodule\n"}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": ""}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (load) begin\n\t\t\tq <= data;\n\t\tend else begin\n\t\t\tcase (ena)\n\t\t\t\t2'b01: begin // rotate right\n\t\t\t\t\tq <= {q[0], q[99:1]};\n\t\t\t\tend\n\t\t\t\t2'b10: begin // rotate left\n\t\t\t\t\tq <= {q[98:0], q[99]};\n\t\t\t\tend\n\t\t\t\t2'b00: begin // do nothing\n\t\t\t\t\tq <= q;\n\t\t\t\tend\n\t\t\t\t2'b11: begin // do nothing\n\t\t\t\t\tq <= q;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'd0;\n    end else if (q == 10'd999) begin\n        q <= 10'd0;\n    end else begin\n        q <= q + 10'd1;\n    end\nend\nendmodule\n"}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": " out = ~in;\nendmodule\n"}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\nassign next_state = \n    (state[0] & ~in) ? 10'b0000000001 : // S0 --0--> S0\n    (state[0] & in) ? 10'b0000000010 :  // S0 --1--> S1\n    (state[1] & ~in) ? 10'b0000000001 : // S1 --0--> S0\n    (state[1] & in) ? 10'b0000000100 :  // S1 --1--> S2\n    (state[2] & ~in) ? 10'b0000000001 : // S2 --0--> S0\n    (state[2] & in) ? 10'b0000001000 :   // S2 --1--> S3\n    (state[3] & ~in) ? 10'b0000000001 : // S3 --0--> S0\n    (state[3] & in) ? 10'b0000010000 :   // S3 --1--> S4\n    (state[4] & ~in) ? 10'b0000000001 : // S4 --0--> S0\n    (state[4] & in) ? 10'b0000100000 :   // S4 --1--> S5\n    (state[5] & ~in) ? 10'b0001000000 :   // S5 --0--> S8\n    (state[5] & in) ? 10'b0010000000 :    // S5 --1--> S6\n    (state[6] & ~in) ? 10'b0100000000 :   // S6 --0--> S9\n    (state[6] & in) ? 10'b0000000110 :    // S6 --1--> S7\n    (state[7] & ~in) ? 10'b0000000001 : // S7 --0--> S0\n    (state[7] & in) ? 10'b0000001000 :    // S7 --1--> S7\n    (state[8] & ~in) ? 10'b0000000001 : // S8 --0--> S0\n    (state[8] & in) ? 10'b0000000010 :    // S8 --1--> S1\n    (state[9] & ~in) ? 10'b0000000001 : // S9 --0--> S0\n    (state[9] & in) ? 10'b0000000010 :    // S9 --1--> S1\n    10'b0000000000; // default case\n\nassign out1 = state[7] | state[8] | state[9]; // out1 is high in states S7, S8, S9\nassign out2 = state[7]; // out2 is high in state S7 \n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    case({j, k})\n        2'b00: Q <= Q;       // Qold\n        2'b01: Q <= 1'b0;    // Reset\n        2'b10: Q <= 1'b1;    // Set\n        2'b11: Q <= ~Q;      // Toggle\n    endcase\nend\n\nendmodule\n"}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n    assign out = in[0] + in[1] + in[2];\nendmodule\n"}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\tassign out[24] = ~(a ^ a);\n\tassign out[23] = ~(a ^ b);\n\tassign out[22] = ~(a ^ c);\n\tassign out[21] = ~(a ^ d);\n\tassign out[20] = ~(a ^ e);\n\t\n\tassign out[19] = ~(b ^ a);\n\tassign out[18] = ~(b ^ b);\n\tassign out[17] = ~(b ^ c);\n\tassign out[16] = ~(b ^ d);\n\tassign out[15] = ~(b ^ e);\n\t\n\tassign out[14] = ~(c ^ a);\n\tassign out[13] = ~(c ^ b);\n\tassign out[12] = ~(c ^ c);\n\tassign out[11] = ~(c ^ d);\n\tassign out[10] = ~(c ^ e);\n\t\n\tassign out[9] = ~(d ^ a);\n\tassign out[8] = ~(d ^ b);\n\tassign out[7] = ~(d ^ c);\n\tassign out[6] = ~(d ^ d);\n\tassign out[5] = ~(d ^ e);\n\t\n\tassign out[4] = ~(e ^ a);\n\tassign out[3] = ~(e ^ b);\n\tassign out[2] = ~(e ^ c);\n\tassign out[1] = ~(e ^ d);\n\tassign out[0] = ~(e ^ e);\nendmodule\n"}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    typedef enum logic [1:0] {\n        STATE_WALK_LEFT,\n        STATE_WALK_RIGHT\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transitions\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= STATE_WALK_LEFT;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            STATE_WALK_LEFT: begin\n                if (bump_right) begin\n                    next_state = STATE_WALK_RIGHT;\n                end else begin\n                    next_state = STATE_WALK_LEFT;\n                end\n            end\n            STATE_WALK_RIGHT: begin\n                if (bump_left) begin\n                    next_state = STATE_WALK_LEFT;\n                end else begin\n                    next_state = STATE_WALK_RIGHT;\n                end\n            end\n            default: next_state = STATE_WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    assign walk_left = (current_state == STATE_WALK_LEFT);\n    assign walk_right = (current_state == STATE_WALK_RIGHT);\n\nendmodule\n"}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\nassign q = a & b;\n\nendmodule\n"}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nwire and1_out, and2_out, and3_out, and4_out;\n\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\nassign p1y = and1_out | and2_out;\n\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\nassign p2y = and3_out | and4_out;\n\nendmodule\n"}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\nalways @(posedge clk) begin\n\tcase (y)\n\t\t3'b000: begin\n\t\t\tY0 <= (x == 0) ? 3'b000 : 3'b001;\n\t\t\tz <= 1'b0;\n\t\tend\n\t\t3'b001: begin\n\t\t\tY0 <= (x == 0) ? 3'b001 : 3'b100;\n\t\t\tz <= 1'b0;\n\t\tend\n\t\t3'b010: begin\n\t\t\tY0 <= (x == 0) ? 3'b010 : 3'b001;\n\t\t\tz <= 1'b0;\n\t\tend\n\t\t3'b011: begin\n\t\t\tY0 <= (x == 0) ? 3'b001 : 3'b010;\n\t\t\tz <= 1'b1;\n\t\tend\n\t\t3'b100: begin\n\t\t\tY0 <= (x == 0) ? 3'b011 : 3'b100;\n\t\t\tz <= 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tY0 <= 3'b000;\n\t\t\tz <= 1'b0;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nalways @* begin\n    out = ~(in1 | in2);\nend\nendmodule\n"}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": " w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n"}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n"}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\nreg [9:0] counter;\nassign tc = (counter == 0);\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter > 0) begin\n        counter <= counter - 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\nreg [3:0] state, next_state;\nparameter IDLE = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0011, S4 = 4'b0100;\n\nassign start_shifting = (state == S4);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (data) next_state = S1;\n            else next_state = IDLE;\n        end\n        S1: begin\n            if (data) next_state = S2;\n            else next_state = IDLE;\n        end\n        S2: begin\n            if (data) next_state = S3;\n            else next_state = IDLE;\n        end\n        S3: begin\n            if (!data) next_state = S4;\n            else next_state = S2;\n        end\n        S4: begin\n            next_state = S4; // Remain in this state once found\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    anyedge <= 0; // Reset anyedge output for this clock cycle\n    anyedge <= (in & ~prev_in); // Detect any 0 to 1 transitions\n    prev_in <= in; // Store current input for next clock cycle\nend\n\nendmodule\n"}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset counter to 1\n    end else begin\n        if (q == 4'b1010) // If q is 10, reset to 1\n            q <= 4'b0001;\n        else\n            q <= q + 1; // Increment counter\n    end\nend\nendmodule\n"}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a) begin\n        q <= q; // Maintain the value when 'a' is high\n    end else begin\n        q <= q + 1; // Increment 'q' when 'a' is low\n    end\nend\nendmodule\n"}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset to 1\n    end else begin\n        // Feedback calculation for Galois LFSR with taps at positions 5 and 3\n        q <= {q[3] ^ q[4], q[4], q[2], q[1], q[0]}; // Shift and feedback\n    end\nend\nendmodule\n"}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\talways @(*) begin\n\t\tif (do_sub) \n\t\t\tout = a - b;\n\t\telse \n\t\t\tout = a + b;\n\n\t\tresult_is_zero = (out == 8'b00000000);\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always @(*) begin\n        case (x)\n            4'b0000: f = 1'b0;    // x[3]x[4] = 00\n            4'b0001: f = 1'b0;    // x[3]x[4] = 01\n            4'b0010: f = 1'b0;    // x[3]x[4] = 10\n            4'b0011: f = 1'b1;    // x[3]x[4] = 11\n            4'b0100: f = 1'b0;    // x[3]x[4] = 00\n            4'b0101: f = 1'b1;    // x[3]x[4] = 01\n            4'b0110: f = 1'b1;    // x[3]x[4] = 10\n            4'b0111: f = 1'b1;    // x[3]x[4] = 11\n            4'b1000: f = 1'b1;    // x[3]x[4] = 00\n            4'b1001: f = 1'b1;    // x[3]x[4] = 01\n            4'b1010: f = 1'b0;    // x[3]x[4] = 10\n            4'b1011: f = 1'bd;    // x[3]x[4] = 11 (don't-care)\n            4'b1100: f = 1'b1;    // x[3]x[4] = 00\n            4'b1101: f = 1'b1;    // x[3]x[4] = 01\n            4'b1110: f = 1'bd;    // x[3]x[4] = 10 (don't-care)\n            4'b1111: f = 1'bd;    // x[3]x[4] = 11 (don't-care)\n            default: f = 1'b0;\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\nalways @(*) begin\n    case(code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end  // key '0'\n        8'h16: begin out = 4'd1; valid = 1'b1; end  // key '1'\n        8'h1e: begin out = 4'd2; valid = 1'b1; end  // key '2'\n        8'h26: begin out = 4'd3; valid = 1'b1; end  // key '3'\n        8'h25: begin out = 4'd4; valid = 1'b1; end  // key '4'\n        8'h2e: begin out = 4'd5; valid = 1'b1; end  // key '5'\n        8'h36: begin out = 4'd6; valid = 1'b1; end  // key '6'\n        8'h3d: begin out = 4'd7; valid = 1'b1; end  // key '7'\n        8'h3e: begin out = 4'd8; valid = 1'b1; end  // key '8'\n        8'h46: begin out = 4'd9; valid = 1'b1; end  // key '9'\n        default: begin out = 4'd0; valid = 1'b0; end // invalid case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": " out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @* begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'bx; // d\n        4'b0001: out = 1'b0; \n        4'b0010: out = 1'b1; \n        4'b0011: out = 1'b1; \n        4'b0100: out = 1'b0; \n        4'b0101: out = 1'b0; \n        4'b0110: out = 1'bx; // d\n        4'b0111: out = 1'bx; // d\n        4'b1000: out = 1'b0; \n        4'b1001: out = 1'b1; \n        4'b1010: out = 1'b1; \n        4'b1011: out = 1'b1; \n        4'b1100: out = 1'b0; \n        4'b1101: out = 1'b1; \n        4'b1110: out = 1'b1; \n        4'b1111: out = 1'b1; \n        default: out = 1'bx; \n    endcase\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {data, q[3:1]};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule\n"}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\nreg [2:0] count;\nreg shift_enable;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b111; // Load count with 4 (111 in binary)\n        shift_enable <= 1'b1; // Enable shift register\n    end else if (count > 0) begin\n        count <= count - 1; // Decrement the count\n    end else begin\n        shift_enable <= 1'b0; // Disable shift register\n    end\nend\n\nassign shift_ena = shift_enable;\n\nendmodule\n"}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) \n        q <= 4'b0000;\n    else \n        q <= q + 1;\nend\nendmodule\n"}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\nalways @(*) begin\n    if (sel_b1 && sel_b2) \n        out_always = b;\n    else \n        out_always = a;\nend\n\nendmodule\n"}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\nassign out = (b & c) | (b & ~a) | (~b & c) | (~a & ~c);\nendmodule\n"}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n\t// State Encoding\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\treg [1:0] state, next_state;\n\n\t// Output logic\n\tassign g[1] = (state == B) ? 1 : 0;\n\tassign g[2] = (state == C) ? 1 : 0;\n\tassign g[3] = (state == D) ? 1 : 0;\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse if (r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse if (r[3])\n\t\t\t\t\tnext_state = D;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tB: begin\n\t\t\t\tif (r[1])\n\t\t\t\t\tnext_state = B;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tC: begin\n\t\t\t\tif (r[2])\n\t\t\t\t\tnext_state = C;\n\t\t\t\telse\n\t\t\t\t\tnext_state = A;\n\t\t\tend\n\t\t\tD: begin\n\t\t\t\tnext_state = A; // D state leads back to A\n\t\t\tend\n\t\t\tdefault: next_state = A;\n\t\tendcase\n\tend\n\n\t// State register\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn)\n\t\t\tstate <= A;\n\t\telse\n\t\t\tstate <= next_state;\n\tend\n\nendmodule\n"}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tq <= 4'b0000;\n\tend else if (q == 4'b1001) begin\n\t\tq <= 4'b0000;\n\tend else begin\n\t\tq <= q + 1;\n\tend\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\tparameter IDLE = 2'd0, BYTE1 = 2'd1, BYTE2 = 2'd2, COMPLETE = 2'd3;\n\n\tassign done = (state == COMPLETE);\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @* begin\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1'b1) \n\t\t\t\t\tnext_state = BYTE1;\n\t\t\t\telse \n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE1: begin\n\t\t\t\tif (in[3] == 1'b1)\n\t\t\t\t\tnext_state = BYTE2;\n\t\t\t\telse \n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE2: begin\n\t\t\t\tif (in[3] == 1'b1)\n\t\t\t\t\tnext_state = COMPLETE;\n\t\t\t\telse \n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tCOMPLETE: begin\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\nassign out = (sel) ? b : a;\nendmodule\n"}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: begin\n            next_state = (x) ? 3'b001 : 3'b000;\n            z = 0;\n        end\n        3'b001: begin\n            next_state = (x) ? 3'b100 : 3'b001;\n            z = 0;\n        end\n        3'b010: begin\n            next_state = (x) ? 3'b001 : 3'b010;\n            z = 0;\n        end\n        3'b011: begin\n            next_state = (x) ? 3'b010 : 3'b001;\n            z = 1;\n        end\n        3'b100: begin\n            next_state = (x) ? 3'b100 : 3'b011;\n            z = 1;\n        end\n        default: begin\n            next_state = 3'b000;\n            z = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n\treg [1:0] state;\n\treg [2:0] x_history;\n\treg y_count;\n\treg g_reg;\n\tassign f = (state == 2'b01) ? 1'b1 : 1'b0;\n\tassign g = g_reg;\n\n\tparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n\talways @(posedge clk or negedge resetn) begin\n\t\tif (!resetn) begin\n\t\t\tstate <= A;\n\t\t\tg_reg <= 1'b0;\n\t\t\tx_history <= 3'b000;\n\t\t\ty_count <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tA: begin\n\t\t\t\t\tstate <= B; // move to state B after reset\n\t\t\t\tend\n\t\t\t\tB: begin\n\t\t\t\t\tx_history <= {x_history[1:0], x}; // shift in the new x value\n\t\t\t\t\tif (x_history == 3'b101) begin // check for 101 in x_history\n\t\t\t\t\t\tstate <= C;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\tC: begin\n\t\t\t\t\tg_reg <= 1'b1; // set g to 1\n\t\t\t\t\ty_count <= 0;\n\t\t\t\t\tstate <= D; // move to state D to monitor y\n\t\t\t\tend\n\t\t\t\tD: begin\n\t\t\t\t\tif (y) begin\n\t\t\t\t\t\t// g remains 1 permanently as y is detected\n\t\t\t\t\t\tg_reg <= 1'b1;\n\t\t\t\t\tend else if (y_count < 2) begin\n\t\t\t\t\t\ty_count <= y_count + 1; // count the clock cycles without y = 1\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tg_reg <= 1'b0; // set g to 0 if y was not 1 in 2 cycles\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(negedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b00110100; // Set to 0x34\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\nassign parity = ^in;\nendmodule\n"}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\nalways @(*) begin\n    case (state)\n        2'b00: next_state = (in) ? 2'b01 : 2'b00; // A\n        2'b01: next_state = (in) ? 2'b01 : 2'b10; // B\n        2'b10: next_state = (in) ? 2'b11 : 2'b00; // C\n        2'b11: next_state = (in) ? 2'b01 : 2'b10; // D\n        default: next_state = 2'b00; // Default state\n    endcase\nend\n\nassign out = (state == 2'b11) ? 1 : 0; // Output logic for state D\n\nendmodule\n"}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nreg z;\n\nalways @(x or y) begin\n    case ({x, y})\n        2'b00: z = 1;    // For (0, 0)\n        2'b01: z = 0;    // For (0, 1)\n        2'b10: z = 0;    // For (1, 0)\n        2'b11: z = 1;    // For (1, 1)\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11, E = 2'b100, F = 2'b101;\nreg [2:0] state, next_state;\nassign z = (state == E) ? 1 : 0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: begin\n            if (w)\n                next_state = B;\n            else\n                next_state = A;\n        end\n        B: begin\n            if (w)\n                next_state = C;\n            else\n                next_state = D;\n        end\n        C: begin\n            if (w)\n                next_state = E;\n            else\n                next_state = D;\n        end\n        D: begin\n            if (w)\n                next_state = F;\n            else\n                next_state = A;\n        end\n        E: begin\n            if (w)\n                next_state = E;\n            else\n                next_state = D;\n        end\n        F: begin\n            if (w)\n                next_state = C;\n            else\n                next_state = D;\n        end\n        default: next_state = A;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\n    integer i;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                for (i = 0; i < 8; i = i + 1) begin\n                    q[i] <= d[i];\n                end\n            end\n            if (byteena[1]) begin\n                for (i = 8; i < 16; i = i + 1) begin\n                    q[i] <= d[i];\n                end\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\n    always @(posedge clk) begin\n        pedge <= 8'b0; // Reset output\n        for (int i = 0; i < 8; i = i + 1) begin\n            if (i > 0 && in[i] == 1 && in[i-1] == 0) begin\n                pedge[i] <= 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\nalways @(posedge clock) begin\n    if (a == 1) begin\n        p <= 1;\n        q <= 0;\n    end else begin\n        p <= q;\n        q <= p;\n    end\nend\nendmodule\n"}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 1'b0 ^ q[1]; // q[-1] is considered as 0\n        for (integer i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n        q[511] <= q[510] ^ 1'b0; // q[512] is considered as 0\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\nassign z = (A == B) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\nassign out_both[98] = in[98] & in[99];\nassign out_any[99:1] = in[1:99] | in[0:98];\nassign out_different[98] = in[98] ^ in[99];\n\ngenvar i;\ngenerate\n    for (i = 0; i < 98; i = i + 1) begin : gen_out_both\n        assign out_both[i] = in[i] & in[i + 1];\n    end\nendgenerate\n\ngenerate\n    for (i = 1; i < 99; i = i + 1) begin : gen_out_any\n        assign out_any[i] = in[i] | in[i - 1];\n    end\nendgenerate\n\ngenerate\n    for (i = 0; i < 99; i = i + 1) begin : gen_out_different\n        assign out_different[i] = in[i] ^ in[(i + 1) % 100];\n    end\nendgenerate\n\nendmodule\n"}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\nalways @ (ena or d) begin\n    if (ena) \n        q <= d;\nend\n\nendmodule\n"}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\nassign out = in[(sel * 4) +: 4];\nendmodule\n"}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\nalways_comb begin\n    case (sel)\n        4'd0: out = a;\n        4'd1: out = b;\n        4'd2: out = c;\n        4'd3: out = d;\n        4'd4: out = e;\n        4'd5: out = f;\n        4'd6: out = g;\n        4'd7: out = h;\n        4'd8: out = i;\n        default: out = 16'hFFFF; // For unused cases (sel=9 to 15)\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": " out_or_bitwise = a | b;\nassign out_or_logical = |(a | b);\nassign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n\t\t\t4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n\t\t\t4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n\t\t\t4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n\t\t\tdefault: next_state = 4'b0001; // Default to State A\n\t\tendcase\n\tend\n\n\tassign out = (state == 4'b1000) ? 1 : 0; // Output logic for State D\n\nendmodule\n"}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\nalways @(*) begin\n    min = a; // Assume a is the minimum initially\n    if (b < min) min = b;\n    if (c < min) min = c;\n    if (d < min) min = d;\nend\nendmodule\n"}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": " out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = (c & ~d & ~b & ~a) | (c & d & b) | (c & d & ~a) | (c & ~d & a) | \n             (b & ~c & d & ~a) | (~b & ~c & d & a) | (~c & b & a);\n\nendmodule\n"}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\nreg [1:0] current_state, next_state;\nreg [2:0] w_count; // To count '1's in three clock cycles\n\nparameter A = 2'b00, B = 2'b01;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tcurrent_state <= A;\n\t\tz <= 0;\n\t\tw_count <= 0;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\t\tif (current_state == B) begin\n\t\t\tw_count <= {w_count[1:0], w}; // Shift previous w values\n\t\tend\n\t\tif (current_state == A && s == 1) begin\n\t\t\tnext_state <= B;\n\t\tend\n\tend\nend\n\nalways @(*) begin\n\tcase (current_state)\n\t\tA: begin\n\t\t\tnext_state = (s) ? B : A;\n\t\t\tz = 0; // In state A, output z is 0\n\t\tend\n\t\tB: begin\n\t\t\tif (w_count == 3'b011 || w_count == 3'b101 || w_count == 3'b110) begin\n\t\t\t\tz = 1; // Exactly two '1's in the last three cycles\n\t\t\tend else begin\n\t\t\t\tz = 0; // Otherwise\n\t\t\tend\n\t\t\tnext_state = B; // Remain in state B\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state = A; // Default case (shouldn't happen)\n\t\t\tz = 0;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": " out = { {24{in[7]}}, in };\nendmodule\n"}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule\n"}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n    case (in)\n        4'b0000: pos = 2'd0; // No input is high\n        4'b0001: pos = 2'd0; // First bit (0)\n        4'b0010: pos = 2'd1; // Second bit (1)\n        4'b0011: pos = 2'd1; // Second bit (1)\n        4'b0100: pos = 2'd2; // Third bit (2)\n        4'b0101: pos = 2'd2; // Third bit (2)\n        4'b0110: pos = 2'd2; // Third bit (2)\n        4'b0111: pos = 2'd2; // Third bit (2)\n        4'b1000: pos = 2'd3; // Fourth bit (3)\n        4'b1001: pos = 2'd3; // Fourth bit (3)\n        4'b1010: pos = 2'd3; // Fourth bit (3)\n        4'b1011: pos = 2'd3; // Fourth bit (3)\n        4'b1100: pos = 2'd3; // Fourth bit (3)\n        4'b1101: pos = 2'd3; // Fourth bit (3)\n        4'b1110: pos = 2'd3; // Fourth bit (3)\n        4'b1111: pos = 2'd3; // Fourth bit (3)\n        default: pos = 2'd0; // Default case\n    endcase\nend\nendmodule\n"}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n\treg state, next_state;\n\n\tparameter OFF = 1'b0, ON = 1'b1;\n\n\t// Asynchronous reset and state transition\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) \n\t\t\tstate <= OFF; \n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\t// Next state logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tOFF: begin\n\t\t\t\tif (j) \n\t\t\t\t\tnext_state = ON; \n\t\t\t\telse \n\t\t\t\t\tnext_state = OFF;\n\t\t\tend\n\t\t\tON: begin\n\t\t\t\tif (k) \n\t\t\t\t\tnext_state = OFF; \n\t\t\t\telse \n\t\t\t\t\tnext_state = ON;\n\t\t\tend\n\t\t\tdefault: next_state = OFF; // default case\n\t\tendcase\n\tend\n\n\t// Output logic\n\tassign out = (state == ON) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\n\tassign out = 1'b0;\nendmodule\n"}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\nassign one = 1'b1;\nendmodule\n"}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\nalways @* begin\n    out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9],\n           in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], \n           in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], \n           in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], \n           in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], \n           in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], \n           in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], \n           in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], \n           in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], \n           in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], \n           in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], \n           in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], \n           in[98], in[99]};\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\nlogic xor_output;\n\nassign xor_output = in ^ out;\n\nalways_ff @(posedge clk) begin\n    out <= xor_output;\nend\n\nendmodule\n"}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule\n"}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\nassign f = (x2 & ~x1) | (x2 & x1) | (x3 & x1);\nendmodule\n"}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b00000000;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n"}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\nendmodule\n"}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Added else to avoid latch inference\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Added else to define behavior when arrived\n    end\n\nendmodule\n"}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg state, next_state;\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    assign out = state;\n\n    always @(posedge clk) begin\n        if (reset) \n            state <= OFF;\n        else \n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF;\n        endcase\n    end\nendmodule\n"}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n\tassign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};\nendmodule\n"}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\n\tassign q = (a & b & ~c & ~d) | (a & b & c & d) | (a & ~b & c & ~d) | (b & ~c & d);\nendmodule\n"}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\nassign out = a & b;\nendmodule\n"}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nlocalparam B = 2'b00, A = 2'b01;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= B;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        B: begin\n            if (in) begin\n                next_state = B; // Stay in B\n                out = 1;\n            end else begin\n                next_state = A; // Go to A\n                out = 1;\n            end\n        end\n        A: begin\n            if (in) begin\n                next_state = A; // Stay in A\n                out = 0;\n            end else begin\n                next_state = B; // Go to B\n                out = 0;\n            end\n        end\n        default: begin\n            next_state = B;\n            out = 1;\n        end\n    endcase\nend\n\nassign out = (state == B) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n"}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\nlogic xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\n    wire mux1_out, mux2_out, mux3_out;\n\n    assign mux_in[0] = 0;           // K-map: ab = 00 -> 0\n    assign mux_in[1] = c;           // K-map: ab = 01 -> c (1)\n    assign mux_in[2] = c | d;       // K-map: ab = 11 -> c + d (1)\n    assign mux_in[3] = c;           // K-map: ab = 10 -> c (1)\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    typedef enum logic [1:0] {\n        A = 2'b01,\n        B = 2'b10\n    } state_t;\n\n    state_t state, next_state;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A;\n        else \n            state <= next_state;\n    end\n\n    always_comb begin\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = A;\n                    z = 0;\n                end\n            end\n            B: begin\n                next_state = B; // stay in B regardless of input\n                z = x ? 0 : 1;\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\n\n    assign z = (state == A && x) ? 1 : (state == B) ? (x ? 0 : 1) : 0;\n\nendmodule\n"}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\nreg q_reg;\nreg state_reg;\n\nassign q = q_reg;\nassign state = state_reg;\n\nalways @(posedge clk) begin\n    if (a && !b) begin\n        q_reg <= 1;\n        state_reg <= 1;\n    end else if (!a && b) begin\n        q_reg <= 0;\n        state_reg <= 0;\n    end else if (a && b) begin\n        q_reg <= ~q_reg;\n        state_reg <= 1;\n    end else begin\n        state_reg <= state_reg;\n    end\nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 1; // 1 at (0,0)\n            4'b0001: f = 0; // 0 at (0,1)\n            4'b0010: f = 0; // 0 at (0,3)\n            4'b0011: f = 1; // 1 at (0,2)\n            4'b0100: f = 0; // 0 at (1,0)\n            4'b0101: f = 0; // 0 at (1,1)\n            4'b0110: f = 0; // 0 at (1,3)\n            4'b0111: f = 0; // 0 at (1,2)\n            4'b1000: f = 1; // 1 at (2,0)\n            4'b1001: f = 1; // 1 at (2,1)\n            4'b1010: f = 0; // 0 at (2,3)\n            4'b1011: f = 1; // 1 at (2,2)\n            4'b1100: f = 1; // 1 at (3,0)\n            4'b1101: f = 1; // 1 at (3,1)\n            4'b1110: f = 0; // 0 at (3,3)\n            4'b1111: f = 1; // 1 at (3,2)\n            default: f = 0;\n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n\treg [3:0] state, next_state;\n\tparameter S0 = 4'b0000, // Initial state, expecting 0\n\t          S1 = 4'b0001, // Received 0\n\t          S2 = 4'b0010, // Received 1\n\t          S3 = 4'b0011, // Received 11\n\t          S4 = 4'b0100, // Received 111\n\t          S5 = 4'b0101, // Received 1111\n\t          S6 = 4'b0110, // Received 11111\n\t          S7 = 4'b0111; // Received 111111\n\n\tassign disc = (state == S5); // Discard on 0111110\n\tassign flag = (state == S6); // Flag on 01111110\n\tassign err = (state == S7 || (state == S6 && in == 1)); // Error on 01111111 or more\n\n\t// State transition logic\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tS0: next_state = (in == 0) ? S0 : S1; // waiting for 0 or 1\n\t\t\tS1: next_state = (in == 0) ? S0 : S2; // waiting for next input\n\t\t\tS2: next_state = (in == 0) ? S0 : S3; // received 1\n\t\t\tS3: next_state = (in == 0) ? S0 : S4; // received 11\n\t\t\tS4: next_state = (in == 0) ? S0 : S5; // received 111\n\t\t\tS5: next_state = (in == 0) ? S0 : S6; // received 1111\n\t\t\tS6: next_state = (in == 0) ? S0 : S7; // received 11111\n\t\t\tS7: next_state = (in == 0) ? S0 : S7; // received 111111 or more\n\t\t\tdefault: next_state = S0;\n\t\tendcase\n\tend\n\n\t// State update logic\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= S0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\nreg [3:0] delay;\nreg [11:0] counter; // For counting (delay + 1) * 1000\nreg [3:0] current_count;\nreg [3:0] state;\nreg [3:0] bit_count;\n\nlocalparam IDLE = 4'b0000;\nlocalparam WAIT_START = 4'b0001;\nlocalparam SHIFT_DELAY = 4'b0010;\nlocalparam COUNTING = 4'b0011;\nlocalparam DONE_STATE = 4'b0100;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= IDLE;\n        counting <= 0;\n        done <= 0;\n        counter <= 0;\n        bit_count <= 0;\n        current_count <= 4'b0000;\n    end else begin\n        case (state)\n            IDLE: begin\n                counting <= 0;\n                done <= 0;\n                if ({data, 1'b0} == 4'b1101) begin\n                    state <= SHIFT_DELAY;\n                    bit_count <= 0;\n                end\n            end\n            \n            SHIFT_DELAY: begin\n                if (bit_count < 4) begin\n                    delay <= {delay[2:0], data};\n                    bit_count <= bit_count + 1;\n                end else begin\n                    counter <= (delay + 1) * 1000;\n                    current_count <= delay;\n                    counting <= 1;\n                    state <= COUNTING;\n                    delay <= delay; // Keep the delay\n                end\n            end\n            \n            COUNTING: begin\n                if (counter > 0) begin\n                    counter <= counter - 1;\n                    if (counter[9:0] == 0) begin\n                        if (current_count > 0) begin\n                            current_count <= current_count - 1;\n                        end\n                    end\n                end else begin\n                    counting <= 0;\n                    done <= 1;\n                    state <= DONE_STATE;\n                end\n            end\n            \n            DONE_STATE: begin\n                if (ack) begin\n                    state <= IDLE;\n                    done <= 0;\n                    delay <= 0;\n                    current_count <= 0;\n                end\n            end\n            \n            default: state <= IDLE;\n        endcase\n    end\nend\n\nassign count = counting ? current_count : 4'bxxxx; // Don't care value when not counting\nendmodule\n"}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\nreg [1:0] state, next_state;\n\nlocalparam STATE_LOW = 2'b00, \n           STATE_MID = 2'b01, \n           STATE_HIGH = 2'b10, \n           STATE_VERY_HIGH = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= STATE_LOW;\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        STATE_LOW: begin\n            if (s[1]) begin\n                next_state = STATE_MID;\n            end else begin\n                next_state = STATE_LOW;\n            end\n        end\n        \n        STATE_MID: begin\n            if (s[2]) begin\n                next_state = STATE_HIGH;\n            end else if (!s[1]) begin\n                next_state = STATE_LOW;\n            end else begin\n                next_state = STATE_MID;\n            end\n        end\n        \n        STATE_HIGH: begin\n            if (s[3]) begin\n                next_state = STATE_VERY_HIGH;\n            end else if (!s[1]) begin\n                next_state = STATE_LOW;\n            end else begin\n                next_state = STATE_HIGH;\n            end\n        end\n        \n        STATE_VERY_HIGH: begin\n            next_state = STATE_VERY_HIGH;\n        end\n        \n        default: next_state = STATE_LOW;\n    endcase\nend\n\nalways @(posedge clk) begin\n    case (state)\n        STATE_LOW: begin\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n        end\n        \n        STATE_MID: begin\n            fr3 <= 0;\n            fr2 <= 0;\n            fr1 <= 1;\n            dfr <= 0;\n        end\n        \n        STATE_HIGH: begin\n            fr3 <= 0;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n        end\n        \n        STATE_VERY_HIGH: begin\n            fr3 <= 0;\n            fr2 <= 0;\n            fr1 <= 0;\n            dfr <= 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        DATA_0,\n        DATA_1,\n        DATA_2,\n        DATA_3,\n        DATA_4,\n        DATA_5,\n        DATA_6,\n        DATA_7,\n        STOP\n    } state_t;\n\n    state_t current_state, next_state;\n    int count;\n\n    assign done = (current_state == STOP);\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= IDLE;\n        else \n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (in == 0) \n                    next_state = START;\n            end\n            START: begin\n                next_state = DATA_0; // After identifying start bit, move to first data bit\n            end\n            DATA_0: begin\n                count = 1;\n                next_state = DATA_1;\n            end\n            DATA_1: begin\n                count = 2;\n                next_state = DATA_2;\n            end\n            DATA_2: begin\n                count = 3;\n                next_state = DATA_3;\n            end\n            DATA_3: begin\n                count = 4;\n                next_state = DATA_4;\n            end\n            DATA_4: begin\n                count = 5;\n                next_state = DATA_5;\n            end\n            DATA_5: begin\n                count = 6;\n                next_state = DATA_6;\n            end\n            DATA_6: begin\n                count = 7;\n                next_state = DATA_7;\n            end\n            DATA_7: begin\n                count = 8;\n                next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1) \n                    next_state = IDLE; // Correct stop bit\n                else \n                    next_state = IDLE; // Wait for next start\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    reg [3:0] state, next_state;\n    reg [7:0] data_byte;\n    reg [3:0] bit_count;\n    reg done_reg;\n\n    localparam IDLE      = 4'b0000;\n    localparam START_BIT = 4'b0001;\n    localparam DATA      = 4'b0010;\n    localparam STOP_BIT  = 4'b0011;\n\n    assign out_byte = data_byte;\n    assign done = done_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            data_byte <= 8'b0;\n            bit_count <= 4'd0;\n            done_reg <= 1'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        done_reg = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (in == 1'b0) // Start bit detected\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            end\n\n            START_BIT: begin\n                next_state = DATA;\n                bit_count = 4'd0; // Reset bit count\n            end\n\n            DATA: begin\n                if (bit_count < 4'd7) begin\n                    data_byte[bit_count] = in; // Capture data bit\n                    bit_count = bit_count + 1;\n                    next_state = DATA;\n                end else begin\n                    data_byte[7] = in; // Capture last data bit\n                    next_state = STOP_BIT;\n                end\n            end\n\n            STOP_BIT: begin\n                if (in == 1'b1) begin // Stop bit detected\n                    done_reg = 1'b1; // Set done flag\n                    next_state = IDLE; // Go back to idle to wait for next byte\n                end else begin\n                    next_state = STOP_BIT; // Wait for a correct stop bit\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\nreg [1:0] PHT [127:0]; // Pattern history table\nreg [6:0] GHR; // Global history register\nwire [6:0] index; \n\nassign index = (predict_pc ^ GHR) & 7'b0111111; // 7-bit index using XOR\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        GHR <= 7'b0; // Reset GHR\n        // Reset PHT entries\n        integer i;\n        for (i = 0; i < 128; i = i + 1) begin\n            PHT[i] <= 2'b00; \n        end\n    end else begin\n        if (train_valid) begin\n            if (train_mispredicted) begin\n                GHR <= train_history; // Recover GHR on misprediction\n            end else begin\n                GHR <= {GHR[5:0], train_taken}; // Update GHR\n            end\n\n            // Update PHT for training\n            if (train_taken) begin\n                if (PHT[train_pc ^ GHR] < 2'b11)\n                    PHT[train_pc ^ GHR] <= PHT[train_pc ^ GHR] + 1; // Increment counter\n            end else begin\n                if (PHT[train_pc ^ GHR] > 2'b00)\n                    PHT[train_pc ^ GHR] <= PHT[train_pc ^ GHR] - 1; // Decrement counter\n            end\n        end \n\n        if (predict_valid) begin\n            // Output prediction and current GHR\n            predict_taken <= (PHT[predict_pc ^ GHR] > 2'b01); \n            predict_history <= GHR;\n        end \n    end\nend\n\nendmodule\n"}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [3:0] state, next_state;\n    parameter WALK_LEFT = 4'b0001, WALK_RIGHT = 4'b0010, FALLING = 4'b0100, DIGGING = 4'b1000, SPLATTER = 4'b1111;\n    reg [4:0] fall_counter; // 5 bits for counting 0-31\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n\n            FALLING: begin\n                if (ground) begin\n                    if (fall_counter > 20) next_state = SPLATTER;\n                    else if (bump_left) next_state = FALLING;\n                    else if (bump_right) next_state = FALLING;\n                    else next_state = (fall_counter > 20) ? SPLATTER : WALK_LEFT; // Default to walking left on ground\n                end else begin\n                    next_state = FALLING; // Continue falling\n                end\n            end\n            \n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n                else next_state = DIGGING; // Continue digging\n            end\n\n            SPLATTER: begin\n                next_state = SPLATTER; // Stay in splatter state\n            end\n\n            default: next_state = WALK_LEFT; // Default to walk left\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\nreg [2:0] state, next_state;\nreg [3:0] shift_count;\n\nparameter IDLE       = 3'b000,\n          DETECT     = 3'b001,\n          SHIFT      = 3'b010,\n          COUNTING    = 3'b011,\n          DONE       = 3'b100;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n        shift_ena <= 0;\n        counting <= 0;\n        done <= 0;\n        shift_count <= 0;\n    end else begin\n        state <= next_state;\n        if (state == SHIFT) begin\n            if (shift_count < 4) begin\n                shift_count <= shift_count + 1;\n                shift_ena <= 1;\n            end else begin\n                shift_ena <= 0;\n            end\n        end else begin\n            shift_count <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            shift_ena = 0;\n            counting = 0;\n            done = 0;\n            if (data) begin\n                next_state = DETECT;\n            end\n        end\n        DETECT: begin\n            if (data) begin\n                if (shift_count == 3) begin // Pattern 1101 detected\n                    next_state = SHIFT;\n                end\n            end\n        end\n        SHIFT: begin\n            if (shift_count == 4) begin\n                next_state = COUNTING;\n                counting = 1;\n            end\n        end\n        COUNTING: begin\n            if (done_counting) begin\n                next_state = DONE;\n                done = 1;\n            end\n        end\n        DONE: begin\n            if (ack) begin\n                next_state = IDLE;\n                done = 0;\n            end\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    reg [255:0] next_q;\n    reg [4:0] i, j;\n    reg [3:0] count;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= next_q;\n        end\n    end\n\n    always @(*) begin\n        next_q = q;  // Default to current state\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                count = 0;\n                \n                // Count neighbors\n                for (int x = -1; x <= 1; x = x + 1) begin\n                    for (int y = -1; y <= 1; y = y + 1) begin\n                        if (x == 0 && y == 0) continue; // Skip the cell itself\n                        count = count + q[((i + x + 16) % 16) * 16 + ((j + y + 16) % 16)];\n                    end\n                end\n                \n                // Update the next state based on neighbor count\n                if (q[i * 16 + j] == 1) begin\n                    if (count < 2 || count >= 4) \n                        next_q[i * 16 + j] = 0; // Dies\n                end else begin\n                    if (count == 3) \n                        next_q[i * 16 + j] = 1; // Becomes alive\n                end\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10, DIGGING = 2'b11;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (bump_left) begin\n                        next_state = WALK_RIGHT;\n                    end else if (bump_right) begin\n                        next_state = WALK_LEFT;\n                    end else begin\n                        next_state = (state == FALLING) ? (walk_left ? WALK_LEFT : WALK_RIGHT) : state;\n                    end\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left || bump_right) begin\n                    next_state = DIGGING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\nendmodule\n"}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\thh <= 8'b00010010;  // Set to 12:00 AM\n\t\t\tmm <= 8'b00000000;  // Set minutes to 00\n\t\t\tss <= 8'b00000000;  // Set seconds to 00\n\t\t\tpm <= 0;            // Set AM\n\t\tend else if (ena) begin\n\t\t\tif (ss == 8'b00111001) begin // If seconds == 59\n\t\t\t\tss <= 8'b00000000;       // Reset seconds to 0\n\t\t\t\tif (mm == 8'b00111001) begin // If minutes == 59\n\t\t\t\t\tmm <= 8'b00000000;   // Reset minutes to 0\n\t\t\t\t\tif (hh == 8'b00010010) begin // If hours == 12\n\t\t\t\t\t\thh <= 8'b00000001; // Set hours to 01\n\t\t\t\t\t\tpm <= ~pm;        // Toggle AM/PM\n\t\t\t\t\tend else begin\n\t\t\t\t\t\thh <= hh + 1;    // Increment hours\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\tmm <= mm + 1;        // Increment minutes\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tss <= ss + 1;            // Increment seconds\n\t\t\tend\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    reg falling;\n    \n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = falling;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            falling <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            FALLING: begin\n                if (ground) begin\n                    next_state = (bump_left) ? WALK_LEFT : (bump_right) ? WALK_RIGHT : state;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        // Update counter\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'b0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'b0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'b0;\n                    if (q[15:12] < 4'd9) begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9);\nassign ena[2] = (ena[1] && (q[7:4] == 4'd9));\nassign ena[3] = (ena[2] && (q[11:8] == 4'd9));\n\nendmodule\n"}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\nalways @(*) begin\n    if (sel == 0) begin\n        out = a;\n    end else begin\n        out = b;\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = (w == 0) ? 0 : 0; // State A\n        3'b001: Y2 = (w == 0) ? 0 : 1; // State B\n        3'b010: Y2 = (w == 0) ? 0 : 1; // State C\n        3'b011: Y2 = (w == 0) ? 0 : 1; // State D\n        3'b100: Y2 = 1;                 // State E\n        3'b101: Y2 = (w == 0) ? 1 : 1; // State F\n        default: Y2 = 0;                // Default case\n    endcase\nend\nendmodule\n"}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\nassign motor = vibrate_mode ? 1 : (ring ? 0 : 0);\nassign ringer = vibrate_mode ? 0 : (ring ? 1 : 0);\nendmodule\n"}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\nendmodule\n"}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\nassign zero = 1'b0;\nendmodule\n"}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a == 0) begin\n        q <= q; // Maintain state when a is 0\n    end else begin\n        q <= ~q; // Toggle q when a is 1\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] num; // Assuming maximum input length of 32 bits\n    reg [5:0] count; // Count the number of bits received\n    reg z_reg; // Output register\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            num <= 0;\n            count <= 0;\n            z_reg <= 0;\n        end else begin\n            if (count < 32) begin\n                num[count] <= x; // Store input bits\n                count <= count + 1; // Increment bit count\n            end else begin\n                z_reg <= ~num + 1; // Compute 2's complement\n            end\n        end\n    end\n\n    assign z = (count == 32) ? z_reg : 0; // Output Z only when all bits have been received\n\nendmodule\n"}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nlocalparam A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nassign out = (state == D) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n        state <= A;\n    else \n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = (in) ? B : A;\n        B: next_state = (in) ? B : C;\n        C: next_state = (in) ? D : A;\n        D: next_state = (in) ? B : C;\n        default: next_state = A;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge r) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;      // Shift left by 1 bit\n            2'b01: q <= q << 8;      // Shift left by 8 bits\n            2'b10: q <= {q[62:0], q[63]}; // Arithmetic right shift by 1 bit\n            2'b11: q <= {q[63:8], q[63]}; // Arithmetic right shift by 8 bits\n            default: q <= q;         // No shift\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n\treg [1:0] current_state, next_state;\n\n\tparameter S0 = 2'b00, // Initial state\n\t\t\t  S1 = 2'b01, // State after seeing '1'\n\t\t\t  S2 = 2'b10; // State after seeing '10'\n\n\talways @(posedge clk or negedge aresetn) begin\n\t\tif (!aresetn)\n\t\t\tcurrent_state <= S0;\n\t\telse\n\t\t\tcurrent_state <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase (current_state)\n\t\t\tS0: begin\n\t\t\t\tif (x)\n\t\t\t\t\tnext_state = S1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S0;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\t\tS1: begin\n\t\t\t\tif (!x)\n\t\t\t\t\tnext_state = S2;\n\t\t\t\telse\n\t\t\t\t\tnext_state = S1;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\t\tS2: begin\n\t\t\t\tif (x) begin\n\t\t\t\t\tnext_state = S1;\n\t\t\t\t\tz = 1'b1; // \"101\" detected\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = S0;\n\t\t\t\t\tz = 1'b0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tnext_state = S0;\n\t\t\t\tz = 1'b0;\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\nreg [2:0] state, next_state;\n\nlocalparam A = 3'd0,\n           B = 3'd1,\n           C = 3'd2,\n           D = 3'd3,\n           E = 3'd4,\n           F = 3'd5;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        state <= A;\n    else \n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: begin\n            if (w == 0) next_state = B;\n            else next_state = A;\n        end\n        B: begin\n            if (w == 0) next_state = C;\n            else next_state = D;\n        end\n        C: begin\n            if (w == 0) next_state = E;\n            else next_state = D;\n        end\n        D: begin\n            if (w == 0) next_state = F;\n            else next_state = A;\n        end\n        E: begin\n            if (w == 0) next_state = E;\n            else next_state = D;\n        end\n        F: begin\n            if (w == 0) next_state = C;\n            else next_state = D;\n        end\n        default: next_state = A;\n    endcase\nend\n\nassign z = (state == E) ? 1 : 0;\nendmodule\n"}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n\treg [23:0] out_bytes_reg;\n\treg done_reg;\n\treg [1:0] byte_count;\n\n\tassign out_bytes = out_bytes_reg;\n\tassign done = done_reg;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tout_bytes_reg <= 24'b0;\n\t\t\tdone_reg <= 0;\n\t\t\tbyte_count <= 0;\n\t\tend else begin\n\t\t\tif (byte_count == 0) begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tout_bytes_reg[23:16] <= in;\n\t\t\t\t\tbyte_count <= 1;\n\t\t\t\tend\n\t\t\tend else if (byte_count == 1) begin\n\t\t\t\tout_bytes_reg[15:8] <= in;\n\t\t\t\tbyte_count <= 2;\n\t\t\tend else if (byte_count == 2) begin\n\t\t\t\tout_bytes_reg[7:0] <= in;\n\t\t\t\tdone_reg <= 1;\n\t\t\t\tbyte_count <= 0;\n\t\t\tend\n\t\tdone_reg <= (byte_count == 2) ? 0 : done_reg;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    assign Y1 = (y[0] & ~w) | (y[1] & w) | (y[4] & ~w) | (y[5] & ~w);\n    assign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[3] & w) | (y[4] & ~w) | (y[5] & ~w);\nendmodule\n"}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": " outv = vec;\nassign o0 = vec[0];\nassign o1 = vec[1];\nassign o2 = vec[2];\nendmodule\n"}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 0; \n        4'b0001: out = 1; \n        4'b0010: out = 0; \n        4'b0011: out = 1; \n        4'b0100: out = 1; \n        4'b0101: out = 0; \n        4'b0110: out = 1; \n        4'b0111: out = 0; \n        4'b1000: out = 1; \n        4'b1001: out = 0; \n        4'b1010: out = 1; \n        4'b1011: out = 0; \n        4'b1100: out = 0; \n        4'b1101: out = 1; \n        4'b1110: out = 0; \n        4'b1111: out = 1; \n        default: out = 0; \n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\nassign out_lo = in[7:0];\nassign out_hi = in[15:8];\nendmodule\n"}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a | b);\nendmodule\n"}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n    assign out_assign = a ^ b;\n\n    always @* begin\n        out_always_comb = a ^ b;\n    end\n\n    always @(posedge clk) begin\n        out_always_ff <= a ^ b;\n    end\n\nendmodule\n"}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\nalways @(*) begin\n    case (y)\n        6'b000001: begin // A\n            Y2 = 0; // A - State A\n            Y4 = 0;\n        end\n        6'b000010: begin // B\n            Y2 = 0; // B - State B\n            Y4 = 0;\n        end\n        6'b000100: begin // C\n            Y2 = 1; // C - State C\n            Y4 = 0;\n        end\n        6'b001000: begin // D\n            Y2 = 0; // D - State D\n            Y4 = 1;\n        end\n        6'b010000: begin // E\n            Y2 = 0; // E - State E\n            Y4 = 0;\n        end\n        6'b100000: begin // F\n            Y2 = 1; // F - State F\n            Y4 = 0;\n        end\n        default: begin\n            Y2 = 0;\n            Y4 = 0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\n\treg q1, q2, q3;\n\twire not_q1, not_q2, not_q3;\n\twire xor_out, and_out, or_out;\n\n\t// Inverting flip-flop outputs\n\tassign not_q1 = ~q1;\n\tassign not_q2 = ~q2;\n\tassign not_q3 = ~q3;\n\n\t// Logic gates\n\tassign xor_out = x ^ q1;\n\tassign and_out = x & not_q2;\n\tassign or_out = x | not_q3;\n\n\t// D flip-flops\n\talways @(posedge clk) begin\n\t\tq1 <= xor_out;\n\t\tq2 <= and_out;\n\t\tq3 <= or_out;\n\tend\n\n\t// Output Z from XNOR\n\tassign z = ~(q1 ^ q2 ^ q3);\nendmodule\n"}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (b & d) | (c & ~a) | (a & ~b & c);\nendmodule\n"}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [511:0] next_q;\n        integer i;\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i > 0 ? q[i-1] : 1'b0), q[i], (i < 511 ? q[i+1] : 1'b0)})\n                3'b111: next_q[i] = 1'b0;\n                3'b110: next_q[i] = 1'b1;\n                3'b101: next_q[i] = 1'b1;\n                3'b100: next_q[i] = 1'b0;\n                3'b011: next_q[i] = 1'b1;\n                3'b010: next_q[i] = 1'b1;\n                3'b001: next_q[i] = 1'b1;\n                3'b000: next_q[i] = 1'b0;\n                default: next_q[i] = 1'b0; // should not occur\n            endcase\n        end\n        q <= next_q;\n    end\nend\nendmodule\n"}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\ntypedef enum reg [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\nstate_t state, next_state;\n\nassign out = (state == D) ? 1'b1 : 1'b0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= A;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (c)\n        4'b0000: q = b;      // c = 0\n        4'b0001: q = e;      // c = 1\n        4'b0010: q = a;      // c = 2\n        4'b0011: q = d;      // c = 3\n        4'b0100: q = 4'b1111; // c = 4\n        4'b0101: q = 4'b1111; // c = 5\n        4'b0110: q = 4'b1111; // c = 6\n        4'b0111: q = 4'b1111; // c = 7\n        4'b1000: q = 4'b1111; // c = 8\n        4'b1001: q = 4'b1111; // c = 9\n        4'b1010: q = 4'b1111; // c = a\n        4'b1011: q = 4'b1111; // c = b\n        4'b1100: q = 4'b1111; // c = c\n        4'b1101: q = 4'b1111; // c = d\n        4'b1110: q = 4'b1111; // c = e\n        4'b1111: q = 4'b1111; // c = f\n        default: q = 4'bx;   // default case to handle unknown scenarios\n    endcase\nend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @(*) begin\n    if (sel) \n        out = b;\n    else \n        out = a;\nend\nendmodule\n"}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": ""}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 32'b0;\n\tend else begin\n\t\tfor (int i = 0; i < 32; i = i + 1) begin\n\t\t\tif (in[i] == 0 && out[i] == 0) begin\n\t\t\t\tout[i] <= 1;\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n"}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire [8:0] sum;\n    assign sum = {1'b0, a} + {1'b0, b}; // 9-bit sum to detect overflow\n    assign s = sum[7:0]; // Lower 8 bits for the output sum\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]); // Overflow condition\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    // State transition logic\n    assign S_next = state[0] & d; // S --d=1--> S1\n    assign S1_next = state[1] & (~d) | (state[1] & d); // S1 --d=0--> S or --d=1--> S11\n    assign Count_next = state[8] & (~done_counting); // Count (counting=1) --!(done_counting)--> Count\n    assign Wait_next = state[8] & done_counting; // Count (counting=1) --(done_counting)--> Wait\n    assign B3_next = state[7] & 1'b1; // B3 (shift_ena=1) -- (always go to next cycle) --> Count\n\n    // Output logic\n    assign done = state[9] & ack; // Wait (done=1) --ack=1--> S\n    assign counting = state[8]; // Count (counting=1)\n    assign shift_ena = state[7] | state[6] | state[5] | state[4]; // B0 to B3 (shift_ena=1)\n\nendmodule\n"}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b01; // Reset to weakly not-taken\n    end else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11) begin\n                state <= state + 1; // Increment\n            end\n        end else begin\n            if (state > 2'b00) begin\n                state <= state - 1; // Decrement\n            end\n        end\n    end\nend\nendmodule\n"}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\nalways @(*) begin\n    pos = 3'b0; // Default to zero\n    casez (in) // casez allows for 'z's to be treated as match\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1????????: pos = 3'd7;\n        default: pos = 3'b0; // If none are high\n    endcase\nend\n\nendmodule\n"}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\nalways @(*) begin\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    case (scancode)\n        16'hE06B: left = 1;\n        16'hE072: down = 1;\n        16'hE074: right = 1;\n        16'hE075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\nwire [3:0] c; // Carry bits\n\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c[0])\n);\n\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c[0]),\n    .sum(sum[1]),\n    .cout(c[1])\n);\n\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c[1]),\n    .sum(sum[2]),\n    .cout(c[2])\n);\n\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c[2]),\n    .sum(sum[3]),\n    .cout(sum[4]) // Overflow bit\n);\n\nendmodule\n"}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule\n"}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\n    wire and_out1;\n    wire and_out2;\n\n    and u1(and_out1, a, b);\n    and u2(and_out2, c, d);\n    or u3(out, and_out1, and_out2);\n    not u4(out_n, out);\nendmodule\n"}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\n\treg [7:0] Q;\n\twire [7:0] mux_out;\n\n\talways @(posedge clk) begin\n\t\tif (enable) begin\n\t\t\tQ <= {S, Q[7:1]}; // Shift operation\n\t\tend\n\tend\n\n\tassign mux_out[0] = Q[0];\n\tassign mux_out[1] = Q[1];\n\tassign mux_out[2] = Q[2];\n\tassign mux_out[3] = Q[3];\n\tassign mux_out[4] = Q[4];\n\tassign mux_out[5] = Q[5];\n\tassign mux_out[6] = Q[6];\n\tassign mux_out[7] = Q[7];\n\n\talways @(*) begin\n\t\tcase ({A, B, C})\n\t\t\t3'b000: Z = mux_out[0];\n\t\t\t3'b001: Z = mux_out[1];\n\t\t\t3'b010: Z = mux_out[2];\n\t\t\t3'b011: Z = mux_out[3];\n\t\t\t3'b100: Z = mux_out[4];\n\t\t\t3'b101: Z = mux_out[5];\n\t\t\t3'b110: Z = mux_out[6];\n\t\t\t3'b111: Z = mux_out[7];\n\t\t\tdefault: Z = 1'b0; // Default case\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\nassign heater = (mode == 1 && too_cold == 1) ? 1 : 0;\nassign aircon = (mode == 0 && too_hot == 1) ? 1 : 0;\nassign fan = fan_on | heater | aircon;\n\nendmodule\n"}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\nassign out_sop = (a & ~b & ~c & d) | (~a & b & c & d) | (a & b & c & d);\nassign out_pos = (~a | b | c | ~d) & (a | ~b | ~c | ~d) & (a | b | ~c | ~d);\nendmodule\n"}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])};\n    end\nend\nendmodule\n"}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (b & d) | (b & c & ~d) | (a & ~b & c) | (a & b & ~c) | (~a & b & ~c & ~d);\n\nendmodule\n"}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @(*) begin\n    out = 0;\n    for (integer i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\nendmodule\n"}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n"}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'h0000;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q == 4'b1001) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nassign out = in1 & ~in2;\nendmodule\n"}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "n out = in;\nendmodule\n"}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    typedef enum logic [1:0] {A, B} state_t;\n    state_t state, next_state;\n\n    // Output logic\n    assign out = (state == A) ? 1'b0 : 1'b1;\n\n    // State register with asynchronous reset\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (state)\n            A: begin\n                if (in == 0)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nalways @(negedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a ^ b);\nendmodule\n"}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\nassign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\nassign z = ~(x & y);\nendmodule\n\nA a1 (\n    .x(x),\n    .y(y),\n    .z(a1_out)\n);\n\nB b1 (\n    .x(x),\n    .y(y),\n    .z(b1_out)\n);\n\nA a2 (\n    .x(x),\n    .y(y),\n    .z(a2_out)\n);\n\nB b2 (\n    .x(x),\n    .y(y),\n    .z(b2_out)\n);\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\nassign z = or_out ^ and_out;\n\nendmodule\n"}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: begin // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            2'b00: begin // No rotation\n                q <= q;\n            end\n            2'b11: begin // No rotation\n                q <= q;\n            end\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q == 10'd999) begin\n        q <= 10'b0;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": " out = ~in;\nendmodule\n"}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n    assign next_state = \n        (state[0] & ~in) ? 10'b0000000001 :  // S0 --0--> S0\n        (state[0] & in) ? 10'b0000000010 :   // S0 --1--> S1\n        (state[1] & ~in) ? 10'b0000000001 :  // S1 --0--> S0\n        (state[1] & in) ? 10'b0000000100 :   // S1 --1--> S2\n        (state[2] & ~in) ? 10'b0000000001 :  // S2 --0--> S0\n        (state[2] & in) ? 10'b0000001000 :   // S2 --1--> S3\n        (state[3] & ~in) ? 10'b0000000001 :  // S3 --0--> S0\n        (state[3] & in) ? 10'b0000010000 :   // S3 --1--> S4\n        (state[4] & ~in) ? 10'b0000000001 :  // S4 --0--> S0\n        (state[4] & in) ? 10'b0000100000 :   // S4 --1--> S5\n        (state[5] & ~in) ? 10'b0010000000 :  // S5 --0--> S8\n        (state[5] & in) ? 10'b0001000000 :   // S5 --1--> S6\n        (state[6] & ~in) ? 10'b0100000000 :  // S6 --0--> S9\n        (state[6] & in) ? 10'b0000001000 :   // S6 --1--> S7\n        (state[7] & ~in) ? 10'b0000000001 :  // S7 --0--> S0\n        (state[7] & in) ? 10'b0000001000 :   // S7 --1--> S7\n        (state[8] & ~in) ? 10'b0000000001 :  // S8 --0--> S0\n        (state[8] & in) ? 10'b0000000010 :   // S8 --1--> S1\n        (state[9] & ~in) ? 10'b0000000001 :  // S9 --0--> S0\n        (state[9] & in) ? 10'b0000000010 :   // S9 --1--> S1\n        10'b0000000000;                      // default case (should not happen)\n\n    assign out1 = state[7] | state[8] | state[9]; // Outputs only for S7, S8, S9\n    assign out2 = state[7];                        // Output 2 is active only for S7\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;        // Qold\n        2'b01: Q <= 1'b0;     // Reset\n        2'b10: Q <= 1'b1;     // Set\n        2'b11: Q <= ~Q;       // Toggle\n    endcase\nend\nendmodule\n"}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\nassign out = in[0] + in[1] + in[2];\n\nendmodule\n"}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\nassign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[9] = ~(d ^ a);\nassign out[8] = ~(d ^ b);\nassign out[7] = ~(d ^ c);\nassign out[6] = ~(d ^ d);\nassign out[5] = ~(d ^ e);\nassign out[4] = ~(e ^ a);\nassign out[3] = ~(e ^ b);\nassign out[2] = ~(e ^ c);\nassign out[1] = ~(e ^ d);\nassign out[0] = ~(e ^ e);\nendmodule\n"}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    reg state; // 0 = walk_left, 1 = walk_right\n    assign walk_left = ~state;\n    assign walk_right = state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // Reset to walk_left\n        end else begin\n            if (bump_left) begin\n                state <= 1; // Switch to walk_right\n            end else if (bump_right) begin\n                state <= 0; // Switch to walk_left\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\nassign q = a & b;\n\nendmodule\n"}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\n\twire and1_out, and2_out;\n\twire and3_out, and4_out;\n\n\tassign and1_out = p1a & p1b & p1c;\n\tassign and2_out = p1d & p1e & p1f;\n\tassign p1y = and1_out | and2_out;\n\n\tassign and3_out = p2a & p2b;\n\tassign and4_out = p2c & p2d;\n\tassign p2y = and3_out | and4_out;\n\nendmodule\n"}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            Y0 <= (x) ? 3'b001 : 3'b000;\n            z <= 1'b0;\n        end\n        3'b001: begin\n            Y0 <= (x) ? 3'b100 : 3'b001;\n            z <= 1'b0;\n        end\n        3'b010: begin\n            Y0 <= (x) ? 3'b001 : 3'b010;\n            z <= 1'b0;\n        end\n        3'b011: begin\n            Y0 <= (x) ? 3'b010 : 3'b001;\n            z <= 1'b1;\n        end\n        3'b100: begin\n            Y0 <= (x) ? 3'b100 : 3'b011;\n            z <= 1'b1;\n        end\n        default: begin\n            Y0 <= 3'b000;\n            z <= 1'b0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": " @* begin\n    out = ~(in1 | in2);\nend\nendmodule\n"}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\n\tassign w = a;\n\tassign x = b;\n\tassign y = b;\n\tassign z = c;\nendmodule\n"}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @(*) begin\n    case (sel)\n        3'd0: out = data0;\n        3'd1: out = data1;\n        3'd2: out = data2;\n        3'd3: out = data3;\n        3'd4: out = data4;\n        3'd5: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\nendmodule\n"}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\nreg [9:0] counter;\n\nassign tc = (counter == 0);\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter > 0) begin\n        counter <= counter - 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\nreg [2:0] state, next_state;\nreg start_shifting;\n\nparameter S0 = 3'b000, // Initial state\n          S1 = 3'b001, // First '1' detected\n          S2 = 3'b010, // Second '1' detected\n          S3 = 3'b011, // '0' detected\n          S4 = 3'b100; // '1' detected (sequence complete)\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S0;\n        start_shifting <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        S0: begin\n            if (data) \n                next_state = S1; \n            else \n                next_state = S0;\n        end\n        S1: begin\n            if (data) \n                next_state = S2; \n            else \n                next_state = S0;\n        end\n        S2: begin\n            if (!data) \n                next_state = S3; \n            else \n                next_state = S2;\n        end\n        S3: begin\n            if (data) \n                next_state = S4; \n            else \n                next_state = S0;\n        end\n        S4: begin\n            next_state = S4; // stay in this state once detected\n            start_shifting = 1; // signal the detection\n        end\n        default: begin\n            next_state = S0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    anyedge <= 8'b0; // reset the output\n    anyedge <= (in & ~prev_in); // detect rising edge\n    prev_in <= in; // store current input for the next clock cycle\nend\nendmodule\n"}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset to 1\n    end else begin\n        if (q < 4'b1010) begin\n            q <= q + 1; // Count from 1 to 10\n        end else begin\n            q <= 4'b0001; // Reset to 1 after reaching 10\n        end\n    end\nend\nendmodule\n"}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a) begin\n        q <= q + 1;\n    end else begin\n        q <= q;\n    end\nend\n\nendmodule\n"}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset state\n    end else begin\n        q <= {q[3] ^ q[4], q[4:1]}; // Galois LFSR update with taps at positions 5 and 3\n    end\nend\nendmodule\n"}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t1'b0: out = a + b;\n\t\t\t1'b1: out = a - b;\n\t\tendcase\n\n\t\tif (out == 8'b00000000)\n\t\t\tresult_is_zero = 1;\n\t\telse\n\t\t\tresult_is_zero = 0;\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    logic w1, w2, w3, w4;\n\n    assign w1 = (x == 4'b0011) || (x == 4'b0111); // minterms: 3, 7\n    assign w2 = (x == 4'b1011) || (x == 4'b1101); // minterms: 11, 13\n    assign w3 = (x == 4'b0100);                   // minterm: 4\n    assign w4 = (x == 4'b0101);                   // minterm: 5\n\n    assign f = w1 || w2 || w3 || w4;\nendmodule\n"}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\nalways @* begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end // 0\n        8'h16: begin out = 4'd1; valid = 1'b1; end // 1\n        8'h1e: begin out = 4'd2; valid = 1'b1; end // 2\n        8'h26: begin out = 4'd3; valid = 1'b1; end // 3\n        8'h25: begin out = 4'd4; valid = 1'b1; end // 4\n        8'h2e: begin out = 4'd5; valid = 1'b1; end // 5\n        8'h36: begin out = 4'd6; valid = 1'b1; end // 6\n        8'h3d: begin out = 4'd7; valid = 1'b1; end // 7\n        8'h3e: begin out = 4'd8; valid = 1'b1; end // 8\n        8'h46: begin out = 4'd9; valid = 1'b1; end // 9\n        default: begin out = 4'd0; valid = 1'b0; end // invalid\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'bx; // d\n        4'b0001: out = 1'b0; \n        4'b0010: out = 1'b1; \n        4'b0011: out = 1'b1; \n        4'b0100: out = 1'b0; \n        4'b0101: out = 1'b0; \n        4'b0110: out = 1'bx; // d\n        4'b0111: out = 1'bx; // d\n        4'b1000: out = 1'b0; \n        4'b1001: out = 1'b1; \n        4'b1010: out = 1'b1; \n        4'b1011: out = 1'b1; \n        4'b1100: out = 1'b0; \n        4'b1101: out = 1'b1; \n        4'b1110: out = 1'b1; \n        4'b1111: out = 1'b1; \n        default: out = 1'b0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        q <= {data, q[3:1]};\n    end else if (count_ena) begin\n        q <= q - 1;\n    end\nend\nendmodule\n"}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\nreg [1:0] count;\nreg shift_ena_reg;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tcount <= 2'b00;\n\t\tshift_ena_reg <= 1'b1;\n\tend else if (count < 2'b11) begin\n\t\tcount <= count + 1'b1;\n\t\tshift_ena_reg <= 1'b1;\n\tend else begin\n\t\tshift_ena_reg <= 1'b0;\n\tend\nend\n\nassign shift_ena = shift_ena_reg;\n\nendmodule\n"}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\nalways @* begin\n    if (sel_b1 && sel_b2) \n        out_always = b; \n    else \n        out_always = a; \nend\n\nendmodule\n"}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\nassign out = (b & c) | (a & (b | c));\nendmodule\n"}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    // State Encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n    \n    // Output Logic\n    assign g = (state == B) ? 3'b100 :   // Grant device 1\n               (state == C) ? 3'b010 :   // Grant device 2\n               (state == D) ? 3'b001 :   // Grant device 3\n               3'b000;                   // No grant\n\n    // State Transition Logic\n    always @(*) begin\n        case(state)\n            A: begin\n                if (r[1]) \n                    next_state = B;\n                else if (r[2]) \n                    next_state = C;\n                else if (r[3]) \n                    next_state = D;\n                else \n                    next_state = A;\n            end\n            B: begin\n                if (r[1]) \n                    next_state = B;\n                else \n                    next_state = A;\n            end\n            C: begin\n                if (r[2]) \n                    next_state = C;\n                else \n                    next_state = A;\n            end\n            D: begin\n                next_state = A;  // Return to A from D\n            end\n            default: next_state = A;  // Default state\n        endcase\n    end\n\n    // State Flip-Flops\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule\n"}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'b1001) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [1:0] count;\n\treg done_reg;\n\n\t// Assigning output\n\tassign done = done_reg;\n\n\t// FSM states\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcount <= 0;\n\t\t\tdone_reg <= 0;\n\t\tend else begin\n\t\t\tif (count == 0) begin\n\t\t\t\tif (in[3] == 1) begin\n\t\t\t\t\tcount <= 1;\n\t\t\t\t\tdone_reg <= 0;\n\t\t\t\tend\n\t\t\tend else if (count < 3) begin\n\t\t\t\tif (count == 2) begin\n\t\t\t\t\tdone_reg <= 1; // Signal done on the 3rd byte\n\t\t\t\tend\n\t\t\t\tcount <= count + 1;\n\t\t\tend else begin\n\t\t\t\tcount <= 0; // Reset count after 3 bytes\n\t\t\t\tdone_reg <= 0; // Reset done after signaling\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\nassign out = (sel) ? b : a;\nendmodule\n"}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": " out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @* begin\n    case (state)\n        3'b000: begin\n            next_state = (x) ? 3'b001 : 3'b000;\n            z = 0;\n        end\n        3'b001: begin\n            next_state = (x) ? 3'b100 : 3'b001;\n            z = 0;\n        end\n        3'b010: begin\n            next_state = (x) ? 3'b001 : 3'b010;\n            z = 0;\n        end\n        3'b011: begin\n            next_state = (x) ? 3'b010 : 3'b001;\n            z = 1;\n        end\n        3'b100: begin\n            next_state = (x) ? 3'b100 : 3'b011;\n            z = 1;\n        end\n        default: begin\n            next_state = 3'b000;\n            z = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    reg [2:0] state, next_state;\n    reg f_reg, g_reg;\n    reg [2:0] x_counter;\n    reg y_detected;\n\n    localparam STATE_A = 3'b000, \n               STATE_B = 3'b001, \n               STATE_C = 3'b010, \n               STATE_G1 = 3'b011, \n               STATE_Y_CHECK = 3'b100, \n               STATE_Y_SET = 3'b101;\n\n    assign f = f_reg;\n    assign g = g_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            state <= STATE_A;\n            f_reg <= 0;\n            g_reg <= 0;\n            x_counter <= 0;\n            y_detected <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                f_reg = 0;\n                g_reg = 0;\n                next_state = STATE_B;\n            end\n\n            STATE_B: begin\n                f_reg = 1;\n                g_reg = 0;\n                x_counter = 0;\n                next_state = STATE_C;\n            end\n\n            STATE_C: begin\n                f_reg = 0;\n                if (x_counter == 2) begin\n                    next_state = STATE_G1;\n                end else begin\n                    if (x) begin\n                        x_counter = x_counter + 1;\n                    end\n                    next_state = STATE_C;\n                end\n            end\n\n            STATE_G1: begin\n                f_reg = 0;\n                g_reg = 1;\n                y_detected = 0;\n                next_state = STATE_Y_CHECK;\n            end\n\n            STATE_Y_CHECK: begin\n                if (y) begin\n                    y_detected = 1;\n                end\n                next_state = (y_detected) ? STATE_Y_SET : STATE_Y_CHECK;\n            end\n\n            STATE_Y_SET: begin\n                g_reg = 1;\n                next_state = STATE_Y_SET;\n            end\n\n            default: next_state = STATE_A;\n        endcase\n    end\nendmodule\n"}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(negedge clk) begin\n    if (reset) begin\n        q <= 8'b00110100; // Reset to 0x34\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\nassign parity = ~(in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7]);\nendmodule\n"}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\nalways @(*) begin\n    case (state)\n        2'b00: begin // State A\n            if (in == 0) begin\n                next_state = 2'b00; // Stay in A\n                out = 0;\n            end else begin\n                next_state = 2'b01; // Go to B\n                out = 0;\n            end\n        end\n        2'b01: begin // State B\n            if (in == 0) begin\n                next_state = 2'b10; // Go to C\n                out = 0;\n            end else begin\n                next_state = 2'b01; // Stay in B\n                out = 0;\n            end\n        end\n        2'b10: begin // State C\n            if (in == 0) begin\n                next_state = 2'b00; // Go to A\n                out = 0;\n            end else begin\n                next_state = 2'b11; // Go to D\n                out = 0;\n            end\n        end\n        2'b11: begin // State D\n            if (in == 0) begin\n                next_state = 2'b10; // Go to C\n                out = 1;\n            end else begin\n                next_state = 2'b01; // Go to B\n                out = 1;\n            end\n        end\n        default: begin\n            next_state = 2'b00; // Default to state A\n            out = 0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nreg z;\n\nalways @(x or y) begin\n    case({x, y})\n        2'b00: z = 1;\n        2'b01: z = 0;\n        2'b10: z = 0;\n        2'b11: z = 1;\n        default: z = 1;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n// State encoding\nparameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n\nreg [2:0] state, next_state;\nassign z = (state == E) ? 1'b1 : 1'b0;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        A: begin\n            if (w) next_state = B;\n            else next_state = A;\n        end\n        B: begin\n            if (w) next_state = C;\n            else next_state = D;\n        end\n        C: begin\n            if (w) next_state = E;\n            else next_state = D;\n        end\n        D: begin\n            if (w) next_state = F;\n            else next_state = A;\n        end\n        E: begin\n            if (w) next_state = E;\n            else next_state = D;\n        end\n        F: begin\n            if (w) next_state = C;\n            else next_state = D;\n        end\n        default: next_state = A; // reset condition\n    endcase\nend\n\n// State flip-flop\nalways @(posedge clk or posedge reset) begin\n    if (reset) \n        state <= A;\n    else \n        state <= next_state;\nend\n\nendmodule\n"}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\nalways @(posedge clk) begin\n    pedge <= 8'b0; // Reset output on clock edge\n    pedge <= in & ~({1'b0, in[7:1]}); // Detect 0 to 1 transitions for each bit\nend\nendmodule\n"}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\nalways @(posedge clock) begin\n    if (a == 0) begin\n        p <= 0;\n        q <= 0;\n    end else begin\n        p <= p + 1;\n        if (p == 2) begin\n            q <= 1;\n        end else if (p == 5) begin\n            q <= 0;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 1'b0 ^ q[1]; // q[-1] is 0\n        for (integer i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n        q[511] <= q[510] ^ 1'b0; // q[512] is 0\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\tassign z = (A == B) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    assign out_both[98] = in[98] & in[99];\n    \n    genvar i;\n    generate\n        for (i = 1; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i - 1] = in[i - 1] & in[i];\n        end\n    endgenerate\n    \n    assign out_any[99] = in[0] | in[1];\n    \n    generate\n        for (i = 1; i < 99; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i - 1];\n        end\n    endgenerate\n\n    assign out_different[0] = in[0] ^ in[99];\n\n    generate\n        for (i = 1; i < 99; i = i + 1) begin : different_loop\n            assign out_different[i] = in[i] ^ in[i - 1];\n        end\n    endgenerate\n    \nendmodule\n"}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\nalways @(ena or d) begin\n    if (ena) begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\nassign out = in[sel * 4 +: 4];\nendmodule\n"}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\nalways_comb begin\n    case (sel)\n        4'b0000: out = a;\n        4'b0001: out = b;\n        4'b0010: out = c;\n        4'b0011: out = d;\n        4'b0100: out = e;\n        4'b0101: out = f;\n        4'b0110: out = g;\n        4'b0111: out = h;\n        4'b1000: out = i;\n        default: out = 16'b1111111111111111; // Setting output bits to '1' for unused cases\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\nassign out_or_bitwise = a | b;\nassign out_or_logical = |(a | b);\nassign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = (in) ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = (in) ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = (in) ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = (in) ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0000; // Default case\n        endcase\n    end\n\n    assign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output logic\nendmodule\n"}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\nalways @* begin\n    min = a; // Assume a is the minimum initially\n    if (b < min) min = b;\n    if (c < min) min = c;\n    if (d < min) min = d;\nend\nendmodule\n"}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": " out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = (d & ~c & ~b & ~a) | (d & ~c & b & ~a) | (c & b & ~a) | (c & ~b & a) | (d & c & a) | (~d & c & a) | (~b & c & a);\nendmodule\n"}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        CHECK_1 = 2'b10,\n        CHECK_2 = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [2:0] count_w; // Count for w = 1\n\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= A;\n            z <= 0;\n            count_w <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == B) begin\n                count_w <= 0; // Reset the count when entering state B\n            end\n            if (current_state == CHECK_2) begin\n                if (count_w == 3'b010 || count_w == 3'b001 || count_w == 3'b100) // Exactly two w = 1\n                    z <= 1;\n                else\n                    z <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (s) \n                    next_state = B;\n                else \n                    next_state = A;\n            end\n            B: begin\n                if (w) \n                    count_w = count_w + 1;\n                next_state = CHECK_1;\n            end\n            CHECK_1: begin\n                if (count_w < 3) begin\n                    next_state = (count_w == 2) ? CHECK_2 : B; // Keep checking or go to state CHECK_2\n                end else begin\n                    next_state = B; // Go back to state B to start over\n                end\n            end\n            CHECK_2: begin\n                next_state = B; // After checking the count, go back to B\n            end\n            default: next_state = A; // Reset to state A in case of unknown state\n        endcase\n    end\nendmodule\n"}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": " out = { {24{in[7]}}, in };\nendmodule\n"}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\n reg [3:0] shift_reg;\n\n always @(posedge clk) begin\n     if (!resetn) begin\n         shift_reg <= 4'b0000;\n     end else begin\n         shift_reg <= {shift_reg[2:0], in};\n     end\n end\n\n assign out = shift_reg[3];\nendmodule\n"}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n    casez (in)\n        4'b1??? : pos = 2'd3; // position 3\n        4'b01?? : pos = 2'd2; // position 2\n        4'b001? : pos = 2'd1; // position 1\n        4'b0001 : pos = 2'd0; // position 0\n        default : pos = 2'd0; // if none are high\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n  reg state, next_state;\n\n  localparam OFF = 1'b0,\n             ON  = 1'b1;\n\n  always @(posedge clk or posedge areset) begin\n    if (areset)\n      state <= OFF;\n    else\n      state <= next_state;\n  end\n\n  always @(*) begin\n    case (state)\n      OFF: begin\n        if (j)\n          next_state = ON;\n        else\n          next_state = OFF;\n      end\n      ON: begin\n        if (k)\n          next_state = OFF;\n        else\n          next_state = ON;\n      end\n      default: next_state = OFF; // Default state to OFF\n    endcase\n  end\n\n  assign out = state;\n\nendmodule\n"}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\nassign out = 0;\nendmodule\n"}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\n\tassign one = 1'b1;\nendmodule\n"}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\nalways @* begin\n    out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9],\n           in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],\n           in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],\n           in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],\n           in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],\n           in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],\n           in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],\n           in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],\n           in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],\n           in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\nlogic xor_out;\n\nassign xor_out = in ^ out;\n\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n"}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule\n"}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\nassign f = (x2 & ~x1) | (x2 & x1) | (x3 & x1);\nendmodule\n"}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\nassign out_and = &in;          // 100-input AND gate\nassign out_or = |in;           // 100-input OR gate\nassign out_xor = ^in;          // 100-input XOR gate\nendmodule\n"}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Ensure to reset when not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Ensure to stop driving when arrived\n    end\n\nendmodule\n"}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg state, next_state;\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // Output logic\n    assign out = state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // State register with synchronous reset\n    always @(posedge clk) begin\n        if (reset) \n            state <= OFF;\n        else \n            state <= next_state;\n    end\n\nendmodule\n"}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    wire [29:0] concatenated_inputs;\n    assign concatenated_inputs = {a, b, c, d, e, f};\n    \n    assign w = {concatenated_inputs[29:24]};\n    assign x = {concatenated_inputs[23:16]};\n    assign y = {concatenated_inputs[15:8]};\n    assign z = {concatenated_inputs[7:0], 2'b11};\n\nendmodule\n"}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) |\n           (a & b & ~c & ~d) | (a & b & c & d) | (a & ~b & c & ~d);\nendmodule\n"}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\nassign out = a & b;\nendmodule\n"}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\n\nlocalparam B = 2'b00;\nlocalparam A = 2'b01;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= B;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        B: begin\n            if (in) begin\n                next_state = B;\n                out = 1;\n            end else begin\n                next_state = A;\n                out = 1;\n            end\n        end\n        A: begin\n            if (in) begin\n                next_state = A;\n                out = 0;\n            end else begin\n                next_state = B;\n                out = 0;\n            end\n        end\n        default: begin\n            next_state = B;\n            out = 1;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n"}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\nlogic xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\nassign mux_in[0] = 1'b1; // for ab = 00\nassign mux_in[1] = (c & ~d); // for ab = 01\nassign mux_in[2] = (c & d) | (~c & d); // for ab = 11\nassign mux_in[3] = (c & ~d); // for ab = 10\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\nreg [1:0] state, next_state;\nreg z_reg;\n\nparameter A = 2'b01, B = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: begin\n            z_reg = (x) ? 1 : 0;\n            next_state = (x) ? B : A;\n        end\n        B: begin\n            z_reg = (x) ? 0 : 1;\n            next_state = B;\n        end\n        default: begin\n            z_reg = 0;\n            next_state = A;\n        end\n    endcase\nend\n\nassign z = z_reg;\n\nendmodule\n"}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\nreg ff;\nassign q = ff;\nassign state = (a && b) ? 1'b1 : 1'b0;\n\nalways @(posedge clk) begin\n    if (a && !b) begin\n        ff <= 1'b1;\n    end else if (!a && b) begin\n        ff <= 1'b0;\n    end\nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 1; // 1\n            4'b0001: f = 0; // 0\n            4'b0011: f = 0; // 0\n            4'b0010: f = 1; // 1\n            4'b0100: f = 0; // 0\n            4'b0101: f = 0; // 0\n            4'b0111: f = 1; // 1\n            4'b0110: f = 1; // 1\n            4'b1000: f = 1; // 1\n            4'b1001: f = 1; // 1\n            4'b1011: f = 0; // 0\n            4'b1010: f = 1; // 1\n            4'b1100: f = 0; // 0\n            4'b1101: f = 0; // 0\n            4'b1111: f = 1; // 1\n            4'b1110: f = 0; // 0\n            default: f = 0; \n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    reg [3:0] state, next_state;\n    reg [2:0] count;\n    \n    localparam S0 = 4'b0000, // Initial state, expect 0\n               S1 = 4'b0001, // Received 0\n               S2 = 4'b0010, // Received 01\n               S3 = 4'b0011, // Received 011\n               S4 = 4'b0100, // Received 0111\n               S5 = 4'b0101, // Received 01111\n               S6 = 4'b0110, // Received 011111\n               S7 = 4'b0111; // Error state (7 or more 1s)\n\n    // Output registers\n    reg disc_reg, flag_reg, err_reg;\n\n    assign disc = disc_reg;\n    assign flag = flag_reg;\n    assign err = err_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n            disc_reg <= 0;\n            flag_reg <= 0;\n            err_reg <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        disc_reg = 0;\n        flag_reg = 0;\n        err_reg = 0;\n        \n        case (state)\n            S0: begin\n                if (in) next_state = S1;\n            end\n            S1: begin\n                if (in) next_state = S2;\n                else next_state = S0;\n            end\n            S2: begin\n                if (in) next_state = S3;\n                else next_state = S0;\n            end\n            S3: begin\n                if (in) next_state = S4;\n                else next_state = S0;\n            end\n            S4: begin\n                if (in) next_state = S5;\n                else next_state = S0;\n            end\n            S5: begin\n                if (in) next_state = S6;\n                else begin\n                    next_state = S0;\n                    disc_reg = 1;\n                end\n            end\n            S6: begin\n                if (in) begin\n                    next_state = S7;\n                    err_reg = 1;\n                end else begin\n                    next_state = S0;\n                    flag_reg = 1;\n                end\n            end\n            S7: begin\n                // Stay in error state (7 or more 1s)\n                if (!in) next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n    reg [3:0] delay;\n    reg [9:0] counter;\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg [3:0] current_count;\n\n    parameter IDLE = 2'b00, DETECT = 2'b01, COUNT = 2'b10, DONE = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            current_count <= 0;\n            counter <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    current_count <= 0;\n                    if (data == 1) begin\n                        next_state <= DETECT;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                \n                DETECT: begin\n                    if (data == 1) begin\n                        state <= IDLE;\n                    end else if (counter < 10) begin\n                        if (counter == 0 && data == 0) begin\n                            next_state <= COUNT;\n                        end else if (counter >= 3 && counter <= 9) begin\n                            delay <= {delay[2:0], data};\n                        end\n                        counter <= counter + 1;\n                    end\n                end\n                \n                COUNT: begin\n                    counting <= 1;\n                    if (counter < (delay + 1) * 10) begin\n                        if (counter % 10 == 0) begin\n                            current_count <= delay;\n                        end else if (counter % 10 == 1) begin\n                            current_count <= delay - 1;\n                        end else if (counter % 10 == 2) begin\n                            current_count <= delay - 2;\n                        end else if (counter % 10 == 3) begin\n                            current_count <= delay - 3;\n                        end else if (counter % 10 == 4) begin\n                            current_count <= delay - 4;\n                        end else if (counter % 10 == 5) begin\n                            current_count <= delay - 5;\n                        end else if (counter % 10 == 6) begin\n                            current_count <= delay - 6;\n                        end else if (counter % 10 == 7) begin\n                            current_count <= delay - 7;\n                        end else if (counter % 10 == 8) begin\n                            current_count <= delay - 8;\n                        end else if (counter % 10 == 9) begin\n                            current_count <= delay - 9;\n                        end\n                        counter <= counter + 1;\n                    end else begin\n                        counting <= 0;\n                        done <= 1;\n                        current_count <= 0;\n                        next_state <= DONE;\n                    end\n                end\n                \n                DONE: begin\n                    if (ack) begin\n                        next_state <= IDLE;\n                    end else begin\n                        next_state <= DONE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign count = counting ? current_count : 4'bzzzz;\n\nendmodule\n"}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\nreg [1:0] state, next_state;\nparameter LOW = 2'b00, MID1 = 2'b01, MID2 = 2'b10, HIGH = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= LOW;\n        fr3 <= 1;\n        fr2 <= 1;\n        fr1 <= 1;\n        dfr <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        LOW: begin\n            if (s[1] == 1) begin\n                next_state = MID2;\n                fr3 = 0; fr2 = 0; fr1 = 0; dfr = 1; // Open all flow\n            end else begin\n                next_state = LOW;\n                fr3 = 1; fr2 = 1; fr1 = 1; dfr = 0; // Max flow\n            end\n        end\n        \n        MID2: begin\n            if (s[2] == 1) begin\n                next_state = HIGH;\n                fr3 = 0; fr2 = 0; fr1 = 1; dfr = 0; // Open fr1\n            end else begin\n                next_state = LOW;\n                fr3 = 1; fr2 = 1; fr1 = 1; dfr = 0; // Max flow\n            end\n        end\n        \n        MID1: begin\n            if (s[3] == 1) begin\n                next_state = HIGH;\n                fr3 = 0; fr2 = 1; fr1 = 1; dfr = 0; // Open fr1, fr2\n            end else begin\n                next_state = LOW;\n                fr3 = 1; fr2 = 1; fr1 = 1; dfr = 0; // Max flow\n            end\n        end\n        \n        HIGH: begin\n            next_state = HIGH;\n            fr3 = 0; fr2 = 0; fr1 = 0; dfr = 0; // No flow\n        end\n        \n        default: begin\n            next_state = LOW;\n            fr3 = 1; fr2 = 1; fr1 = 1; dfr = 0; // Default to max flow\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [3:0] current_state, next_state;\n    localparam [3:0]\n        IDLE        = 4'b0000,\n        START       = 4'b0001,\n        DATA0       = 4'b0010,\n        DATA1       = 4'b0011,\n        DATA2       = 4'b0100,\n        DATA3       = 4'b0101,\n        DATA4       = 4'b0110,\n        DATA5       = 4'b0111,\n        DATA6       = 4'b1000,\n        DATA7       = 4'b1001,\n        STOP        = 4'b1010,\n        ERROR       = 4'b1011;\n\n    assign done = (current_state == STOP) ? 1 : 0;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (in == 1'b0) // Start bit detected\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = DATA0; // Move to first data bit\n            end\n            DATA0: next_state = (data_bit_received()) ? DATA1 : ERROR;\n            DATA1: next_state = (data_bit_received()) ? DATA2 : ERROR;\n            DATA2: next_state = (data_bit_received()) ? DATA3 : ERROR;\n            DATA3: next_state = (data_bit_received()) ? DATA4 : ERROR;\n            DATA4: next_state = (data_bit_received()) ? DATA5 : ERROR;\n            DATA5: next_state = (data_bit_received()) ? DATA6 : ERROR;\n            DATA6: next_state = (data_bit_received()) ? DATA7 : ERROR;\n            DATA7: next_state = (data_bit_received()) ? STOP : ERROR;\n            STOP: begin\n                if (in == 1'b0) // Idle detected again, go to IDLE\n                    next_state = IDLE;\n                else\n                    next_state = STOP; // Wait for the next byte\n            end\n            ERROR: begin\n                if (in == 1'b1) // Wait for a stop bit then go to IDLE\n                    next_state = IDLE;\n                else\n                    next_state = ERROR; // Remain in error state\n            end\n            default: next_state = IDLE; // Default case\n        endcase\n    end\n\n    function data_bit_received;\n        begin\n            // Implementation of data bit reception logic goes here\n            // This is placeholder, actual implementation would be based on your requirements\n            data_bit_received = 1'b1; // Example return value for valid data bit\n        end\n    endfunction\nendmodule\n"}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n\treg [3:0] state, next_state;\n\treg [7:0] data;\n\treg [2:0] bit_count;\n\treg valid_done;\n\n\tlocalparam IDLE      = 4'b0000;\n\tlocalparam START     = 4'b0001;\n\tlocalparam DATA      = 4'b0010;\n\tlocalparam STOP      = 4'b0011;\n\tlocalparam CHECK_STOP = 4'b0100;\n\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\t\tvalid_done <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tvalid_done = 0;\n\t\t\t\tif (in == 0) begin\n\t\t\t\t\tnext_state = START;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTART: begin\n\t\t\t\tif (bit_count == 3'b000) begin\n\t\t\t\t\tnext_state = DATA;\n\t\t\t\tend\n\t\t\tend\n\t\t\tDATA: begin\n\t\t\t\tif (bit_count == 3'b111) begin\n\t\t\t\t\tnext_state = STOP;\n\t\t\t\tend\n\t\t\tend\n\t\t\tSTOP: begin\n\t\t\t\tif (in == 1) begin\n\t\t\t\t\tvalid_done = 1;\n\t\t\t\t\tdata = data; // Retain last received byte\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = CHECK_STOP;\n\t\t\t\tend\n\t\t\tend\n\t\t\tCHECK_STOP: begin\n\t\t\t\tif (in == 1) begin\n\t\t\t\t\tvalid_done = 1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend \n\t\t\tend\n\t\tendcase\n\tend\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tbit_count <= 0;\n\t\t\tdata <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tSTART: begin\n\t\t\t\t\tbit_count <= 0;\n\t\t\t\tend\n\t\t\t\tDATA: begin\n\t\t\t\t\tdata[bit_count] <= in;\n\t\t\t\t\tbit_count <= bit_count + 1;\n\t\t\t\tend\n\t\t\t\tSTOP: begin\n\t\t\t\t\t// Do nothing, waiting for stop bit check\n\t\t\t\tend\n\t\t\t\tCHECK_STOP: begin\n\t\t\t\t\t// Do nothing, just waiting for stop bit\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\tassign out_byte = data;\n\tassign done = valid_done;\nendmodule\n"}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\nreg [6:0] history_register;\nreg [1:0] pht [127:0];\n\nwire [6:0] index;\nwire [1:0] pht_state;\nwire mispredict;\n\nassign index = (predict_pc ^ history_register) & 7'b0111111; // Hashing using XOR\nassign pht_state = pht[index];\nassign predict_taken = pht_state[1];\nassign predict_history = history_register;\n\nalways @(posedge clk or posedge areset) begin\n\tif (areset) begin\n\t\thistory_register <= 7'b0;\n\t\tinteger i;\n\t\tfor (i = 0; i < 128; i = i + 1) begin\n\t\t\tpht[i] <= 2'b00; // Initialize PHT to 00 (strongly not taken)\n\t\tend\n\tend else begin\n\t\tif (train_valid) begin\n\t\t\tif (train_mispredicted) begin\n\t\t\t\thistory_register <= train_history; // Recover history if mispredicted\n\t\t\tend else begin\n\t\t\t\tif (train_taken) begin\n\t\t\t\t\tif (pht[train_pc ^ train_history] < 2'b11)\n\t\t\t\t\t\tpht[train_pc ^ train_history] <= pht[train_pc ^ train_history] + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tif (pht[train_pc ^ train_history] > 2'b00)\n\t\t\t\t\t\tpht[train_pc ^ train_history] <= pht[train_pc ^ train_history] - 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\n\t\tif (predict_valid) begin\n\t\t\thistory_register <= {history_register[5:0], predict_taken}; // Update history register\n\t\tend\n\tend\nend\nendmodule\n"}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n\treg [4:0] state, next_state;\n\treg [4:0] fall_count;\n\treg walking_left, walking_right, falling, digging_state;\n\t\n\tlocalparam WALK_LEFT = 2'b00,\n\t           WALK_RIGHT = 2'b01,\n\t           FALLING = 2'b10,\n\t           DIGGING = 2'b11,\n\t           SPLATTERED = 2'b100;\n\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= WALK_LEFT;\n\t\t\tfall_count <= 0;\n\t\t\twalking_left <= 1; \n\t\t\twalking_right <= 0;\n\t\t\tfalling <= 0; \n\t\t\tdigging_state <= 0;\t\t\t\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\t\tif (falling) begin\n\t\t\t\tfall_count <= fall_count + 1;\n\t\t\tend else begin\n\t\t\t\tfall_count <= 0;\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @(*) begin\n\t\tnext_state = state;\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = FALLING;\n\t\t\t\t\twalking_left = 0; walking_right = 0; falling = 1; digging_state = 0;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = DIGGING;\n\t\t\t\t\twalking_left = 0; walking_right = 0; falling = 0; digging_state = 1;\n\t\t\t\tend else if (bump_right) begin\n\t\t\t\t\tnext_state = WALK_RIGHT;\n\t\t\t\t\twalking_left = 0; walking_right = 1; falling = 0; digging_state = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = FALLING;\n\t\t\t\t\twalking_left = 0; walking_right = 0; falling = 1; digging_state = 0;\n\t\t\t\tend else if (dig) begin\n\t\t\t\t\tnext_state = DIGGING;\n\t\t\t\t\twalking_left = 0; walking_right = 0; falling = 0; digging_state = 1;\n\t\t\t\tend else if (bump_left) begin\n\t\t\t\t\tnext_state = WALK_LEFT;\n\t\t\t\t\twalking_left = 1; walking_right = 0; falling = 0; digging_state = 0;\n\t\t\t\tend\n\t\t\tend\n\t\t\tFALLING: begin\n\t\t\t\tif (ground) begin\n\t\t\t\t\tif (fall_count > 20) begin\n\t\t\t\t\t\tnext_state = SPLATTERED;\n\t\t\t\t\t\twalking_left = 0; walking_right = 0; aaah = 0; digging_state = 0;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tnext_state = (walking_left) ? WALK_LEFT : WALK_RIGHT;\n\t\t\t\t\t\twalking_left = (walking_left) ? 1 : 0; \n\t\t\t\t\t\twalking_right = (walking_right) ? 1 : 0; \n\t\t\t\t\t\tfalling = 0; \n\t\t\t\t\t\tdigging_state = 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\t\tDIGGING: begin\n\t\t\t\tif (!ground) begin\n\t\t\t\t\tnext_state = FALLING;\n\t\t\t\t\twalking_left = 0; walking_right = 0; falling = 1; digging_state = 0;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = DIGGING;\n\t\t\t\t\tdigging_state = 1; \n\t\t\t\tend\n\t\t\tend\n\t\t\tSPLATTERED: begin\n\t\t\t\twalking_left = 0; walking_right = 0; falling = 0; digging_state = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\tassign walk_left = walking_left;\n\tassign walk_right = walking_right;\n\tassign aaah = falling;\n\tassign digging = digging_state;\n\nendmodule\n"}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    reg [3:0] state, next_state;\n    \n    parameter IDLE = 4'b0000,\n              WAIT_PATTERN = 4'b0001,\n              SHIFT_ENABLE = 4'b0010,\n              COUNTING = 4'b0011,\n              DONE = 4'b0100;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @* begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if ({data, 1'b0} == 4'b1101) begin\n                    next_state = WAIT_PATTERN;\n                end\n            end\n            \n            WAIT_PATTERN: begin\n                next_state = SHIFT_ENABLE;\n            end\n            \n            SHIFT_ENABLE: begin\n                shift_ena = 1;\n                if (next_state == SHIFT_ENABLE) begin\n                    next_state = COUNTING;\n                end\n            end\n            \n            COUNTING: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                done = 1;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [15:0] next_state [15:0];\n        integer i, j, count;\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                count = 0;\n                for (integer di = -1; di <= 1; di = di + 1) begin\n                    for (integer dj = -1; dj <= 1; dj = dj + 1) begin\n                        if (di == 0 && dj == 0) continue; // skip the cell itself\n                        count = count + q[(i + di + 16) % 16 * 16 + (j + dj + 16) % 16];\n                    end\n                end\n                if (q[i * 16 + j] == 1) begin\n                    if (count < 2 || count > 3) \n                        next_state[i][j] = 0; // becomes 0\n                    else \n                        next_state[i][j] = 1; // stays alive\n                end else begin\n                    if (count == 3) \n                        next_state[i][j] = 1; // becomes alive\n                    else \n                        next_state[i][j] = 0; // stays dead\n                end\n            end\n        end\n        for (i = 0; i < 16; i = i + 1) begin\n            q[i * 16 +: 16] <= next_state[i];\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    \n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALLING = 2'b10,\n               DIGGING = 2'b11;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) \n                    next_state = FALLING;\n                else if (bump_right) \n                    next_state = WALK_RIGHT;\n                else if (dig) \n                    next_state = DIGGING;\n                else \n                    next_state = WALK_LEFT;\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_left)\n                    next_state = WALK_LEFT;\n                else if (dig) \n                    next_state = DIGGING;\n                else \n                    next_state = WALK_RIGHT;\n            end\n            \n            FALLING: begin\n                if (ground) \n                    next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                else \n                    next_state = FALLING;\n            end\n            \n            DIGGING: begin\n                if (!ground) \n                    next_state = FALLING;\n                else \n                    next_state = DIGGING;\n            end\n            \n            default: next_state = WALK_LEFT;\n        endcase\n    end\nendmodule\n"}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        hh <= 8'b00001100; // Reset to 12\n        mm <= 8'b00000000; // Reset to 00\n        ss <= 8'b00000000; // Reset to 00\n        pm <= 1'b0;        // Reset to AM\n    end else if (ena) begin\n        if (ss == 8'b00111001) begin // 59 seconds\n            ss <= 8'b00000000; // Reset seconds to 0\n            if (mm == 8'b00111001) begin // 59 minutes\n                mm <= 8'b00000000; // Reset minutes to 0\n                if (hh == 8'b00001101) begin // 12 hours\n                    hh <= 8'b00000001; // Reset hours to 1\n                    pm <= ~pm; // Toggle AM/PM\n                end else begin\n                    hh <= hh + 1; // Increment hour\n                end\n            end else begin\n                mm <= mm + 1; // Increment minutes\n            end\n        end else begin\n            ss <= ss + 1; // Increment seconds\n        end\n    end\nend\nendmodule\n"}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    reg state; // 0 for walk_left, 1 for walk_right\n    reg falling; // 1 if falling, 0 otherwise\n\n    assign walk_left = (state == 0) && !falling;\n    assign walk_right = (state == 1) && !falling;\n    assign aaah = falling;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // start walking left\n            falling <= 0; // not falling\n        end else begin\n            if (ground) begin\n                if (falling) begin\n                    falling <= 0; // ground appeared, stop falling\n                end else begin\n                    if (bump_left) begin\n                        state <= 1; // bump_left causes change to walk right\n                    end else if (bump_right) begin\n                        state <= 0; // bump_right causes change to walk left\n                    end\n                end\n            end else begin\n                falling <= 1; // no ground, start falling\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'b0;\n            if (q[7:4] == 4'd9) begin\n                q[7:4] <= 4'b0;\n                if (q[11:8] == 4'd9) begin\n                    q[11:8] <= 4'b0;\n                    if (q[15:12] < 4'd9) begin\n                        q[15:12] <= q[15:12] + 4'b1;\n                        ena[3] <= 1'b1;\n                    end else begin\n                        ena[3] <= 1'b0;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 4'b1;\n                    ena[2] <= 1'b1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 4'b1;\n                ena[1] <= 1'b1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 4'b1;\n            ena[1] <= 1'b0;\n            ena[2] <= 1'b0;\n            ena[3] <= 1'b0;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": " @(*) begin\n    if (sel) begin\n        out = b;\n    end else begin\n        out = a;\n    end\nend\n\nendmodule\n"}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0; // State A\n        3'b001: Y2 = (w == 0) ? 0 : 0; // State B\n        3'b010: Y2 = (w == 0) ? 0 : 0; // State C\n        3'b011: Y2 = (w == 0) ? 0 : 0; // State D\n        3'b100: Y2 = 1; // State E\n        3'b101: Y2 = 1; // State F\n        default: Y2 = 0; // Default case\n    endcase\nend\nendmodule\n"}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\nassign motor = ring & vibrate_mode;\nassign ringer = ring & ~vibrate_mode;\n\nendmodule\n"}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\n\tassign out_assign = a & b;\n\n\talways @(*) begin\n\t\tout_alwaysblock = a & b;\n\tend\nendmodule\n"}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\nassign zero = 1'b0;\nendmodule\n"}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a) \n        q <= ~q; \nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] number; // register to store the input number\n    reg [31:0] result; // register to store the result (2's complement)\n    reg [5:0] count;   // counter to count the number of bits received\n    reg done;          // flag to indicate when the conversion is complete\n    \n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            number <= 0;\n            result <= 0;\n            count <= 0;\n            done <= 0;\n        end else if (~areset) begin\n            if (count < 32) begin\n                number[count] <= x; // store the input bit\n                count <= count + 1;\n            end else begin\n                result <= ~number + 1; // calculate 2's complement\n                done <= 1; // set done flag\n            end\n        end\n    end\n\n    assign z = (done) ? result[0] : 1'b0; // output the LSB of the result when done\n\nendmodule\n"}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\n\n// State encoding\nlocalparam A = 2'b00,\n           B = 2'b01,\n           C = 2'b10,\n           D = 2'b11;\n\n// Output logic based on state\nassign out = (state == D) ? 1'b1 : 1'b0;\n\n// State transition logic\nalways @(*) begin\n    case (state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // Default case (should not happen)\n    endcase\nend\n\n// State update\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= A; // Reset to state A\n    else\n        state <= next_state;\nend\n\nendmodule\n"}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge r) begin\n    if (r) \n        q <= 1'b0;\n    else \n        q <= d;\nend\nendmodule\n"}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n\tassign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;      // shift left by 1 bit\n            2'b01: q <= q << 8;      // shift left by 8 bits\n            2'b10: q <= {q[62:0], q[63]}; // arithmetic right shift by 1 bit\n            2'b11: q <= {q[63:8], q[63:56]}; // arithmetic right shift by 8 bits\n            default: q <= q;         // no change\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\ntypedef enum reg [1:0] {S0, S1, S2} state_t;\nstate_t current_state, next_state;\n\nalways @(posedge clk or negedge aresetn) begin\n\tif (!aresetn) \n\t\tcurrent_state <= S0;\n\telse \n\t\tcurrent_state <= next_state;\nend\n\nalways @* begin\n\tcase (current_state)\n\t\tS0: begin\n\t\t\tz = 0;\n\t\t\tif (x)\n\t\t\t\tnext_state = S1;\n\t\t\telse\n\t\t\t\tnext_state = S0;\n\t\tend\n\t\tS1: begin\n\t\t\tz = 0;\n\t\t\tif (x)\n\t\t\t\tnext_state = S1;\n\t\t\telse\n\t\t\t\tnext_state = S2;\n\t\tend\n\t\tS2: begin\n\t\t\tz = 0;\n\t\t\tif (x) begin\n\t\t\t\tz = 1;\n\t\t\t\tnext_state = S1;\n\t\t\tend else\n\t\t\t\tnext_state = S0;\n\t\tend\n\t\tdefault: next_state = S0;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\nreg [2:0] state, next_state;\n\nlocalparam A = 3'b000,\n           B = 3'b001,\n           C = 3'b010,\n           D = 3'b011,\n           E = 3'b100,\n           F = 3'b101;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= A;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        A: begin\n            if (w == 0) next_state = B;\n            else next_state = A;\n        end\n        B: begin\n            if (w == 0) next_state = C;\n            else next_state = D;\n        end\n        C: begin\n            if (w == 0) next_state = E;\n            else next_state = D;\n        end\n        D: begin\n            if (w == 0) next_state = F;\n            else next_state = A;\n        end\n        E: begin\n            if (w == 0) next_state = E;\n            else next_state = D;\n        end\n        F: begin\n            if (w == 0) next_state = C;\n            else next_state = D;\n        end\n        default: next_state = A;\n    endcase\nend\n\nassign z = (state == E) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\n    reg [23:0] out_bytes_reg;\n    reg done_reg;\n    reg [1:0] byte_count;\n    reg [1:0] state, next_state;\n\n    localparam IDLE = 2'b00, RECEIVING = 2'b01, DONE = 2'b10;\n\n    assign out_bytes = out_bytes_reg;\n    assign done = done_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            byte_count <= 2'b00;\n            out_bytes_reg <= 24'b0;\n            done_reg <= 1'b0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVING) begin\n                out_bytes_reg <= {out_bytes_reg[15:0], in}; // Shift in new byte\n                byte_count <= byte_count + 1;\n            end else if (state == DONE) begin\n                done_reg <= 1'b1;\n                byte_count <= 2'b00; // Reset byte count for next message\n            end else begin\n                done_reg <= 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1) begin\n                    next_state = RECEIVING;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            RECEIVING: begin\n                if (byte_count == 2'b10) begin\n                    next_state = DONE;\n                end else begin\n                    next_state = RECEIVING;\n                end\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\nendmodule\n"}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\n    assign Y1 = (y[0] & ~w) | (y[1] & ~w) | (y[2] & w) | (y[3] & ~w) | (y[4] & ~w);\n    assign Y3 = (y[2] & w) | (y[3] & w) | (y[4] & ~w) | (y[5] & w);\nendmodule\n"}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": " outv = vec;\nassign o0 = vec[0];\nassign o1 = vec[1];\nassign o2 = vec[2];\nendmodule\n"}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0001: out = 1; // cd = 01\n        4'b0100: out = 1; // cd = 00\n        4'b0110: out = 1; // cd = 10\n        4'b1001: out = 1; // cd = 01\n        4'b1100: out = 1; // cd = 01\n        4'b1000: out = 1; // cd = 00\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": "\nassign out_lo = in[7:0];\nassign out_hi = in[15:8];\nendmodule\n"}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a | b);\nendmodule\n"}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\nassign out_assign = a ^ b;\n\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n"}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\nassign Y2 = (y[6] & ~w) | (y[5] & ~w) | (y[2] & w);  // From states A, B, and C\nassign Y4 = (y[3] & ~w) | (y[4] & w);                  // From states D and E\nendmodule\n"}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n\tif (L) begin\n\t\tQ <= R;  // Load the value R when L is asserted\n\tend else if (E) begin\n\t\tQ <= w;  // Shift in the value w when E is asserted\n\tend\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\nwire dff1_out, dff2_out, dff3_out;\nwire dff1_n, dff2_n, dff3_n;\n\nDFF dff1 (\n    .clk(clk),\n    .d(x ^ dff1_out),\n    .q(dff1_out)\n);\n\nDFF dff2 (\n    .clk(clk),\n    .d(x & ~dff2_out),\n    .q(dff2_out)\n);\n\nDFF dff3 (\n    .clk(clk),\n    .d(x | ~dff3_out),\n    .q(dff3_out)\n);\n\nassign dff1_n = ~dff1_out;\nassign dff2_n = ~dff2_out;\nassign dff3_n = ~dff3_out;\n\nassign z = ~(dff1_out ^ dff2_out ^ dff3_out);\n\nendmodule\n"}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (a & ~b & ~c & ~d) | (a & ~b & c & ~d) | (a & ~b & c & d) | (a & b & ~d) | (b & c & ~d) | (b & c & d) | (b & ~c & d) | (c & d);\nendmodule\n"}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [511:0] next_q;\n        next_q[0] = 0;\n        next_q[511] = 0;\n        \n        for (integer i = 1; i < 511; i = i + 1) begin\n            next_q[i] = (q[i-1] & q[i] & q[i+1]) | \n                         (q[i] & ~q[i+1]) | \n                         (q[i-1] & ~q[i]) |\n                         (q[i+1] & q[i] & ~q[i-1]);\n        end\n        \n        q <= next_q;\n    end\nend\nendmodule\n"}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg [1:0] state, next_state;\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nassign out = (state == D) ? 1 : 0;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\nalways @* begin\n    case (c)\n        4'b0000: q = b;\n        4'b0001: q = e;\n        4'b0010: q = a;\n        4'b0011: q = d;\n        4'b0100: q = f;\n        4'b0101: q = f;\n        4'b0110: q = f;\n        4'b0111: q = f;\n        4'b1000: q = f;\n        4'b1001: q = f;\n        4'b1010: q = f;\n        4'b1011: q = f;\n        4'b1100: q = f;\n        4'b1101: q = f;\n        4'b1110: q = f;\n        4'b1111: q = f;\n        default: q = 4'bxxxx;\n    endcase\nend\nendmodule\n"}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @(*) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule\n"}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": ""}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tout <= 32'h0;\n\tend else begin\n\t\tout <= out | (~in & {32{1'b1}}) & (in != {32{1'b1}});\n\tend\nend\nendmodule\n"}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\nwire [8:0] sum; // 9-bit to accommodate overflow\nassign sum = {1'b0, a} + {1'b0, b}; // Add a and b with sign extension\n\nassign s = sum[7:0]; // 8-bit sum\nassign overflow = (a[7] == b[7]) && (s[7] != a[7]); // Check for overflow condition\n\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    assign B3_next = state[9]; // From B3 to Count with shift_ena = 1\n    assign S_next = (state == 10'b0000000001 && d == 1) ? 1 : 0; // From S to S1\n    assign S1_next = (state == 10'b0000000010) ? (d == 0 ? 1 : (d == 1 ? 1 : 0)) : 0; // From S1 to S or S11\n    assign Count_next = (state == 10'b0000001000) ? (done_counting ? 0 : 1) : 0; // From Count to itself or Wait\n    assign Wait_next = (state == 10'b0000000001) ? (ack == 1 ? 1 : 0) : 0; // From Wait to S if ack = 1\n    assign done = (state == 10'b0000000001) && ack ? 1 : 0; // done output\n    assign counting = (state == 10'b0000001000) ? 1 : 0; // counting output\n    assign shift_ena = (state >= 10'b0000000100 && state <= 10'b0000001000) ? 1 : 0; // shift_ena was high in B0 to Count states\n\nendmodule\n"}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end else if (train_valid) begin\n            if (train_taken && state < 2'b11) begin\n                state <= state + 1;\n            end else if (!train_taken && state > 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\nalways @(*) begin\n    casez (in)\n        8'b1??????? : pos = 3'd7;\n        8'b01?????? : pos = 3'd6;\n        8'b001????? : pos = 3'd5;\n        8'b0001???? : pos = 3'd4;\n        8'b00001??? : pos = 3'd3;\n        8'b000001?? : pos = 3'd2;\n        8'b0000001? : pos = 3'd1;\n        8'b00000001 : pos = 3'd0;\n        default      : pos = 3'd0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\nalways @(*) begin\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    case (scancode)\n        16'hE06B: left = 1;\n        16'hE072: down = 1;\n        16'hE074: right = 1;\n        16'hE075: up = 1;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\nwire c1, c2, c3;\n\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c1)\n);\n\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c1),\n    .sum(sum[1]),\n    .cout(c2)\n);\n\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c2),\n    .sum(sum[2]),\n    .cout(c3)\n);\n\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c3),\n    .sum(sum[3]),\n    .cout(sum[4])\n);\n\nendmodule\n"}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\nendmodule\n"}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\nwire and1_out;\nwire and2_out;\n\nassign and1_out = a & b;\nassign and2_out = c & d;\nassign out = and1_out | and2_out;\nassign out_n = ~out;\n\nendmodule\n"}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\nreg [7:0] Q;\nwire [2:0] sel;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {S, Q[7:1]}; // Shift register operation\n    end\nend\n\nassign sel = {A, B, C}; // Combine A, B, and C for selection\n\nalways @(*) begin\n    case(sel)\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n        default: Z = 1'b0; // Default case (although it should never hit this)\n    endcase\nend\n\nendmodule\n"}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\n\tassign heater = (mode == 1 && too_cold) || fan_on;\n\tassign aircon = (mode == 0 && too_hot) || fan_on;\n\tassign fan = heater || aircon || fan_on;\n\nendmodule\n"}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\nassign out_sop = (a & ~b & ~c & d) | (~a & b & c & d) | (~a & ~b & ~c & ~d) | (a & b & c & d);\n\nassign out_pos = (~a | b | c | ~d) & (a | ~b | ~c | ~d) & (a | b | ~c | ~d) & (a | b | c | d);\n\nendmodule\n"}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Tap positions: 32, 22, 2, 1\n    end\nend\nendmodule\n"}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": " q = (b & d) | (b & c) | (a & c & d);\nendmodule\n"}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @* begin\n    out = 0;\n    integer i;\n    for (i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\n\nendmodule\n"}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    assign out_any[0] = 1'b0; // No right neighbour for in[0]\n\n    assign out_different[3] = in[3] ^ in[0]; // Wrapping around\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n"}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @* begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'h0000; // Default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (slowena) begin\n        if (q < 4'b1001) begin\n            q <= q + 1;\n        end else begin\n            q <= 4'b0000;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nassign out = in1 & ~in2;\nendmodule\n"}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    reg state, next_state;\n    \n    // State encoding\n    localparam A = 1'b0, B = 1'b1;\n\n    // Output logic\n    assign out = state;\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: if (in == 0) next_state = B; else next_state = A;\n            B: if (in == 0) next_state = A; else next_state = B;\n            default: next_state = B; // Default to B\n        endcase\n    end\n\n    // State register\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\nendmodule\n"}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nalways @(negedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "assign out = ~(a ^ b);\nendmodule"}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": ""}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: begin\n                q <= {q[0], q[99:1]}; // Rotate right\n            end\n            2'b10: begin\n                q <= {q[98:0], q[99]}; // Rotate left\n            end\n            2'b00: begin\n                q <= q; // No rotation\n            end\n            2'b11: begin\n                q <= q; // No rotation\n            end\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b000000000;\n    end else begin\n        if (q < 10'd999) begin\n            q <= q + 1;\n        end else begin\n            q <= 10'b000000000;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": " out = ~in;\nendmodule\n"}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n    assign next_state = (state[0] & ~in) ? 10'b0000000001 :\n                        (state[0] & in)  ? 10'b0000000010 :\n                        (state[1] & ~in) ? 10'b0000000001 :\n                        (state[1] & in)  ? 10'b0000000011 :\n                        (state[2] & ~in) ? 10'b0000000001 :\n                        (state[2] & in)  ? 10'b0000000100 :\n                        (state[3] & ~in) ? 10'b0000000001 :\n                        (state[3] & in)  ? 10'b0000000101 :\n                        (state[4] & ~in) ? 10'b0000000001 :\n                        (state[4] & in)  ? 10'b0000000110 :\n                        (state[5] & ~in) ? 10'b0000001000 :\n                        (state[5] & in)  ? 10'b0000000111 :\n                        (state[6] & ~in) ? 10'b0000001001 :\n                        (state[6] & in)  ? 10'b0000000111 :\n                        (state[7] & ~in) ? 10'b0000000001 :\n                        (state[7] & in)  ? 10'b0000000111 :\n                        (state[8] & ~in) ? 10'b0000000001 :\n                        (state[8] & in)  ? 10'b0000000010 :\n                        (state[9] & ~in) ? 10'b0000000001 :\n                        (state[9] & in)  ? 10'b0000000010 :\n                        10'b0000000000;\n\n    assign out1 = state[7] | state[8] | state[9];\n    assign out2 = state[7];\n    \nendmodule\n"}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;         // Qold state\n        2'b01: Q <= 0;         // Reset\n        2'b10: Q <= 1;         // Set\n        2'b11: Q <= ~Q;        // Toggle\n    endcase\nend\n\nendmodule\n"}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": " @(*) begin\n    out = in[0] + in[1] + in[2];\nend\n\nendmodule\n"}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\tassign out[24] = ~(a ^ a);\n\tassign out[23] = ~(a ^ b);\n\tassign out[22] = ~(a ^ c);\n\tassign out[21] = ~(a ^ d);\n\tassign out[20] = ~(a ^ e);\n\tassign out[19] = ~(b ^ a);\n\tassign out[18] = ~(b ^ b);\n\tassign out[17] = ~(b ^ c);\n\tassign out[16] = ~(b ^ d);\n\tassign out[15] = ~(b ^ e);\n\tassign out[14] = ~(c ^ a);\n\tassign out[13] = ~(c ^ b);\n\tassign out[12] = ~(c ^ c);\n\tassign out[11] = ~(c ^ d);\n\tassign out[10] = ~(c ^ e);\n\tassign out[9]  = ~(d ^ a);\n\tassign out[8]  = ~(d ^ b);\n\tassign out[7]  = ~(d ^ c);\n\tassign out[6]  = ~(d ^ d);\n\tassign out[5]  = ~(d ^ e);\n\tassign out[4]  = ~(e ^ a);\n\tassign out[3]  = ~(e ^ b);\n\tassign out[2]  = ~(e ^ c);\n\tassign out[1]  = ~(e ^ d);\n\tassign out[0]  = ~(e ^ e);\nendmodule\n"}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\nreg [1:0] state, next_state;\n\nlocalparam LEFT  = 2'b00,\n           RIGHT = 2'b01;\n\nassign walk_left = (state == LEFT);\nassign walk_right = (state == RIGHT);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= LEFT;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @* begin\n    case (state)\n        LEFT: begin\n            if (bump_right) next_state = RIGHT;\n            else if (bump_left) next_state = LEFT;\n            else next_state = LEFT;\n        end\n        \n        RIGHT: begin\n            if (bump_left) next_state = LEFT;\n            else if (bump_right) next_state = RIGHT;\n            else next_state = RIGHT;\n        end\n        \n        default: next_state = LEFT;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": "\nassign q = a & b;\nendmodule\n"}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nwire and1_out, and2_out, and3_out, and4_out;\n\nassign and1_out = p1a & p1b & p1c; // First 3-input AND gate\nassign and2_out = p1d & p1e & p1f; // Second 3-input AND gate\nassign p1y = and1_out | and2_out;   // OR gate for p1y\n\nassign and3_out = p2a & p2b;       // First 2-input AND gate\nassign and4_out = p2c & p2d;       // Second 2-input AND gate\nassign p2y = and3_out | and4_out;  // OR gate for p2y\n\nendmodule\n"}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            Y0 <= (x ? 3'b001 : 3'b000);\n            z <= 0;\n        end\n        3'b001: begin\n            Y0 <= (x ? 3'b100 : 3'b001);\n            z <= 0;\n        end\n        3'b010: begin\n            Y0 <= (x ? 3'b001 : 3'b010);\n            z <= 0;\n        end\n        3'b011: begin\n            Y0 <= (x ? 3'b010 : 3'b001);\n            z <= 1;\n        end\n        3'b100: begin\n            Y0 <= (x ? 3'b100 : 3'b011);\n            z <= 1;\n        end\n        default: begin\n            Y0 <= 3'b000;\n            z <= 0;\n        end\n    endcase\nend\nendmodule\n"}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nalways @* begin\n    out = ~(in1 | in2);\nend\nendmodule\n"}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": "\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n"}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n"}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @* begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\nreg [9:0] counter;\nassign tc = (counter == 0);\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter > 0) begin\n        counter <= counter - 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\nreg [3:0] state, next_state;\nparameter S0 = 4'b0000, S1 = 4'b0001, S2 = 4'b0010, S3 = 4'b0011, S4 = 4'b0100;\n\nassign start_shifting = (state == S4);\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tstate <= S0;\n\tend else begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (state)\n\t\tS0: next_state = (data) ? S1 : S0;\n\t\tS1: next_state = (data) ? S2 : S0;\n\t\tS2: next_state = (data) ? S3 : S0;\n\t\tS3: next_state = (data) ? S4 : S0;\n\t\tS4: next_state = S4; // Stay in S4 once the sequence is found\n\t\tdefault: next_state = S0;\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b00000000;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\nreg [7:0] in_prev;\n\nalways @(posedge clk) begin\n    anyedge <= 8'b0; // Reset output\n    anyedge <= (in & ~in_prev); // Detect rising edges\n    in_prev <= in; // Store current input for next cycle\nend\nendmodule\n"}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset to 1\n    end else begin\n        if (q < 4'b1010) begin\n            q <= q + 1; // Count up to 10\n        end else begin\n            q <= 4'b0001; // Reset back to 1 after reaching 10\n        end\n    end\nend\nendmodule\n"}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a) begin\n        q <= q + 1;\n    end else begin\n        q <= 0;\n    end\nend\nendmodule\n"}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset output to 1\n    end else begin\n        q <= {q[3] ^ q[4], q[4:1]}; // Shift and apply XOR based on tap positions\n    end\nend\nendmodule\n"}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n\talways @(*) begin\n\t\tif (do_sub == 0) \n\t\t\tout = a + b;\n\t\telse \n\t\t\tout = a - b;\n\n\t\tif (out == 8'b00000000)\n\t\t\tresult_is_zero = 1;\n\t\telse\n\t\t\tresult_is_zero = 0;\n\tend\n\nendmodule\n"}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\nalways_comb begin\n    case (x)\n        4'b0000: f = 1'b0; // (00, 00)\n        4'b0001: f = 1'b0; // (00, 01)\n        4'b0010: f = 1'b0; // (00, 10)\n        4'b0011: f = 1'b1; // (00, 11)\n        4'b0100: f = 1'b0; // (01, 00)\n        4'b0101: f = 1'b1; // (01, 01)\n        4'b0110: f = 1'b1; // (01, 10)\n        4'b0111: f = 1'b1; // (01, 11)\n        4'b1000: f = 1'b1; // (10, 00)\n        4'b1001: f = 1'b1; // (10, 01)\n        4'b1010: f = 1'b0; // (10, 10)\n        4'b1011: f = 1'bd; // (10, 11) don't-care\n        4'b1100: f = 1'b1; // (11, 00)\n        4'b1101: f = 1'b1; // (11, 01)\n        4'b1110: f = 1'bd; // (11, 10) don't-care\n        4'b1111: f = 1'bd; // (11, 11) don't-care\n        default: f = 1'b0; // Default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'd0; valid = 1'b1; end\n        8'h16: begin out = 4'd1; valid = 1'b1; end\n        8'h1e: begin out = 4'd2; valid = 1'b1; end\n        8'h26: begin out = 4'd3; valid = 1'b1; end\n        8'h25: begin out = 4'd4; valid = 1'b1; end\n        8'h2e: begin out = 4'd5; valid = 1'b1; end\n        8'h36: begin out = 4'd6; valid = 1'b1; end\n        8'h3d: begin out = 4'd7; valid = 1'b1; end\n        8'h3e: begin out = 4'd8; valid = 1'b1; end\n        8'h46: begin out = 4'd9; valid = 1'b1; end\n        default: begin out = 4'd0; valid = 1'b0; end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({a, b, c, d})\n        4'b0000: out = 1'bx; // d\n        4'b0001: out = 1'b0; \n        4'b0010: out = 1'b1; \n        4'b0011: out = 1'b1; \n        4'b0100: out = 1'b0; \n        4'b0101: out = 1'b0; \n        4'b0110: out = 1'bx; // d\n        4'b0111: out = 1'bx; // d\n        4'b1000: out = 1'b0; \n        4'b1001: out = 1'b1; \n        4'b1010: out = 1'b1; \n        4'b1011: out = 1'b1; \n        4'b1100: out = 1'b0; \n        4'b1101: out = 1'b1; \n        4'b1110: out = 1'b1; \n        4'b1111: out = 1'b1; \n        default: out = 1'b0; \n    endcase\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (shift_ena) begin\n\t\t\tq <= {data, q[3:1]}; // Shift in data MSB first\n\t\tend\n\t\telse if (count_ena) begin\n\t\t\tq <= q - 1; // Decrement the value in the register\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\nreg [2:0] count; // 3-bit counter to count 4 cycles\nreg shift_enable;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 3'b000; // Reset counter\n        shift_enable <= 1'b1; // Enable shift for 4 cycles\n    end else if (count < 3'b100) begin\n        count <= count + 1; // Increment counter\n        shift_enable <= 1'b1; // Keep shift enabled\n    end else begin\n        shift_enable <= 1'b0; // Disable shift after 4 cycles\n    end\nend\n\nassign shift_ena = shift_enable;\n\nendmodule\n"}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\n// Using assign statements\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Using procedural if statement\nalways @(*) begin\n    if (sel_b1 && sel_b2) \n        out_always = b;\n    else \n        out_always = a;\nend\n\nendmodule\n"}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": "\nassign out = (b & c) | (b & ~a) | (c & ~a) | (b & a) | (c & a);\nendmodule\n"}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\n    // State encoding\n    typedef enum logic [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State flip-flops\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            A: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else if (r[2] == 1)\n                    next_state = C;\n                else if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2] == 1)\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                next_state = A; // No transitions from D in the FSM\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign g[1] = (current_state == B) ? 1 : 0;\n    assign g[2] = (current_state == C) ? 1 : 0;\n    assign g[3] = (current_state == D) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else if (q == 4'b1001) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\t// State encoding\n\ttypedef enum logic [1:0] {\n\t\tIDLE = 2'b00,\n\t\tFIRST_BYTE = 2'b01,\n\t\tSECOND_BYTE = 2'b10,\n\t\tTHIRD_BYTE = 2'b11\n\t} state_t;\n\n\tstate_t current_state, next_state;\n\t\n\tassign done = (current_state == THIRD_BYTE);\n\t\n\t// Sequential logic to update state\n\talways_ff @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tcurrent_state <= IDLE;\n\t\tend else begin\n\t\t\tcurrent_state <= next_state;\n\t\tend\n\tend\n\n\t// Combinational logic to determine next state\n\talways_comb begin\n\t\tcase (current_state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1) \n\t\t\t\t\tnext_state = FIRST_BYTE;\n\t\t\t\telse \n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tFIRST_BYTE: begin\n\t\t\t\tnext_state = SECOND_BYTE;\n\t\t\tend\n\t\t\tSECOND_BYTE: begin\n\t\t\t\tnext_state = THIRD_BYTE;\n\t\t\tend\n\t\t\tTHIRD_BYTE: begin\n\t\t\t\tnext_state = IDLE;  // Go back to IDLE after processing third byte\n\t\t\tend\n\t\t\tdefault: next_state = IDLE;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": " out = (sel) ? b : a;\nendmodule\n"}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [2:0] state, next_state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= 3'b000;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        3'b000: begin\n            next_state = (x) ? 3'b001 : 3'b000;\n            z = 0;\n        end\n        3'b001: begin\n            next_state = (x) ? 3'b100 : 3'b001;\n            z = 0;\n        end\n        3'b010: begin\n            next_state = (x) ? 3'b001 : 3'b010;\n            z = 0;\n        end\n        3'b011: begin\n            next_state = (x) ? 3'b010 : 3'b001;\n            z = 1;\n        end\n        3'b100: begin\n            next_state = (x) ? 3'b100 : 3'b011;\n            z = 1;\n        end\n        default: begin\n            next_state = 3'b000;\n            z = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\n    typedef enum logic [1:0] {A, B, C, D, E} state_t;\n    state_t current_state, next_state;\n    reg [1:0] x_count;\n    reg g_reg;\n\n    assign f = (current_state == B);\n    assign g = g_reg;\n\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    always_ff @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            x_count <= 0;\n            g_reg <= 0;\n        end else begin\n            if (current_state == C) begin\n                if (y) \n                    g_reg <= 1;\n                else if (x_count < 2) \n                    x_count <= x_count + 1;\n                else \n                    g_reg <= 0;\n            end\n        end\n    end\n\n    always_comb begin\n        case (current_state)\n            A: begin\n                next_state = resetn ? A : B;\n            end\n            B: begin\n                next_state = C;\n            end\n            C: begin\n                if (x == 1) \n                    x_count = x_count + 1;\n                if (x_count == 1) \n                    next_state = D;\n                else\n                    next_state = C;\n            end\n            D: begin\n                if (x == 0) \n                    next_state = E;\n                else \n                    next_state = D;\n            end\n            E: begin\n                next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\nendmodule\n"}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(negedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'b00110100; // 0x34\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\nassign parity = ^in;\nendmodule\n"}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\nalways @(*) begin\n    case (state)\n        2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // State A\n        2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State B\n        2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // State C\n        2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State D\n        default: next_state = 2'b00; // Default case\n    endcase\nend\n\nassign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output logic for state D\n\nendmodule\n"}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nreg z;\n\nalways @(x or y) begin\n    case ({x, y})\n        2'b00: z = 1;\n        2'b01: z = 0;\n        2'b10: z = 0;\n        2'b11: z = 1;\n        default: z = 1'bx; // In case of unexpected input\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    state_t current_state, next_state;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= A; \n        else \n            current_state <= next_state; \n    end\n\n    always_comb begin\n        case (current_state)\n            A: begin\n                if (w) next_state = B; \n                else next_state = A; \n            end\n            B: begin\n                if (w) next_state = C; \n                else next_state = D; \n            end\n            C: begin\n                if (w) next_state = E; \n                else next_state = D; \n            end\n            D: begin\n                if (w) next_state = F; \n                else next_state = A; \n            end\n            E: begin\n                if (w) next_state = E; \n                else next_state = D; \n            end\n            F: begin\n                if (w) next_state = C; \n                else next_state = D; \n            end\n            default: next_state = A; \n        endcase\n    end\n\n    assign z = (current_state == E) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\nalways @(posedge clk) begin\n    pedge <= 8'b0; // Reset output to 0\n    pedge <= (in & ~{4'b0, in[7:1]}); // Set output bits for positive edges\nend\nendmodule\n"}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\nalways @(posedge clock) begin\n\tif (a) begin\n\t\tp <= p + 1;\n\t\tif (p == 3)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= 0;\n\tend\nend\n\nalways @(negedge clock) begin\n\tif (a) begin\n\t\tq <= q; // retain value during a high\n\tend else if (!a) begin\n\t\tq <= q;\n\tend\nend\n\ninitial begin\n\tp = 0;\n\tq = 0;\nend\n\nendmodule\n"}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 1'b0 ^ q[1]; // q[-1] is considered as 0\n        for (integer i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n        q[511] <= q[510] ^ 1'b0; // q[512] is considered as 0\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\n\tassign z = (A == B) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\n    genvar i;\n    \n    generate\n        for (i = 0; i < 99; i = i + 1) begin : out_both_gen\n            assign out_both[i] = in[i] & in[i + 1];\n        end\n    endgenerate\n    \n    generate\n        for (i = 1; i < 100; i = i + 1) begin : out_any_gen\n            assign out_any[i] = in[i] | in[i - 1];\n        end\n    endgenerate\n    \n    generate\n        for (i = 0; i < 99; i = i + 1) begin : out_different_gen\n            assign out_different[i] = in[i] ^ in[i + 1];\n        end\n        assign out_different[99] = in[99] ^ in[0];\n    endgenerate\n    \nendmodule\n"}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\nalways @ (ena or d) begin\n    if (ena) begin\n        q = d;\n    end\nend\nendmodule\n"}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n\tassign out = in[sel*4 +: 4];\nendmodule\n"}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\n    always_comb begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'b1111111111111111; // All bits set to '1' for sel = 9 to 15\n        endcase\n    end\nendmodule\n"}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\nassign out_or_bitwise = a | b;\nassign out_or_logical = |(a | b);\nassign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n    always @(*) begin\n        case (state)\n            4'b0001: next_state = in ? 4'b0010 : 4'b0001; // State A\n            4'b0010: next_state = in ? 4'b0010 : 4'b0100; // State B\n            4'b0100: next_state = in ? 4'b1000 : 4'b0001; // State C\n            4'b1000: next_state = in ? 4'b0010 : 4'b0100; // State D\n            default: next_state = 4'b0001; // Default to State A\n        endcase\n    end\n\n    assign out = (state == 4'b1000); // Output is 1 only in State D\n\nendmodule\n"}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\nalways @(*) begin\n    min = a; // Initially assume a is the minimum\n    if (b < min) min = b; // Compare with b\n    if (c < min) min = c; // Compare with c\n    if (d < min) min = d; // Compare with d\nend\nendmodule\n"}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = (b & d) | (a & c) | (a & b) | (c & ~d);\nendmodule\n"}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\treg [2:0] count; // To count the number of times w = 1 in three cycles\n\n\tparameter A = 2'b00, B = 2'b01;\n\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tstate <= A;\n\t\t\tcount <= 0;\n\t\t\tz <= 0;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\talways @(state or s or w) begin\n\t\tnext_state = state;\n\t\tz = 0;\n\t\tcase (state)\n\t\t\tA: begin\n\t\t\t\tif (s == 1) begin\n\t\t\t\t\tnext_state = B;\n\t\t\t\t\tcount = 0; // Reset count when moving to state B\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tB: begin\n\t\t\t\tif (count < 3) begin\n\t\t\t\t\tif (w == 1) begin\n\t\t\t\t\t\tcount = count + 1; // Increment count if w = 1\n\t\t\t\t\tend\n\t\t\t\t\tif (count == 2) begin\n\t\t\t\t\t\tz = 1; // Set z to 1 if there are exactly 2 ones\n\t\t\t\t\tend \n\t\t\t\tend else begin\n\t\t\t\t\tcount = 0; // Reset count after 3 cycles\n\t\t\t\tend\n\t\t\tend\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": " out = { {24{in[7]}}, in };\nendmodule\n"}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\n\nendmodule\n"}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n    casez (in)\n        4'b1??? : pos = 2'd3;\n        4'b01?? : pos = 2'd2;\n        4'b001? : pos = 2'd1;\n        4'b0001 : pos = 2'd0;\n        default : pos = 2'd0; // if none are high\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\nreg state, next_state;\nparameter OFF = 1'b0, ON = 1'b1;\n\nassign out = state;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= OFF;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        OFF: begin\n            if (j == 1'b1) \n                next_state = ON;\n            else \n                next_state = OFF;\n        end\n        ON: begin\n            if (k == 1'b1) \n                next_state = OFF;\n            else \n                next_state = ON;\n        end\n        default: next_state = OFF; // Default case to handle unexpected states\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\nassign out = 1'b0;\nendmodule\n"}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\nassign one = 1'b1;\nendmodule\n"}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\nalways @* begin\n    out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9],\n           in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],\n           in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],\n           in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],\n           in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],\n           in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],\n           in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],\n           in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],\n           in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],\n           in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\nlogic xor_out;\n\nassign xor_out = in ^ out;\n\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n"}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule\n"}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\nassign f = (x2 & ~x1) | (x2 & x1) | (x3 & x1);\n\nendmodule\n"}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b00000000;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\nendmodule\n"}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0; // Reset shut_off_computer if not overheated\n\tend\n\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = ~gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 0; // Reset keep_driving if arrived\n\tend\n\nendmodule\n"}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg state, next_state;\n\nlocalparam OFF = 1'b0,\n           ON = 1'b1;\n\nassign out = state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= OFF;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        OFF: begin\n            if (j)\n                next_state = ON;\n            else\n                next_state = OFF;\n        end\n        ON: begin\n            if (k)\n                next_state = OFF;\n            else\n                next_state = ON;\n        end\n        default: next_state = OFF; // default to OFF state\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    wire [29:0] concatenated;\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    assign w = concatenated[7:0];\n    assign x = concatenated[15:8];\n    assign y = concatenated[23:16];\n    assign z = concatenated[31:24];\n\nendmodule\n"}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (~(a & b) & (c ^ d)) | ((a & ~b) & (c | ~d)) | ((a & b & ~c) & d);\nendmodule\n"}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = a & b;\nendmodule\n"}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\nreg state, next_state;\n\nparameter B = 1'b1, A = 1'b0;\n\nassign out = state;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= B;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        B: begin\n            if (in) begin\n                next_state = B;\n            end else begin\n                next_state = A;\n            end\n        end\n        A: begin\n            if (in) begin\n                next_state = A;\n            end else begin\n                next_state = B;\n            end\n        end\n        default: next_state = B; // Default to reset state\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\n\tassign sum = a ^ b ^ cin;\n\tassign cout = (a & b) | (cin & (a ^ b));\nendmodule\n"}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\nlogic xnor_out;\n\nassign xnor_out = ~(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\nassign mux_in[0] = 0;        // ab = 00\nassign mux_in[1] = 1;        // ab = 01\nassign mux_in[2] = (c & d);  // ab = 10 -> c & d\nassign mux_in[3] = (c | d);  // ab = 11 -> c | d\n\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    \n    localparam A = 2'b01, \n               B = 2'b10;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (x)\n                    next_state = B;\n                else\n                    next_state = B;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    assign z = (state == A && x) || (state == B && !x);\n\nendmodule\n"}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\nreg q_reg, state_reg;\n\nassign q = q_reg;\nassign state = state_reg;\n\nalways @(posedge clk) begin\n    state_reg <= q_reg;\n    if (a & ~b) \n        q_reg <= 1;\n    else if (~a & b) \n        q_reg <= 0;\nend\n\ninitial begin\n    q_reg = 0;\n    state_reg = 0;\nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 1;  // (0, 0) -> 1\n            4'b0001: f = 0;  // (0, 1) -> 0\n            4'b0011: f = 0;  // (1, 1) -> 0\n            4'b0010: f = 1;  // (1, 0) -> 1\n            4'b0100: f = 0;  // (0, 0) -> 0\n            4'b0110: f = 0;  // (1, 0) -> 0\n            4'b0111: f = 1;  // (1, 1) -> 1\n            4'b0101: f = 1;  // (1, 0) -> 1\n            4'b1000: f = 1;  // (0, 0) -> 1\n            4'b1001: f = 1;  // (0, 1) -> 1\n            4'b1011: f = 0;  // (1, 1) -> 0\n            4'b1010: f = 1;  // (1, 0) -> 1\n            4'b1100: f = 1;  // (0, 0) -> 1\n            4'b1101: f = 1;  // (0, 1) -> 1\n            4'b1111: f = 0;  // (1, 1) -> 0\n            4'b1110: f = 1;  // (1, 0) -> 1\n            4'b1000: f = 1;  // (0, 0) -> 1\n            default: f = 0;  // Default case\n        endcase\n    end\nendmodule\n"}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    reg [2:0] state, next_state;\n    \n    parameter S0 = 3'b000, // Initial state (0)\n              S1 = 3'b001, // Received 0\n              S2 = 3'b010, // Received 1\n              S3 = 3'b011, // Received 1, 1\n              S4 = 3'b100, // Received 1, 1, 1\n              S5 = 3'b101, // Received 1, 1, 1, 1\n              S6 = 3'b110, // Received 1, 1, 1, 1, 1\n              S7 = 3'b111; // Received 1, 1, 1, 1, 1, 1\n\n    assign disc = (state == S7); // 6 consecutive 1s followed by 0\n    assign flag = (state == S6 && in == 0); // 6 consecutive 1s followed by 0 for flag\n    assign err = (state == S7); // 7 or more consecutive 1s\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @* begin\n        case (state)\n            S0: next_state = (in) ? S1 : S0;  // 0\n            S1: next_state = (in) ? S2 : S0;  // 01\n            S2: next_state = (in) ? S3 : S0;  // 011\n            S3: next_state = (in) ? S4 : S0;  // 0111\n            S4: next_state = (in) ? S5 : S0;  // 01111\n            S5: next_state = (in) ? S6 : S0;  // 011111\n            S6: next_state = (in) ? S7 : S0;  // 0111111\n            S7: next_state = (in) ? S7 : S0;  // 01111111...\n            default: next_state = S0;\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\nreg [3:0] delay;\nreg [10:0] counter;\nreg [1:0] state;\nreg [3:0] remaining_time;\nlocalparam IDLE = 2'b00, RECEIVE = 2'b01, COUNT = 2'b10, DONE = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n        counting <= 0;\n        done <= 0;\n        counter <= 0;\n        delay <= 0;\n        remaining_time <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                counting <= 0;\n                done <= 0;\n                if ({prev_data, data} == 4'b1101) begin\n                    state <= RECEIVE;\n                    counter <= 0;\n                    remaining_time <= 0;\n                end\n                prev_data <= data;\n            end\n            \n            RECEIVE: begin\n                if (counter < 4) begin\n                    delay[3 - counter] <= data;\n                    counter <= counter + 1;\n                end else begin\n                    delay <= delay;\n                    state <= COUNT;\n                    remaining_time <= delay;\n                    counter <= 0;\n                    counting <= 1;\n                end\n            end\n            \n            COUNT: begin\n                if (counter < (remaining_time + 1) * 1000) begin\n                    counter <= counter + 1;\n                    if (counter % 1000 == 0) begin\n                        if (remaining_time > 0)\n                            remaining_time <= remaining_time - 1;\n                    end\n                end else begin\n                    counting <= 0;\n                    done <= 1;\n                    state <= DONE;\n                end\n            end\n            \n            DONE: begin\n                if (ack) begin\n                    state <= IDLE;\n                    done <= 0;\n                    remaining_time <= 0;\n                end\n            end\n        endcase\n    end\nend\n\nassign count = (counting) ? remaining_time : 4'bxxxx;\n\nendmodule\n"}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tfr3 <= 1;\n\t\t\tfr2 <= 1;\n\t\t\tfr1 <= 1;\n\t\t\tdfr <= 0;\n\t\tend else begin\n\t\t\tcase (s)\n\t\t\t\t3'b000: begin // Below s[1]\n\t\t\t\t\tfr3 <= 1;\n\t\t\t\t\tfr2 <= 1;\n\t\t\t\t\tfr1 <= 1;\n\t\t\t\t\tdfr <= 0; // No increment as below s[1]\n\t\t\t\tend\n\t\t\t\t3'b001: begin // At s[1]\n\t\t\t\t\tfr3 <= 0; \n\t\t\t\t\tfr2 <= 0; \n\t\t\t\t\tfr1 <= 1; \n\t\t\t\t\tdfr <= 0; // No increment as level stays the same\n\t\t\t\tend\n\t\t\t\t3'b011: begin // Between s[1] and s[2]\n\t\t\t\t\tfr3 <= 0; \n\t\t\t\t\tfr2 <= 1; \n\t\t\t\t\tfr1 <= 1; \n\t\t\t\t\tdfr <= 1; // Increment as moving up\n\t\t\t\tend\n\t\t\t\t3'b111: begin // Between s[2] and s[3]\n\t\t\t\t\tfr3 <= 0; \n\t\t\t\t\tfr2 <= 1; \n\t\t\t\t\tfr1 <= 1; \n\t\t\t\t\tdfr <= 0; // No increment as level stays the same\n\t\t\t\tend\n\t\t\t\tdefault: begin // Above s[3]\n\t\t\t\t\tfr3 <= 0; \n\t\t\t\t\tfr2 <= 0; \n\t\t\t\t\tfr1 <= 0; \n\t\t\t\t\tdfr <= 0; // No flow above s[3]\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\nreg [3:0] state;\nreg [3:0] next_state;\nreg [7:0] data;\nreg valid_byte;\n\nlocalparam IDLE        = 4'b0000;\nlocalparam START_BIT   = 4'b0001;\nlocalparam DATA_BITS   = 4'b0010;\nlocalparam STOP_BIT    = 4'b0011;\nlocalparam COMPLETE     = 4'b0100;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= IDLE;\n        valid_byte <= 0;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            valid_byte = 0;\n            if (in == 0) // Detect start bit\n                next_state = START_BIT;\n            else\n                next_state = IDLE;\n        end\n        START_BIT: begin\n            next_state = DATA_BITS; // Proceed to data bits after start bit\n        end\n        DATA_BITS: begin\n            if (data_count < 7) begin\n                next_state = DATA_BITS; // Receive data bits\n            end else begin\n                next_state = STOP_BIT; // Move to stop bit\n            end\n        end\n        STOP_BIT: begin\n            if (in == 1) begin\n                valid_byte = 1; // Stop bit is correct\n                next_state = COMPLETE;\n            end else begin\n                valid_byte = 0; // Wait for stop bit\n                next_state = STOP_BIT;\n            end\n        end\n        COMPLETE: begin\n            valid_byte = 0; // Reset valid_byte for next byte\n            next_state = IDLE; // Return to IDLE state after completion\n        end\n        default: begin\n            next_state = IDLE; // Fallback to IDLE\n        end\n    endcase\nend\n\nassign done = valid_byte;\n\nendmodule\n"}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    typedef enum reg [1:0] {\n        IDLE = 2'b00,\n        START_BIT = 2'b01,\n        DATA_BITS = 2'b10,\n        STOP_BIT = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [2:0] bit_count;\n    reg [7:0] data_byte;\n    reg done_reg;\n\n    assign out_byte = data_byte;\n    assign done = done_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_count <= 0;\n            data_byte <= 0;\n            done_reg <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        done_reg = 0;\n\n        case (current_state)\n            IDLE: begin\n                if (in == 0) begin\n                    next_state = START_BIT;\n                end\n            end\n            \n            START_BIT: begin\n                if (in == 1) begin\n                    // Wait for the next start bit\n                    next_state = IDLE;\n                end else begin\n                    // Start bit received, move to data bits\n                    bit_count = 0;\n                    data_byte = 0;\n                    next_state = DATA_BITS;\n                end\n            end\n\n            DATA_BITS: begin\n                if (bit_count < 8) begin\n                    data_byte[bit_count] = in; // Capture data bit\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = STOP_BIT; \n                end\n            end\n            \n            STOP_BIT: begin\n                done_reg = 1; // Set done flag when stop bit is checked\n                if (in == 1) begin\n                    next_state = IDLE; // Stop bit is valid, go back to idle\n                end else begin\n                    // Wait for next valid stop bit\n                    next_state = STOP_BIT;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\nreg [1:0] PHT[127:0]; // Pattern History Table with 128 entries of 2-bit saturating counters\nreg [6:0] global_history; // 7-bit global branch history register\nwire [6:0] index; // Index computed from PC and global history\n\n// Compute the index using XOR\nassign index = predict_pc ^ global_history;\n\n// Prediction logic\nassign predict_taken = (PHT[index] >> 1) & 1; // Taken if the higher bit is 1\nassign predict_history = global_history;\n\n// Training logic\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        global_history <= 7'b0;\n        integer i;\n        for (i = 0; i < 128; i = i + 1) begin\n            PHT[i] <= 2'b00; // Initialize PHT\n        end\n    end else begin\n        if (train_valid) begin\n            if (train_mispredicted) begin\n                global_history <= train_history; // Recover to state after misprediction\n            end else begin\n                global_history <= {global_history[5:0], train_taken}; // Update history\n            end\n            \n            // Train PHT\n            if (train_taken) begin\n                if (PHT[train_pc ^ global_history] != 2'b11) // Increment if not maxed out\n                    PHT[train_pc ^ global_history] <= PHT[train_pc ^ global_history] + 1;\n            end else begin\n                if (PHT[train_pc ^ global_history] != 2'b00) // Decrement if not min\n                    PHT[train_pc ^ global_history] <= PHT[train_pc ^ global_history] - 1;\n            end\n        end\n\n        // Update history on prediction\n        if (predict_valid) begin\n            global_history <= {global_history[5:0], predict_taken}; // Update history\n        end\n    end\nend\nendmodule\n"}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [2:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    localparam WALK_LEFT = 3'b000,\n               WALK_RIGHT = 3'b001,\n               FALLING = 3'b010,\n               DIGGING = 3'b011,\n               SPLATTER = 3'b100;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (fall_counter > 20) begin\n                        next_state = SPLATTER;\n                    end else begin\n                        next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                    end\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (ground && dig) begin\n                    next_state = DIGGING;\n                end\n            end\n            SPLATTER: begin\n                next_state = SPLATTER; // Stay in splatter state forever\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    reg [3:0] state, next_state;\n    reg [1:0] bit_count;\n\n    localparam IDLE = 4'd0,\n               WAIT_PATTERN = 4'd1,\n               SHIFT = 4'd2,\n               COUNTING = 4'd3,\n               DONE = 4'd4;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (state)\n            IDLE: begin\n                if (data == 1) begin\n                    next_state = WAIT_PATTERN;\n                    bit_count = 1;\n                end\n            end\n            \n            WAIT_PATTERN: begin\n                if (bit_count == 3 && data == 1) begin\n                    next_state = SHIFT;\n                end else if (data == 0) begin\n                    bit_count = 0;\n                    next_state = IDLE;\n                end else begin\n                    bit_count = bit_count + 1;\n                end\n            end\n            \n            SHIFT: begin\n                if (bit_count < 4) begin\n                    shift_ena = 1;\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = COUNTING;\n                end\n            end\n            \n            COUNTING: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                done = 1;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\n    reg [255:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            q <= next_q;\n        end\n    end\n\n    always @* begin\n        integer i, j, cnt;\n        next_q = q; // Default next state is the current state\n\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                cnt = 0;\n\n                // Count alive neighbors\n                for (integer x = -1; x <= 1; x = x + 1) begin\n                    for (integer y = -1; y <= 1; y = y + 1) begin\n                        if (x == 0 && y == 0) continue; // Skip the cell itself\n                        cnt = cnt + q[((i + x + 16) % 16) * 16 + ((j + y + 16) % 16)];\n                    end\n                end\n\n                // Update the next_q based on the rules\n                case (cnt)\n                    0, 1, 4: next_q[i * 16 + j] = 0; // 0-1 or 4+ neighbors\n                    2: next_q[i * 16 + j] = q[i * 16 + j]; // 2 neighbors\n                    3: next_q[i * 16 + j] = 1; // 3 neighbors\n                endcase\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [2:0] state, next_state;\n    reg [1:0] direction; // 00: left, 01: right\n    parameter IDLE = 3'b000, WALK_LEFT = 3'b001, WALK_RIGHT = 3'b010, FALL = 3'b011, DIG = 3'b100;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALL);\n    assign digging = (state == DIG);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (~ground) \n                    next_state = FALL;\n                else if (dig) \n                    next_state = DIG;\n                else if (bump_right) \n                    next_state = WALK_RIGHT;\n                else \n                    next_state = WALK_LEFT;\n            end\n            \n            WALK_RIGHT: begin\n                if (~ground) \n                    next_state = FALL;\n                else if (dig) \n                    next_state = DIG;\n                else if (bump_left) \n                    next_state = WALK_LEFT;\n                else \n                    next_state = WALK_RIGHT;\n            end\n            \n            FALL: begin\n                if (ground) \n                    next_state = (direction == 0) ? WALK_LEFT : WALK_RIGHT;\n                else \n                    next_state = FALL;\n            end\n            \n            DIG: begin\n                if (~ground) \n                    next_state = FALL;\n                else \n                    next_state = DIG;\n            end\n            \n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    always @(state or bump_left or bump_right) begin\n        if (state == WALK_LEFT || state == WALK_RIGHT) begin\n            if (state == WALK_LEFT)\n                direction = 0; // walking left\n            else\n                direction = 1; // walking right\n        end\n    end\n\nendmodule\n"}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        hh <= 8'd0;  // Reset hours to 12 (encoded in BCD)\n        mm <= 8'd0;  // Reset minutes to 0\n        ss <= 8'd0;  // Reset seconds to 0\n        pm <= 1'b0;  // Reset to AM\n    end else if (ena) begin\n        if (ss == 8'd59) begin\n            ss <= 8'd0;\n            if (mm == 8'd59) begin\n                mm <= 8'd0;\n                if (hh == 8'd11) begin\n                    hh <= 8'd0;\n                    pm <= ~pm;  // Toggle PM/AM\n                end else begin\n                    hh <= hh + 8'd1;  // Increment the hour\n                end\n            end else begin\n                mm <= mm + 8'd1;  // Increment the minutes\n            end\n        end else begin\n            ss <= ss + 8'd1;  // Increment the seconds\n        end\n    end\nend\nendmodule\n"}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    reg state; // 0 = walk_left, 1 = walk_right\n    reg falling;\n    reg walk_left_reg;\n    reg walk_right_reg;\n    reg aaah_reg;\n\n    assign walk_left = walk_left_reg;\n    assign walk_right = walk_right_reg;\n    assign aaah = aaah_reg;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // starts walking left\n            falling <= 0;\n        end else begin\n            if (ground) begin\n                if (!falling) begin\n                    if (bump_left) begin\n                        state <= 1; // bump left, walk right\n                    end else if (bump_right) begin\n                        state <= 0; // bump right, walk left\n                    end\n                    falling <= 0; // not falling anymore\n                end\n            end else begin // ground = 0\n                falling <= 1; // now falling\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            0: begin // walking left\n                walk_left_reg = 1;\n                walk_right_reg = 0;\n                aaah_reg = falling;\n            end\n            1: begin // walking right\n                walk_left_reg = 0;\n                walk_right_reg = 1;\n                aaah_reg = falling;\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\n\tinteger i;\n\talways @(posedge clk) begin\n\t\tif (reset) begin\n\t\t\tq <= 0;\n\t\tend else begin\n\t\t\tif (q[3:0] == 9) begin\n\t\t\t\tq[3:0] <= 0;\n\t\t\t\tif (q[7:4] == 9) begin\n\t\t\t\t\tq[7:4] <= 0;\n\t\t\t\t\tif (q[11:8] == 9) begin\n\t\t\t\t\t\tq[11:8] <= 0;\n\t\t\t\t\t\tif (q[15:12] < 9) begin\n\t\t\t\t\t\t\tq[15:12] <= q[15:12] + 1;\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tq[11:8] <= q[11:8] + 1;\n\t\t\t\t\tend\n\t\t\t\tend else begin\n\t\t\t\t\tq[7:4] <= q[7:4] + 1;\n\t\t\t\tend\n\t\t\tend else begin\n\t\t\t\tq[3:0] <= q[3:0] + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign ena[1] = (q[3:0] == 9);\n\tassign ena[2] = (ena[1] && q[7:4] == 9);\n\tassign ena[3] = (ena[2] && q[11:8] == 9);\n\nendmodule\n"}
{"task_id": "mux2to1v", "description": "Create a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "completion": "\nassign out = (sel) ? b : a;\nendmodule\n"}
{"task_id": "m2014_q6b", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Assume that you want to Implement the FSM using three flip-flops and state codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F, respectively. Implement just the next-state logic for y[2] in Verilog. The output Y2 is y[2].", "prompt": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "completion": "\nalways @(*) begin\n    case (y)\n        3'b000: Y2 = 0; // State A\n        3'b001: Y2 = 0; // State B\n        3'b010: Y2 = 0; // State C\n        3'b011: Y2 = 0; // State D\n        3'b100: Y2 = 1; // State E\n        3'b101: Y2 = 1; // State F\n    endcase\nend\nendmodule\n"}
{"task_id": "ringer", "description": "Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. Whenever the phone needs to ring from an incoming call (input ring), your circuit must either turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.", "prompt": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "completion": "\nassign motor = vibrate_mode ? 1 : 0;\nassign ringer = vibrate_mode ? 0 : ring;\nendmodule\n"}
{"task_id": "alwaysblock1", "description": "Build an AND gate using both an assign statement and a combinational always block. ", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "completion": "\nassign out_assign = a & b;\n\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n"}
{"task_id": "zero", "description": "Build a circuit that always outputs a LOW.", "prompt": "module top_module(\n\toutput zero);\n", "completion": "\nassign zero = 1'b0;\nendmodule\n"}
{"task_id": "circuit7", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               x               x               \n// 5ns             1               0               x               \n// 10ns            0               0               x               \n// 15ns            1               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               1               \n// 30ns            0               0               1               \n// 35ns            1               1               1               \n// 40ns            0               1               1               \n// 45ns            1               1               0               \n// 50ns            0               1               0               \n// 55ns            1               1               0               \n// 60ns            0               1               0               \n// 65ns            1               1               0               \n// 70ns            0               1               0               \n// 75ns            1               1               0               \n// 80ns            0               1               0               \n// 85ns            1               1               0               \n// 90ns            0               1               0         ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a == 0) begin\n        q <= 1;\n    end else begin\n        q <= ~q;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q5a", "description": "You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires a positive edge triggered asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [31:0] shift_reg; // To store input bits\n    reg [31:0] result;    // To store final result (2's complement)\n    reg [4:0] count;      // To count number of bits entered\n    reg output_valid;     // To indicate when output is valid\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 0;\n            result <= 0;\n            count <= 0;\n            output_valid <= 0;\n        end else if (!areset) begin\n            if (count < 32) begin\n                shift_reg <= {x, shift_reg[31:1]}; // Shift in new input bit\n                count <= count + 1; // Increment count\n            end\n            \n            if (count == 32) begin\n                result <= ~shift_reg + 1; // Compute 2's complement\n                output_valid <= 1; // Set output valid\n            end\n        end\n    end\n\n    assign z = output_valid ? result[0] : 1'bz; // Output the least significant bit\n\nendmodule\n"}
{"task_id": "fsm3", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a positive edge triggered asynchronous reset that resets the FSM to state A.\n \n// state | next state in=0, next state in=1 | output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in) next_state = B; else next_state = A;\n                out = 0;\n            end\n            B: begin\n                if (in) next_state = B; else next_state = C;\n                out = 0;\n            end\n            C: begin\n                if (in) next_state = D; else next_state = A;\n                out = 0;\n            end\n            D: begin\n                if (in) next_state = B; else next_state = C;\n                out = 1;\n            end\n            default: begin\n                next_state = A;\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "vector2", "description": "Build a circuit that reverses the byte order of a 32-bit vector.", "prompt": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "completion": "\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\n"}
{"task_id": "m2014_q4c", "description": "Implement a simple D flip flop with active high synchronous reset (reset output to 0).", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge r) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_q4a", "description": "Implement the boolean function z = (x^y) & x.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\n    assign z = (x ^ y) & x;\nendmodule\n"}
{"task_id": "shift18", "description": "Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by \"amount.\" Assume the right shit is an arithmetic right shift. \n\n// Signals are defined as below:\n// (1) load: Loads shift register with data[63:0] instead of shifting. Active high.\n// (2) ena: Chooses whether to shift. Active high. \n// (3) amount: Chooses which direction and how much to shift. \n//     (a) 2'b00: shift left by 1 bit. \n//     (b) 2'b01: shift left by 8 bits. \n//     (c) 2'b10: shift right by 1 bit. \n//     (d) 2'b11: shift right by 8 bits. \n// (4) q: The contents of the shifter.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1;       // shift left by 1 bit\n            2'b01: q <= q << 8;       // shift left by 8 bits\n            2'b10: q <= {{1'b0, q[63:1]}}; // arithmetic right shift by 1 bit\n            2'b11: q <= {{q[63]}, q[63:8]}; // arithmetic right shift by 8 bits\n            default: q <= q;          // no shift\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2013_q8", "description": "Implement a Mealy-type finite state machine that recognizes the sequence \"101\" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the \"101\" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.", "prompt": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\nreg [1:0] state, next_state;\n\n// State encoding\nlocalparam S0 = 2'b00, // Initial state\n           S1 = 2'b01, // Seen '1'\n           S2 = 2'b10; // Seen '10'\n\nalways @(posedge clk or negedge aresetn) begin\n    if (!aresetn)\n        state <= S0;\n    else\n        state <= next_state;\nend\n\nalways @(*) begin\n    case (state)\n        S0: begin\n            if (x) begin\n                next_state = S1;\n                z = 0;\n            end else begin\n                next_state = S0;\n                z = 0;\n            end\n        end\n        S1: begin\n            if (!x) begin\n                next_state = S2;\n                z = 0;\n            end else begin\n                next_state = S1;\n                z = 0;\n            end\n        end\n        S2: begin\n            if (x) begin\n                next_state = S1;\n                z = 1; // Detected \"101\"\n            end else begin\n                next_state = S0;\n                z = 0;\n            end\n        end\n        default: begin\n            next_state = S0;\n            z = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q6", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Implement this state machine in Verilog.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\ntypedef enum logic [2:0] {\n    A = 3'b000,\n    B = 3'b001,\n    C = 3'b010,\n    D = 3'b011,\n    E = 3'b100,\n    F = 3'b101\n} state_t;\n\nstate_t state, next_state;\n\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways_comb begin\n    case (state)\n        A: begin\n            if (w == 0)\n                next_state = B;\n            else\n                next_state = A;\n            z = 0;\n        end\n        B: begin\n            if (w == 0)\n                next_state = C;\n            else\n                next_state = D;\n            z = 0;\n        end\n        C: begin\n            if (w == 0)\n                next_state = E;\n            else\n                next_state = D;\n            z = 0;\n        end\n        D: begin\n            if (w == 0)\n                next_state = F;\n            else\n                next_state = A;\n            z = 0;\n        end\n        E: begin\n            if (w == 0)\n                next_state = E;\n            else\n                next_state = D;\n            z = 1;\n        end\n        F: begin\n            if (w == 0)\n                next_state = C;\n            else\n                next_state = D;\n            z = 1;\n        end\n        default: next_state = A; // default case\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm_ps2data", "description": "We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.\n\n// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). \n\n// Waveform example:\n// time            clk             reset           in[7:0]         done            out_bytes       \n// 0ns             0               1                0              x                    x          \n// 5ns             1               1                0              0                    x          \n// 10ns            0               1                0              0                    x          \n// 15ns            1               0               2c              0                    x          \n// 20ns            0               0               2c              0                    x          \n// 25ns            1               0               81              0                    x          \n// 30ns            0               0               81              0                    x          \n// 35ns            1               0                9              0                    x          \n// 40ns            0               0                9              0                    x          \n// 45ns            1               0               6b              1               2c8109          \n// 50ns            0               0               6b              1               2c8109          \n// 55ns            1               0                d              0                    x          \n// 60ns            0               0                d              0                    x          \n// 65ns            1               0               8d              0                    x          \n// 70ns            0               0               8d              0                    x          \n// 75ns            1               0               6d              1               6b0d8d          \n// 80ns            0               0               6d              1               6b0d8d          \n// 85ns            1               0               12              0                    x          \n// 90ns            0               0               12              0                    x          \n// 95ns            1               0                1              0                    x          \n// 100ns           0               0                1              0                    x          \n// 105ns           1               0                d              1               6d1201          \n// 110ns           0               0                d              1               6d1201          \n// 115ns           1               0               76              0                    x          \n// 120ns           0               0               76              0                    x          \n// 125ns           1               0               3d              0                    x          \n// 130ns           0               0               3d              0                    x          \n// 135ns           1               0               ed              1                d763d          \n// 140ns           0               0               ed              1                d763d          \n// 145ns           1               0               8c              0                    x          \n// 150ns           0               0               8c              0                    x          \n// 155ns           1               0               f9              0                    x          \n// 160ns           0               0               f9              0                    x          \n// 165ns           1               0               ce              1               ed8cf9          \n// 170ns           0               0               ce              1               ed8cf9          \n// 175ns           1               0               c5              0                    x          \n// 180ns           0               0               c5              0                    x          \n// 185ns           1               0               aa              0                    x          \n// 190ns           0               0               aa              0                    x          ", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "completion": "\nreg [23:0] out_bytes_reg;\nreg [1:0] count;\nreg done_reg;\n\nassign out_bytes = out_bytes_reg;\nassign done = done_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out_bytes_reg <= 24'b0;\n        count <= 2'b0;\n        done_reg <= 1'b0;\n    end else begin\n        if (count == 2'b00) begin\n            if (in[3] == 1) begin\n                out_bytes_reg[23:16] <= in;\n                count <= count + 1;\n                done_reg <= 1'b0;\n            end\n        end else if (count == 2'b01) begin\n            out_bytes_reg[15:8] <= in;\n            count <= count + 1;\n            done_reg <= 1'b0;\n        end else if (count == 2'b10) begin\n            out_bytes_reg[7:0] <= in;\n            count <= 2'b00;\n            done_reg <= 1'b1;\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "2012_q2b", "description": "\n// Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Assume that a one-hot code is used with the state assignment y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Write a Verilog for the signal Y1, which is the input of state flip-flop y[1], for the signal Y3, which is the input of state flip-flop y[3]. Derive the Verilog by inspection assuming a one-hot encoding.\n", "prompt": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "completion": "\nassign Y1 = (y[0] & ~w) | (y[1] & w);\nassign Y3 = (y[1] & ~w) | (y[2] & w) | (y[5] & ~w);\n\nendmodule\n"}
{"task_id": "vector0", "description": "Build a circuit that has one 3-bit input, then outputs the same vector, and also splits it into three separate 1-bit outputs. Connect output o0 to the input vector's position 0, o1 to position 1, etc.", "prompt": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "completion": "\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\nendmodule\n"}
{"task_id": "kmap4", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 0 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 1 | 0 |\n//  11 | 0 | 1 | 0 | 1 |\n//  10 | 1 | 0 | 1 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    case ({c, d, b, a})\n        4'b0000: out = 0; // 0\n        4'b0001: out = 1; // 1\n        4'b0010: out = 0; // 0\n        4'b0011: out = 1; // 1\n        4'b0100: out = 1; // 1\n        4'b0101: out = 0; // 0\n        4'b0110: out = 1; // 1\n        4'b0111: out = 0; // 0\n        4'b1000: out = 1; // 1\n        4'b1001: out = 0; // 0\n        4'b1010: out = 1; // 1\n        4'b1011: out = 0; // 0\n        4'b1100: out = 0; // 0\n        4'b1101: out = 1; // 1\n        4'b1110: out = 0; // 0\n        4'b1111: out = 1; // 1\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vector1", "description": "Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) into lower [7:0] and upper [15:8] bytes.", "prompt": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "completion": " out_lo = in[7:0];\nassign out_hi = in[15:8];\nendmodule\n"}
{"task_id": "norgate", "description": "Create a module that implements a NOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": " out = ~(a | b);\nendmodule\n"}
{"task_id": "alwaysblock2", "description": "Build an XOR gate three ways, using an assign statement (output out_assign), a combinational always block (output out_always_comb), and a clocked always block (output out_always_ff). Note that the clocked always block produces a different circuit from the other two: There is a flip-flop so the output is delayed.", "prompt": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "completion": "\n\tassign out_assign = a ^ b;\n\n\talways @* begin\n\t\tout_always_comb = a ^ b;\n\tend\n\n\talways @(posedge clk) begin\n\t\tout_always_ff <= a ^ b;\n\tend\nendmodule\n"}
{"task_id": "m2014_q6c", "description": "Consider the state machine shown below:\n\n// A (0) --0--> B\n// A (0) --1--> A\n// B (0) --0--> C\n// B (0) --1--> D\n// C (0) --0--> E\n// C (0) --1--> D\n// D (0) --0--> F\n// D (0) --1--> A\n// E (1) --0--> E\n// E (1) --1--> D\n// F (1) --0--> C\n// F (1) --1--> D\n\n// Resets into state A. For this part, assume that a one-hot code is used with the state assignment y[6:1] = 000001, 000010, 000100, 001000, 010000, 100000 for states A, B,..., F, respectively.\n\n// Write Verilog for the next-state signals Y2 and Y4 corresponding to signal y[2] and y[4]. Derive the logic equations by inspection assuming a one-hot encoding. ", "prompt": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "completion": "\nalways @(*) begin\n    case (y)\n        6'b000001: begin // State A\n            Y2 = 0; // Next state outputs based on input w\n            Y4 = 0;\n        end\n        6'b000010: begin // State B\n            Y2 = w; // Y2 is set when w is 1 to transition to state D\n            Y4 = w; // Y4 is set when w is 1 to transition to state D\n        end\n        6'b000100: begin // State C\n            Y2 = w; // Y2 is set when w is 1 to transition to state D\n            Y4 = 0; // Y4 stays 0\n        end\n        6'b001000: begin // State D\n            Y2 = 0; // Next state outputs based on input w\n            Y4 = 1; // Y4 is set for state D\n        end\n        6'b010000: begin // State E\n            Y2 = 0; // Next state outputs based on input w\n            Y4 = 0; // Y4 stays 0\n        end\n        6'b100000: begin // State F\n            Y2 = 0; // Next state outputs based on input w\n            Y4 = 0; // Y4 stays 0\n        end\n        default: begin\n            Y2 = 0;\n            Y4 = 0;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "mux256to1", "description": "Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], sel=2 selects bits in[2], etc.", "prompt": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "completion": "\nassign out = in[sel];\nendmodule\n"}
{"task_id": "2014_q4a", "description": "Consider an n-bit shift register circuit. Inputs E are for enabling shift, R for value to load, L is asserted when it should load, and w is the input to the first stage of the shift register. Write a Verilog module named top_module for one stage of this circuit, including both the flip-flop and multiplexers.", "prompt": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R;\n    end else if (E) begin\n        Q <= w;\n    end\nend\nendmodule\n"}
{"task_id": "ece241_2014_q4", "description": "Given the finite state machine circuit described below, assume that the D flip-flops are initially reset to zero before the machine begins.\n\n// Build this circuit in Verilog.\n\n// Input x goes to three different two-input gates: a XOR, an AND, and a OR gate. Each of the three gates is connected to the input of a D flip-flop and then the flip-flop outputs all go to a three-input XNOR, whose output is Z. The second input of the XOR is its corresponding flip-flop's output, the second input of the AND is its corresponding flip-flop's complemented output, and finally the second input of the OR is its corresponding flip-flop's complementary output.", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "completion": "\nreg dff1, dff2, dff3;\nwire xor_out, and_out, or_out;\nwire dff1_inv, dff2_inv, dff3_inv;\n\nassign dff1_inv = ~dff1;\nassign dff2_inv = ~dff2;\nassign dff3_inv = ~dff3;\n\nassign xor_out = x ^ dff1;\nassign and_out = x & dff2_inv;\nassign or_out = x | dff3_inv;\n\nalways @(posedge clk) begin\n\tdff1 <= xor_out;\n\tdff2 <= and_out;\n\tdff3 <= or_out;\nend\n\nassign z = dff1 ~^ dff2 ~^ dff3;\n\nendmodule\n"}
{"task_id": "circuit4", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               1               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               1               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               0               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (a & ~b & c) | (a & ~b & d) | (a & b & c) | (b & ~c & d) | (b & c) | (a & b & ~d);\nendmodule\n"}
{"task_id": "rule110", "description": "Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete). There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 1\n// 1 | 0 | 0 | 0\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 1\n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0 \n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The synchronous active high load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        reg [511:0] next_state;\n        integer i;\n        for (i = 0; i < 512; i = i + 1) begin\n            case ({(i == 0) ? 0 : q[i-1], q[i], (i == 511) ? 0 : q[i+1]})\n                3'b111: next_state[i] = 0;\n                3'b110: next_state[i] = 1;\n                3'b101: next_state[i] = 1;\n                3'b100: next_state[i] = 0;\n                3'b011: next_state[i] = 1;\n                3'b010: next_state[i] = 1;\n                3'b001: next_state[i] = 1;\n                3'b000: next_state[i] = 0;\n                default: next_state[i] = 0; // Default case\n            endcase\n        end\n        q <= next_state;\n    end\nend\nendmodule\n"}
{"task_id": "fsm3s", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include a synchronous active high reset that resets the FSM to state A. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = C;\n            end\n            C: begin\n                if (in)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (in)\n                    next_state = B;\n                else\n                    next_state = C;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    assign out = (state == D) ? 1 : 0;\n\nendmodule\n"}
{"task_id": "circuit5", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               e               q               \n// 0ns             x               x               x               x               x               x               \n// 5ns             x               x               x               x               x               x               \n// 10ns            x               x               x               x               x               x               \n// 15ns            a               b               0               d               e               b               \n// 20ns            a               b               1               d               e               e               \n// 25ns            a               b               2               d               e               a               \n// 30ns            a               b               3               d               e               d               \n// 35ns            a               b               4               d               e               f               \n// 40ns            a               b               5               d               e               f               \n// 45ns            a               b               6               d               e               f               \n// 50ns            a               b               7               d               e               f               \n// 55ns            a               b               8               d               e               f               \n// 60ns            a               b               9               d               e               f               \n// 65ns            a               b               a               d               e               f               \n// 70ns            a               b               b               d               e               f               \n// 75ns            a               b               c               d               e               f               \n// 80ns            a               b               d               d               e               f               \n// 85ns            a               b               e               d               e               f               \n// 90ns            a               b               f               d               e               f               ", "prompt": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (c)\n        4'b0000: q = b;\n        4'b0001: q = e;\n        4'b0010: q = a;\n        4'b0011: q = d;\n        4'b0100: q = 4'b0100;\n        4'b0101: q = 4'b0101;\n        4'b0110: q = 4'b0110;\n        4'b0111: q = 4'b0111;\n        4'b1000: q = 4'b1000;\n        4'b1001: q = 4'b1001;\n        4'b1010: q = a;\n        4'b1011: q = b;\n        4'b1100: q = c;\n        4'b1101: q = d;\n        4'b1110: q = e;\n        4'b1111: q = f;\n        default: q = 4'bxxxx; // Undefined state\n    endcase\nend\n\nendmodule\n"}
{"task_id": "bugs_mux2", "description": "Find the bug and fix this 8-bit wide 2-to-1 mux.\n\n// module top_module (\n//     input sel,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output out  );\n\n//     assign out = (~sel & a) | (sel & b);\n\n// endmodule", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @(*) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule\n"}
{"task_id": "mt2015_muxdff", "description": "Consider this Verilog module \"full_module\":\n\n// module full_module (\n//     input [2:0] r,\n//     input L,\n//     input clk,\n//     output reg [2:0] q\n);\n\n// always @(posedge clk) begin\n//     if (L) begin\n//         q <= r;\n//     end else begin\n//         q <= {q[1] ^ q[2], q[0], q[2]};\n//     end\n// end\n\n// endmodule\n\n// You want to create a hierarchical Verilog design where a flipflop and 2-1 multiplexer are in a submodule, and that submodule is instantiated three times in this code. Create the submodule called \"top_module\".\n", "prompt": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "completion": ""}
{"task_id": "edgecapture", "description": "For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. \"Capture\" means that the output will remain 1 until the register is reset (active high synchronous reset).", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n    end else begin\n        out <= (in == 32'b0) ? out : (out | (~in & (in >> 1)));\n    end\nend\nendmodule\n"}
{"task_id": "dff8", "description": "Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2014_q1c", "description": "Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "completion": "\n    wire signed [8:0] sum;\n    assign sum = $signed(a) + $signed(b);\n    assign s = sum[7:0];\n    assign overflow = (sum[8] ^ sum[7]); // Overflow occurs if the sign bit of the result differs from the sign bits of the operands\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "description": "Given the following Moore state machine with 3 input (d, done_counting, ack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in the diagram below, assume outputs are 0 and inputs are don't cares.\n\n// S () --d=0--> S\n// S () --d=1--> S1\n// S1 () --d=0--> S\n// S1 () --d=1--> S11\n// S11 () --d=0--> S110\n// S11 () --d=1--> S11\n// S110 () --d=0--> S\n// S110 () --d=1--> B0\n// B0 (shift_ena=1) -- (always go to next cycle) --> B1\n// B1 (shift_ena=1) -- (always go to next cycle) --> B2\n// B2 (shift_ena=1) -- (always go to next cycle) --> B3\n// B3 (shift_ena=1) -- (always go to next cycle) --> Count\n// Count (counting=1) --!(done_counting)--> Count\n// Count (counting=1) --(done_counting)--> Wait\n// Wait (done=1) --ack=0--> Wait\n// Wait (done=1) --ack=1--> S\n\n// At reset, the state machine starts in state \"S\". Derive next-state logic equations and output logic equations by inspection assuming the following one-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait) = (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\n// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine.\n\n// Write code that generates the following equations:\n\n// - B3_next -- next-state logic for state B3\n// - S_next\n// - S1_next\n// - Count_next\n// - Wait_next\n// - done -- output logic\n// - counting\n// - shift_ena\n", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "completion": "\n    assign B3_next = state[8]; // B3 -> Count transition on always\n    assign S_next = (!d & state[0]) | (d & state[1]) | (ack & state[9]); // S transitions\n    assign S1_next = (d & state[0]) | (!d & state[2]); // S1 transitions\n    assign Count_next = state[8] & !done_counting; // Count transitions\n    assign Wait_next = state[8] & done_counting; // Wait transitions\n    assign done = state[9]; // done output when in Wait state\n    assign counting = state[8]; // counting output when in Count state\n    assign shift_ena = state[4] | state[5] | state[6] | state[7]; // shift_ena output for states B0, B1, B2, B3\n\nendmodule\n"}
{"task_id": "counter_2bc", "description": "Build a two-bit saturating counter. The counter increments (up to a maximum of 3) when train_valid = 1 and train_taken = 1. It decrements (down to a minimum of 0) when train_valid = 1 and train_taken = 0. When not training (train_valid = 0), the counter keeps its value unchanged. areset is a positive edge triggered asynchronous reset that resets the counter to weakly not-taken (2'b01). Output state[1:0] is the two-bit counter value.", "prompt": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "completion": "\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset to weakly not-taken\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) \n                    state <= state + 2'b01; // Increment, max 3\n            end else begin\n                if (state > 2'b00) \n                    state <= state - 2'b01; // Decrement, min 0\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "always_casez", "description": "Build a priority encoder for 8-bit inputs. Given an 8-bit vector, the output should report the first (least significant) bit in the vector that is 1. Report zero if the input vector has no bits that are high. For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "completion": "\nalways @* begin\n    pos = 3'b000; // Default output is zero\n    casez (in)\n        8'b1???????: pos = 3'd0; // Bit 0 is high\n        8'b01??????: pos = 3'd1; // Bit 1 is high\n        8'b001?????: pos = 3'd2; // Bit 2 is high\n        8'b0001????: pos = 3'd3; // Bit 3 is high\n        8'b00001???: pos = 3'd4; // Bit 4 is high\n        8'b000001??: pos = 3'd5; // Bit 5 is high\n        8'b0000001?: pos = 3'd6; // Bit 6 is high\n        8'b00000001: pos = 3'd7; // Bit 7 is high\n        default: pos = 3'b000;    // No high bits\n    endcase\nend\nendmodule\n"}
{"task_id": "always_nolatches", "description": "Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. Given the last two bytes of scancodes received, you need to indicate whether one of the arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, which can be implemented as a case statement (or if-elseif) with four cases.\n// Scancode[15:0] | Arrow key\n// 16'he06b | left arrow\n// 16'he072 | down arrow\n// 16'he074 | right arrow\n// 16'he075 | up arrow\n// Anything else | none\n// Your circuit has one 16-bit input, and four outputs. Build this circuit that recognizes these four scancodes and asserts the correct output.\n\n", "prompt": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "completion": "\nalways @* begin\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'hE06B: left = 1;\n        16'hE072: down = 1;\n        16'hE074: right = 1;\n        16'hE075: up = 1;\n        default: ;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "m2014_q4j", "description": "Implement a 4-bit adder with full adders. The output sum should include the overflow bit.", "prompt": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "completion": "\nwire [3:0] carry;\n\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(sum[4]) // overflow bit\n);\n\nendmodule\n"}
{"task_id": "history_shift", "description": "Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.\n\n", "prompt": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "completion": "\n    logic [31:0] history_reg;\n    \n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            history_reg <= 32'b0;\n        end else if (train_mispredicted) begin\n            history_reg <= {train_taken, train_history[31:1]};\n        end else if (predict_valid) begin\n            history_reg <= {predict_taken, history_reg[31:1]};\n        end\n    end\n    \n    assign predict_history = history_reg;\n\nendmodule\n"}
{"task_id": "wire_decl", "description": "Implement the following circuit. Create two intermediate wires (named anything you want) to connect the AND and OR gates together. Note that the wire that feeds the NOT gate is really wire `out`, so you do not necessarily need to declare a third wire here. Notice how wires are driven by exactly one source (output of a gate), but can feed multiple inputs.\n\n// The circuit is composed of two layers. The first layer, counting from the input, is two AND gates: one whose input is connected to a and b, and the second is connected to c and d. The second layer there is an OR gate to OR the two AND outputs, connected the output 'out'. Additionally, there is an inverted output 'out_n'.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "completion": "\nwire and1_out;\nwire and2_out;\n\nand u1(and1_out, a, b);\nand u2(and2_out, c, d);\nor  u3(out, and1_out, and2_out);\nnot u4(out_n, out);\n\nendmodule\n"}
{"task_id": "dff", "description": "Create a single D flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "ece241_2013_q12", "description": "In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is \"random access\", as in a typical RAM. You will then use the circuit to realize a 3-input logic function. First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input is synchronous active high and controls whether to shift. Extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. ", "prompt": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "completion": "\nreg [7:0] Q;\nwire [2:0] addr;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {S, Q[7:1]};\n    end\nend\n\nassign addr = {A, B, C};\nalways @(*) begin\n    case (addr)\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n        default: Z = 1'b0;\n    endcase\nend\nendmodule\n"}
{"task_id": "thermostat", "description": "A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate. The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. When the heater or air conditioner are on, also turn on the fan to circulate the air. In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.", "prompt": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "completion": "\nassign heater = mode & too_cold; // Heater on in heating mode if too cold\nassign aircon = ~mode & too_hot;  // Air conditioner on in cooling mode if too hot\nassign fan = heater | aircon | fan_on; // Fan on if heater or aircon are on or if fan is manually requested\n\nendmodule\n"}
{"task_id": "ece241_2013_q2", "description": "A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively. Determine the output out_sop in minimum sum-of-products form, and the output out_pos in minimum product-of-sums form.\n\n", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "completion": "\nassign out_sop = (a & ~b & ~c & d) | (~a & b & c & d) | (a & b & c & d);\n\nassign out_pos = (~a | b | c | ~d) & (a | ~b | ~c | ~d) & (a | b | ~c | ~d) & (a | b | c | d);\nendmodule\n"}
{"task_id": "lfsr32", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce each bit's next value, while bit positions without a tap shift. Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high synchronous, and should reset the output q to 32'h1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        // Galois LFSR with taps at 32, 22, 2, and 1\n        q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])};\n    end\nend\nendmodule\n"}
{"task_id": "circuit3", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               0               \n// 5ns             0               0               0               0               0               \n// 10ns            0               0               0               0               0               \n// 15ns            0               0               0               0               0               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               0               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               1               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               1               \n// 75ns            1               1               0               0               0               \n// 80ns            1               1               0               1               1               \n// 85ns            1               1               1               0               1               \n// 90ns            1               1               1               1               1               ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (~a & ~b & d) | (~a & b & c) | (a & b & d) | (a & ~b & ~c);\nendmodule\n"}
{"task_id": "7420", "description": "The 7400-series integrated circuits are a series of digital chips with a few gates each. The 7420 is a chip with two 4-input NAND gates.\n\n// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nassign p1y = ~(p1a & p1b & p1c & p1d);\nassign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n"}
{"task_id": "popcount255", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.", "prompt": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "completion": "\nalways @* begin\n    out = 0; // Initialize output to zero\n    for (integer i = 0; i < 255; i = i + 1) begin\n        out = out + in[i]; // Sum the number of '1's in the input vector\n    end\nend\n\nendmodule\n"}
{"task_id": "gatesv", "description": "You are given a four-bit input vector in[3:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left (higher index) are '1'. For example, out_both[2] should indicate if in[2] and in[3] are both 1. Since in[3] has no neighbour to the left, the answer is obvious so we don't need to know out_both[3]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[2] should indicate if in[2] is different from in[3]. For this part, treat the vector as wrapping around, so in[3]'s neighbour to the left is in[0].", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "completion": "\n\tassign out_both[2] = in[2] & in[3];\n\tassign out_both[1] = in[1] & in[2];\n\tassign out_both[0] = in[0] & in[1];\n\n\tassign out_any[3] = in[3] | in[2];\n\tassign out_any[2] = in[2] | in[1];\n\tassign out_any[1] = in[1] | in[0];\n\n\tassign out_different[3] = in[3] ^ in[0];\n\tassign out_different[2] = in[2] ^ in[3];\n\tassign out_different[1] = in[1] ^ in[2];\n\tassign out_different[0] = in[0] ^ in[1];\nendmodule\n"}
{"task_id": "circuit6", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a                  q            \n// 0ns             x                  x            \n// 5ns             x                  x            \n// 10ns            x                  x            \n// 15ns            0               1232            \n// 20ns            1               aee0            \n// 25ns            2               27d4            \n// 30ns            3               5a0e            \n// 35ns            4               2066            \n// 40ns            5               64ce            \n// 45ns            6               c526            \n// 50ns            7               2f19            \n// 55ns            0               1232            \n// 60ns            1               aee0            \n// 65ns            2               27d4            \n// 70ns            4               2066            \n// 75ns            1               aee0            \n// 80ns            1               aee0            \n// 85ns            3               5a0e            \n// 90ns            5               64ce            ", "prompt": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "completion": "\nalways @(*) begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'hxxxx; // Undefined state\n    endcase\nend\n\nendmodule\n"}
{"task_id": "countslow", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the \"slowena\" input if high indicates when the counter should increment. ", "prompt": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000; // Reset the counter to 0\n    end else if (slowena) begin\n        if (q == 4'b1001) // If counter reaches 9\n            q <= 4'b0000; // Reset to 0\n        else\n            q <= q + 1; // Increment the counter\n    end\nend\nendmodule\n"}
{"task_id": "m2014_q4f", "description": "Implement the following circuit in Verilog. Two inputs (in1 and in2) go to an AND gate, but the in2 input to the AND gate has a bubble. The output of the AND gate is connected to 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nassign out = in1 & ~in2;\nendmodule\n"}
{"task_id": "m2014_q4h", "description": "The module assigns the output port to the same value as the input port combinationally.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": "\nassign out = in;\nendmodule\n"}
{"task_id": "fsm1", "description": "Consider the follow Moore machine with the diagram described below:\n\n// B (1) --0--> A\n// B (1) --1--> B\n// A (0) --0--> B\n// A (0) --1--> A\n\n// Write Verilog implementing this state machine. It should asynchronously reset into state B if reset if high.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "completion": "\ntypedef enum logic [1:0] {\n    A = 2'b00,\n    B = 2'b01\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset) begin\n        current_state <= B;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\nalways_comb begin\n    case (current_state)\n        A: begin\n            out = 1'b0;\n            if (in == 0) \n                next_state = B;\n            else \n                next_state = A;\n        end\n        B: begin\n            out = 1'b1;\n            if (in == 0)\n                next_state = A;\n            else \n                next_state = B;\n        end\n        default: begin\n            out = 1'b0;\n            next_state = B;\n        end\n    endcase\nend\n\nendmodule\n"}
{"task_id": "dualedge", "description": "A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list. Build a circuit that functionally behaves like a dual-edge triggered flip-flop.", "prompt": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "completion": "\nalways @(posedge clk) begin\n    q <= d;\nend\n\nalways @(negedge clk) begin\n    q <= d;\nend\nendmodule\n"}
{"task_id": "xnorgate", "description": "Create a module that implements an XNOR gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\n\tassign out = ~(a ^ b);\nendmodule\n"}
{"task_id": "mt2015_q4", "description": "Module A implements the boolean function z = (x^y) & x.\n\n// Module B can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               \n\n\n// Now consider a top-level that uses two A submodules and two B submodules. The first input of all four submodules is connect to input 'x', and the second input of all four submodules is connected to 'y'. The output of the first A submodule is connected to a two-input OR, along with the output of the first B submodule. The second pair of A and B submodules is similarly connected to an AND gate. The output of the OR and the AND is connected to an XOR, whose output is 'z'.\n\n// Implement this circuit in Verilog.", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nwire a1_out, a2_out, b1_out, b2_out;\nwire or_out, and_out;\n\nmodule A (\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B (\n    input x,\n    input y,\n    output z\n);\n    assign z = ~(x & y);\nendmodule\n\nA a1 (.x(x), .y(y), .z(a1_out));\nB b1 (.x(x), .y(y), .z(b1_out));\nA a2 (.x(x), .y(y), .z(a2_out));\nB b2 (.x(x), .y(y), .z(b2_out));\n\nassign or_out = a1_out | b1_out;\nassign and_out = a2_out & b2_out;\n\nassign z = or_out ^ and_out;\n\nendmodule\n"}
{"task_id": "rotate100", "description": "Build a 100-bit left/right rotator, with synchronous load and left/right enable. A rotator shifts-in the shifted-out bit from the other end of the register, unlike a shifter that discards the shifted-out bit and shifts in a zero. If enabled, a rotator rotates the bits around and does not modify/discard them. \n// (1) load: Loads shift register with data[99:0] instead of rotating. Synchronous active high.\n// (2) ena[1:0]: Synchronous. Chooses whether and which direction to rotate: \n//     (a) 2'b01 rotates right by one bit, \n//     (b) 2'b10 rotates left by one bit, \n//     (c) 2'b00 and 2'b11 do not rotate. \n// (3) q: The contents of the rotator.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: q <= {q[0], q[99:1]}; // Rotate right\n            2'b10: q <= {q[98:0], q[99]}; // Rotate left\n            2'b00: q <= q; // No rotation\n            2'b11: q <= q; // No rotation (alternative)\n        endcase\n    end\nend\nendmodule\n"}
{"task_id": "review2015_count1k", "description": "Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 10'b0;\n    end else if (q < 10'd999) begin\n        q <= q + 1;\n    end else begin\n        q <= 10'b0;\n    end\nend\nendmodule\n"}
{"task_id": "notgate", "description": "Create a module that implements a NOT gate.", "prompt": "module top_module(\n\tinput in,\n\toutput out\n);\n", "completion": "\nassign out = ~in;\nendmodule\n"}
{"task_id": "fsm_onehot", "description": "Given the follow state machine with 1 input and 2 outputs (the outputs are given as \"(out1, out2)\"):\n\n// S0 (0, 0) --0--> S0\n// S0 (0, 0) --1--> S1\n// S1 (0, 0) --0--> S0\n// S1 (0, 0) --1--> S2\n// S2 (0, 0) --0--> S0\n// S2 (0, 0) --1--> S3\n// S3 (0, 0) --0--> S0\n// S3 (0, 0) --1--> S4\n// S4 (0, 0) --0--> S0\n// S4 (0, 0) --1--> S5\n// S5 (0, 0) --0--> S8\n// S5 (0, 0) --1--> S6\n// S6 (0, 0) --0--> S9\n// S6 (0, 0) --1--> S7\n// S7 (0, 1) --0--> S0\n// S7 (0, 1) --1--> S7\n// S8 (1, 0) --0--> S0\n// S8 (1, 0) --1--> S1\n// S9 (1, 1) --0--> S0\n// S9 (1, 1) --1--> S1\n\n// Suppose this state machine uses one-hot encoding, where state[0] through state[9] correspond to the states S0 though S9, respectively. The outputs are zero unless otherwise specified.\n\n// Write Verilog implementing the state transition logic and output logic portions of the state machine (but not the state flip-flops). You are given the current state in state[9:0] and must produce next_state[9:0] and the two outputs. Derive the logic equations by inspection assuming a one-hot encoding.", "prompt": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "completion": "\n    assign next_state = (state[0] & ~in) ? 10'b0000000001 :\n                        (state[0] & in) ? 10'b0000000010 :\n                        (state[1] & ~in) ? 10'b0000000001 :\n                        (state[1] & in) ? 10'b0000000010 :\n                        (state[2] & ~in) ? 10'b0000000001 :\n                        (state[2] & in) ? 10'b0000000100 :\n                        (state[3] & ~in) ? 10'b0000000001 :\n                        (state[3] & in) ? 10'b0000001000 :\n                        (state[4] & ~in) ? 10'b0000000001 :\n                        (state[4] & in) ? 10'b0000010000 :\n                        (state[5] & ~in) ? 10'b0000100000 :\n                        (state[5] & in) ? 10'b0001000000 :\n                        (state[6] & ~in) ? 10'b0010000000 :\n                        (state[6] & in) ? 10'b0001000000 :\n                        (state[7] & ~in) ? 10'b0000000000 :\n                        (state[7] & in) ? 10'b0000000001 :\n                        (state[8] & ~in) ? 10'b0000000001 :\n                        (state[8] & in) ? 10'b0000000010 :\n                        (state[9] & ~in) ? 10'b0000000001 :\n                        (state[9] & in) ? 10'b0000000010 : 10'b0000000000;\n\n    assign out1 = state[7] | state[8] | state[9];\n    assign out2 = state[7] ? 1 : 0;\n\nendmodule\n"}
{"task_id": "ece241_2013_q7", "description": "A JK flip-flop has the below truth table. Note: Qold is the output of the flip-flop before the positive clock edge.\n// J | K | Q\n// 0 | 0 | Qold\n// 0 | 1 | 0\n// 1 | 0 | 1\n// 1 | 1 | ~Qold", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "completion": "\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;       // No change\n        2'b01: Q <= 0;       // Reset\n        2'b10: Q <= 1;       // Set\n        2'b11: Q <= ~Q;      // Toggle\n    endcase\nend\n\nendmodule\n"}
{"task_id": "popcount3", "description": "A \"population count\" circuit counts the number of '1's in an input vector. Build a population count circuit for a 3-bit input vector.", "prompt": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "completion": "\n\tassign out = in[0] + in[1] + in[2];\nendmodule\n"}
{"task_id": "vector5", "description": "Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons in the 25-bit output vector. The output should be 1 if the two bits being compared are equal. Example: out[24] = ~a ^ a; out[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^ e.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "completion": "\n\tassign out[24] = ~(a ^ a);\n\tassign out[23] = ~(a ^ b);\n\tassign out[22] = ~(a ^ c);\n\tassign out[21] = ~(a ^ d);\n\tassign out[20] = ~(a ^ e);\n\tassign out[19] = ~(b ^ a);\n\tassign out[18] = ~(b ^ b);\n\tassign out[17] = ~(b ^ c);\n\tassign out[16] = ~(b ^ d);\n\tassign out[15] = ~(b ^ e);\n\tassign out[14] = ~(c ^ a);\n\tassign out[13] = ~(c ^ b);\n\tassign out[12] = ~(c ^ c);\n\tassign out[11] = ~(c ^ d);\n\tassign out[10] = ~(c ^ e);\n\tassign out[9]  = ~(d ^ a);\n\tassign out[8]  = ~(d ^ b);\n\tassign out[7]  = ~(d ^ c);\n\tassign out[6]  = ~(d ^ d);\n\tassign out[5]  = ~(d ^ e);\n\tassign out[4]  = ~(e ^ a);\n\tassign out[3]  = ~(e ^ b);\n\tassign out[2]  = ~(e ^ c);\n\tassign out[1]  = ~(e ^ d);\n\tassign out[0]  = ~(e ^ e);\nendmodule\n"}
{"task_id": "lemmings1", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. Implement a Moore state machine with two states, two inputs, and one output (internal to the module) that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "completion": "\n    reg state; // 0 for walk_left, 1 for walk_right\n    assign walk_left = ~state;\n    assign walk_right = state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // Reset to walking left\n        end else begin\n            if (bump_left) begin\n                state <= 1; // Bumped on the left, walk right\n            end else if (bump_right) begin\n                state <= 0; // Bumped on the right, walk left\n            end\n        end\n    end\n\nendmodule\n"}
{"task_id": "circuit1", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               q               \n// 0ns             0               0               0               \n// 5ns             0               0               0               \n// 10ns            0               0               0               \n// 15ns            0               0               0               \n// 20ns            0               0               0               \n// 25ns            0               1               0               \n// 30ns            0               1               0               \n// 35ns            1               0               0               \n// 40ns            1               0               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               0               \n// 60ns            0               0               0               \n// 65ns            0               1               0               \n// 70ns            0               1               0               \n// 75ns            1               0               0               \n// 80ns            1               0               0               \n// 85ns            1               1               1               \n// 90ns            1               1               1               \n", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "completion": " q = a & b;\nendmodule\n"}
{"task_id": "7458", "description": "The 7458 is a chip with four AND gates and two OR gates. Create a module in Verilog with the same functionality as the 7458 chip. It has 10 inputs and 2 outputs. You may choose to use an `assign` statement to drive each of the output wires, or you may choose to declare (four) wires for use as intermediate signals, where each internal wire is driven by the output of one of the AND gates.\n\n// In this circuit, p1y should be the OR of two 3-input AND gates: one that ANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The output p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b, and the second that ANDs p2c and p2d.", "prompt": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "completion": "\nwire and1_out, and2_out, and3_out, and4_out;\n\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\nassign p1y = and1_out | and2_out;\n\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\nassign p2y = and3_out | and4_out;\n\nendmodule\n"}
{"task_id": "2014_q3c", "description": "Given the state-assigned table shown below, implement the logic functions Y[0] and z.\n// Present state y[2:0] | Next state Y[2:0] x=0, Next state Y[2:0] x=1 | Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "completion": "\nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            if (x)\n                y <= 3'b001;\n            else\n                y <= 3'b000;\n            z <= 0;\n        end\n        3'b001: begin\n            if (x)\n                y <= 3'b100;\n            else\n                y <= 3'b001;\n            z <= 0;\n        end\n        3'b010: begin\n            if (x)\n                y <= 3'b001;\n            else\n                y <= 3'b010;\n            z <= 0;\n        end\n        3'b011: begin\n            if (x)\n                y <= 3'b010;\n            else\n                y <= 3'b001;\n            z <= 1;\n        end\n        3'b100: begin\n            if (x)\n                y <= 3'b100;\n            else\n                y <= 3'b011;\n            z <= 1;\n        end\n    endcase\nend\n\nalways @(*) begin\n    Y0 = y[0];\nend\n\nendmodule\n"}
{"task_id": "m2014_q4e", "description": "Implement a 2-input NOR gate.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "completion": "\nalways @(*) begin\n    out = ~(in1 | in2);\nend\nendmodule\n"}
{"task_id": "wire4", "description": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections: a -> w\n// ; b -> x; b -> y; c -> z.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "completion": " w = a;\nassign x = b;\nassign y = b;\nassign z = c;\nendmodule\n"}
{"task_id": "m2014_q4b", "description": "Implement a D flip flop, positive edge triggered, with an asynchronous reset \"ar\".", "prompt": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "completion": "\nalways_ff @(posedge clk or posedge ar) begin\n    if (ar) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "always_case", "description": "Create a 6-to-1 multiplexer. When sel is between 0 and 5, choose the corresponding data input. Otherwise, output 0. The data inputs and outputs are all 4 bits wide.", "prompt": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "completion": "\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n"}
{"task_id": "timer", "description": "Implement a timer that counts down for a given number of clock cycles, then asserts a signal to indicate that the given duration has elapsed. A good way to implement this is with a down-counter that asserts an output signal when the count becomes 0. At each clock cycle: \n// (1) If load = 1, load the internal counter with the 10-bit data, the number of clock cycles the timer should count before timing out. The counter can be loaded at any time, including when it is still counting and has not yet reached 0. \n// (2) If load = 0, the internal counter should decrement by 1. The output signal tc (\"terminal count\") indicates whether the internal counter has reached 0. Once the internal counter has reached 0, it should stay 0 (stop counting) until the counter is loaded again.\n\n", "prompt": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "completion": "\nreg [9:0] counter;\nassign tc = (counter == 0);\n\nalways @(posedge clk) begin\n    if (load) begin\n        counter <= data;\n    end else if (counter > 0) begin\n        counter <= counter - 1;\n    end\nend\n\nendmodule\n"}
{"task_id": "review2015_fsmseq", "description": "Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Reset is active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "completion": "\n  reg [2:0] state, next_state;\n  reg start_shifting_reg;\n\n  localparam S0 = 3'd0,\n             S1 = 3'd1,\n             S2 = 3'd2,\n             S3 = 3'd3,\n             S4 = 3'd4;\n\n  assign start_shifting = start_shifting_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      start_shifting_reg <= 0;\n    end else begin\n      state <= next_state;\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      S0: begin\n        if (data) next_state = S1; else next_state = S0;\n      end\n      S1: begin\n        if (data) next_state = S2; else next_state = S0;\n      end\n      S2: begin\n        if (data) next_state = S3; else next_state = S0;\n      end\n      S3: begin\n        if (!data) begin\n          next_state = S4;\n          start_shifting_reg = 1;\n        end else begin\n          next_state = S1;\n        end\n      end\n      S4: begin\n        next_state = S4; // Stay in this state\n      end\n    endcase\n  end\nendmodule\n"}
{"task_id": "dff8r", "description": "Create 8 D flip-flops with active high synchronous reset setting the output to zero. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 8'b00000000;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect2", "description": "For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "completion": "\nreg [7:0] in_d;\n\nalways @(posedge clk) begin\n\tin_d <= in;\n\tanyedge <= (in & ~in_d);\nend\n\nendmodule\n"}
{"task_id": "count1to10", "description": "Make a decade counter that counts 1 through 10, inclusive. The reset input is active high synchronous, and should reset the counter to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset the counter to 1\n    end else if (q == 4'b1010) begin\n        q <= 4'b0001; // Reset to 1 after reaching 10\n    end else begin\n        q <= q + 1; // Increment the counter\n    end\nend\nendmodule\n"}
{"task_id": "circuit9", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               q               \n// 0ns             0               1               x               \n// 5ns             1               1               4               \n// 10ns            0               1               4               \n// 15ns            1               1               4               \n// 20ns            0               1               4               \n// 25ns            1               1               4               \n// 30ns            0               1               4               \n// 35ns            1               1               4               \n// 40ns            0               1               4               \n// 45ns            1               0               4               \n// 50ns            0               0               4               \n// 55ns            1               0               5               \n// 60ns            0               0               5               \n// 65ns            1               0               6               \n// 70ns            0               0               6               \n// 75ns            1               0               0               \n// 80ns            0               0               0               \n// 85ns            1               0               1               \n// 90ns            0               0               1               ", "prompt": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "completion": "\nalways @(posedge clk) begin\n    if (a) begin\n        q <= q + 1'b1;\n    end\nend\n\nalways @(negedge clk) begin\n    if (!a) begin\n        q <= 0;\n    end\nend\nendmodule\n"}
{"task_id": "lfsr5", "description": "A linear feedback shift register is a shift register usually with a few XOR gates to produce the next state of the shift register. A Galois LFSR is one particular arrangement where bit positions with a \"tap\" are XORed with the output bit to produce its next value, while bit positions without a tap shift. If the taps positions are carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length LFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is never reached). Build a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3. The active-high synchronous reset should reset the LFSR output to 1.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "completion": "\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001; // Reset to 1\n    end else begin\n        q <= {q[3:0], q[4] ^ q[2]}; // Shift and apply XOR taps\n    end\nend\nendmodule\n"}
{"task_id": "bugs_addsubz", "description": "The following adder-subtractor with zero flag doesn't work. Fix the bug(s).\n\n// synthesis verilog_input_version verilog_2001\n// module top_module ( \n//     input do_sub,\n//     input [7:0] a,\n//     input [7:0] b,\n//     output reg [7:0] out,\n//     output reg result_is_zero\n// );//\n\n//     always @(*) begin\n//         case (do_sub)\n//           0: out = a+b;\n//           1: out = a-b;\n//         endcase\n\n//         if (~out)\n//             result_is_zero = 1;\n//     end\n\n// endmodule", "prompt": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "completion": "\n    always @(*) begin\n        case (do_sub)\n            1'b0: out = a + b;\n            1'b1: out = a - b;\n        endcase\n\n        if (out == 8'b00000000)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule\n"}
{"task_id": "m2014_q3", "description": "Consider the function f shown in the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient. Implement this function. \n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | d | 0 | d | d |\n//  01 | 0 | d | 1 | 0 |\n//  11 | 1 | 1 | d | d |\n//  10 | 1 | 1 | 0 | d |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    always_comb begin\n        case ({x[4], x[3], x[2], x[1]})\n            4'b0000: f = 1'b0; // d\n            4'b0001: f = 1'b0; // 0\n            4'b0010: f = 1'bx; // d\n            4'b0011: f = 1'bx; // d\n            4'b0100: f = 1'b0; // 0\n            4'b0101: f = 1'bx; // d\n            4'b0110: f = 1'b1; // 1\n            4'b0111: f = 1'b0; // 0\n            4'b1000: f = 1'b1; // 1\n            4'b1001: f = 1'b1; // 1\n            4'b1010: f = 1'b0; // 0\n            4'b1011: f = 1'bx; // d\n            4'b1100: f = 1'bx; // d\n            4'b1101: f = 1'bx; // d\n            4'b1110: f = 1'bx; // d\n            4'b1111: f = 1'bx; // d\n            default: f = 1'b0;\n        endcase\n    end\nendmodule\n"}
{"task_id": "bugs_case", "description": "This combinational circuit is supposed to recognize 8-bit keyboard scancodes for keys 0 through 9. It should indicate whether one of the 10 cases were recognized (valid), and if so, which key was detected. If the 8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d, 8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9 respectively, the 1-bit valid would be set to 1. If the input does not match any of the cases, both output signals would be set to 0.", "prompt": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "completion": "\nalways @(*) begin\n    case (code)\n        8'h45: begin out = 4'b0000; valid = 1; end // Key 0\n        8'h16: begin out = 4'b0001; valid = 1; end // Key 1\n        8'h1e: begin out = 4'b0010; valid = 1; end // Key 2\n        8'h26: begin out = 4'b0011; valid = 1; end // Key 3\n        8'h25: begin out = 4'b0100; valid = 1; end // Key 4\n        8'h2e: begin out = 4'b0101; valid = 1; end // Key 5\n        8'h36: begin out = 4'b0110; valid = 1; end // Key 6\n        8'h3d: begin out = 4'b0111; valid = 1; end // Key 7\n        8'h3e: begin out = 4'b1000; valid = 1; end // Key 8\n        8'h46: begin out = 4'b1001; valid = 1; end // Key 9\n        default: begin out = 4'b0000; valid = 0; end // No valid key\n    endcase\nend\n\nendmodule\n"}
{"task_id": "vectorr", "description": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "completion": "\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule\n"}
{"task_id": "kmap3", "description": "Implement the circuit described by the Karnaugh map below. d is don't-care, which means you may choose to output whatever value is convenient.\n\n//        ab\n// cd   01 00 10 11\n//  00 | d | 0 | 1 | 1 |\n//  01 | 0 | 0 | d | d |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 0 | 1 | 1 | 1 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "completion": "\nalways @(*) begin\n    if (c == 1'b0) begin\n        if (b == 1'b1) begin\n            out = 1'b1; // from minterms 10 and 11\n        end else begin\n            out = 1'b0; // from minterms 00 and 01\n        end\n    end else begin\n        if (b == 1'b1) begin\n            out = 1'b1; // from minterms 11 and 10\n        end else begin\n            out = 1'b1; // from minterms 01 and 11\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "review2015_shiftcount", "description": "Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).", "prompt": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "completion": "\n\talways @(posedge clk) begin\n\t\tif (shift_ena) begin\n\t\t\tq <= {data, q[3:1]};\n\t\tend else if (count_ena) begin\n\t\t\tq <= q - 1;\n\t\tend\n\tend\nendmodule\n"}
{"task_id": "wire", "description": "Create a module with one input and one output that behaves like a wire.", "prompt": "module top_module(\n\tinput in,\n\toutput out);\n", "completion": " out = in;\nendmodule\n"}
{"task_id": "review2015_fsmshift", "description": "This module is a part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset). Reset should be active high synchronous.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "completion": "\nreg [2:0] count;\nreg shift_ena_reg;\n\nalways @(posedge clk) begin\n\tif (reset) begin\n\t\tcount <= 3'b000;\n\t\tshift_ena_reg <= 1'b1;\n\tend else if (count < 3'b100) begin\n\t\tcount <= count + 1;\n\t\tshift_ena_reg <= 1'b1;\n\tend else begin\n\t\tshift_ena_reg <= 1'b0;\n\tend\nend\n\nassign shift_ena = shift_ena_reg;\n\nendmodule\n"}
{"task_id": "count15", "description": "Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000;\n    end else begin\n        q <= q + 1;\n    end\nend\nendmodule\n"}
{"task_id": "always_if", "description": "Build a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. Do the same twice, once using assign statements and once using a procedural if statement.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "completion": "\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\nalways @(*) begin\n    if (sel_b1 & sel_b2) begin\n        out_always = b;\n    end else begin\n        out_always = a;\n    end\nend\nendmodule\n"}
{"task_id": "kmap1", "description": "Implement the circuit described by the Karnaugh map below.\n//        a\n// bc   0 1 \n//  00 | 0 | 1 |\n//  01 | 1 | 1 | \n//  11 | 1 | 1 | \n//  10 | 1 | 1 | \n", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "completion": " out = (b & c) | (a & b) | (a & c) | (a & b & c);\nendmodule\n"}
{"task_id": "2013_q2afsm", "description": "Consider the FSM described by the state diagram shown below:\n\n// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\n\n// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.\n\n// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "completion": "\ntypedef enum reg [1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\nstate_t current_state, next_state;\n\nalways @(posedge clk or negedge resetn) begin\n    if (!resetn)\n        current_state <= A;\n    else\n        current_state <= next_state;\nend\n\nalways @(*) begin\n    case (current_state)\n        A: begin\n            if (r[1]) next_state = B;\n            else if (r[2]) next_state = C;\n            else if (r[3]) next_state = D;\n            else next_state = A;\n        end\n        B: begin\n            if (r[1]) next_state = B;\n            else next_state = A;\n        end\n        C: begin\n            if (r[2]) next_state = C;\n            else next_state = A;\n        end\n        D: begin\n            next_state = A; // Assuming D transitions back to A\n        end\n        default: next_state = A;\n    endcase\nend\n\nassign g[1] = (current_state == B);\nassign g[2] = (current_state == C);\nassign g[3] = (current_state == D);\n\nendmodule\n"}
{"task_id": "count10", "description": "Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is active high synchronous, and should reset the counter to 0.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else if (q == 4'b1001) \n        q <= 4'b0000;\n    else \n        q <= q + 1;\nend\nendmodule\n"}
{"task_id": "fsm_ps2", "description": "The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n\treg [1:0] state, next_state;\n\tparameter IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n\tassign done = (state == BYTE3);\n\n\talways @(posedge clk) begin\n\t\tif (reset) \n\t\t\tstate <= IDLE;\n\t\telse \n\t\t\tstate <= next_state;\n\tend\n\n\talways @(*) begin\n\t\tcase(state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in[3] == 1'b1)\n\t\t\t\t\tnext_state = BYTE1;\n\t\t\t\telse\n\t\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\t\tBYTE1: begin\n\t\t\t\tnext_state = BYTE2;\n\t\t\tend\n\t\t\tBYTE2: begin\n\t\t\t\tnext_state = BYTE3;\n\t\t\tend\n\t\t\tBYTE3: begin\n\t\t\t\tnext_state = IDLE; // Go back to IDLE after processing the message\n\t\t\tend\n\t\t\tdefault: next_state = IDLE; // Default case\n\t\tendcase\n\tend\nendmodule\n"}
{"task_id": "mux2to1", "description": "Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "completion": "\nassign out = sel ? b : a;\nendmodule\n"}
{"task_id": "gates4", "description": "Build a combinational circuit with four inputs, in[3:0]. There are 3 outputs: \n// (1) out_and: output of a 4-input AND gate. \n// (2) out_or: output of a 4-input OR gate. \n// (3) out_xor: output of a 4-input XOR gate.\n", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": " out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n"}
{"task_id": "2014_q3bfsm", "description": "Given the state-assigned table shown below, implement the finite-state machine. Reset should synchronous active high reset the FSM to state 000.\n\n// Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1, Output z\n// 000 | 000, 001 | 0\n// 001 | 001, 100 | 0\n// 010 | 010, 001 | 0\n// 011 | 001, 010 | 1\n// 100 | 011, 100 | 1\n", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "completion": "\n    reg [2:0] y;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            y <= 3'b000;\n            z <= 0;\n        end else begin\n            case (y)\n                3'b000: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 0;\n                    end else begin\n                        y <= 3'b000;\n                        z <= 0;\n                    end\n                end\n                3'b001: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 0;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 0;\n                    end\n                end\n                3'b010: begin\n                    if (x) begin\n                        y <= 3'b001;\n                        z <= 0;\n                    end else begin\n                        y <= 3'b010;\n                        z <= 0;\n                    end\n                end\n                3'b011: begin\n                    if (x) begin\n                        y <= 3'b010;\n                        z <= 1;\n                    end else begin\n                        y <= 3'b001;\n                        z <= 1;\n                    end\n                end\n                3'b100: begin\n                    if (x) begin\n                        y <= 3'b100;\n                        z <= 1;\n                    end else begin\n                        y <= 3'b011;\n                        z <= 1;\n                    end\n                end\n                default: begin\n                    y <= 3'b000;\n                    z <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n"}
{"task_id": "2013_q2bfsm", "description": "Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input (synchronous, active low) called resetn. The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "completion": "\nreg [1:0] current_state, next_state;\nreg [2:0] x_sequence;\nreg y_timer;\n\nassign f = (current_state == 1) ? 1 : 0;\nassign g = (current_state == 3) ? 1 : 0;\n\nlocalparam STATE_A = 0;\nlocalparam STATE_B = 1;\nlocalparam STATE_C = 2;\nlocalparam STATE_D = 3;\n\nalways @(posedge clk or negedge resetn) begin\n\tif (!resetn) begin\n\t\tcurrent_state <= STATE_A;\n\t\tx_sequence <= 3'b000;\n\t\ty_timer <= 0;\n\tend else begin\n\t\tcurrent_state <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tcase (current_state)\n\t\tSTATE_A: begin\n\t\t\tnext_state = STATE_B;\n\t\t\tx_sequence = 3'b000;\n\t\t\ty_timer = 0;\n\t\tend\n\t\tSTATE_B: begin\n\t\t\tnext_state = (x_sequence == 3'b101) ? STATE_D : STATE_C;\n\t\t\tx_sequence = {x_sequence[1:0], x};\n\t\t\ty_timer = 0;\n\t\tend\n\t\tSTATE_C: begin\n\t\t\tnext_state = (x_sequence == 3'b010) ? STATE_D : STATE_B;\n\t\t\tx_sequence = {x_sequence[1:0], x};\n\t\t\ty_timer = (y_timer < 2) ? y_timer + 1 : y_timer;\n\t\tend\n\t\tSTATE_D: begin\n\t\t\tnext_state = (y == 1) ? STATE_D : \n\t\t\t\t\t     (y_timer < 2) ? STATE_C : \n\t\t\t\t\t     STATE_B;\n\t\t\tx_sequence = {x_sequence[1:0], x};\n\t\t\ty_timer = (y_timer < 2) ? y_timer + 1 : y_timer;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state = STATE_A;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}
{"task_id": "dff8p", "description": "Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(negedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "reduction", "description": "Parity checking is often used as a simple method of detecting errors when transmitting data through an imperfect channel. Create a circuit that will compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). We will use \"even\" parity, where the parity bit is just the XOR of all 8 data bits.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "completion": "\nassign parity = ^in;\nendmodule\n"}
{"task_id": "fsm3comb", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.\n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "completion": "\nalways @(*) begin\n    case (state)\n        2'b00: next_state = (in == 0) ? 2'b00 : 2'b01; // A\n        2'b01: next_state = (in == 0) ? 2'b10 : 2'b01; // B\n        2'b10: next_state = (in == 0) ? 2'b00 : 2'b11; // C\n        2'b11: next_state = (in == 0) ? 2'b10 : 2'b01; // D\n        default: next_state = 2'b00; // Default state\n    endcase\nend\n\nassign out = (state == 2'b11) ? 1'b1 : 1'b0; // Output is 1 only when in state D\n\nendmodule\n"}
{"task_id": "mt2015_q4b", "description": "The module can be described by the following simulation waveform: \n\n// time            x               y               z               \n// 0ns             0               0               1               \n// 5ns             0               0               1               \n// 10ns            0               0               1               \n// 15ns            0               0               1               \n// 20ns            0               0               1               \n// 25ns            1               0               0               \n// 30ns            1               0               0               \n// 35ns            0               1               0               \n// 40ns            0               1               0               \n// 45ns            1               1               1               \n// 50ns            1               1               1               \n// 55ns            0               0               1               \n// 60ns            0               1               0               \n// 65ns            0               1               0               \n// 70ns            1               1               1               \n// 75ns            0               1               0               \n// 80ns            0               1               0               \n// 85ns            0               1               0               \n// 90ns            1               0               0               ", "prompt": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "completion": "\nreg z;\n\nalways @(*) begin\n    case ({x, y})\n        2'b00: z = 1;\n        2'b01: z = 0;\n        2'b10: z = 0;\n        2'b11: z = 1;\n        default: z = 1; // Default case to handle unexpected values\n    endcase\nend\n\nendmodule\n"}
{"task_id": "2012_q2fsm", "description": "Consider the state machine shown below:\n\n// A (0) --1--> B\n// A (0) --0--> A\n// B (0) --1--> C\n// B (0) --0--> D\n// C (0) --1--> E\n// C (0) --0--> D\n// D (0) --1--> F\n// D (0) --0--> A\n// E (1) --1--> E\n// E (1) --0--> D\n// F (1) --1--> C\n// F (1) --0--> D\n\n// Reset resets into state A and is synchronous active-high. \n\n// Write complete Verilog code that represents this FSM. Use separate **always** blocks for the state table and the state flip-flops. Describe the FSM output, which is called _z_, using either continuous assignment statement(s) or an **always** block (at your discretion). Assign any state codes that you wish to use.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "completion": "\ntypedef enum logic [2:0] {\n    A = 3'b000,\n    B = 3'b001,\n    C = 3'b010,\n    D = 3'b011,\n    E = 3'b100,\n    F = 3'b101\n} state_t;\n\nstate_t current_state, next_state;\n\nalways_ff @(posedge clk or posedge reset) begin\n    if (reset) \n        current_state <= A;\n    else \n        current_state <= next_state;\nend\n\nalways_comb begin\n    case (current_state)\n        A: if (w) next_state = B; else next_state = A;\n        B: if (w) next_state = C; else next_state = D;\n        C: if (w) next_state = E; else next_state = D;\n        D: if (w) next_state = F; else next_state = A;\n        E: if (w) next_state = E; else next_state = D;\n        F: if (w) next_state = C; else next_state = D;\n        default: next_state = A;\n    endcase\nend\n\nassign z = (current_state == E) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "dff16e", "description": "Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0]. resetn is a synchronous, active-low reset. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\nendmodule\n"}
{"task_id": "edgedetect", "description": "For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "completion": "\nalways @(posedge clk) begin\n    pedge <= 8'b0; // Clear output on every clock cycle\n    for (int i = 0; i < 8; i = i + 1) begin\n        if (in[i] == 1 && (i == 0 || in[i-1] == 0)) begin\n            pedge[i] <= 1; // Set output for current bit on 0 to 1 transition\n        end\n    end\nend\nendmodule\n"}
{"task_id": "circuit8", "description": "This is a sequential circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clock           a               p               q               \n// 0ns             0               0               x               x               \n// 5ns             0               0               x               x               \n// 10ns            0               0               x               x               \n// 15ns            0               0               x               x               \n// 20ns            0               0               x               x               \n// 25ns            1               0               0               x               \n// 30ns            1               0               0               x               \n// 35ns            1               0               0               x               \n// 40ns            1               0               0               x               \n// 45ns            1               0               0               x               \n// 50ns            1               0               0               x               \n// 55ns            0               0               0               0               \n// 60ns            0               0               0               0               \n// 65ns            0               0               0               0               \n// 70ns            0               1               0               0               \n// 75ns            0               0               0               0               \n// 80ns            0               1               0               0               \n// 85ns            1               0               0               0               \n// 90ns            1               1               1               0               \n// 95ns            1               0               0               0               \n// 100ns           1               1               1               0               \n// 105ns           1               0               0               0               \n// 110ns           1               1               1               0               \n// 115ns           0               0               1               1               \n// 120ns           0               1               1               1               \n// 125ns           0               0               1               1               \n// 130ns           0               1               1               1               \n// 135ns           0               0               1               1               \n// 140ns           0               0               1               1               \n// 145ns           1               0               0               1               \n// 150ns           1               0               0               1               \n// 155ns           1               0               0               1               \n// 160ns           1               0               0               1               \n// 165ns           1               1               1               1               \n// 170ns           1               0               0               1               \n// 175ns           0               1               0               0               \n// 180ns           0               0               0               0               \n// 185ns           0               1               0               0               \n// 190ns           0               0               0               0       ", "prompt": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "completion": "\nalways @(posedge clock) begin\n    if (a) begin\n        p <= ~p;\n        q <= p;\n    end\nend\n\nalways @(negedge clock) begin\n    if (a) begin\n        q <= p;\n    end\nend\nendmodule\n"}
{"task_id": "rule90", "description": "Rule 90 is a one-dimensional cellular automaton with interesting properties. The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours:\n// Left | Center | Right | Center's next state\n// 1 | 1 | 1 | 0\n// 1 | 1 | 0 | 1\n// 1 | 0 | 1 | 0\n// 1 | 0 | 0 | 1\n// 0 | 1 | 1 | 1\n// 0 | 1 | 0 | 0 \n// 0 | 0 | 1 | 1\n// 0 | 0 | 0 | 0\n// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q[0] <= 1'b0 ^ q[1]; // Left boundary is assumed to be 0\n        for (integer i = 1; i < 511; i = i + 1) begin\n            q[i] <= q[i-1] ^ q[i+1];\n        end\n        q[511] <= q[510] ^ 1'b0; // Right boundary is assumed to be 0\n    end\nend\nendmodule\n"}
{"task_id": "mt2015_eq2", "description": "Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. The value of z should be 1 if A = B, otherwise z should be 0.", "prompt": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "completion": "\nassign z = (A == B) ? 1'b1 : 1'b0;\nendmodule\n"}
{"task_id": "gatesv100", "description": "You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: \n// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. \n// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. \n// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "completion": "\ngenvar i;\n\ngenerate\n    for (i = 0; i < 99; i = i + 1) begin : both\n        assign out_both[i] = in[i] & in[i + 1];\n    end\nendgenerate\n\ngenerate\n    for (i = 1; i < 100; i = i + 1) begin : any\n        assign out_any[i] = in[i - 1] | in[i];\n    end\nendgenerate\n\ngenerate\n    for (i = 0; i < 99; i = i + 1) begin : different\n        assign out_different[i] = in[i] ^ in[i + 1];\n    end\n    assign out_different[99] = in[99] ^ in[0];\nendgenerate\n\nendmodule\n"}
{"task_id": "m2014_q4a", "description": "Implement a D latch using an always block.\n", "prompt": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "completion": "\nalways @(*) begin\n    if (ena) begin\n        q = d;\n    end\nend\n\nendmodule\n"}
{"task_id": "mux256to1v", "description": "Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.", "prompt": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "completion": "\n    assign out = in[sel * 4 +: 4];\nendmodule\n"}
{"task_id": "mux9to1v", "description": "Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.", "prompt": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "completion": "\nalways_comb begin\n    case(sel)\n        4'b0000: out = a;\n        4'b0001: out = b;\n        4'b0010: out = c;\n        4'b0011: out = d;\n        4'b0100: out = e;\n        4'b0101: out = f;\n        4'b0110: out = g;\n        4'b0111: out = h;\n        4'b1000: out = i;\n        default: out = 16'b1111111111111111; // Set all output bits to '1' for sel 9 to 15\n    endcase\nend\nendmodule\n"}
{"task_id": "vectorgates", "description": "Build a circuit that has two 3-bit inputs that computes the bitwise-OR of the two vectors, the logical-OR of the two vectors, and the inverse (NOT) of both vectors. Place the inverse of b in the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.", "prompt": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "completion": "\nassign out_or_bitwise = a | b;\nassign out_or_logical = |(a | b);\nassign out_not = {~b, ~a};\nendmodule\n"}
{"task_id": "fsm3onehot", "description": "The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. \n// State | Next state in=0, Next state in=1 | Output\n// A | A, B | 0\n// B | C, B | 0\n// C | A, D | 0\n// D | C, B | 1", "prompt": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "completion": "\n\talways @(*) begin\n\t\tcase (state)\n\t\t\t4'b0001: // State A\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = 4'b0010; // Go to B\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0001; // Stay in A\n\t\t\t4'b0010: // State B\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = 4'b0010; // Stay in B\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0100; // Go to C\n\t\t\t4'b0100: // State C\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = 4'b1000; // Go to D\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0001; // Go to A\n\t\t\t4'b1000: // State D\n\t\t\t\tif (in)\n\t\t\t\t\tnext_state = 4'b0100; // Go to C\n\t\t\t\telse\n\t\t\t\t\tnext_state = 4'b0010; // Go to B\n\t\t\tdefault: next_state = 4'b0001; // Default to state A\n\t\tendcase\n\tend\n\t\n\tassign out = (state == 4'b1000) ? 1'b1 : 1'b0; // Output logic for state D\n\nendmodule\n"}
{"task_id": "conditional", "description": "Given four unsigned numbers, find the minimum. Unsigned numbers can be compared with standard comparison operators (a < b). ", "prompt": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "completion": "\nalways @* begin\n    min = a; // Assume a is the minimum\n    if (b < min) min = b; // Compare with b\n    if (c < min) min = c; // Compare with c\n    if (d < min) min = d; // Compare with d\nend\n\nendmodule\n"}
{"task_id": "gates", "description": "Build a combinational circuit with two inputs, a and b. There are 7 outputs, each with a logic gate driving it: \n// (1) out_and: a and b \n// (2) out_or: a or b \n// (3) out_xor: a xor b \n// (4) out_nand: a nand b \n// (5) out_nor: a nor b \n// (6) out_xnor: a xnor b \n// (7) out_anotb: a and-not b", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "completion": "\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\nendmodule\n"}
{"task_id": "kmap2", "description": "Implement the circuit described by the Karnaugh map below.\n\n//        ab\n// cd   00 01 11 10\n//  00 | 1 | 1 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 1 |\n//  11 | 0 | 1 | 1 | 1 |\n//  10 | 1 | 1 | 0 | 0 |", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "completion": "\nassign out = (c ~^ d) & (a | (b & (c | d))) | (~c & d & (a | ~b)) | (a & ~b & c);\nendmodule\n"}
{"task_id": "2014_q3fsm", "description": "Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input. Assume reset is active high synchronous.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "completion": "\n    typedef enum logic [1:0] {\n        A, B, CHECK1, CHECK2, CHECK3, OUTPUT\n    } state_t;\n\n    state_t state, next_state;\n    logic [2:0] w_count;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A;\n            z <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (state == B) begin\n            w_count <= {w_count[1:0], w}; // Shift in w\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            A: begin\n                z = 0;\n                if (s == 1) begin\n                    next_state = B;\n                    w_count = 3'b000; // Reset counter\n                end\n            end\n            B: begin\n                z = 0;\n                if (w_count == 3'b111) begin\n                    next_state = OUTPUT; // If w = 1 this cycle, move to output\n                end else if (w_count == 3'b000) begin\n                    next_state = CHECK1; // Move to checking states\n                end\n            end\n            CHECK1: begin\n                z = 0;\n                next_state = CHECK2;\n            end\n            CHECK2: begin\n                z = 0;\n                next_state = CHECK3;\n            end\n            CHECK3: begin\n                if (w_count == 3'b011) begin\n                    z = 1; // Set z if 2 out of 3 are 1's\n                end else begin\n                    z = 0;\n                end\n                next_state = B; // Go back to B to check again\n            end\n            OUTPUT: begin\n                z = 1;\n                next_state = B; // Go back to B to check again\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "vector4", "description": "One common place to see a replication operator is when sign-extending a smaller number to a larger one, while preserving its signed value. This is done by replicating the sign bit (the most significant bit) of the smaller number to the left. For example, sign-extending 4'b0101 (5) to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8 bits results in 8'b11111101 (-3). Build a circuit that sign-extends an 8-bit number to 32 bits. This requires a concatenation of 24 copies of the sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.", "prompt": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "completion": " out = { {24{in[7]}}, in };\nendmodule\n"}
{"task_id": "m2014_q4k", "description": "Implement a shift register with four D flops. Reset is active-low synchronous resettable.", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "completion": "\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (~resetn) begin\n        shift_reg <= 4'b0000;\n    end else begin\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\nassign out = shift_reg[3];\nendmodule\n"}
{"task_id": "always_case2", "description": "A priority encoder is a combinational circuit that, when given an input bit vector, outputs the position of the first 1 bit in the vector. For example, a 8-bit priority encoder given the input 8'b10010000 would output 3'd4, because bit[4] is first bit that is high. Build a 4-bit priority encoder. For this problem, if none of the input bits are high (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "completion": "\nalways @(*) begin\n    casez (in)\n        4'b1??? : pos = 2'd3; // if in[3] is high\n        4'b01?? : pos = 2'd2; // if in[2] is high\n        4'b001? : pos = 2'd1; // if in[1] is high\n        4'b0001 : pos = 2'd0; // if in[0] is high\n        default : pos = 2'd0; // if no input is high\n    endcase\nend\n\nendmodule\n"}
{"task_id": "fsm2", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high asynchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "completion": "\n    reg state, next_state;\n    \n    parameter OFF = 1'b0, ON = 1'b1;\n    \n    assign out = state;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @* begin\n        case (state)\n            OFF: begin\n                if (j) begin\n                    next_state = ON;\n                end else begin\n                    next_state = OFF;\n                end\n            end\n            ON: begin\n                if (k) begin\n                    next_state = OFF;\n                end else begin\n                    next_state = ON;\n                end\n            end\n            default: next_state = OFF;\n        endcase\n    end\n\nendmodule\n"}
{"task_id": "m2014_q4i", "description": "Build a circuit with no inputs and one output. That output should always drive 0 (or logic low).", "prompt": "module top_module(\n\toutput out);\n", "completion": "\nassign out = 0;\nendmodule\n"}
{"task_id": "step_one", "description": "Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).", "prompt": "module top_module(\n\toutput one);\n", "completion": "\nassign one = 1'b1;\nendmodule\n"}
{"task_id": "vector100r", "description": "Given a 100-bit input vector [99:0], reverse its bit ordering.", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "completion": "\nalways @* begin\n    out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9],\n           in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19],\n           in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29],\n           in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39],\n           in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49],\n           in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59],\n           in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69],\n           in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79],\n           in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89],\n           in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99]};\nend\n\nendmodule\n"}
{"task_id": "m2014_q4d", "description": "Implement in Verilog the following circuit: A D flip-flop takes as input the output of a two-input XOR. The flip-flop is positive edge triggered by clk, but there is no reset. The XOR takes as input 'in' along with the output 'out' of the flip-flop.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "completion": "\nlogic xor_output;\n\nassign xor_output = in ^ out;\n\nalways_ff @(posedge clk) begin\n    out <= xor_output;\nend\n\nendmodule\n"}
{"task_id": "shift4", "description": "Build a 4-bit shift register (right shift), with asynchronous positive edge triggered areset, synchronous active high signals load, and enable. \n// (1) areset: Resets shift register to zero. \n// (2) load: Loads shift register with data[3:0] instead of shifting. \n// (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears). \n// (4) q: The contents of the shift register. If both the load and ena inputs are asserted (1), the load input has higher priority. \n", "prompt": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\nendmodule\n"}
{"task_id": "truthtable1", "description": "Create a combinational circuit that implements the truth table.\n\n// x3 | x2 | x1 | f\n// 0 | 0 | 0 | 0\n// 0 | 0 | 1 | 0\n// 0 | 1 | 0 | 1\n// 0 | 1 | 1 | 1\n// 1 | 0 | 0 | 0\n// 1 | 0 | 1 | 1\n// 1 | 1 | 0 | 0\n// 1 | 1 | 1 | 1", "prompt": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "completion": "\nassign f = (x2 & ~x1) | (x2 & x1) | (~x3 & x1) | (x3 & x1);\nendmodule\n"}
{"task_id": "dff8ar", "description": "Create 8 D flip-flops with active high asynchronous reset. The output should be reset to 0. All DFFs should be triggered by the positive edge of clk.", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "completion": "\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b00000000;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\n"}
{"task_id": "gates100", "description": "Build a combinational circuit with 100 inputs, in[99:0]. There are 3 outputs: \n// (1) out_and: output of a 100-input AND gate. \n// (2) out_or: output of a 100-input OR gate. \n// (3) out_xor: output of a 100-input XOR gate.\n\n", "prompt": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "completion": "\nassign out_and = &in;\nassign out_or = |in;\nassign out_xor = ^in;\n\nendmodule\n"}
{"task_id": "hadd", "description": "Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "completion": "\nassign sum = a ^ b;\nassign cout = a & b;\nendmodule\n"}
{"task_id": "always_if2", "description": "Fix any and all bugs in this code:\n\n// module top_module (\n//     input      cpu_overheated,\n//     output reg shut_off_computer,\n//     input      arrived,\n//     input      gas_tank_empty,\n//     output reg keep_driving  ); //\n\n//     always @(*) begin\n//         if (cpu_overheated)\n//            shut_off_computer = 1;\n//     end\n\n//     always @(*) begin\n//         if (~arrived)\n//            keep_driving = ~gas_tank_empty;\n//     end\n\n// endmodule\n", "prompt": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "completion": "    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0; // Ensure shut_off_computer is reset when not overheating\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0; // Stop driving if arrived\n    end\n\nendmodule"}
{"task_id": "fsm2s", "description": "This is a Moore state machine with two states, two inputs, and one output. Implement this state machine in Verilog. Reset is an active-high synchronous reset to state OFF.\n\n// OFF (out=0) --j=0--> OFF\n// OFF (out=0) --j=1--> ON\n// ON (out=1) --k=0--> ON\n// ON (out=1) --k=1--> OFF", "prompt": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n reg state, next_state;\n parameter OFF = 1'b0, ON = 1'b1;\n\n assign out = state;\n\n always @(posedge clk) begin\n     if (reset) \n         state <= OFF;\n     else \n         state <= next_state;\n end\n\n always @(*) begin\n     case (state)\n         OFF: begin\n             if (j) \n                 next_state = ON;\n             else \n                 next_state = OFF;\n         end\n         ON: begin\n             if (k) \n                 next_state = OFF;\n             else \n                 next_state = ON;\n         end\n         default: next_state = OFF; // default case to prevent latch\n     endcase\n end\nendmodule\n"}
{"task_id": "vector3", "description": "Given several input vectors, concatenate them together then split them up into several output vectors. There are six 5-bit input vectors: a, b, c, d, e, and f, for a total of 30 bits of input. There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. The output should be a concatenation of the input vectors followed by two 1 bits (the two 1 bits should be in the LSB positions).", "prompt": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "completion": "\n    assign w = {a, b, c};              // 5 bits from a, 5 bits from b, 3 bits from c\n    assign x = {c[2:0], d, e};         // 3 bits from c, 5 bits from d, 3 bits from e\n    assign y = {e[2:0], f, 2'b11};      // 3 bits from e, 5 bits from f, and two 1 bits\n    assign z = 8'b00000000;             // z is not defined by the concatenation, keeping it 0\n\nendmodule\n"}
{"task_id": "circuit2", "description": "This is a combinational circuit. Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            a               b               c               d               q               \n// 0ns             0               0               0               0               1               \n// 5ns             0               0               0               0               1               \n// 10ns            0               0               0               0               1               \n// 15ns            0               0               0               0               1               \n// 20ns            0               0               0               1               0               \n// 25ns            0               0               1               0               0               \n// 30ns            0               0               1               1               1               \n// 35ns            0               1               0               0               0               \n// 40ns            0               1               0               1               1               \n// 45ns            0               1               1               0               1               \n// 50ns            0               1               1               1               0               \n// 55ns            1               0               0               0               0               \n// 60ns            1               0               0               1               1               \n// 65ns            1               0               1               0               1               \n// 70ns            1               0               1               1               0               \n// 75ns            1               1               0               0               1               \n// 80ns            1               1               0               1               0               \n// 85ns            1               1               1               0               0               \n// 90ns            1               1               1               1               1       ", "prompt": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "completion": "\nassign q = (~a & ~b & ~c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d) | (a & b & ~c & ~d) | (a & b & c & d);\nendmodule\n"}
{"task_id": "andgate", "description": "Create a module that implements an AND gate.", "prompt": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "completion": "\nassign out = a & b;\nendmodule\n"}
{"task_id": "fsm1s", "description": "This is a Moore state machine with two states, one input, and one output. Implement this state machine in Verilog. The reset state is B and reset is active-high synchronous.\n\n// B (out=1) --in=0--> A\n// B (out=1) --in=1--> B\n// A (out=0) --in=0--> B\n// A (out=0) --in=1--> A", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter B = 1'b0, A = 1'b1;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= B;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            B: begin\n                if (in) begin\n                    next_state = B;\n                end else begin\n                    next_state = A;\n                end\n            end\n            A: begin\n                if (in) begin\n                    next_state = A;\n                end else begin\n                    next_state = B;\n                end\n            end\n            default: next_state = B; \n        endcase\n    end\n\n    assign out = (state == B) ? 1'b1 : 1'b0;\n\nendmodule\n"}
{"task_id": "fadd", "description": "Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.", "prompt": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "completion": "\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\nendmodule\n"}
{"task_id": "m2014_q4g", "description": "Implement in Verilog the following circuit: A two-input XNOR (connected to 'in1' and 'in2) has an output connected to the input of a two-input XOR. The second input of the XOR is 'in3.' The output of the XOR is 'out'.", "prompt": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "completion": "\nlogic xnor_out;\n\nassign xnor_out = !(in1 ^ in2);\nassign out = xnor_out ^ in3;\n\nendmodule\n"}
{"task_id": "ece241_2014_q3", "description": "For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use _a_ and _b_ as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.\n\n//       ab\n// cd   00 01 11 10\n//  00 | 0 | 0 | 0 | 1 |\n//  01 | 1 | 0 | 0 | 0 |\n//  11 | 1 | 0 | 1 | 1 |\n//  10 | 1 | 0 | 0 | 1 |\n\n// Consider a block diagram with inputs 'c' and 'd' going into a module called \"top_module\". This \"top_module\" has four outputs, mux_in[3:0], that connect to a four input mux. The mux takes as input {a,b} and ab = 00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in. You are implementing in Verilog just the portion labelled \"top_module\", such that the entire circuit (including the 4-to-1 mux) implements the K-map.\n", "prompt": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "completion": "\nassign mux_in[0] = 0;  // ab = 00\nassign mux_in[1] = c;  // ab = 01\nassign mux_in[2] = c | d; // ab = 11\nassign mux_in[3] = d;  // ab = 10\nendmodule\n"}
{"task_id": "ece241_2014_q5b", "description": "The following diagram is a Mealy machine implementation of the 2's complementer. Implement in Verilog using one-hot encoding. Resets into state A and reset is asynchronous active-high.\n\n// A --x=0 (z=0)--> A\n// A --x=1 (z=1)--> B\n// B --x=0 (z=1)--> B\n// B --x=1 (z=0)--> B", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    reg z_reg;\n\n    // State encoding\n    localparam A = 2'b01, B = 2'b10;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= A;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x) begin\n                    next_state = B;\n                    z_reg = 1;\n                end else begin\n                    next_state = A;\n                    z_reg = 0;\n                end\n            end\n            B: begin\n                next_state = B; // Remain in state B\n                z_reg = ~x; // z = 1 if x = 0, z = 0 if x = 1\n            end\n            default: begin\n                next_state = A;\n                z_reg = 0;\n            end\n        endcase\n    end\n\n    // Output assignment\n    assign z = z_reg;\n\nendmodule\n"}
{"task_id": "circuit10", "description": "This is a sequential circuit. The circuit consists of combinational logic and one bit of memory (i.e., one flip-flop). The output of the flip-flop has been made observable through the output state.\n\n// Read the simulation waveforms to determine what the circuit does, then implement it.\n\n// time            clk             a               b               state           q               \n// 0ns             0               1               x               x               x               \n// 5ns             1               1               x               x               x               \n// 10ns            0               0               0               x               x               \n// 15ns            1               0               0               0               0               \n// 20ns            0               0               0               0               0               \n// 25ns            1               0               0               0               0               \n// 30ns            0               0               0               0               0               \n// 35ns            1               0               0               0               0               \n// 40ns            0               0               0               0               0               \n// 45ns            1               0               1               0               1               \n// 50ns            0               0               1               0               1               \n// 55ns            1               1               0               0               1               \n// 60ns            0               1               0               0               1               \n// 65ns            1               1               1               0               0               \n// 70ns            0               1               1               0               0               \n// 75ns            1               0               0               1               1               \n// 80ns            0               0               0               1               1               \n// 85ns            1               1               1               0               0               \n// 90ns            0               1               1               0               0               \n// 95ns            1               1               1               1               1               \n// 100ns           0               1               1               1               1               \n// 105ns           1               1               1               1               1               \n// 110ns           0               1               1               1               1               \n// 115ns           1               1               0               1               0               \n// 120ns           0               1               0               1               0               \n// 125ns           1               0               1               1               0               \n// 130ns           0               0               1               1               0               \n// 135ns           1               0               0               1               1               \n// 140ns           0               0               0               1               1               \n// 145ns           1               0               0               0               0               \n// 150ns           0               0               0               0               0               \n// 155ns           1               0               0               0               0               \n// 160ns           0               0               0               0               0               \n// 165ns           1               0               0               0               0               \n// 170ns           0               0               0               0               0               \n// 175ns           1               0               0               0               0               \n// 180ns           0               0               0               0               0               \n// 185ns           1               0               0               0               0               \n// 190ns           0               0               0               0               0        ", "prompt": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "completion": "\nreg q_reg;\nreg state_reg;\n\nassign q = q_reg;\nassign state = state_reg;\n\nalways @(posedge clk) begin\n    if (a && !b) begin\n        q_reg <= 1;\n    end else if (!a && b) begin\n        q_reg <= 0;\n    end\n    \n    // Update state when q is 1\n    if (q_reg) begin\n        state_reg <= 1;\n    end else if (!q_reg) begin\n        state_reg <= 0;\n    end\nend\n\nendmodule\n"}
{"task_id": "2012_q1g", "description": "Consider the function f shown in the Karnaugh map below. Implement this function.\n//        x[1]x[2]\n// x[3]x[4]   00 01 11 10\n//  00 | 1 | 0 | 0 | 1 |\n//  01 | 0 | 0 | 0 | 0 |\n//  11 | 1 | 1 | 1 | 0 |\n//  10 | 1 | 1 | 0 | 1 |", "prompt": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "completion": "\n    assign f = (x[1] ~^ x[3]) & (x[2] | x[4]) | (x[3] & ~x[4]) | (x[1] & x[2]);\nendmodule\n"}
{"task_id": "fsm_hdlc", "description": "Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a \"flag\" that indicate frame boundaries. To avoid the data stream from accidentally containing \"flags\", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:\n\n// (1) 0111110: Signal a bit needs to be discarded (disc).\n// (2) 01111110: Flag the beginning/end of a frame (flag).\n// (3) 01111111...: Error (7 or more 1s) (err).\n\n// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "completion": "\n    reg [3:0] state, next_state;\n    parameter S0 = 4'b0000, // Initial state, expecting 0\n              S1 = 4'b0001, // 0 followed by 1\n              S2 = 4'b0010, // 01 followed by 1\n              S3 = 4'b0011, // 011 followed by 1\n              S4 = 4'b0100, // 0111 followed by 1\n              S5 = 4'b0101, // 01111 followed by 0 (discard)\n              S6 = 4'b0110, // 011111 followed by 0 (flag)\n              S7 = 4'b0111; // 0111111 (error state)\n\n    assign disc = (state == S5);\n    assign flag = (state == S6);\n    assign err = (state == S7);\n\n    always @(posedge clk) begin\n        if (reset) \n            state <= S0;\n        else \n            state <= next_state;\n    end\n\n    always @(*) begin\n        case (state)\n            S0: next_state = (in == 0) ? S0 : S1;\n            S1: next_state = (in == 0) ? S0 : S2;\n            S2: next_state = (in == 0) ? S0 : S3;\n            S3: next_state = (in == 0) ? S0 : S4;\n            S4: next_state = (in == 0) ? S0 : S5; // 5 ones, waiting for 0\n            S5: next_state = (in == 0) ? S0 : S6; // 6 ones in a row, discarding 0\n            S6: next_state = (in == 0) ? S0 : S7; // 7 ones in a row, error\n            S7: next_state = (in == 0) ? S0 : S7; // stay in error state\n            default: next_state = S0; // default case\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fancytimer", "description": "We want to create a timer with one input that:\n\n// (1) is started when a particular input pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n\n// The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, most-significant-bit first. These 4 bits determine the duration of the timer delay, referred to as delay[3:0]. After that, the state machine asserts its counting output to indicate it is counting. Once the 1101 and delay[3:0] have been read, the circuit no longer looks at the data input until it resumes searching after everything else is done.\n\n// The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. \n\n// When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement). At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).\n\n// The circuit should reset into a state where it begins searching for the input sequence 1101. The reset signal is active high synchronous. \n", "prompt": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "completion": "\n    reg [3:0] delay;\n    reg [9:0] counter;\n    reg [2:0] state;\n    reg [2:0] next_state;\n    \n    localparam SEARCH = 3'b000,\n               DETECT = 3'b001,\n               SHIFT = 3'b010,\n               COUNT = 3'b011,\n               DONE = 3'b100;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCH;\n            counting <= 0;\n            done <= 0;\n            counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == COUNT) begin\n                if (counter < (delay + 1) * 1000 - 1) begin\n                    counter <= counter + 1;\n                end else begin\n                    counter <= 0;\n                    done <= 1;\n                end\n            end else if (state == DONE && ack) begin\n                done <= 0;\n                state <= SEARCH;\n            end else if (state == SHIFT) begin\n                delay <= {data, delay[3:1]};\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            SEARCH: begin\n                counting = 0;\n                if (data == 1'b1) begin\n                    next_state = DETECT;\n                end else begin\n                    next_state = SEARCH;\n                end\n            end\n\n            DETECT: begin\n                if (data == 1'b1) \n                    next_state = SEARCH; \n                else \n                    next_state = SHIFT;\n            end\n\n            SHIFT: begin\n                if (counter == 4) begin\n                    next_state = COUNT;\n                    counting = 1;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n\n            COUNT: begin\n                if (counter < (delay + 1) * 1000 - 1) begin\n                    next_state = COUNT;\n                end else begin\n                    next_state = DONE;\n                end\n            end\n\n            DONE: begin\n                next_state = DONE;\n            end\n            \n            default: next_state = SEARCH;\n        endcase\n    end\n\n    assign count = (state == COUNT) ? delay : 4'bxxxx;\n\nendmodule\n"}
{"task_id": "ece241_2013_q4", "description": "A large reservior of water serves several users. In order to keep the level of water succificently high, three sensors are placed vertically at 5-inch intervals. When the water level is above the highest sensor s[3], the input flow rate should be zero. When the level is below the lowest sensor s[1], the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when the level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it as show in the table below. If the sensor change indicates that the previous level was lower than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by dfr). \n// Water Level | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n// Above s[3] | s[1], s[2], s[3] | None\n// Between s[3] and s[2] | s[1], s[2] | fr1\n// Between s[2] and s[1]  | s[1] | fr1, fr2\n// Below s[1] | None | fr1, fr2, fr3\n// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    reg [1:0] prev_state;\n\n    localparam STATE_HIGH = 2'b00, \n               STATE_MID2 = 2'b01, \n               STATE_MID1 = 2'b10, \n               STATE_LOW = 2'b11;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= STATE_LOW;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        fr3 = 0;\n        fr2 = 0;\n        fr1 = 0;\n        dfr = 0;\n\n        case (state)\n            STATE_LOW: begin\n                if (s[1] == 1) begin\n                    next_state = STATE_MID1;\n                end\n            end\n\n            STATE_MID1: begin\n                fr1 = 1;\n                if (s[2] == 1) begin\n                    next_state = STATE_MID2;\n                end else if (s[1] == 0) begin\n                    next_state = STATE_LOW;\n                end\n            end\n\n            STATE_MID2: begin\n                fr1 = 1;\n                fr2 = 1;\n                if (s[3] == 1) begin\n                    next_state = STATE_HIGH;\n                end else if (s[2] == 0) begin\n                    next_state = STATE_MID1;\n                end\n            end\n\n            STATE_HIGH: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 0;\n                if (s[3] == 0) begin\n                    next_state = STATE_MID2;\n                end\n            end\n        endcase\n\n        // Supplemental flow valve control\n        if (next_state > state) begin\n            dfr = 1;\n        end\n    end\nendmodule\n"}
{"task_id": "fsm_serial", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "completion": "\n    typedef enum reg [2:0] {\n        IDLE,      // Waiting for start bit\n        START,     // Start bit detected\n        DATA,      // Receiving data bits\n        STOP       // Expected stop bit\n    } state_t;\n\n    state_t current_state, next_state;\n    reg [3:0] bit_count; // To count number of data bits received\n    assign done = (current_state == STOP) && (bit_count == 8);\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_count <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    always @* begin\n        case (current_state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            \n            START: begin\n                next_state = DATA; // Move to data receiving\n                bit_count = 0;     // Reset bit count\n            end\n            \n            DATA: begin\n                if (bit_count < 8) begin\n                    next_state = DATA; // Continue receiving data bits\n                end else begin\n                    next_state = STOP; // Move to expecting stop bit\n                end\n            end\n            \n            STOP: begin\n                if (in == 1) // Stop bit detected\n                    next_state = IDLE; // Return to IDLE after receiving complete byte\n                else\n                    next_state = STOP; // Expecting correct stop bit\n            end\n            \n            default: next_state = IDLE; // Fallback to IDLE\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (current_state == DATA) begin\n            bit_count <= bit_count + 1; // Count data bits\n        end\n    end\nendmodule\n"}
{"task_id": "fsm_serialdata", "description": "In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle). Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. The module will also output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte. Include a active-high synchronous reset. Note that the serial protocol sends the least significant bit first. It should assert done each time it finds a stop bit.", "prompt": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "completion": "\n    reg [3:0] state, next_state;\n    reg [7:0] data_byte;\n    reg done_reg;\n    \n    parameter IDLE = 4'b0000, START = 4'b0001, DATA = 4'b0010, STOP = 4'b0011;\n\n    assign out_byte = done ? data_byte : 8'bz;\n    assign done = done_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            data_byte <= 8'b0;\n            done_reg <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                done_reg = 0;\n                if (in == 0) begin // Start bit detected\n                    next_state = START;\n                end\n            end\n            START: begin\n                if (in == 0) begin // Still in start bit\n                    next_state = DATA;\n                end\n            end\n            DATA: begin\n                data_byte = {in, data_byte[7:1]}; // Shift in data bit\n                if (data_byte[7:0] == 8'b11111111) begin // Assuming 8 data bits received\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                if (in == 1) begin // Stop bit detected\n                    done_reg = 1;\n                    next_state = IDLE;\n                end else begin\n                    next_state = IDLE; // Wait for a stop bit to return to idle\n                end\n            end\n        endcase\n    end\nendmodule\n"}
{"task_id": "gshare", "description": "Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. \n// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. \n// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.\n// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.", "prompt": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "completion": "\nreg [1:0] pht [127:0]; // Pattern History Table\nreg [6:0] bhr; // Global Branch History Register\n\nwire [6:0] index = predict_pc ^ bhr; // Index calculation using XOR\nwire [6:0] train_index = train_pc ^ train_history; // Training index\n\n// Prediction logic\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        bhr <= 7'b0; // Reset BHR\n        for (int i = 0; i < 128; i++) begin\n            pht[i] <= 2'b00; // Reset PHT\n        end\n    end else begin\n        // Training takes precedence over prediction\n        if (train_valid) begin\n            if (train_taken) begin\n                if (pht[train_index] < 2'b11) begin\n                    pht[train_index] <= pht[train_index] + 1; // Increment counter\n                end\n            end else begin\n                if (pht[train_index] > 2'b00) begin\n                    pht[train_index] <= pht[train_index] - 1; // Decrement counter\n                end\n            end\n            \n            // Update BHR for training\n            bhr <= {bhr[5:0], train_taken};\n        end\n        \n        // Prediction update only if no training occurs in the same cycle\n        if (predict_valid) begin\n            predict_taken <= (pht[index] >= 2'b10); // Taken prediction\n            predict_history <= bhr; // Output current BHR\n            \n            // Update BHR for prediction after the next cycle\n            bhr <= {bhr[5:0], predict_taken}; \n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "lemmings4", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Although Lemmings can walk, fall, and dig, Lemmings aren't invulnerable. If a Lemming falls for too long then hits the ground, it can splatter. In particular, if a Lemming falls for more than 20 clock cycles then hits the ground, it will splatter and cease walking, falling, or digging (all 4 outputs become 0), forever (Or until the FSM gets reset). There is no upper limit on how far a Lemming can fall before hitting the ground. Lemmings only splatter when hitting the ground; they do not splatter in mid-air.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [4:0] state, next_state;\n    reg [4:0] fall_counter;\n\n    localparam WALK_LEFT = 5'b00001, \n               WALK_RIGHT = 5'b00010, \n               FALLING = 5'b00100, \n               DIGGING = 5'b01000, \n               SPLATTER = 5'b10000;\n\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                fall_counter <= fall_counter + 1;\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            \n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            FALLING: begin\n                if (ground) begin\n                    if (fall_counter > 20) begin\n                        next_state = SPLATTER;\n                    end else begin\n                        next_state = (bump_left || bump_right) ? (bump_left ? WALK_RIGHT : WALK_LEFT) : (state == FALLING ? WALK_LEFT : WALK_RIGHT);\n                    end\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            \n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left || bump_right) begin\n                    next_state = DIGGING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            \n            SPLATTER: begin\n                next_state = SPLATTER;\n            end\n\n            default: next_state = WALK_LEFT;\n        endcase\n    end\nendmodule\n"}
{"task_id": "review2015_fsm", "description": "We want to create a timer that:\n// (1) is started when a particular pattern (1101) is detected,\n// (2) shifts in 4 more bits to determine the duration to delay,\n// (3) waits for the counters to finish counting, and\n// (4) notifies the user and waits for the user to acknowledge the timer.\n// In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.\n// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles. After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101). The state machine should have a active high synchronous reset, setting the state to where it begins searching for the input sequence 1101.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "completion": "\n    reg [3:0] current_state, next_state;\n    reg [3:0] bit_count;\n\n    localparam S_IDLE = 4'b0000,\n               S_PATTERN = 4'b0001,\n               S_SHIFT = 4'b0010,\n               S_COUNTING = 4'b0011,\n               S_DONE = 4'b0100;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= S_IDLE;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            bit_count <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always @(*) begin\n        next_state = current_state;\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (current_state)\n            S_IDLE: begin\n                if (data == 1) begin\n                    next_state = S_PATTERN;\n                end\n            end\n\n            S_PATTERN: begin\n                if (bit_count < 3) begin\n                    bit_count = bit_count + 1;\n                    if (data == (3 - bit_count)) begin\n                        next_state = S_PATTERN; \n                    end else begin\n                        next_state = S_IDLE;\n                        bit_count = 0; \n                    end\n                end else begin\n                    next_state = S_SHIFT;\n                    bit_count = 0;\n                end\n            end\n\n            S_SHIFT: begin\n                if (bit_count < 4) begin\n                    shift_ena = 1;\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = S_COUNTING;\n                end\n            end\n\n            S_COUNTING: begin\n                counting = 1;\n                if (done_counting) begin\n                    next_state = S_DONE;\n                end\n            end\n\n            S_DONE: begin\n                done = 1;\n                if (ack) begin\n                    next_state = S_IDLE;\n                end\n            end\n            \n        endcase\n    end\nendmodule\n"}
{"task_id": "conwaylife", "description": "The \"game\" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:\n// (1) 0-1 neighbour: Cell becomes 0.\n// (2) 2 neighbours: Cell state does not change.\n// (3) 3 neighbours: Cell becomes 1.\n// (4) 4+ neighbours: Cell becomes 0.\n// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. \n// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.\n// (2) q: The 16x16 current state of the game, updated every clock cycle.\n// The game state should advance by one timestep every clock cycle.", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "completion": "\nreg [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        q <= next_q;\n    end\nend\n\ninteger i, j, count;\nalways @* begin\n    next_q = q; // Default is to keep the current state\n    for (i = 0; i < 16; i = i + 1) begin\n        for (j = 0; j < 16; j = j + 1) begin\n            count = 0;\n            // Count alive neighbors\n            for (integer di = -1; di <= 1; di = di + 1) begin\n                for (integer dj = -1; dj <= 1; dj = dj + 1) begin\n                    if (di == 0 && dj == 0) continue; // skip the cell itself\n                    count = count + q[((i + di + 16) % 16) * 16 + ((j + dj + 16) % 16)];\n                end\n            end\n            \n            // Update next_q based on the Game of Life rules\n            if (q[i * 16 + j] == 1) begin\n                if (count < 2 || count > 3) begin\n                    next_q[i * 16 + j] = 0; // Cell dies\n                end\n            end else begin\n                if (count == 3) begin\n                    next_q[i * 16 + j] = 1; // Cell becomes alive\n                end\n            end\n        end\n    end\nend\n\nendmodule\n"}
{"task_id": "lemmings3", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// In addition to walking and falling, Lemmings can sometimes be told to do useful things, like dig (it starts digging when dig=1). A Lemming can dig if it is currently walking on ground (ground=1 and not falling), and will continue digging until it reaches the other side (ground=0). At that point, since there is no ground, it will fall (aaah!), then continue walking in its original direction once it hits ground again. As with falling, being bumped while digging has no effect, and being told to dig when falling or when there is no ground is ignored. (In other words, a walking Lemming can fall, dig, or switch directions. If more than one of these conditions are satisfied, fall has higher precedence than dig, which has higher precedence than switching directions.)\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "completion": "\n    reg [1:0] state, next_state;\n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALLING = 2'b10, DIGGING = 2'b11;\n\n    // Output logic\n    assign walk_left = (state == WALK_LEFT);\n    assign walk_right = (state == WALK_RIGHT);\n    assign aaah = (state == FALLING);\n    assign digging = (state == DIGGING);\n\n    // State transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    if (state == FALLING) begin\n                        next_state = (bump_left) ? WALK_LEFT : (bump_right) ? WALK_RIGHT : state;\n                    end else begin\n                        next_state = (bump_left) ? WALK_LEFT : (bump_right) ? WALK_RIGHT : state; \n                    end\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\nendmodule\n"}
{"task_id": "count_clock", "description": "Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while \"clk\" is much faster than once per second). The signal \"pm\" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to \"12:00 AM.\" Reset has higher priority than enable and can occur even when not enabled.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        hh <= 8'd12;  // 12:00 AM\n        mm <= 8'd0;\n        ss <= 8'd0;\n        pm <= 1'b0;   // Start with AM\n    end else if (ena) begin\n        if (ss == 8'd59) begin\n            ss <= 8'd0;\n            if (mm == 8'd59) begin\n                mm <= 8'd0;\n                if (hh == 8'd12) begin\n                    hh <= 8'd1; // wrap to 01 after 12\n                    pm <= ~pm; // toggle AM/PM \n                end else begin\n                    hh <= hh + 8'd1;\n                end\n            end else begin\n                mm <= mm + 8'd1;\n            end\n        end else begin\n            ss <= ss + 8'd1;\n        end\n    end\nend\nendmodule\n"}
{"task_id": "lemmings2", "description": "The game Lemmings involves critters with fairly simple brains. So simple that we are going to model it using a finite state machine. In the Lemmings' 2D world, Lemmings can be in one of two states: walking left (walk_left is 1) or walking right (walk_right is 1). It will switch directions if it hits an obstacle. In particular, if a Lemming is bumped on the left (by receiving a 1 on bump_left), it will walk right. If it's bumped on the right (by receiving a 1 on bump_right), it will walk left. If it's bumped on both sides at the same time, it will still switch directions. \n// In addition to walking left and right and changing direction when bumped, when ground=0, the Lemming will fall and say \"aaah!\". When the ground reappears (ground=1), the Lemming will resume walking in the same direction as before the fall. Being bumped while falling does not affect the walking direction, and being bumped in the same cycle as ground disappears (but not yet falling), or when the ground reappears while still falling, also does not affect the walking direction.\n// Implement a Moore state machine that models this behaviour. areset is positive edge triggered asynchronous reseting the Lemming machine to walk left.", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "completion": "\n    reg state; // 0: walking left, 1: walking right\n    reg falling; // 0: not falling, 1: falling\n\n    assign walk_left = (state == 0) && !falling;\n    assign walk_right = (state == 1) && !falling;\n    assign aaah = falling;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 0; // Start by walking left\n            falling <= 0; // Not falling initially\n        end else begin\n            if (ground) begin // When the ground is present\n                if (falling) begin\n                    falling <= 0; // Recover from falling\n                end else if (bump_left) begin\n                    state <= 1; // Bump on the left, walk right\n                end else if (bump_right) begin\n                    state <= 0; // Bump on the right, walk left\n                end\n            end else begin // When the ground is gone\n                falling <= 1; // Start falling\n            end\n        end\n    end\nendmodule\n"}
{"task_id": "countbcd", "description": "Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented. Include a synchronous active-high reset.", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "completion": "\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        // Increment the ones place\n        if (q[3:0] == 4'd9) begin\n            q[3:0] <= 4'b0;\n            ena[1] <= 1;\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n            ena[1] <= 0;\n        end\n\n        // Increment the tens place\n        if (ena[1] && (q[7:4] == 4'd9)) begin\n            q[7:4] <= 4'b0;\n            ena[2] <= 1;\n        end else if (ena[1]) begin\n            q[7:4] <= q[7:4] + 1;\n            ena[2] <= 0;\n        end else begin\n            ena[2] <= 0;\n        end\n\n        // Increment the hundreds place\n        if (ena[2] && (q[11:8] == 4'd9)) begin\n            q[11:8] <= 4'b0;\n            ena[3] <= 1;\n        end else if (ena[2]) begin\n            q[11:8] <= q[11:8] + 1;\n            ena[3] <= 0;\n        end else begin\n            ena[3] <= 0;\n        end\n\n        // Increment the thousands place\n        if (ena[3] && (q[15:12] == 4'd9)) begin\n            q[15:12] <= 4'b0;\n        end else if (ena[3]) begin\n            q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\nendmodule\n"}
